/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../../.config/yarn/global/node_modules/regenerator-runtime/runtime.js":
/*!********************************************************************************!*\
  !*** ../../../.config/yarn/global/node_modules/regenerator-runtime/runtime.js ***!
  \********************************************************************************/
/***/ ((module) => {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar runtime = function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var defineProperty = Object.defineProperty || function (obj, key, desc) {\n    obj[key] = desc.value;\n  };\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function (obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    defineProperty(generator, \"_invoke\", {\n      value: makeInvokeMethod(innerFn, self, context)\n    });\n    return generator;\n  }\n  exports.wrap = wrap;\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  defineProperty(Gp, \"constructor\", {\n    value: GeneratorFunctionPrototype,\n    configurable: true\n  });\n  defineProperty(GeneratorFunctionPrototype, \"constructor\", {\n    value: GeneratorFunction,\n    configurable: true\n  });\n  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\");\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n  exports.isGeneratorFunction = function (genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor ? ctor === GeneratorFunction ||\n    // For the native GeneratorFunction constructor, the best we can\n    // do is to check its .name property.\n    (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n  };\n  exports.mark = function (genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  };\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function (value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function (err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n        return PromiseImpl.resolve(value).then(function (unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function (error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n    var previousPromise;\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n      return previousPromise =\n      // If enqueue has been called before, then we want to wait until\n      // all previous Promises have been resolved before calling invoke,\n      // so that results are always delivered in the correct order. If\n      // enqueue has not been called before, then it is important to\n      // call invoke immediately, without waiting on a callback to fire,\n      // so that the async generator function has the opportunity to do\n      // any necessary setup in a predictable way. This predictability\n      // is why the Promise constructor synchronously invokes its\n      // executor callback, and why async functions synchronously\n      // execute code before the first await. Since we implement simple\n      // async functions in terms of async generators, it is especially\n      // important to get this right, even though it requires care.\n      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,\n      // Avoid propagating failures to Promises returned by later\n      // invocations of the iterator.\n      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    }\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    defineProperty(this, \"_invoke\", {\n      value: enqueue\n    });\n  }\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n    : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  };\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n      context.method = method;\n      context.arg = arg;\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n          context.dispatchException(context.arg);\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n        state = GenStateExecuting;\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var methodName = context.method;\n    var method = delegate.iterator[methodName];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method, or a missing .next mehtod, always terminate the\n      // yield* loop.\n      context.delegate = null;\n      // Note: [\"return\"] must be used for ES3 parsing compatibility.\n      if (methodName === \"throw\" && delegate.iterator[\"return\"]) {\n        // If the delegate iterator has a return method, give it a\n        // chance to clean up.\n        context.method = \"return\";\n        context.arg = undefined;\n        maybeInvokeDelegate(delegate, context);\n        if (context.method === \"throw\") {\n          // If maybeInvokeDelegate(context) changed context.method from\n          // \"return\" to \"throw\", let that override the TypeError below.\n          return ContinueSentinel;\n        }\n      }\n      if (methodName !== \"return\") {\n        context.method = \"throw\";\n        context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\");\n      }\n      return ContinueSentinel;\n    }\n    var record = tryCatch(method, delegate.iterator, context.arg);\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n    var info = record.arg;\n    if (!info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n  define(Gp, toStringTagSymbol, \"Generator\");\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function () {\n    return this;\n  });\n  define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  });\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n    this.tryEntries.push(entry);\n  }\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n  exports.keys = function (val) {\n    var object = Object(val);\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n          next = function next() {\n            while (++i < iterable.length) {\n              if (hasOwn.call(iterable, i)) {\n                next.value = iterable[i];\n                next.done = false;\n                return next;\n              }\n            }\n            next.value = undefined;\n            next.done = true;\n            return next;\n          };\n        return next.next = next;\n      }\n    }\n    // Return an iterator with no values.\n    return {\n      next: doneResult\n    };\n  }\n  exports.values = values;\n  function doneResult() {\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n  Context.prototype = {\n    constructor: Context,\n    reset: function (skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n      this.method = \"next\";\n      this.arg = undefined;\n      this.tryEntries.forEach(resetTryEntry);\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n    stop: function () {\n      this.done = true;\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n      return this.rval;\n    },\n    dispatchException: function (exception) {\n      if (this.done) {\n        throw exception;\n      }\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n        return !!caught;\n      }\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n    abrupt: function (type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n      if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n      return this.complete(record);\n    },\n    complete: function (record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n      if (record.type === \"break\" || record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n      return ContinueSentinel;\n    },\n    finish: function (finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n    \"catch\": function (tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function (iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n      return ContinueSentinel;\n    }\n  };\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n}(\n// If this script is executing as a CommonJS module, use module.exports\n// as the regeneratorRuntime namespace. Otherwise create a new empty\n// object. Either way, the resulting object will be used to initialize\n// the regeneratorRuntime variable at the top of this file.\n true ? module.exports : 0);\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vLmNvbmZpZy95YXJuL2dsb2JhbC9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYWIvLi4vLi4vLi4vLmNvbmZpZy95YXJuL2dsb2JhbC9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzP2MyMGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICAgIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24gKG9iaiwga2V5LCBkZXNjKSB7IG9ialtrZXldID0gZGVzYy52YWx1ZTsgfTtcbiAgICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICAgIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gICAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuICAgIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgb25seSB3b3JrcyBvbiBET00gb2JqZWN0cy5cbiAgICAgICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBkZWZpbmUgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgICAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICAgICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuICAgICAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICAgICAgZGVmaW5lUHJvcGVydHkoZ2VuZXJhdG9yLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB9KTtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgICB9XG4gICAgZXhwb3J0cy53cmFwID0gd3JhcDtcbiAgICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gICAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAgIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAgIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAgIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gICAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICAgIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICAgIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gICAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcbiAgICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gICAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICAgIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG4gICAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gICAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gICAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICAgIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHsgfVxuICAgIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkgeyB9XG4gICAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7IH1cbiAgICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gICAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgICBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICAgIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gICAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICAgICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgICB9XG4gICAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICAgICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgIGRlZmluZVByb3BlcnR5KEdwLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgZGVmaW5lUHJvcGVydHkoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb24sIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICAgIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICAgICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICAgICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgICAgICByZXR1cm4gY3RvclxuICAgICAgICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAgICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgIH07XG4gICAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgICAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICAgICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgICAgIHJldHVybiBnZW5GdW47XG4gICAgfTtcbiAgICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAgIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICAgIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICAgIH07XG4gICAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgICAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuICAgICAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgICAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAgICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgICAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAgICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgICAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAgICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgICAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICAgICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogZW5xdWV1ZSB9KTtcbiAgICB9XG4gICAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgICBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gICAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcbiAgICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gICAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gICAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICAgICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApXG4gICAgICAgICAgICBQcm9taXNlSW1wbCA9IFByb21pc2U7XG4gICAgICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgICAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgICAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgICAgICBjb250ZXh0LmFyZyA9IGFyZztcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgICAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICAgICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICAgICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gICAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gICAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gICAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGNvbnRleHQubWV0aG9kO1xuICAgICAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAgICAgICAvLyBtZXRob2QsIG9yIGEgbWlzc2luZyAubmV4dCBtZWh0b2QsIGFsd2F5cyB0ZXJtaW5hdGUgdGhlXG4gICAgICAgICAgICAvLyB5aWVsZCogbG9vcC5cbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgICAgIGlmIChtZXRob2ROYW1lID09PSBcInRocm93XCIgJiYgZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1ldGhvZE5hbWUgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICdcIiArIG1ldGhvZE5hbWUgKyBcIicgbWV0aG9kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG4gICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgICAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcbiAgICAgICAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG4gICAgICAgICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgICAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgICAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAgICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAgICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAgICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAgIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuICAgIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpO1xuICAgIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gICAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAgIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gICAgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcbiAgICAgICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgICAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgICAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICAgICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgICAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAgICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgICAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICAgICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgICB9XG4gICAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgb2JqZWN0ID0gT2JqZWN0KHZhbCk7XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGtleXMucmV2ZXJzZSgpO1xuICAgICAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgICAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgICAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAgICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgICAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgICAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgICB9XG4gICAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbiAgICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IENvbnRleHQsXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoc2tpcFRlbXBSZXNldCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAgICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG4gICAgICAgICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgICAgICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFicnVwdDogZnVuY3Rpb24gKHR5cGUsIGFyZykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgICAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICAgICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgICAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG4gICAgICAgICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9LFxuICAgICAgICBmaW5pc2g6IGZ1bmN0aW9uIChmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImNhdGNoXCI6IGZ1bmN0aW9uICh0cnlMb2MpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgICAgICB9LFxuICAgICAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiAoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgICAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICAgICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICAgIHJldHVybiBleHBvcnRzO1xufShcbi8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4vLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbnR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9KSk7XG50cnkge1xuICAgIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59XG5jYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAgIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAgIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgaW4gbW9kZXJuIGVuZ2luZXNcbiAgICAvLyB3ZSBjYW4gZXhwbGljaXRseSBhY2Nlc3MgZ2xvYmFsVGhpcy4gSW4gb2xkZXIgZW5naW5lcyB3ZSBjYW4gZXNjYXBlXG4gICAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gICAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gICAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAgIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAgIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBnbG9iYWxUaGlzLnJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../.config/yarn/global/node_modules/regenerator-runtime/runtime.js\n");

/***/ }),

/***/ "./src/common/gl/index.ts":
/*!********************************!*\
  !*** ./src/common/gl/index.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nvar _a, _b;\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.renderFullScreenCanvas = exports.simpleInit = exports.createProgram = exports.createGlContext = exports.useInjectGlData = exports.createInjectAttrGroup = exports.setBlend = exports.ensureCanvas = exports.DEFAULT_GL2_FRAG = exports.DEFAULT_GL1_FRAG = exports.DEFAULT_GL2_VERT = exports.DEFAULT_GL1_VERT = void 0;\nexports.DEFAULT_GL1_VERT = `\nattribute vec2 a_position;\nvarying vec2 v_texCoord;\nvoid main() {\n    gl_Position = vec4(a_position, 0.0, 1.0);\n    v_texCoord = (a_position + 1.0) * 0.5;\n}`;\nconst simpleVertHeader = `#version 300 es\n\nout vec2 v_texCoord;\n\n`;\nexports.DEFAULT_GL2_VERT = `${simpleVertHeader}\n\nlayout(location = 0) in vec2 a_position;\n\nvoid main() {\n    // 计算顶点的最终位置\n    gl_Position = vec4(a_position, 0.0, 1.0);\n\n    // 将纹理坐标传递给片段着色器\n    v_texCoord = (a_position + 1.0) * 0.5;\n}\n`;\nexports.DEFAULT_GL1_FRAG = `\nprecision mediump float;\n\nvoid main(){\n    gl_FragColor=vec4(0.);\n}\n`;\nconst simpleFragHeader = `#version 300 es\n\n// 指定默认精度为 highp\nprecision highp float;\nprecision highp sampler2D; // 指定精度和 sampler2D 类型\n\nin vec2 v_texCoord; // 从顶点着色器传入的纹理坐标\nout vec4 fragColor; // 片段颜色输出\n\nuniform vec2 u_resolution;\nuniform float u_time;\nuniform vec3 iResolution;\nuniform vec2 iMouse;\nuniform float iTime;\n\n#define fragCoord vec2(v_texCoord * iResolution.xy)\n\n`;\nexports.DEFAULT_GL2_FRAG = `${simpleFragHeader}\n\nvoid main(){\n    fragColor = vec4(fragCoord.x / iResolution.x , 0., 0., 1.);\n}\n\n`;\nconst DEFAULT_RATIO = Math.min((_b = (_a = globalThis.window) === null || _a === void 0 ? void 0 : _a.devicePixelRatio) !== null && _b !== void 0 ? _b : 1, 2);\nfunction ensureCanvas(canvas) {\n  let ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_RATIO;\n  canvas.width = canvas.clientWidth * ratio;\n  canvas.height = canvas.clientHeight * ratio;\n}\nexports.ensureCanvas = ensureCanvas;\nfunction setBlend(gl, blendMode) {\n  gl.enable(gl.BLEND);\n  switch (blendMode) {\n    case 'add':\n      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n      break;\n    case 'multiply':\n      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n      gl.blendFuncSeparate(gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n      break;\n    case 'normal':\n    default:\n      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n      break;\n  }\n}\nexports.setBlend = setBlend;\nfunction injectAttr(gl, program, value, fieldSet) {\n  const data = new Float32Array(value);\n  const vBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, vBuffer);\n  let startOffset = 0;\n  const totalLen = fieldSet.reduce((d, c) => d += c.length, 0);\n  fieldSet.forEach(field => {\n    const {\n      name,\n      length\n    } = field;\n    const positionAttributeLocation = gl.getAttribLocation(program, name);\n    if (positionAttributeLocation < 0) {\n      console.error(`name<${name}> does not found in vertShader`);\n    }\n    gl.vertexAttribPointer(positionAttributeLocation, length, gl.FLOAT, false, data.BYTES_PER_ELEMENT * totalLen, data.BYTES_PER_ELEMENT * startOffset);\n    gl.enableVertexAttribArray(positionAttributeLocation);\n    startOffset += length;\n  });\n  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n}\nfunction createUBO(gl, program) {\n  let index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  const ubo = gl.createBuffer();\n  const data = Float32Array.from(value);\n  gl.bindBuffer(gl.UNIFORM_BUFFER, ubo);\n  gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);\n  gl.bindBufferBase(gl.UNIFORM_BUFFER, index, ubo);\n}\nfunction initFBO(gl) {\n  const fbo = gl.createFramebuffer();\n  // 创建对应的纹理\n  const texture = createTexture(gl);\n  // 绑定纹理到FBO\n  bindFBO(gl, fbo, texture);\n  // 初始化纹理为透明\n  clearTexture(gl, texture);\n  return {\n    fbo,\n    texture\n  };\n}\nfunction createTexture(gl) {\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  // 设置纹理参数（重要！防止边缘闪烁）\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n  // 初始空纹理\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.canvas.width, gl.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n  return texture;\n}\nfunction bindFBO(gl, fbo, texture) {\n  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n}\nfunction clearTexture(gl, texture) {\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.canvas.width, gl.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 0]));\n}\nfunction createInjectAttrGroup() {\n  const groupData = [];\n  let currentLen = 0;\n  return {\n    addGroup: (name, data) => {\n      var _a, _b;\n      const length = (_b = (_a = data[0]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;\n      if (length <= 0) {\n        console.warn(`no data found in@${name}, received ${data}`);\n      }\n      if (currentLen && data.length !== currentLen) {\n        console.warn(`length not match@${name}, expected ${currentLen}, received ${data.length}`);\n      }\n      currentLen = data.length;\n      groupData.push({\n        name,\n        length,\n        data\n      });\n    },\n    inject: (gl, program) => {\n      var _a, _b;\n      const value = [];\n      for (let i = 0; i < currentLen; i++) {\n        for (let j = 0; j < groupData.length; j++) {\n          const currentGroup = groupData[j];\n          for (let k = 0; k < currentGroup.length; k++) {\n            value.push((_b = (_a = currentGroup.data[i]) === null || _a === void 0 ? void 0 : _a[k]) !== null && _b !== void 0 ? _b : 0);\n          }\n        }\n      }\n      injectAttr(gl, program, value, groupData);\n    },\n    get length() {\n      return currentLen;\n    }\n  };\n}\nexports.createInjectAttrGroup = createInjectAttrGroup;\nfunction injectVert() {\n  const group = createInjectAttrGroup();\n  // [-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0];\n  group.addGroup('a_position', [[-1.0, -1.0], [1.0, -1.0], [-1.0, 1.0], [1.0, 1.0]]);\n  return group;\n}\nfunction injectUniform(gl, program, name, method) {\n  const n = gl.getUniformLocation(program, name);\n  // @ts-expect-error\n  for (var _len = arguments.length, value = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {\n    value[_key - 4] = arguments[_key];\n  }\n  gl[method](n, ...value);\n}\nfunction injectTexture(gl, program, name) {\n  let index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let img = arguments.length > 4 ? arguments[4] : undefined;\n  let options = arguments.length > 5 ? arguments[5] : undefined;\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n  const texture = gl.createTexture();\n  const sampler = gl.getUniformLocation(program, name);\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, ((_a = options === null || options === void 0 ? void 0 : options.flip) !== null && _a !== void 0 ? _a : 1) ? 1 : 0);\n  gl.activeTexture(gl[`TEXTURE${index}`]);\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  const defaultMinFilter = !(options === null || options === void 0 ? void 0 : options.mipmap) ? gl.NEAREST : gl.LINEAR_MIPMAP_LINEAR;\n  const defaultMaxFilter = !(options === null || options === void 0 ? void 0 : options.mipmap) ? gl.LINEAR : gl.LINEAR;\n  const texParameteri = options === null || options === void 0 ? void 0 : options.texParameteri;\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, (_c = (_b = texParameteri === null || texParameteri === void 0 ? void 0 : texParameteri[gl.TEXTURE_MIN_FILTER]) !== null && _b !== void 0 ? _b : texParameteri === null || texParameteri === void 0 ? void 0 : texParameteri['TEXTURE_MIN_FILTER']) !== null && _c !== void 0 ? _c : defaultMinFilter);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, (_e = (_d = texParameteri === null || texParameteri === void 0 ? void 0 : texParameteri[gl.TEXTURE_MAG_FILTER]) !== null && _d !== void 0 ? _d : texParameteri === null || texParameteri === void 0 ? void 0 : texParameteri['TEXTURE_MAG_FILTER']) !== null && _e !== void 0 ? _e : defaultMaxFilter);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, (_g = (_f = texParameteri === null || texParameteri === void 0 ? void 0 : texParameteri[gl.TEXTURE_WRAP_S]) !== null && _f !== void 0 ? _f : texParameteri === null || texParameteri === void 0 ? void 0 : texParameteri['TEXTURE_WRAP_S']) !== null && _g !== void 0 ? _g : gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, (_j = (_h = texParameteri === null || texParameteri === void 0 ? void 0 : texParameteri[gl.TEXTURE_WRAP_T]) !== null && _h !== void 0 ? _h : texParameteri === null || texParameteri === void 0 ? void 0 : texParameteri['TEXTURE_WRAP_T']) !== null && _j !== void 0 ? _j : gl.CLAMP_TO_EDGE);\n  gl.uniform1i(sampler, index);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);\n  if (options === null || options === void 0 ? void 0 : options.mipmap) {\n    gl.generateMipmap(gl.TEXTURE_2D);\n  }\n}\nfunction useInjectGlData(gl, program, canvas, options) {\n  const lastMousePosition = [0, 0];\n  const start = Date.now();\n  function inject() {\n    const now = new Date();\n    // 为 u_time 提供值\n    const time = (now.getTime() - start) / 1000;\n    const uTimeLocation = gl.getUniformLocation(program, 'u_time');\n    gl.uniform1f(uTimeLocation, time);\n    const iTimeLocation = gl.getUniformLocation(program, 'iTime');\n    gl.uniform1f(iTimeLocation, time);\n    // 为 u_mouse 提供值\n    const uMouseLocation = gl.getUniformLocation(program, 'iMouse');\n    gl.uniform2f(uMouseLocation, ...lastMousePosition);\n    const uResolution = gl.getUniformLocation(program, 'u_resolution');\n    gl.uniform2f(uResolution, canvas.clientWidth * options.ratio, canvas.clientHeight * options.ratio);\n    const iResolution = gl.getUniformLocation(program, 'iResolution');\n    gl.uniform3f(iResolution, canvas.clientWidth * options.ratio, canvas.clientHeight * options.ratio, 0);\n    // gl.uniform4f(\n    //     uDateLocation,\n    //     now.getFullYear(),\n    //     now.getMonth() + 1,\n    //     now.getDate(),\n    //     now.getHours() + now.getMinutes() / 60,\n    // );\n    // 为 u_camera 提供值\n    // const uCameraLocation = gl.getUniformLocation(program, 'u_camera');\n    // gl.uniform3f(uCameraLocation, 0.0, 0.0, -2.0);\n    // 为 u_sampleRate 提供值\n    // const uSampleRateLocation = gl.getUniformLocation(program, 'u_sampleRate');\n    // gl.uniform1f(uSampleRateLocation, 44100.0);\n    // 为 iResolution 提供值\n    const iResolutionLocation = gl.getUniformLocation(program, 'iResolution');\n    gl.uniform3f(iResolutionLocation, canvas.clientWidth, canvas.clientHeight, options.ratio);\n  }\n  function setMove(e) {\n    const w = canvas.clientWidth;\n    const h = canvas.clientHeight;\n    lastMousePosition[0] = e.clientX / w;\n    lastMousePosition[1] = e.clientY / h;\n  }\n  canvas.addEventListener('pointermove', setMove);\n  return {\n    inject,\n    destroy: () => {\n      canvas.removeEventListener('pointermove', setMove);\n    }\n  };\n}\nexports.useInjectGlData = useInjectGlData;\nfunction createGlContext(canvas, options) {\n  const gl = canvas.getContext('webgl2', Object.assign({\n    alpha: true,\n    depth: true,\n    premultipliedAlpha: true\n  }, options));\n  if (!gl) {\n    throw new Error(`webgl context create failed`);\n  }\n  setBlend(gl, 'normal');\n  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n  return gl;\n}\nexports.createGlContext = createGlContext;\nfunction checkShader(gl, shader, source) {\n  var _a;\n  const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  if (!compiled) {\n    const error = gl.getShaderInfoLog(shader);\n    console.error('Shader compile error: ' + error);\n    const [match, file, line] = (_a = /ERROR: ([\\d]+):([\\d]+)/.exec(error !== null && error !== void 0 ? error : '')) !== null && _a !== void 0 ? _a : [];\n    console.error('error line: ', source.split('\\n')[+line - 1]);\n  }\n}\nfunction createProgram(gl, shader) {\n  var _a, _b;\n  const program = gl.createProgram();\n  // 创建顶点着色器\n  const vShader = gl.createShader(gl.VERTEX_SHADER);\n  // 创建片元着色器\n  const fShader = gl.createShader(gl.FRAGMENT_SHADER);\n  if (!program) {\n    throw new Error(`program create failed`);\n  }\n  if (!vShader || !fShader) {\n    throw new Error(`shader create failed`);\n  }\n  const finalVert = (_a = shader === null || shader === void 0 ? void 0 : shader.vert) !== null && _a !== void 0 ? _a : exports.DEFAULT_GL2_VERT;\n  const finalFrag = (_b = shader === null || shader === void 0 ? void 0 : shader.frag) !== null && _b !== void 0 ? _b : exports.DEFAULT_GL2_FRAG;\n  // shader容器与着色器绑定\n  gl.shaderSource(vShader, finalVert);\n  gl.shaderSource(fShader, finalFrag);\n  // 将GLSE语言编译成浏览器可用代码\n  gl.compileShader(vShader);\n  gl.compileShader(fShader);\n  checkShader(gl, vShader, finalVert);\n  checkShader(gl, fShader, finalFrag);\n  // 将着色器添加到程序上\n  gl.attachShader(program, vShader);\n  gl.attachShader(program, fShader);\n  // 链接程序，在链接操作执行以后，可以任意修改shader的源代码，\n  // 对shader重新编译不会影响整个程序，除非重新链接程序\n  gl.linkProgram(program);\n  // 加载并使用链接好的程序\n  gl.useProgram(program);\n  const message = gl.getShaderInfoLog(fShader);\n  if (message && message.length > 0) {\n    /* message may be an error or a warning */\n    throw message;\n  }\n  return program;\n}\nexports.createProgram = createProgram;\nfunction getFinalShaderConfig(options) {\n  var _a, _b;\n  return {\n    vert: (_a = options === null || options === void 0 ? void 0 : options.vert) !== null && _a !== void 0 ? _a : (options === null || options === void 0 ? void 0 : options.vertMain) ? `${simpleVertHeader}${options.vertMain}` : undefined,\n    frag: (_b = options === null || options === void 0 ? void 0 : options.frag) !== null && _b !== void 0 ? _b : (options === null || options === void 0 ? void 0 : options.main) ? `${simpleFragHeader}${options.main}` : undefined\n  };\n}\nfunction simpleInit(canvas, options) {\n  var _a, _b, _c, _d, _e;\n  const ratio = (_a = options === null || options === void 0 ? void 0 : options.ratio) !== null && _a !== void 0 ? _a : DEFAULT_RATIO;\n  const fps = (_b = options === null || options === void 0 ? void 0 : options.fps) !== null && _b !== void 0 ? _b : 40;\n  ensureCanvas(canvas, ratio);\n  const gl = createGlContext(canvas, {\n    preserveDrawingBuffer: (_c = options === null || options === void 0 ? void 0 : options.preserveDrawingBuffer) !== null && _c !== void 0 ? _c : false\n  });\n  const program = createProgram(gl, getFinalShaderConfig(options));\n  const {\n    inject,\n    destroy\n  } = useInjectGlData(gl, program, canvas, {\n    ratio\n  });\n  const injectGroupData = (_d = options === null || options === void 0 ? void 0 : options.attr) !== null && _d !== void 0 ? _d : injectVert();\n  injectGroupData.inject(gl, program);\n  inject();\n  let timer = 0;\n  let lastRender = Date.now();\n  const tickDuration = 1000 / fps;\n  const clearColor = (_e = options.clearColor) !== null && _e !== void 0 ? _e : [0, 0, 0, 0];\n  // FBO处理\n  const {\n    fbo: fbo1,\n    texture: texture1\n  } = initFBO(gl);\n  const {\n    fbo: fbo2,\n    texture: texture2\n  } = initFBO(gl);\n  const FBOCache = [fbo1, fbo2];\n  const FBOTextureCache = [texture1, texture2];\n  const FBOCacheLength = FBOCache.length;\n  // if(options?.postProcess){\n  //     const postPostPrograms = options.postProcess?.map(shaderOptions => createProgram(gl, getFinalShaderConfig(shaderOptions)));\n  // }\n  // FBO处理\n  let currentFBOIndex = 0;\n  let prevFBOIndex = 1;\n  function clear() {\n    // clear\n    gl.clearColor(...clearColor);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n  }\n  function draw() {\n    var _a;\n    gl.drawArrays((_a = options === null || options === void 0 ? void 0 : options.drawType) !== null && _a !== void 0 ? _a : gl.TRIANGLE_STRIP, 0, injectGroupData.length);\n  }\n  let currentRenderer = undefined;\n  function loopRender() {\n    const now = Date.now();\n    if (now - lastRender >= tickDuration) {\n      lastRender = now;\n      currentRenderer === null || currentRenderer === void 0 ? void 0 : currentRenderer();\n    }\n    timer = requestAnimationFrame(loopRender);\n  }\n  function renderTickWithLastScene() {\n    // 绑定到当前FBO\n    gl.bindFramebuffer(gl.FRAMEBUFFER, FBOCache[currentFBOIndex]);\n    // 使用上一帧的结果作为纹理输入\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, FBOTextureCache[prevFBOIndex]); // 注意这里使用交换后的texture2\n    // 注入uniform\n    const loc = gl.getUniformLocation(program, 'uPrev');\n    gl.uniform1i(loc, 0);\n    inject();\n    clear();\n    // 绘制到fbo\n    draw();\n    // 解绑FBO，后续绘制到屏幕\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    // 将最终结果绘制到屏幕（使用当前FBO的纹理）\n    gl.bindTexture(gl.TEXTURE_2D, FBOTextureCache[currentFBOIndex]);\n    draw();\n    currentFBOIndex = (currentFBOIndex + 1) % FBOCacheLength;\n    prevFBOIndex = (prevFBOIndex + 1) % FBOCacheLength;\n  }\n  function renderTick() {\n    inject();\n    clear();\n    // 绘制到fbo\n    draw();\n  }\n  if (options.useLastView) {\n    currentRenderer = renderTickWithLastScene;\n  } else {\n    currentRenderer = renderTick;\n  }\n  const api = {\n    gl,\n    inject: function (name, method) {\n      for (var _len2 = arguments.length, value = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        value[_key2 - 2] = arguments[_key2];\n      }\n      injectUniform(gl, program, name, method, ...value);\n    },\n    injectTexture: (name, index, img, options) => {\n      injectTexture(gl, program, name, index, img, options);\n    },\n    createUBO: (index, value) => {\n      // layout(std140) uniform UBO\n      // {\n      //     vec2 data[100];\n      // } ubo;\n      // ubo.data[i];\n      return createUBO(gl, program, index, value);\n    },\n    play: () => {\n      cancelAnimationFrame(timer);\n      loopRender();\n    },\n    stop: () => {\n      cancelAnimationFrame(timer);\n    }\n  };\n  if (options === null || options === void 0 ? void 0 : options.autoPlay) {\n    api.play();\n  }\n  return api;\n}\nexports.simpleInit = simpleInit;\nfunction renderFullScreenCanvas(options) {\n  const canvas = document.createElement('canvas');\n  document.body.style.cssText += `margin:0;padding:0;`;\n  canvas.style.cssText = `display:block;width:100vw;height:100vh;background:transparent;`;\n  document.body.appendChild(canvas);\n  ensureCanvas(canvas);\n  return simpleInit(canvas, options);\n}\nexports.renderFullScreenCanvas = renderFullScreenCanvas;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tbW9uL2dsL2luZGV4LnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUZBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhYi8uL3NyYy9jb21tb24vZ2wvaW5kZXgudHM/ZTc0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfYSwgX2I7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlbmRlckZ1bGxTY3JlZW5DYW52YXMgPSBleHBvcnRzLnNpbXBsZUluaXQgPSBleHBvcnRzLmNyZWF0ZVByb2dyYW0gPSBleHBvcnRzLmNyZWF0ZUdsQ29udGV4dCA9IGV4cG9ydHMudXNlSW5qZWN0R2xEYXRhID0gZXhwb3J0cy5jcmVhdGVJbmplY3RBdHRyR3JvdXAgPSBleHBvcnRzLnNldEJsZW5kID0gZXhwb3J0cy5lbnN1cmVDYW52YXMgPSBleHBvcnRzLkRFRkFVTFRfR0wyX0ZSQUcgPSBleHBvcnRzLkRFRkFVTFRfR0wxX0ZSQUcgPSBleHBvcnRzLkRFRkFVTFRfR0wyX1ZFUlQgPSBleHBvcnRzLkRFRkFVTFRfR0wxX1ZFUlQgPSB2b2lkIDA7XG5leHBvcnRzLkRFRkFVTFRfR0wxX1ZFUlQgPSBgXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XG52b2lkIG1haW4oKSB7XG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24sIDAuMCwgMS4wKTtcbiAgICB2X3RleENvb3JkID0gKGFfcG9zaXRpb24gKyAxLjApICogMC41O1xufWA7XG5jb25zdCBzaW1wbGVWZXJ0SGVhZGVyID0gYCN2ZXJzaW9uIDMwMCBlc1xuXG5vdXQgdmVjMiB2X3RleENvb3JkO1xuXG5gO1xuZXhwb3J0cy5ERUZBVUxUX0dMMl9WRVJUID0gYCR7c2ltcGxlVmVydEhlYWRlcn1cblxubGF5b3V0KGxvY2F0aW9uID0gMCkgaW4gdmVjMiBhX3Bvc2l0aW9uO1xuXG52b2lkIG1haW4oKSB7XG4gICAgLy8g6K6h566X6aG254K555qE5pyA57uI5L2N572uXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24sIDAuMCwgMS4wKTtcblxuICAgIC8vIOWwhue6ueeQhuWdkOagh+S8oOmAkue7meeJh+auteedgOiJsuWZqFxuICAgIHZfdGV4Q29vcmQgPSAoYV9wb3NpdGlvbiArIDEuMCkgKiAwLjU7XG59XG5gO1xuZXhwb3J0cy5ERUZBVUxUX0dMMV9GUkFHID0gYFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cbnZvaWQgbWFpbigpe1xuICAgIGdsX0ZyYWdDb2xvcj12ZWM0KDAuKTtcbn1cbmA7XG5jb25zdCBzaW1wbGVGcmFnSGVhZGVyID0gYCN2ZXJzaW9uIDMwMCBlc1xuXG4vLyDmjIflrprpu5jorqTnsr7luqbkuLogaGlnaHBcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcbnByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7IC8vIOaMh+WumueyvuW6puWSjCBzYW1wbGVyMkQg57G75Z6LXG5cbmluIHZlYzIgdl90ZXhDb29yZDsgLy8g5LuO6aG254K5552A6Imy5Zmo5Lyg5YWl55qE57q555CG5Z2Q5qCHXG5vdXQgdmVjNCBmcmFnQ29sb3I7IC8vIOeJh+auteminOiJsui+k+WHulxuXG51bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xudW5pZm9ybSBmbG9hdCB1X3RpbWU7XG51bmlmb3JtIHZlYzMgaVJlc29sdXRpb247XG51bmlmb3JtIHZlYzIgaU1vdXNlO1xudW5pZm9ybSBmbG9hdCBpVGltZTtcblxuI2RlZmluZSBmcmFnQ29vcmQgdmVjMih2X3RleENvb3JkICogaVJlc29sdXRpb24ueHkpXG5cbmA7XG5leHBvcnRzLkRFRkFVTFRfR0wyX0ZSQUcgPSBgJHtzaW1wbGVGcmFnSGVhZGVyfVxuXG52b2lkIG1haW4oKXtcbiAgICBmcmFnQ29sb3IgPSB2ZWM0KGZyYWdDb29yZC54IC8gaVJlc29sdXRpb24ueCAsIDAuLCAwLiwgMS4pO1xufVxuXG5gO1xuY29uc3QgREVGQVVMVF9SQVRJTyA9IE1hdGgubWluKChfYiA9IChfYSA9IGdsb2JhbFRoaXMud2luZG93KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGV2aWNlUGl4ZWxSYXRpbykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMSwgMik7XG5mdW5jdGlvbiBlbnN1cmVDYW52YXMoY2FudmFzLCByYXRpbyA9IERFRkFVTFRfUkFUSU8pIHtcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMuY2xpZW50V2lkdGggKiByYXRpbztcbiAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodCAqIHJhdGlvO1xufVxuZXhwb3J0cy5lbnN1cmVDYW52YXMgPSBlbnN1cmVDYW52YXM7XG5mdW5jdGlvbiBzZXRCbGVuZChnbCwgYmxlbmRNb2RlKSB7XG4gICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICBzd2l0Y2ggKGJsZW5kTW9kZSkge1xuICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCk7XG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnbC5TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtdWx0aXBseSc6XG4gICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREKTtcbiAgICAgICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKGdsLkRTVF9DT0xPUiwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdub3JtYWwnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCk7XG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG5leHBvcnRzLnNldEJsZW5kID0gc2V0QmxlbmQ7XG5mdW5jdGlvbiBpbmplY3RBdHRyKGdsLCBwcm9ncmFtLCB2YWx1ZSwgZmllbGRTZXQpIHtcbiAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZSk7XG4gICAgY29uc3QgdkJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB2QnVmZmVyKTtcbiAgICBsZXQgc3RhcnRPZmZzZXQgPSAwO1xuICAgIGNvbnN0IHRvdGFsTGVuID0gZmllbGRTZXQucmVkdWNlKChkLCBjKSA9PiAoZCArPSBjLmxlbmd0aCksIDApO1xuICAgIGZpZWxkU2V0LmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgbGVuZ3RoIH0gPSBmaWVsZDtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BdHRyaWJ1dGVMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIG5hbWUpO1xuICAgICAgICBpZiAocG9zaXRpb25BdHRyaWJ1dGVMb2NhdGlvbiA8IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYG5hbWU8JHtuYW1lfT4gZG9lcyBub3QgZm91bmQgaW4gdmVydFNoYWRlcmApO1xuICAgICAgICB9XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25BdHRyaWJ1dGVMb2NhdGlvbiwgbGVuZ3RoLCBnbC5GTE9BVCwgZmFsc2UsIGRhdGEuQllURVNfUEVSX0VMRU1FTlQgKiB0b3RhbExlbiwgZGF0YS5CWVRFU19QRVJfRUxFTUVOVCAqIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25BdHRyaWJ1dGVMb2NhdGlvbik7XG4gICAgICAgIHN0YXJ0T2Zmc2V0ICs9IGxlbmd0aDtcbiAgICB9KTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xufVxuZnVuY3Rpb24gY3JlYXRlVUJPKGdsLCBwcm9ncmFtLCBpbmRleCA9IDAsIHZhbHVlID0gW10pIHtcbiAgICBjb25zdCB1Ym8gPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBjb25zdCBkYXRhID0gRmxvYXQzMkFycmF5LmZyb20odmFsdWUpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuVU5JRk9STV9CVUZGRVIsIHVibyk7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5VTklGT1JNX0JVRkZFUiwgZGF0YSwgZ2wuRFlOQU1JQ19EUkFXKTtcbiAgICBnbC5iaW5kQnVmZmVyQmFzZShnbC5VTklGT1JNX0JVRkZFUiwgaW5kZXgsIHVibyk7XG59XG5mdW5jdGlvbiBpbml0RkJPKGdsKSB7XG4gICAgY29uc3QgZmJvID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAvLyDliJvlu7rlr7nlupTnmoTnurnnkIZcbiAgICBjb25zdCB0ZXh0dXJlID0gY3JlYXRlVGV4dHVyZShnbCk7XG4gICAgLy8g57uR5a6a57q555CG5YiwRkJPXG4gICAgYmluZEZCTyhnbCwgZmJvLCB0ZXh0dXJlKTtcbiAgICAvLyDliJ3lp4vljJbnurnnkIbkuLrpgI/mmI5cbiAgICBjbGVhclRleHR1cmUoZ2wsIHRleHR1cmUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZibyxcbiAgICAgICAgdGV4dHVyZSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZShnbCkge1xuICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgLy8g6K6+572u57q555CG5Y+C5pWw77yI6YeN6KaB77yB6Ziy5q2i6L6557yY6Zeq54OB77yJXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgLy8g5Yid5aeL56m657q555CGXG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgIHJldHVybiB0ZXh0dXJlO1xufVxuZnVuY3Rpb24gYmluZEZCTyhnbCwgZmJvLCB0ZXh0dXJlKSB7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmYm8pO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG59XG5mdW5jdGlvbiBjbGVhclRleHR1cmUoZ2wsIHRleHR1cmUpIHtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDBdKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbmplY3RBdHRyR3JvdXAoKSB7XG4gICAgY29uc3QgZ3JvdXBEYXRhID0gW107XG4gICAgbGV0IGN1cnJlbnRMZW4gPSAwO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZEdyb3VwOiAobmFtZSwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IChfYiA9IChfYSA9IGRhdGFbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG4gICAgICAgICAgICBpZiAobGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYG5vIGRhdGEgZm91bmQgaW5AJHtuYW1lfSwgcmVjZWl2ZWQgJHtkYXRhfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMZW4gJiYgZGF0YS5sZW5ndGggIT09IGN1cnJlbnRMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYGxlbmd0aCBub3QgbWF0Y2hAJHtuYW1lfSwgZXhwZWN0ZWQgJHtjdXJyZW50TGVufSwgcmVjZWl2ZWQgJHtkYXRhLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRMZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIGdyb3VwRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGluamVjdDogKGdsLCBwcm9ncmFtKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudExlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBncm91cERhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEdyb3VwID0gZ3JvdXBEYXRhW2pdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGN1cnJlbnRHcm91cC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucHVzaCgoX2IgPSAoX2EgPSBjdXJyZW50R3JvdXAuZGF0YVtpXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2tdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluamVjdEF0dHIoZ2wsIHByb2dyYW0sIHZhbHVlLCBncm91cERhdGEpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZW47XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMuY3JlYXRlSW5qZWN0QXR0ckdyb3VwID0gY3JlYXRlSW5qZWN0QXR0ckdyb3VwO1xuZnVuY3Rpb24gaW5qZWN0VmVydCgpIHtcbiAgICBjb25zdCBncm91cCA9IGNyZWF0ZUluamVjdEF0dHJHcm91cCgpO1xuICAgIC8vIFstMS4wLCAtMS4wLCAxLjAsIC0xLjAsIC0xLjAsIDEuMCwgMS4wLCAxLjBdO1xuICAgIGdyb3VwLmFkZEdyb3VwKCdhX3Bvc2l0aW9uJywgW1xuICAgICAgICBbLTEuMCwgLTEuMF0sXG4gICAgICAgIFsxLjAsIC0xLjBdLFxuICAgICAgICBbLTEuMCwgMS4wXSxcbiAgICAgICAgWzEuMCwgMS4wXSxcbiAgICBdKTtcbiAgICByZXR1cm4gZ3JvdXA7XG59XG5mdW5jdGlvbiBpbmplY3RVbmlmb3JtKGdsLCBwcm9ncmFtLCBuYW1lLCBtZXRob2QsIC4uLnZhbHVlKSB7XG4gICAgY29uc3QgbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBuYW1lKTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgZ2xbbWV0aG9kXShuLCAuLi52YWx1ZSk7XG59XG5mdW5jdGlvbiBpbmplY3RUZXh0dXJlKGdsLCBwcm9ncmFtLCBuYW1lLCBpbmRleCA9IDAsIGltZywgb3B0aW9ucykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xuICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgY29uc3Qgc2FtcGxlciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBuYW1lKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZsaXApICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEpID8gMSA6IDApO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2xbYFRFWFRVUkUke2luZGV4fWBdKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBjb25zdCBkZWZhdWx0TWluRmlsdGVyID0gIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWlwbWFwKSA/IGdsLk5FQVJFU1QgOiBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUjtcbiAgICBjb25zdCBkZWZhdWx0TWF4RmlsdGVyID0gIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWlwbWFwKSA/IGdsLkxJTkVBUiA6IGdsLkxJTkVBUjtcbiAgICBjb25zdCB0ZXhQYXJhbWV0ZXJpID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRleFBhcmFtZXRlcmk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIChfYyA9IChfYiA9IHRleFBhcmFtZXRlcmkgPT09IG51bGwgfHwgdGV4UGFyYW1ldGVyaSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4UGFyYW1ldGVyaVtnbC5URVhUVVJFX01JTl9GSUxURVJdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0ZXhQYXJhbWV0ZXJpID09PSBudWxsIHx8IHRleFBhcmFtZXRlcmkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRleFBhcmFtZXRlcmlbJ1RFWFRVUkVfTUlOX0ZJTFRFUiddKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0TWluRmlsdGVyKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgKF9lID0gKF9kID0gdGV4UGFyYW1ldGVyaSA9PT0gbnVsbCB8fCB0ZXhQYXJhbWV0ZXJpID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXhQYXJhbWV0ZXJpW2dsLlRFWFRVUkVfTUFHX0ZJTFRFUl0pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRleFBhcmFtZXRlcmkgPT09IG51bGwgfHwgdGV4UGFyYW1ldGVyaSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4UGFyYW1ldGVyaVsnVEVYVFVSRV9NQUdfRklMVEVSJ10pICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGRlZmF1bHRNYXhGaWx0ZXIpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIChfZyA9IChfZiA9IHRleFBhcmFtZXRlcmkgPT09IG51bGwgfHwgdGV4UGFyYW1ldGVyaSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4UGFyYW1ldGVyaVtnbC5URVhUVVJFX1dSQVBfU10pICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHRleFBhcmFtZXRlcmkgPT09IG51bGwgfHwgdGV4UGFyYW1ldGVyaSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4UGFyYW1ldGVyaVsnVEVYVFVSRV9XUkFQX1MnXSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgKF9qID0gKF9oID0gdGV4UGFyYW1ldGVyaSA9PT0gbnVsbCB8fCB0ZXhQYXJhbWV0ZXJpID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXhQYXJhbWV0ZXJpW2dsLlRFWFRVUkVfV1JBUF9UXSkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogdGV4UGFyYW1ldGVyaSA9PT0gbnVsbCB8fCB0ZXhQYXJhbWV0ZXJpID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXhQYXJhbWV0ZXJpWydURVhUVVJFX1dSQVBfVCddKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC51bmlmb3JtMWkoc2FtcGxlciwgaW5kZXgpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1nKTtcbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1pcG1hcCkge1xuICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1c2VJbmplY3RHbERhdGEoZ2wsIHByb2dyYW0sIGNhbnZhcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxhc3RNb3VzZVBvc2l0aW9uID0gWzAsIDBdO1xuICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBmdW5jdGlvbiBpbmplY3QoKSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIC8vIOS4uiB1X3RpbWUg5o+Q5L6b5YC8XG4gICAgICAgIGNvbnN0IHRpbWUgPSAobm93LmdldFRpbWUoKSAtIHN0YXJ0KSAvIDEwMDA7XG4gICAgICAgIGNvbnN0IHVUaW1lTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfdGltZScpO1xuICAgICAgICBnbC51bmlmb3JtMWYodVRpbWVMb2NhdGlvbiwgdGltZSk7XG4gICAgICAgIGNvbnN0IGlUaW1lTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ2lUaW1lJyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihpVGltZUxvY2F0aW9uLCB0aW1lKTtcbiAgICAgICAgLy8g5Li6IHVfbW91c2Ug5o+Q5L6b5YC8XG4gICAgICAgIGNvbnN0IHVNb3VzZUxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdpTW91c2UnKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmKHVNb3VzZUxvY2F0aW9uLCAuLi5sYXN0TW91c2VQb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IHVSZXNvbHV0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmKHVSZXNvbHV0aW9uLCBjYW52YXMuY2xpZW50V2lkdGggKiBvcHRpb25zLnJhdGlvLCBjYW52YXMuY2xpZW50SGVpZ2h0ICogb3B0aW9ucy5yYXRpbyk7XG4gICAgICAgIGNvbnN0IGlSZXNvbHV0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdpUmVzb2x1dGlvbicpO1xuICAgICAgICBnbC51bmlmb3JtM2YoaVJlc29sdXRpb24sIGNhbnZhcy5jbGllbnRXaWR0aCAqIG9wdGlvbnMucmF0aW8sIGNhbnZhcy5jbGllbnRIZWlnaHQgKiBvcHRpb25zLnJhdGlvLCAwKTtcbiAgICAgICAgLy8gZ2wudW5pZm9ybTRmKFxuICAgICAgICAvLyAgICAgdURhdGVMb2NhdGlvbixcbiAgICAgICAgLy8gICAgIG5vdy5nZXRGdWxsWWVhcigpLFxuICAgICAgICAvLyAgICAgbm93LmdldE1vbnRoKCkgKyAxLFxuICAgICAgICAvLyAgICAgbm93LmdldERhdGUoKSxcbiAgICAgICAgLy8gICAgIG5vdy5nZXRIb3VycygpICsgbm93LmdldE1pbnV0ZXMoKSAvIDYwLFxuICAgICAgICAvLyApO1xuICAgICAgICAvLyDkuLogdV9jYW1lcmEg5o+Q5L6b5YC8XG4gICAgICAgIC8vIGNvbnN0IHVDYW1lcmFMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9jYW1lcmEnKTtcbiAgICAgICAgLy8gZ2wudW5pZm9ybTNmKHVDYW1lcmFMb2NhdGlvbiwgMC4wLCAwLjAsIC0yLjApO1xuICAgICAgICAvLyDkuLogdV9zYW1wbGVSYXRlIOaPkOS+m+WAvFxuICAgICAgICAvLyBjb25zdCB1U2FtcGxlUmF0ZUxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3NhbXBsZVJhdGUnKTtcbiAgICAgICAgLy8gZ2wudW5pZm9ybTFmKHVTYW1wbGVSYXRlTG9jYXRpb24sIDQ0MTAwLjApO1xuICAgICAgICAvLyDkuLogaVJlc29sdXRpb24g5o+Q5L6b5YC8XG4gICAgICAgIGNvbnN0IGlSZXNvbHV0aW9uTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ2lSZXNvbHV0aW9uJyk7XG4gICAgICAgIGdsLnVuaWZvcm0zZihpUmVzb2x1dGlvbkxvY2F0aW9uLCBjYW52YXMuY2xpZW50V2lkdGgsIGNhbnZhcy5jbGllbnRIZWlnaHQsIG9wdGlvbnMucmF0aW8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRNb3ZlKGUpIHtcbiAgICAgICAgY29uc3QgdyA9IGNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgICAgY29uc3QgaCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGxhc3RNb3VzZVBvc2l0aW9uWzBdID0gZS5jbGllbnRYIC8gdztcbiAgICAgICAgbGFzdE1vdXNlUG9zaXRpb25bMV0gPSBlLmNsaWVudFkgLyBoO1xuICAgIH1cbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBzZXRNb3ZlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbmplY3QsXG4gICAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHNldE1vdmUpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnRzLnVzZUluamVjdEdsRGF0YSA9IHVzZUluamVjdEdsRGF0YTtcbmZ1bmN0aW9uIGNyZWF0ZUdsQ29udGV4dChjYW52YXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInLCBPYmplY3QuYXNzaWduKHsgYWxwaGE6IHRydWUsIGRlcHRoOiB0cnVlLCBwcmVtdWx0aXBsaWVkQWxwaGE6IHRydWUgfSwgb3B0aW9ucykpO1xuICAgIGlmICghZ2wpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB3ZWJnbCBjb250ZXh0IGNyZWF0ZSBmYWlsZWRgKTtcbiAgICB9XG4gICAgc2V0QmxlbmQoZ2wsICdub3JtYWwnKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGZhbHNlKTtcbiAgICByZXR1cm4gZ2w7XG59XG5leHBvcnRzLmNyZWF0ZUdsQ29udGV4dCA9IGNyZWF0ZUdsQ29udGV4dDtcbmZ1bmN0aW9uIGNoZWNrU2hhZGVyKGdsLCBzaGFkZXIsIHNvdXJjZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBjb21waWxlZCA9IGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKTtcbiAgICBpZiAoIWNvbXBpbGVkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTaGFkZXIgY29tcGlsZSBlcnJvcjogJyArIGVycm9yKTtcbiAgICAgICAgY29uc3QgW21hdGNoLCBmaWxlLCBsaW5lXSA9IChfYSA9IC9FUlJPUjogKFtcXGRdKyk6KFtcXGRdKykvLmV4ZWMoZXJyb3IgIT09IG51bGwgJiYgZXJyb3IgIT09IHZvaWQgMCA/IGVycm9yIDogJycpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgY29uc29sZS5lcnJvcignZXJyb3IgbGluZTogJywgc291cmNlLnNwbGl0KCdcXG4nKVsrbGluZSAtIDFdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQcm9ncmFtKGdsLCBzaGFkZXIpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgLy8g5Yib5bu66aG254K5552A6Imy5ZmoXG4gICAgY29uc3QgdlNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSKTtcbiAgICAvLyDliJvlu7rniYflhYPnnYDoibLlmahcbiAgICBjb25zdCBmU2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgaWYgKCFwcm9ncmFtKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJvZ3JhbSBjcmVhdGUgZmFpbGVkYCk7XG4gICAgfVxuICAgIGlmICghdlNoYWRlciB8fCAhZlNoYWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNoYWRlciBjcmVhdGUgZmFpbGVkYCk7XG4gICAgfVxuICAgIGNvbnN0IGZpbmFsVmVydCA9IChfYSA9IHNoYWRlciA9PT0gbnVsbCB8fCBzaGFkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNoYWRlci52ZXJ0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBleHBvcnRzLkRFRkFVTFRfR0wyX1ZFUlQ7XG4gICAgY29uc3QgZmluYWxGcmFnID0gKF9iID0gc2hhZGVyID09PSBudWxsIHx8IHNoYWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2hhZGVyLmZyYWcpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGV4cG9ydHMuREVGQVVMVF9HTDJfRlJBRztcbiAgICAvLyBzaGFkZXLlrrnlmajkuI7nnYDoibLlmajnu5HlrppcbiAgICBnbC5zaGFkZXJTb3VyY2UodlNoYWRlciwgZmluYWxWZXJ0KTtcbiAgICBnbC5zaGFkZXJTb3VyY2UoZlNoYWRlciwgZmluYWxGcmFnKTtcbiAgICAvLyDlsIZHTFNF6K+t6KiA57yW6K+R5oiQ5rWP6KeI5Zmo5Y+v55So5Luj56CBXG4gICAgZ2wuY29tcGlsZVNoYWRlcih2U2hhZGVyKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKGZTaGFkZXIpO1xuICAgIGNoZWNrU2hhZGVyKGdsLCB2U2hhZGVyLCBmaW5hbFZlcnQpO1xuICAgIGNoZWNrU2hhZGVyKGdsLCBmU2hhZGVyLCBmaW5hbEZyYWcpO1xuICAgIC8vIOWwhuedgOiJsuWZqOa3u+WKoOWIsOeoi+W6j+S4ilxuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2U2hhZGVyKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZlNoYWRlcik7XG4gICAgLy8g6ZO+5o6l56iL5bqP77yM5Zyo6ZO+5o6l5pON5L2c5omn6KGM5Lul5ZCO77yM5Y+v5Lul5Lu75oSP5L+u5pS5c2hhZGVy55qE5rqQ5Luj56CB77yMXG4gICAgLy8g5a+5c2hhZGVy6YeN5paw57yW6K+R5LiN5Lya5b2x5ZON5pW05Liq56iL5bqP77yM6Zmk6Z2e6YeN5paw6ZO+5o6l56iL5bqPXG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgLy8g5Yqg6L295bm25L2/55So6ZO+5o6l5aW955qE56iL5bqPXG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhmU2hhZGVyKTtcbiAgICBpZiAobWVzc2FnZSAmJiBtZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLyogbWVzc2FnZSBtYXkgYmUgYW4gZXJyb3Igb3IgYSB3YXJuaW5nICovXG4gICAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBwcm9ncmFtO1xufVxuZXhwb3J0cy5jcmVhdGVQcm9ncmFtID0gY3JlYXRlUHJvZ3JhbTtcbmZ1bmN0aW9uIGdldEZpbmFsU2hhZGVyQ29uZmlnKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiB7XG4gICAgICAgIHZlcnQ6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52ZXJ0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52ZXJ0TWFpbikgPyBgJHtzaW1wbGVWZXJ0SGVhZGVyfSR7b3B0aW9ucy52ZXJ0TWFpbn1gIDogdW5kZWZpbmVkKSxcbiAgICAgICAgZnJhZzogKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZyYWcpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1haW4pID8gYCR7c2ltcGxlRnJhZ0hlYWRlcn0ke29wdGlvbnMubWFpbn1gIDogdW5kZWZpbmVkKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gc2ltcGxlSW5pdChjYW52YXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGNvbnN0IHJhdGlvID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJhdGlvKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBERUZBVUxUX1JBVElPO1xuICAgIGNvbnN0IGZwcyA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mcHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDQwO1xuICAgIGVuc3VyZUNhbnZhcyhjYW52YXMsIHJhdGlvKTtcbiAgICBjb25zdCBnbCA9IGNyZWF0ZUdsQ29udGV4dChjYW52YXMsIHtcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlc2VydmVEcmF3aW5nQnVmZmVyKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBmYWxzZSxcbiAgICB9KTtcbiAgICBjb25zdCBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbShnbCwgZ2V0RmluYWxTaGFkZXJDb25maWcob3B0aW9ucykpO1xuICAgIGNvbnN0IHsgaW5qZWN0LCBkZXN0cm95IH0gPSB1c2VJbmplY3RHbERhdGEoZ2wsIHByb2dyYW0sIGNhbnZhcywgeyByYXRpbyB9KTtcbiAgICBjb25zdCBpbmplY3RHcm91cERhdGEgPSAoX2QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXR0cikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogaW5qZWN0VmVydCgpO1xuICAgIGluamVjdEdyb3VwRGF0YS5pbmplY3QoZ2wsIHByb2dyYW0pO1xuICAgIGluamVjdCgpO1xuICAgIGxldCB0aW1lciA9IDA7XG4gICAgbGV0IGxhc3RSZW5kZXIgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHRpY2tEdXJhdGlvbiA9IDEwMDAgLyBmcHM7XG4gICAgY29uc3QgY2xlYXJDb2xvciA9IChfZSA9IG9wdGlvbnMuY2xlYXJDb2xvcikgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogWzAsIDAsIDAsIDBdO1xuICAgIC8vIEZCT+WkhOeQhlxuICAgIGNvbnN0IHsgZmJvOiBmYm8xLCB0ZXh0dXJlOiB0ZXh0dXJlMSB9ID0gaW5pdEZCTyhnbCk7XG4gICAgY29uc3QgeyBmYm86IGZibzIsIHRleHR1cmU6IHRleHR1cmUyIH0gPSBpbml0RkJPKGdsKTtcbiAgICBjb25zdCBGQk9DYWNoZSA9IFtmYm8xLCBmYm8yXTtcbiAgICBjb25zdCBGQk9UZXh0dXJlQ2FjaGUgPSBbdGV4dHVyZTEsIHRleHR1cmUyXTtcbiAgICBjb25zdCBGQk9DYWNoZUxlbmd0aCA9IEZCT0NhY2hlLmxlbmd0aDtcbiAgICAvLyBpZihvcHRpb25zPy5wb3N0UHJvY2Vzcyl7XG4gICAgLy8gICAgIGNvbnN0IHBvc3RQb3N0UHJvZ3JhbXMgPSBvcHRpb25zLnBvc3RQcm9jZXNzPy5tYXAoc2hhZGVyT3B0aW9ucyA9PiBjcmVhdGVQcm9ncmFtKGdsLCBnZXRGaW5hbFNoYWRlckNvbmZpZyhzaGFkZXJPcHRpb25zKSkpO1xuICAgIC8vIH1cbiAgICAvLyBGQk/lpITnkIZcbiAgICBsZXQgY3VycmVudEZCT0luZGV4ID0gMDtcbiAgICBsZXQgcHJldkZCT0luZGV4ID0gMTtcbiAgICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgLy8gY2xlYXJcbiAgICAgICAgZ2wuY2xlYXJDb2xvciguLi5jbGVhckNvbG9yKTtcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZ2wuZHJhd0FycmF5cygoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZHJhd1R5cGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGdsLlRSSUFOR0xFX1NUUklQLCAwLCBpbmplY3RHcm91cERhdGEubGVuZ3RoKTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRSZW5kZXJlciA9IHVuZGVmaW5lZDtcbiAgICBmdW5jdGlvbiBsb29wUmVuZGVyKCkge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAobm93IC0gbGFzdFJlbmRlciA+PSB0aWNrRHVyYXRpb24pIHtcbiAgICAgICAgICAgIGxhc3RSZW5kZXIgPSBub3c7XG4gICAgICAgICAgICBjdXJyZW50UmVuZGVyZXIgPT09IG51bGwgfHwgY3VycmVudFJlbmRlcmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50UmVuZGVyZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lciA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wUmVuZGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyVGlja1dpdGhMYXN0U2NlbmUoKSB7XG4gICAgICAgIC8vIOe7keWumuWIsOW9k+WJjUZCT1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIEZCT0NhY2hlW2N1cnJlbnRGQk9JbmRleF0pO1xuICAgICAgICAvLyDkvb/nlKjkuIrkuIDluKfnmoTnu5PmnpzkvZzkuLrnurnnkIbovpPlhaVcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIEZCT1RleHR1cmVDYWNoZVtwcmV2RkJPSW5kZXhdKTsgLy8g5rOo5oSP6L+Z6YeM5L2/55So5Lqk5o2i5ZCO55qEdGV4dHVyZTJcbiAgICAgICAgLy8g5rOo5YWldW5pZm9ybVxuICAgICAgICBjb25zdCBsb2MgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VQcmV2Jyk7XG4gICAgICAgIGdsLnVuaWZvcm0xaShsb2MsIDApO1xuICAgICAgICBpbmplY3QoKTtcbiAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgLy8g57uY5Yi25YiwZmJvXG4gICAgICAgIGRyYXcoKTtcbiAgICAgICAgLy8g6Kej57uRRkJP77yM5ZCO57ut57uY5Yi25Yiw5bGP5bmVXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICAgIC8vIOWwhuacgOe7iOe7k+aenOe7mOWItuWIsOWxj+W5le+8iOS9v+eUqOW9k+WJjUZCT+eahOe6ueeQhu+8iVxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBGQk9UZXh0dXJlQ2FjaGVbY3VycmVudEZCT0luZGV4XSk7XG4gICAgICAgIGRyYXcoKTtcbiAgICAgICAgY3VycmVudEZCT0luZGV4ID0gKGN1cnJlbnRGQk9JbmRleCArIDEpICUgRkJPQ2FjaGVMZW5ndGg7XG4gICAgICAgIHByZXZGQk9JbmRleCA9IChwcmV2RkJPSW5kZXggKyAxKSAlIEZCT0NhY2hlTGVuZ3RoO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJUaWNrKCkge1xuICAgICAgICBpbmplY3QoKTtcbiAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgLy8g57uY5Yi25YiwZmJvXG4gICAgICAgIGRyYXcoKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudXNlTGFzdFZpZXcpIHtcbiAgICAgICAgY3VycmVudFJlbmRlcmVyID0gcmVuZGVyVGlja1dpdGhMYXN0U2NlbmU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjdXJyZW50UmVuZGVyZXIgPSByZW5kZXJUaWNrO1xuICAgIH1cbiAgICBjb25zdCBhcGkgPSB7XG4gICAgICAgIGdsLFxuICAgICAgICBpbmplY3Q6IChuYW1lLCBtZXRob2QsIC4uLnZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpbmplY3RVbmlmb3JtKGdsLCBwcm9ncmFtLCBuYW1lLCBtZXRob2QsIC4uLnZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5qZWN0VGV4dHVyZTogKG5hbWUsIGluZGV4LCBpbWcsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGluamVjdFRleHR1cmUoZ2wsIHByb2dyYW0sIG5hbWUsIGluZGV4LCBpbWcsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVVQk86IChpbmRleCwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIC8vIGxheW91dChzdGQxNDApIHVuaWZvcm0gVUJPXG4gICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAvLyAgICAgdmVjMiBkYXRhWzEwMF07XG4gICAgICAgICAgICAvLyB9IHVibztcbiAgICAgICAgICAgIC8vIHViby5kYXRhW2ldO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVVCTyhnbCwgcHJvZ3JhbSwgaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGxheTogKCkgPT4ge1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGltZXIpO1xuICAgICAgICAgICAgbG9vcFJlbmRlcigpO1xuICAgICAgICB9LFxuICAgICAgICBzdG9wOiAoKSA9PiB7XG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aW1lcik7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF1dG9QbGF5KSB7XG4gICAgICAgIGFwaS5wbGF5KCk7XG4gICAgfVxuICAgIHJldHVybiBhcGk7XG59XG5leHBvcnRzLnNpbXBsZUluaXQgPSBzaW1wbGVJbml0O1xuZnVuY3Rpb24gcmVuZGVyRnVsbFNjcmVlbkNhbnZhcyhvcHRpb25zKSB7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5jc3NUZXh0ICs9IGBtYXJnaW46MDtwYWRkaW5nOjA7YDtcbiAgICBjYW52YXMuc3R5bGUuY3NzVGV4dCA9IGBkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMHZ3O2hlaWdodDoxMDB2aDtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50O2A7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgIGVuc3VyZUNhbnZhcyhjYW52YXMpO1xuICAgIHJldHVybiBzaW1wbGVJbml0KGNhbnZhcywgb3B0aW9ucyk7XG59XG5leHBvcnRzLnJlbmRlckZ1bGxTY3JlZW5DYW52YXMgPSByZW5kZXJGdWxsU2NyZWVuQ2FudmFzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/common/gl/index.ts\n");

/***/ }),

/***/ "./src/fboTest/index.ts":
/*!******************************!*\
  !*** ./src/fboTest/index.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst gl_1 = __webpack_require__(/*! ../common/gl */ \"./src/common/gl/index.ts\");\nconst frag_glsl_1 = __importDefault(__webpack_require__(/*! ./frag.glsl */ \"./src/fboTest/frag.glsl\"));\nfunction main() {\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      gl,\n      play\n    } = (0, gl_1.renderFullScreenCanvas)({\n      main: frag_glsl_1.default,\n      autoPlay: true,\n      // fps:1,\n      clearColor: [1, 1, 1, 0],\n      useLastView: true\n    });\n  });\n}\nmain();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZmJvVGVzdC9pbmRleC50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhYi8uL3NyYy9mYm9UZXN0L2luZGV4LnRzP2ZlMDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGdsXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2dsXCIpO1xuY29uc3QgZnJhZ19nbHNsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZnJhZy5nbHNsXCIpKTtcbmZ1bmN0aW9uIG1haW4oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgeyBnbCwgcGxheSB9ID0gKDAsIGdsXzEucmVuZGVyRnVsbFNjcmVlbkNhbnZhcykoe1xuICAgICAgICAgICAgbWFpbjogZnJhZ19nbHNsXzEuZGVmYXVsdCxcbiAgICAgICAgICAgIGF1dG9QbGF5OiB0cnVlLFxuICAgICAgICAgICAgLy8gZnBzOjEsXG4gICAgICAgICAgICBjbGVhckNvbG9yOiBbMSwgMSwgMSwgMF0sXG4gICAgICAgICAgICB1c2VMYXN0VmlldzogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5tYWluKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/fboTest/index.ts\n");

/***/ }),

/***/ "./src/fboTest/frag.glsl":
/*!*******************************!*\
  !*** ./src/fboTest/frag.glsl ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"\\nuniform sampler2D uPrev;\\n\\nvoid main(){\\n    vec2 st=fragCoord.xy/iResolution.xy;\\n    \\n    vec4 last=texture(uPrev,st,1.);\\n    \\n    st.x=st.x+iTime/100. * 2.;\\n    float d=distance(st,vec2(.5));\\n    \\n    vec4 color=last;\\n    // vec4 color=vec4(0.);\\n    // color.a = color.a * .9;\\n    // color.r = color.b * .9;\\n    // color.b = 0.5;\\n    \\n    if(d<.1){\\n        // fragColor=vec4(0.,0.,1.,1.);\\n        color = vec4(0.,0.,1.,1.);\\n    }else{\\n        // fragColor=vec4(0.,0.,0.,.1);\\n        color.a -= 0.01;\\n    }\\n    \\n    fragColor=color;\\n    \\n}\\n\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZmJvVGVzdC9mcmFnLmdsc2wuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFiLy4vc3JjL2Zib1Rlc3QvZnJhZy5nbHNsP2M0YzIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJcXG51bmlmb3JtIHNhbXBsZXIyRCB1UHJldjtcXG5cXG52b2lkIG1haW4oKXtcXG4gICAgdmVjMiBzdD1mcmFnQ29vcmQueHkvaVJlc29sdXRpb24ueHk7XFxuICAgIFxcbiAgICB2ZWM0IGxhc3Q9dGV4dHVyZSh1UHJldixzdCwxLik7XFxuICAgIFxcbiAgICBzdC54PXN0LngraVRpbWUvMTAwLiAqIDIuO1xcbiAgICBmbG9hdCBkPWRpc3RhbmNlKHN0LHZlYzIoLjUpKTtcXG4gICAgXFxuICAgIHZlYzQgY29sb3I9bGFzdDtcXG4gICAgLy8gdmVjNCBjb2xvcj12ZWM0KDAuKTtcXG4gICAgLy8gY29sb3IuYSA9IGNvbG9yLmEgKiAuOTtcXG4gICAgLy8gY29sb3IuciA9IGNvbG9yLmIgKiAuOTtcXG4gICAgLy8gY29sb3IuYiA9IDAuNTtcXG4gICAgXFxuICAgIGlmKGQ8LjEpe1xcbiAgICAgICAgLy8gZnJhZ0NvbG9yPXZlYzQoMC4sMC4sMS4sMS4pO1xcbiAgICAgICAgY29sb3IgPSB2ZWM0KDAuLDAuLDEuLDEuKTtcXG4gICAgfWVsc2V7XFxuICAgICAgICAvLyBmcmFnQ29sb3I9dmVjNCgwLiwwLiwwLiwuMSk7XFxuICAgICAgICBjb2xvci5hIC09IDAuMDE7XFxuICAgIH1cXG4gICAgXFxuICAgIGZyYWdDb2xvcj1jb2xvcjtcXG4gICAgXFxufVxcblwiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/fboTest/frag.glsl\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("../../../.config/yarn/global/node_modules/regenerator-runtime/runtime.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/fboTest/index.ts");
/******/ 	
/******/ })()
;