/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.createArrayExpression = exports.checkCompatEnabled = exports.buildSlots = exports.buildProps = exports.buildDirectiveArgs = exports.baseParse = exports.baseCompile = exports.assert = exports.advancePositionWithMutation = exports.advancePositionWithClone = exports.WITH_MEMO = exports.WITH_DIRECTIVES = exports.WITH_CTX = exports.UNREF = exports.TO_HANDLER_KEY = exports.TO_HANDLERS = exports.TO_DISPLAY_STRING = exports.TELEPORT = exports.SUSPENSE = exports.SET_BLOCK_TRACKING = exports.RESOLVE_FILTER = exports.RESOLVE_DYNAMIC_COMPONENT = exports.RESOLVE_DIRECTIVE = exports.RESOLVE_COMPONENT = exports.RENDER_SLOT = exports.RENDER_LIST = exports.PUSH_SCOPE_ID = exports.POP_SCOPE_ID = exports.OPEN_BLOCK = exports.NORMALIZE_STYLE = exports.NORMALIZE_PROPS = exports.NORMALIZE_CLASS = exports.MERGE_PROPS = exports.KEEP_ALIVE = exports.IS_REF = exports.IS_MEMO_SAME = exports.GUARD_REACTIVE_PROPS = exports.FRAGMENT = exports.CREATE_VNODE = exports.CREATE_TEXT = exports.CREATE_STATIC = exports.CREATE_SLOTS = exports.CREATE_ELEMENT_VNODE = exports.CREATE_ELEMENT_BLOCK = exports.CREATE_COMMENT = exports.CREATE_BLOCK = exports.CAPITALIZE = exports.CAMELIZE = exports.BASE_TRANSITION = exports.generateCodeFrame = void 0;\nexports.isTemplateNode = exports.isStaticPropertyKey = exports.isStaticProperty = exports.isStaticExp = exports.isStaticArgOf = exports.isSlotOutlet = exports.isSimpleIdentifier = exports.isReferencedIdentifier = exports.isMemberExpressionNode = exports.isMemberExpressionBrowser = exports.isMemberExpression = exports.isInDestructureAssignment = exports.isFunctionType = exports.isCoreComponent = exports.isBuiltInType = exports.injectProp = exports.helperNameMap = exports.hasScopeRef = exports.hasDynamicKeyVBind = exports.getVNodeHelper = exports.getVNodeBlockHelper = exports.getMemoedVNodeCall = exports.getInnerRange = exports.getConstantType = exports.getBaseTransformPreset = exports.generate = exports.findProp = exports.findDir = exports.extractIdentifiers = exports.createVNodeCall = exports.createTransformContext = exports.createTemplateLiteral = exports.createStructuralDirectiveTransform = exports.createSimpleExpression = exports.createSequenceExpression = exports.createRoot = exports.createReturnStatement = exports.createObjectProperty = exports.createObjectExpression = exports.createInterpolation = exports.createIfStatement = exports.createFunctionExpression = exports.createForLoopParams = exports.createConditionalExpression = exports.createCompoundExpression = exports.createCompilerError = exports.createCallExpression = exports.createCacheExpression = exports.createBlockStatement = exports.createAssignmentExpression = void 0;\nexports.warnDeprecation = exports.walkIdentifiers = exports.walkFunctionParams = exports.walkBlockDeclarations = exports.traverseNode = exports.transformOn = exports.transformModel = exports.transformExpression = exports.transformElement = exports.transformBind = exports.transform = exports.trackVForSlotScopes = exports.trackSlotScopes = exports.toValidAssetId = exports.stringifyExpression = exports.resolveComponentType = exports.registerRuntimeHelpers = exports.processSlotOutlet = exports.processIf = exports.processFor = exports.processExpression = exports.noopDirectiveTransform = exports.makeBlock = exports.locStub = exports.isVSlot = exports.isText = void 0;\nconst shared_1 = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/shared/dist/shared.esm-bundler.js\");\nvar shared_2 = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/shared/dist/shared.esm-bundler.js\");\nObject.defineProperty(exports, \"generateCodeFrame\", ({\n  enumerable: true,\n  get: function () {\n    return shared_2.generateCodeFrame;\n  }\n}));\nfunction defaultOnError(error) {\n  throw error;\n}\nfunction defaultOnWarn(msg) {\n   true && console.warn(`[Vue warn] ${msg.message}`);\n}\nfunction createCompilerError(code, loc, messages, additionalMessage) {\n  const msg =  true ? (messages || errorMessages)[code] + (additionalMessage || ``) : 0;\n  const error = new SyntaxError(String(msg));\n  error.code = code;\n  error.loc = loc;\n  return error;\n}\nexports.createCompilerError = createCompilerError;\nconst errorMessages = {\n  // parse errors\n  [0 /* ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: 'Illegal comment.',\n  [1 /* ErrorCodes.CDATA_IN_HTML_CONTENT */]: 'CDATA section is allowed only in XML context.',\n  [2 /* ErrorCodes.DUPLICATE_ATTRIBUTE */]: 'Duplicate attribute.',\n  [3 /* ErrorCodes.END_TAG_WITH_ATTRIBUTES */]: 'End tag cannot have attributes.',\n  [4 /* ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS */]: \"Illegal '/' in tags.\",\n  [5 /* ErrorCodes.EOF_BEFORE_TAG_NAME */]: 'Unexpected EOF in tag.',\n  [6 /* ErrorCodes.EOF_IN_CDATA */]: 'Unexpected EOF in CDATA section.',\n  [7 /* ErrorCodes.EOF_IN_COMMENT */]: 'Unexpected EOF in comment.',\n  [8 /* ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: 'Unexpected EOF in script.',\n  [9 /* ErrorCodes.EOF_IN_TAG */]: 'Unexpected EOF in tag.',\n  [10 /* ErrorCodes.INCORRECTLY_CLOSED_COMMENT */]: 'Incorrectly closed comment.',\n  [11 /* ErrorCodes.INCORRECTLY_OPENED_COMMENT */]: 'Incorrectly opened comment.',\n  [12 /* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: \"Illegal tag name. Use '&lt;' to print '<'.\",\n  [13 /* ErrorCodes.MISSING_ATTRIBUTE_VALUE */]: 'Attribute value was expected.',\n  [14 /* ErrorCodes.MISSING_END_TAG_NAME */]: 'End tag name was expected.',\n  [15 /* ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: 'Whitespace was expected.',\n  [16 /* ErrorCodes.NESTED_COMMENT */]: \"Unexpected '<!--' in comment.\",\n  [17 /* ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: 'Attribute name cannot contain U+0022 (\"), U+0027 (\\'), and U+003C (<).',\n  [18 /* ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: 'Unquoted attribute value cannot contain U+0022 (\"), U+0027 (\\'), U+003C (<), U+003D (=), and U+0060 (`).',\n  [19 /* ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: \"Attribute name cannot start with '='.\",\n  [21 /* ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: \"'<?' is allowed only in XML context.\",\n  [20 /* ErrorCodes.UNEXPECTED_NULL_CHARACTER */]: `Unexpected null character.`,\n  [22 /* ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG */]: \"Illegal '/' in tags.\",\n  // Vue-specific parse errors\n  [23 /* ErrorCodes.X_INVALID_END_TAG */]: 'Invalid end tag.',\n  [24 /* ErrorCodes.X_MISSING_END_TAG */]: 'Element is missing end tag.',\n  [25 /* ErrorCodes.X_MISSING_INTERPOLATION_END */]: 'Interpolation end sign was not found.',\n  [27 /* ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]: 'End bracket for dynamic directive argument was not found. ' + 'Note that dynamic directive argument cannot contain spaces.',\n  [26 /* ErrorCodes.X_MISSING_DIRECTIVE_NAME */]: 'Legal directive name was expected.',\n  // transform errors\n  [28 /* ErrorCodes.X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,\n  [29 /* ErrorCodes.X_V_IF_SAME_KEY */]: `v-if/else branches must use unique keys.`,\n  [30 /* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,\n  [31 /* ErrorCodes.X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,\n  [32 /* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,\n  [33 /* ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT */]: `<template v-for> key should be placed on the <template> tag.`,\n  [34 /* ErrorCodes.X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,\n  [35 /* ErrorCodes.X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,\n  [36 /* ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,\n  [37 /* ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE */]: `Mixed v-slot usage on both the component and nested <template>. ` + `When there are multiple named slots, all slots should use <template> ` + `syntax to avoid scope ambiguity.`,\n  [38 /* ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,\n  [39 /* ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]: `Extraneous children found when component already has explicitly named ` + `default slot. These children will be ignored.`,\n  [40 /* ErrorCodes.X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,\n  [41 /* ErrorCodes.X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,\n  [42 /* ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,\n  [43 /* ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,\n  [44 /* ErrorCodes.X_V_MODEL_ON_PROPS */]: `v-model cannot be used on a prop, because local prop bindings are not writable.\\nUse a v-bind binding combined with a v-on listener that emits update:x event instead.`,\n  [45 /* ErrorCodes.X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,\n  [46 /* ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,\n  // generic errors\n  [47 /* ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED */]: `\"prefixIdentifiers\" option is not supported in this build of compiler.`,\n  [48 /* ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,\n  [49 /* ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED */]: `\"cacheHandlers\" option is only supported when the \"prefixIdentifiers\" option is enabled.`,\n  [50 /* ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED */]: `\"scopeId\" option is only supported in module mode.`,\n  // just to fulfill types\n  [51 /* ErrorCodes.__EXTEND_POINT__ */]: ``\n};\nconst FRAGMENT = Symbol( true ? `Fragment` : 0);\nexports.FRAGMENT = FRAGMENT;\nconst TELEPORT = Symbol( true ? `Teleport` : 0);\nexports.TELEPORT = TELEPORT;\nconst SUSPENSE = Symbol( true ? `Suspense` : 0);\nexports.SUSPENSE = SUSPENSE;\nconst KEEP_ALIVE = Symbol( true ? `KeepAlive` : 0);\nexports.KEEP_ALIVE = KEEP_ALIVE;\nconst BASE_TRANSITION = Symbol( true ? `BaseTransition` : 0);\nexports.BASE_TRANSITION = BASE_TRANSITION;\nconst OPEN_BLOCK = Symbol( true ? `openBlock` : 0);\nexports.OPEN_BLOCK = OPEN_BLOCK;\nconst CREATE_BLOCK = Symbol( true ? `createBlock` : 0);\nexports.CREATE_BLOCK = CREATE_BLOCK;\nconst CREATE_ELEMENT_BLOCK = Symbol( true ? `createElementBlock` : 0);\nexports.CREATE_ELEMENT_BLOCK = CREATE_ELEMENT_BLOCK;\nconst CREATE_VNODE = Symbol( true ? `createVNode` : 0);\nexports.CREATE_VNODE = CREATE_VNODE;\nconst CREATE_ELEMENT_VNODE = Symbol( true ? `createElementVNode` : 0);\nexports.CREATE_ELEMENT_VNODE = CREATE_ELEMENT_VNODE;\nconst CREATE_COMMENT = Symbol( true ? `createCommentVNode` : 0);\nexports.CREATE_COMMENT = CREATE_COMMENT;\nconst CREATE_TEXT = Symbol( true ? `createTextVNode` : 0);\nexports.CREATE_TEXT = CREATE_TEXT;\nconst CREATE_STATIC = Symbol( true ? `createStaticVNode` : 0);\nexports.CREATE_STATIC = CREATE_STATIC;\nconst RESOLVE_COMPONENT = Symbol( true ? `resolveComponent` : 0);\nexports.RESOLVE_COMPONENT = RESOLVE_COMPONENT;\nconst RESOLVE_DYNAMIC_COMPONENT = Symbol( true ? `resolveDynamicComponent` : 0);\nexports.RESOLVE_DYNAMIC_COMPONENT = RESOLVE_DYNAMIC_COMPONENT;\nconst RESOLVE_DIRECTIVE = Symbol( true ? `resolveDirective` : 0);\nexports.RESOLVE_DIRECTIVE = RESOLVE_DIRECTIVE;\nconst RESOLVE_FILTER = Symbol( true ? `resolveFilter` : 0);\nexports.RESOLVE_FILTER = RESOLVE_FILTER;\nconst WITH_DIRECTIVES = Symbol( true ? `withDirectives` : 0);\nexports.WITH_DIRECTIVES = WITH_DIRECTIVES;\nconst RENDER_LIST = Symbol( true ? `renderList` : 0);\nexports.RENDER_LIST = RENDER_LIST;\nconst RENDER_SLOT = Symbol( true ? `renderSlot` : 0);\nexports.RENDER_SLOT = RENDER_SLOT;\nconst CREATE_SLOTS = Symbol( true ? `createSlots` : 0);\nexports.CREATE_SLOTS = CREATE_SLOTS;\nconst TO_DISPLAY_STRING = Symbol( true ? `toDisplayString` : 0);\nexports.TO_DISPLAY_STRING = TO_DISPLAY_STRING;\nconst MERGE_PROPS = Symbol( true ? `mergeProps` : 0);\nexports.MERGE_PROPS = MERGE_PROPS;\nconst NORMALIZE_CLASS = Symbol( true ? `normalizeClass` : 0);\nexports.NORMALIZE_CLASS = NORMALIZE_CLASS;\nconst NORMALIZE_STYLE = Symbol( true ? `normalizeStyle` : 0);\nexports.NORMALIZE_STYLE = NORMALIZE_STYLE;\nconst NORMALIZE_PROPS = Symbol( true ? `normalizeProps` : 0);\nexports.NORMALIZE_PROPS = NORMALIZE_PROPS;\nconst GUARD_REACTIVE_PROPS = Symbol( true ? `guardReactiveProps` : 0);\nexports.GUARD_REACTIVE_PROPS = GUARD_REACTIVE_PROPS;\nconst TO_HANDLERS = Symbol( true ? `toHandlers` : 0);\nexports.TO_HANDLERS = TO_HANDLERS;\nconst CAMELIZE = Symbol( true ? `camelize` : 0);\nexports.CAMELIZE = CAMELIZE;\nconst CAPITALIZE = Symbol( true ? `capitalize` : 0);\nexports.CAPITALIZE = CAPITALIZE;\nconst TO_HANDLER_KEY = Symbol( true ? `toHandlerKey` : 0);\nexports.TO_HANDLER_KEY = TO_HANDLER_KEY;\nconst SET_BLOCK_TRACKING = Symbol( true ? `setBlockTracking` : 0);\nexports.SET_BLOCK_TRACKING = SET_BLOCK_TRACKING;\nconst PUSH_SCOPE_ID = Symbol( true ? `pushScopeId` : 0);\nexports.PUSH_SCOPE_ID = PUSH_SCOPE_ID;\nconst POP_SCOPE_ID = Symbol( true ? `popScopeId` : 0);\nexports.POP_SCOPE_ID = POP_SCOPE_ID;\nconst WITH_CTX = Symbol( true ? `withCtx` : 0);\nexports.WITH_CTX = WITH_CTX;\nconst UNREF = Symbol( true ? `unref` : 0);\nexports.UNREF = UNREF;\nconst IS_REF = Symbol( true ? `isRef` : 0);\nexports.IS_REF = IS_REF;\nconst WITH_MEMO = Symbol( true ? `withMemo` : 0);\nexports.WITH_MEMO = WITH_MEMO;\nconst IS_MEMO_SAME = Symbol( true ? `isMemoSame` : 0);\nexports.IS_MEMO_SAME = IS_MEMO_SAME;\n// Name mapping for runtime helpers that need to be imported from 'vue' in\n// generated code. Make sure these are correctly exported in the runtime!\nconst helperNameMap = {\n  [FRAGMENT]: `Fragment`,\n  [TELEPORT]: `Teleport`,\n  [SUSPENSE]: `Suspense`,\n  [KEEP_ALIVE]: `KeepAlive`,\n  [BASE_TRANSITION]: `BaseTransition`,\n  [OPEN_BLOCK]: `openBlock`,\n  [CREATE_BLOCK]: `createBlock`,\n  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,\n  [CREATE_VNODE]: `createVNode`,\n  [CREATE_ELEMENT_VNODE]: `createElementVNode`,\n  [CREATE_COMMENT]: `createCommentVNode`,\n  [CREATE_TEXT]: `createTextVNode`,\n  [CREATE_STATIC]: `createStaticVNode`,\n  [RESOLVE_COMPONENT]: `resolveComponent`,\n  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,\n  [RESOLVE_DIRECTIVE]: `resolveDirective`,\n  [RESOLVE_FILTER]: `resolveFilter`,\n  [WITH_DIRECTIVES]: `withDirectives`,\n  [RENDER_LIST]: `renderList`,\n  [RENDER_SLOT]: `renderSlot`,\n  [CREATE_SLOTS]: `createSlots`,\n  [TO_DISPLAY_STRING]: `toDisplayString`,\n  [MERGE_PROPS]: `mergeProps`,\n  [NORMALIZE_CLASS]: `normalizeClass`,\n  [NORMALIZE_STYLE]: `normalizeStyle`,\n  [NORMALIZE_PROPS]: `normalizeProps`,\n  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,\n  [TO_HANDLERS]: `toHandlers`,\n  [CAMELIZE]: `camelize`,\n  [CAPITALIZE]: `capitalize`,\n  [TO_HANDLER_KEY]: `toHandlerKey`,\n  [SET_BLOCK_TRACKING]: `setBlockTracking`,\n  [PUSH_SCOPE_ID]: `pushScopeId`,\n  [POP_SCOPE_ID]: `popScopeId`,\n  [WITH_CTX]: `withCtx`,\n  [UNREF]: `unref`,\n  [IS_REF]: `isRef`,\n  [WITH_MEMO]: `withMemo`,\n  [IS_MEMO_SAME]: `isMemoSame`\n};\nexports.helperNameMap = helperNameMap;\nfunction registerRuntimeHelpers(helpers) {\n  Object.getOwnPropertySymbols(helpers).forEach(s => {\n    helperNameMap[s] = helpers[s];\n  });\n}\nexports.registerRuntimeHelpers = registerRuntimeHelpers;\n// AST Utilities ---------------------------------------------------------------\n// Some expressions, e.g. sequence and conditional expressions, are never\n// associated with template nodes, so their source locations are just a stub.\n// Container types like CompoundExpression also don't need a real location.\nconst locStub = {\n  source: '',\n  start: {\n    line: 1,\n    column: 1,\n    offset: 0\n  },\n  end: {\n    line: 1,\n    column: 1,\n    offset: 0\n  }\n};\nexports.locStub = locStub;\nfunction createRoot(children) {\n  let loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locStub;\n  return {\n    type: 0 /* NodeTypes.ROOT */,\n    children,\n    helpers: new Set(),\n    components: [],\n    directives: [],\n    hoists: [],\n    imports: [],\n    cached: 0,\n    temps: 0,\n    codegenNode: undefined,\n    loc\n  };\n}\nexports.createRoot = createRoot;\nfunction createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives) {\n  let isBlock = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  let disableTracking = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;\n  let isComponent = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;\n  let loc = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : locStub;\n  if (context) {\n    if (isBlock) {\n      context.helper(OPEN_BLOCK);\n      context.helper(getVNodeBlockHelper(context.inSSR, isComponent));\n    } else {\n      context.helper(getVNodeHelper(context.inSSR, isComponent));\n    }\n    if (directives) {\n      context.helper(WITH_DIRECTIVES);\n    }\n  }\n  return {\n    type: 13 /* NodeTypes.VNODE_CALL */,\n    tag,\n    props,\n    children,\n    patchFlag,\n    dynamicProps,\n    directives,\n    isBlock,\n    disableTracking,\n    isComponent,\n    loc\n  };\n}\nexports.createVNodeCall = createVNodeCall;\nfunction createArrayExpression(elements) {\n  let loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locStub;\n  return {\n    type: 17 /* NodeTypes.JS_ARRAY_EXPRESSION */,\n    loc,\n    elements\n  };\n}\nexports.createArrayExpression = createArrayExpression;\nfunction createObjectExpression(properties) {\n  let loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locStub;\n  return {\n    type: 15 /* NodeTypes.JS_OBJECT_EXPRESSION */,\n    loc,\n    properties\n  };\n}\nexports.createObjectExpression = createObjectExpression;\nfunction createObjectProperty(key, value) {\n  return {\n    type: 16 /* NodeTypes.JS_PROPERTY */,\n    loc: locStub,\n    key: (0, shared_1.isString)(key) ? createSimpleExpression(key, true) : key,\n    value\n  };\n}\nexports.createObjectProperty = createObjectProperty;\nfunction createSimpleExpression(content) {\n  let isStatic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let loc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : locStub;\n  let constType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  return {\n    type: 4 /* NodeTypes.SIMPLE_EXPRESSION */,\n    loc,\n    content,\n    isStatic,\n    constType: isStatic ? 3 /* ConstantTypes.CAN_STRINGIFY */ : constType\n  };\n}\nexports.createSimpleExpression = createSimpleExpression;\nfunction createInterpolation(content, loc) {\n  return {\n    type: 5 /* NodeTypes.INTERPOLATION */,\n    loc,\n    content: (0, shared_1.isString)(content) ? createSimpleExpression(content, false, loc) : content\n  };\n}\nexports.createInterpolation = createInterpolation;\nfunction createCompoundExpression(children) {\n  let loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locStub;\n  return {\n    type: 8 /* NodeTypes.COMPOUND_EXPRESSION */,\n    loc,\n    children\n  };\n}\nexports.createCompoundExpression = createCompoundExpression;\nfunction createCallExpression(callee) {\n  let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let loc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : locStub;\n  return {\n    type: 14 /* NodeTypes.JS_CALL_EXPRESSION */,\n    loc,\n    callee,\n    arguments: args\n  };\n}\nexports.createCallExpression = createCallExpression;\nfunction createFunctionExpression(params) {\n  let returns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  let newline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let isSlot = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let loc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : locStub;\n  return {\n    type: 18 /* NodeTypes.JS_FUNCTION_EXPRESSION */,\n    params,\n    returns,\n    newline,\n    isSlot,\n    loc\n  };\n}\nexports.createFunctionExpression = createFunctionExpression;\nfunction createConditionalExpression(test, consequent, alternate) {\n  let newline = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  return {\n    type: 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */,\n    test,\n    consequent,\n    alternate,\n    newline,\n    loc: locStub\n  };\n}\nexports.createConditionalExpression = createConditionalExpression;\nfunction createCacheExpression(index, value) {\n  let isVNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return {\n    type: 20 /* NodeTypes.JS_CACHE_EXPRESSION */,\n    index,\n    value,\n    isVNode,\n    loc: locStub\n  };\n}\nexports.createCacheExpression = createCacheExpression;\nfunction createBlockStatement(body) {\n  return {\n    type: 21 /* NodeTypes.JS_BLOCK_STATEMENT */,\n    body,\n    loc: locStub\n  };\n}\nexports.createBlockStatement = createBlockStatement;\nfunction createTemplateLiteral(elements) {\n  return {\n    type: 22 /* NodeTypes.JS_TEMPLATE_LITERAL */,\n    elements,\n    loc: locStub\n  };\n}\nexports.createTemplateLiteral = createTemplateLiteral;\nfunction createIfStatement(test, consequent, alternate) {\n  return {\n    type: 23 /* NodeTypes.JS_IF_STATEMENT */,\n    test,\n    consequent,\n    alternate,\n    loc: locStub\n  };\n}\nexports.createIfStatement = createIfStatement;\nfunction createAssignmentExpression(left, right) {\n  return {\n    type: 24 /* NodeTypes.JS_ASSIGNMENT_EXPRESSION */,\n    left,\n    right,\n    loc: locStub\n  };\n}\nexports.createAssignmentExpression = createAssignmentExpression;\nfunction createSequenceExpression(expressions) {\n  return {\n    type: 25 /* NodeTypes.JS_SEQUENCE_EXPRESSION */,\n    expressions,\n    loc: locStub\n  };\n}\nexports.createSequenceExpression = createSequenceExpression;\nfunction createReturnStatement(returns) {\n  return {\n    type: 26 /* NodeTypes.JS_RETURN_STATEMENT */,\n    returns,\n    loc: locStub\n  };\n}\nexports.createReturnStatement = createReturnStatement;\nconst isStaticExp = p => p.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ && p.isStatic;\nexports.isStaticExp = isStaticExp;\nconst isBuiltInType = (tag, expected) => tag === expected || tag === (0, shared_1.hyphenate)(expected);\nexports.isBuiltInType = isBuiltInType;\nfunction isCoreComponent(tag) {\n  if (isBuiltInType(tag, 'Teleport')) {\n    return TELEPORT;\n  } else if (isBuiltInType(tag, 'Suspense')) {\n    return SUSPENSE;\n  } else if (isBuiltInType(tag, 'KeepAlive')) {\n    return KEEP_ALIVE;\n  } else if (isBuiltInType(tag, 'BaseTransition')) {\n    return BASE_TRANSITION;\n  }\n}\nexports.isCoreComponent = isCoreComponent;\nconst nonIdentifierRE = /^\\d|[^\\$\\w]/;\nconst isSimpleIdentifier = name => !nonIdentifierRE.test(name);\nexports.isSimpleIdentifier = isSimpleIdentifier;\nconst validFirstIdentCharRE = /[A-Za-z_$\\xA0-\\uFFFF]/;\nconst validIdentCharRE = /[\\.\\?\\w$\\xA0-\\uFFFF]/;\nconst whitespaceRE = /\\s+[.[]\\s*|\\s*[.[]\\s+/g;\n/**\n * Simple lexer to check if an expression is a member expression. This is\n * lax and only checks validity at the root level (i.e. does not validate exps\n * inside square brackets), but it's ok since these are only used on template\n * expressions and false positives are invalid expressions in the first place.\n */\nconst isMemberExpressionBrowser = path => {\n  // remove whitespaces around . or [ first\n  path = path.trim().replace(whitespaceRE, s => s.trim());\n  let state = 0 /* MemberExpLexState.inMemberExp */;\n  let stateStack = [];\n  let currentOpenBracketCount = 0;\n  let currentOpenParensCount = 0;\n  let currentStringType = null;\n  for (let i = 0; i < path.length; i++) {\n    const char = path.charAt(i);\n    switch (state) {\n      case 0 /* MemberExpLexState.inMemberExp */:\n        if (char === '[') {\n          stateStack.push(state);\n          state = 1 /* MemberExpLexState.inBrackets */;\n          currentOpenBracketCount++;\n        } else if (char === '(') {\n          stateStack.push(state);\n          state = 2 /* MemberExpLexState.inParens */;\n          currentOpenParensCount++;\n        } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {\n          return false;\n        }\n        break;\n      case 1 /* MemberExpLexState.inBrackets */:\n        if (char === `'` || char === `\"` || char === '`') {\n          stateStack.push(state);\n          state = 3 /* MemberExpLexState.inString */;\n          currentStringType = char;\n        } else if (char === `[`) {\n          currentOpenBracketCount++;\n        } else if (char === `]`) {\n          if (! --currentOpenBracketCount) {\n            state = stateStack.pop();\n          }\n        }\n        break;\n      case 2 /* MemberExpLexState.inParens */:\n        if (char === `'` || char === `\"` || char === '`') {\n          stateStack.push(state);\n          state = 3 /* MemberExpLexState.inString */;\n          currentStringType = char;\n        } else if (char === `(`) {\n          currentOpenParensCount++;\n        } else if (char === `)`) {\n          // if the exp ends as a call then it should not be considered valid\n          if (i === path.length - 1) {\n            return false;\n          }\n          if (! --currentOpenParensCount) {\n            state = stateStack.pop();\n          }\n        }\n        break;\n      case 3 /* MemberExpLexState.inString */:\n        if (char === currentStringType) {\n          state = stateStack.pop();\n          currentStringType = null;\n        }\n        break;\n    }\n  }\n  return !currentOpenBracketCount && !currentOpenParensCount;\n};\nexports.isMemberExpressionBrowser = isMemberExpressionBrowser;\nconst isMemberExpressionNode = shared_1.NOOP;\nexports.isMemberExpressionNode = isMemberExpressionNode;\nconst isMemberExpression = isMemberExpressionBrowser;\nexports.isMemberExpression = isMemberExpression;\nfunction getInnerRange(loc, offset, length) {\n  const source = loc.source.slice(offset, offset + length);\n  const newLoc = {\n    source,\n    start: advancePositionWithClone(loc.start, loc.source, offset),\n    end: loc.end\n  };\n  if (length != null) {\n    newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);\n  }\n  return newLoc;\n}\nexports.getInnerRange = getInnerRange;\nfunction advancePositionWithClone(pos, source) {\n  let numberOfCharacters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : source.length;\n  return advancePositionWithMutation((0, shared_1.extend)({}, pos), source, numberOfCharacters);\n}\nexports.advancePositionWithClone = advancePositionWithClone;\n// advance by mutation without cloning (for performance reasons), since this\n// gets called a lot in the parser\nfunction advancePositionWithMutation(pos, source) {\n  let numberOfCharacters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : source.length;\n  let linesCount = 0;\n  let lastNewLinePos = -1;\n  for (let i = 0; i < numberOfCharacters; i++) {\n    if (source.charCodeAt(i) === 10 /* newline char code */) {\n      linesCount++;\n      lastNewLinePos = i;\n    }\n  }\n  pos.offset += numberOfCharacters;\n  pos.line += linesCount;\n  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;\n  return pos;\n}\nexports.advancePositionWithMutation = advancePositionWithMutation;\nfunction assert(condition, msg) {\n  /* istanbul ignore if */\n  if (!condition) {\n    throw new Error(msg || `unexpected compiler condition`);\n  }\n}\nexports.assert = assert;\nfunction findDir(node, name) {\n  let allowEmpty = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i];\n    if (p.type === 7 /* NodeTypes.DIRECTIVE */ && (allowEmpty || p.exp) && ((0, shared_1.isString)(name) ? p.name === name : name.test(p.name))) {\n      return p;\n    }\n  }\n}\nexports.findDir = findDir;\nfunction findProp(node, name) {\n  let dynamicOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let allowEmpty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i];\n    if (p.type === 6 /* NodeTypes.ATTRIBUTE */) {\n      if (dynamicOnly) continue;\n      if (p.name === name && (p.value || allowEmpty)) {\n        return p;\n      }\n    } else if (p.name === 'bind' && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {\n      return p;\n    }\n  }\n}\nexports.findProp = findProp;\nfunction isStaticArgOf(arg, name) {\n  return !!(arg && isStaticExp(arg) && arg.content === name);\n}\nexports.isStaticArgOf = isStaticArgOf;\nfunction hasDynamicKeyVBind(node) {\n  return node.props.some(p => p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'bind' && (!p.arg ||\n  // v-bind=\"obj\"\n  p.arg.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */ ||\n  // v-bind:[_ctx.foo]\n  !p.arg.isStatic) // v-bind:[foo]\n  );\n}\n\nexports.hasDynamicKeyVBind = hasDynamicKeyVBind;\nfunction isText$1(node) {\n  return node.type === 5 /* NodeTypes.INTERPOLATION */ || node.type === 2 /* NodeTypes.TEXT */;\n}\n\nexports.isText = isText$1;\nfunction isVSlot(p) {\n  return p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'slot';\n}\nexports.isVSlot = isVSlot;\nfunction isTemplateNode(node) {\n  return node.type === 1 /* NodeTypes.ELEMENT */ && node.tagType === 3 /* ElementTypes.TEMPLATE */;\n}\n\nexports.isTemplateNode = isTemplateNode;\nfunction isSlotOutlet(node) {\n  return node.type === 1 /* NodeTypes.ELEMENT */ && node.tagType === 2 /* ElementTypes.SLOT */;\n}\n\nexports.isSlotOutlet = isSlotOutlet;\nfunction getVNodeHelper(ssr, isComponent) {\n  return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;\n}\nexports.getVNodeHelper = getVNodeHelper;\nfunction getVNodeBlockHelper(ssr, isComponent) {\n  return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;\n}\nexports.getVNodeBlockHelper = getVNodeBlockHelper;\nconst propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);\nfunction getUnnormalizedProps(props) {\n  let callPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  if (props && !(0, shared_1.isString)(props) && props.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {\n    const callee = props.callee;\n    if (!(0, shared_1.isString)(callee) && propsHelperSet.has(callee)) {\n      return getUnnormalizedProps(props.arguments[0], callPath.concat(props));\n    }\n  }\n  return [props, callPath];\n}\nfunction injectProp(node, prop, context) {\n  let propsWithInjection;\n  /**\n   * 1. mergeProps(...)\n   * 2. toHandlers(...)\n   * 3. normalizeProps(...)\n   * 4. normalizeProps(guardReactiveProps(...))\n   *\n   * we need to get the real props before normalization\n   */\n  let props = node.type === 13 /* NodeTypes.VNODE_CALL */ ? node.props : node.arguments[2];\n  let callPath = [];\n  let parentCall;\n  if (props && !(0, shared_1.isString)(props) && props.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {\n    const ret = getUnnormalizedProps(props);\n    props = ret[0];\n    callPath = ret[1];\n    parentCall = callPath[callPath.length - 1];\n  }\n  if (props == null || (0, shared_1.isString)(props)) {\n    propsWithInjection = createObjectExpression([prop]);\n  } else if (props.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {\n    // merged props... add ours\n    // only inject key to object literal if it's the first argument so that\n    // if doesn't override user provided keys\n    const first = props.arguments[0];\n    if (!(0, shared_1.isString)(first) && first.type === 15 /* NodeTypes.JS_OBJECT_EXPRESSION */) {\n      // #6631\n      if (!hasProp(prop, first)) {\n        first.properties.unshift(prop);\n      }\n    } else {\n      if (props.callee === TO_HANDLERS) {\n        // #2366\n        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [createObjectExpression([prop]), props]);\n      } else {\n        props.arguments.unshift(createObjectExpression([prop]));\n      }\n    }\n    !propsWithInjection && (propsWithInjection = props);\n  } else if (props.type === 15 /* NodeTypes.JS_OBJECT_EXPRESSION */) {\n    if (!hasProp(prop, props)) {\n      props.properties.unshift(prop);\n    }\n    propsWithInjection = props;\n  } else {\n    // single v-bind with expression, return a merged replacement\n    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [createObjectExpression([prop]), props]);\n    // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,\n    // it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,\n    // the `guardReactiveProps` will no longer be needed\n    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {\n      parentCall = callPath[callPath.length - 2];\n    }\n  }\n  if (node.type === 13 /* NodeTypes.VNODE_CALL */) {\n    if (parentCall) {\n      parentCall.arguments[0] = propsWithInjection;\n    } else {\n      node.props = propsWithInjection;\n    }\n  } else {\n    if (parentCall) {\n      parentCall.arguments[0] = propsWithInjection;\n    } else {\n      node.arguments[2] = propsWithInjection;\n    }\n  }\n}\nexports.injectProp = injectProp;\n// check existing key to avoid overriding user provided keys\nfunction hasProp(prop, props) {\n  let result = false;\n  if (prop.key.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n    const propKeyName = prop.key.content;\n    result = props.properties.some(p => p.key.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ && p.key.content === propKeyName);\n  }\n  return result;\n}\nfunction toValidAssetId(name, type) {\n  // see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character\n  return `_${type}_${name.replace(/[^\\w]/g, (searchValue, replaceValue) => {\n    return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString();\n  })}`;\n}\nexports.toValidAssetId = toValidAssetId;\n// Check if a node contains expressions that reference current context scope ids\nfunction hasScopeRef(node, ids) {\n  if (!node || Object.keys(ids).length === 0) {\n    return false;\n  }\n  switch (node.type) {\n    case 1 /* NodeTypes.ELEMENT */:\n      for (let i = 0; i < node.props.length; i++) {\n        const p = node.props[i];\n        if (p.type === 7 /* NodeTypes.DIRECTIVE */ && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {\n          return true;\n        }\n      }\n      return node.children.some(c => hasScopeRef(c, ids));\n    case 11 /* NodeTypes.FOR */:\n      if (hasScopeRef(node.source, ids)) {\n        return true;\n      }\n      return node.children.some(c => hasScopeRef(c, ids));\n    case 9 /* NodeTypes.IF */:\n      return node.branches.some(b => hasScopeRef(b, ids));\n    case 10 /* NodeTypes.IF_BRANCH */:\n      if (hasScopeRef(node.condition, ids)) {\n        return true;\n      }\n      return node.children.some(c => hasScopeRef(c, ids));\n    case 4 /* NodeTypes.SIMPLE_EXPRESSION */:\n      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];\n    case 8 /* NodeTypes.COMPOUND_EXPRESSION */:\n      return node.children.some(c => (0, shared_1.isObject)(c) && hasScopeRef(c, ids));\n    case 5 /* NodeTypes.INTERPOLATION */:\n    case 12 /* NodeTypes.TEXT_CALL */:\n      return hasScopeRef(node.content, ids);\n    case 2 /* NodeTypes.TEXT */:\n    case 3 /* NodeTypes.COMMENT */:\n      return false;\n    default:\n      if (true) ;\n      return false;\n  }\n}\nexports.hasScopeRef = hasScopeRef;\nfunction getMemoedVNodeCall(node) {\n  if (node.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */ && node.callee === WITH_MEMO) {\n    return node.arguments[1].returns;\n  } else {\n    return node;\n  }\n}\nexports.getMemoedVNodeCall = getMemoedVNodeCall;\nfunction makeBlock(node, _ref) {\n  let {\n    helper,\n    removeHelper,\n    inSSR\n  } = _ref;\n  if (!node.isBlock) {\n    node.isBlock = true;\n    removeHelper(getVNodeHelper(inSSR, node.isComponent));\n    helper(OPEN_BLOCK);\n    helper(getVNodeBlockHelper(inSSR, node.isComponent));\n  }\n}\nexports.makeBlock = makeBlock;\nconst deprecationData = {\n  [\"COMPILER_IS_ON_ELEMENT\" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */]: {\n    message: `Platform-native elements with \"is\" prop will no longer be ` + `treated as components in Vue 3 unless the \"is\" value is explicitly ` + `prefixed with \"vue:\".`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`\n  },\n  [\"COMPILER_V_BIND_SYNC\" /* CompilerDeprecationTypes.COMPILER_V_BIND_SYNC */]: {\n    message: key => `.sync modifier for v-bind has been removed. Use v-model with ` + `argument instead. \\`v-bind:${key}.sync\\` should be changed to ` + `\\`v-model:${key}\\`.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`\n  },\n  [\"COMPILER_V_BIND_PROP\" /* CompilerDeprecationTypes.COMPILER_V_BIND_PROP */]: {\n    message: `.prop modifier for v-bind has been removed and no longer necessary. ` + `Vue 3 will automatically set a binding as DOM property when appropriate.`\n  },\n  [\"COMPILER_V_BIND_OBJECT_ORDER\" /* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */]: {\n    message: `v-bind=\"obj\" usage is now order sensitive and behaves like JavaScript ` + `object spread: it will now overwrite an existing non-mergeable attribute ` + `that appears before v-bind in the case of conflict. ` + `To retain 2.x behavior, move v-bind to make it the first attribute. ` + `You can also suppress this warning if the usage is intended.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`\n  },\n  [\"COMPILER_V_ON_NATIVE\" /* CompilerDeprecationTypes.COMPILER_V_ON_NATIVE */]: {\n    message: `.native modifier for v-on has been removed as is no longer necessary.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`\n  },\n  [\"COMPILER_V_IF_V_FOR_PRECEDENCE\" /* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */]: {\n    message: `v-if / v-for precedence when used on the same element has changed ` + `in Vue 3: v-if now takes higher precedence and will no longer have ` + `access to v-for scope variables. It is best to avoid the ambiguity ` + `with <template> tags or use a computed property that filters v-for ` + `data source.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`\n  },\n  [\"COMPILER_NATIVE_TEMPLATE\" /* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */]: {\n    message: `<template> with no special directives will render as a native template ` + `element instead of its inner content in Vue 3.`\n  },\n  [\"COMPILER_INLINE_TEMPLATE\" /* CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE */]: {\n    message: `\"inline-template\" has been removed in Vue 3.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`\n  },\n  [\"COMPILER_FILTER\" /* CompilerDeprecationTypes.COMPILER_FILTERS */]: {\n    message: `filters have been removed in Vue 3. ` + `The \"|\" symbol will be treated as native JavaScript bitwise OR operator. ` + `Use method calls or computed properties instead.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`\n  }\n};\nfunction getCompatValue(key, context) {\n  const config = context.options ? context.options.compatConfig : context.compatConfig;\n  const value = config && config[key];\n  if (key === 'MODE') {\n    return value || 3; // compiler defaults to v3 behavior\n  } else {\n    return value;\n  }\n}\nfunction isCompatEnabled(key, context) {\n  const mode = getCompatValue('MODE', context);\n  const value = getCompatValue(key, context);\n  // in v3 mode, only enable if explicitly set to true\n  // otherwise enable for any non-false value\n  return mode === 3 ? value === true : value !== false;\n}\nfunction checkCompatEnabled(key, context, loc) {\n  const enabled = isCompatEnabled(key, context);\n  if ( true && enabled) {\n    for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      args[_key - 3] = arguments[_key];\n    }\n    warnDeprecation(key, context, loc, ...args);\n  }\n  return enabled;\n}\nexports.checkCompatEnabled = checkCompatEnabled;\nfunction warnDeprecation(key, context, loc) {\n  const val = getCompatValue(key, context);\n  if (val === 'suppress-warning') {\n    return;\n  }\n  const {\n    message,\n    link\n  } = deprecationData[key];\n  for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n    args[_key2 - 3] = arguments[_key2];\n  }\n  const msg = `(deprecation ${key}) ${typeof message === 'function' ? message(...args) : message}${link ? `\\n  Details: ${link}` : ``}`;\n  const err = new SyntaxError(msg);\n  err.code = key;\n  if (loc) err.loc = loc;\n  context.onWarn(err);\n}\nexports.warnDeprecation = warnDeprecation;\n// The default decoder only provides escapes for characters reserved as part of\n// the template syntax, and is only used if the custom renderer did not provide\n// a platform-specific decoder.\nconst decodeRE = /&(gt|lt|amp|apos|quot);/g;\nconst decodeMap = {\n  gt: '>',\n  lt: '<',\n  amp: '&',\n  apos: \"'\",\n  quot: '\"'\n};\nconst defaultParserOptions = {\n  delimiters: [`{{`, `}}`],\n  getNamespace: () => 0 /* Namespaces.HTML */,\n  getTextMode: () => 0 /* TextModes.DATA */,\n  isVoidTag: shared_1.NO,\n  isPreTag: shared_1.NO,\n  isCustomElement: shared_1.NO,\n  decodeEntities: rawText => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),\n  onError: defaultOnError,\n  onWarn: defaultOnWarn,\n  comments: \"development\" !== 'production'\n};\nfunction baseParse(content) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const context = createParserContext(content, options);\n  const start = getCursor(context);\n  return createRoot(parseChildren(context, 0 /* TextModes.DATA */, []), getSelection(context, start));\n}\nexports.baseParse = baseParse;\nfunction createParserContext(content, rawOptions) {\n  const options = (0, shared_1.extend)({}, defaultParserOptions);\n  let key;\n  for (key in rawOptions) {\n    // @ts-ignore\n    options[key] = rawOptions[key] === undefined ? defaultParserOptions[key] : rawOptions[key];\n  }\n  return {\n    options,\n    column: 1,\n    line: 1,\n    offset: 0,\n    originalSource: content,\n    source: content,\n    inPre: false,\n    inVPre: false,\n    onWarn: options.onWarn\n  };\n}\nfunction parseChildren(context, mode, ancestors) {\n  const parent = last(ancestors);\n  const ns = parent ? parent.ns : 0 /* Namespaces.HTML */;\n  const nodes = [];\n  while (!isEnd(context, mode, ancestors)) {\n    const s = context.source;\n    let node = undefined;\n    if (mode === 0 /* TextModes.DATA */ || mode === 1 /* TextModes.RCDATA */) {\n      if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {\n        // '{{'\n        node = parseInterpolation(context, mode);\n      } else if (mode === 0 /* TextModes.DATA */ && s[0] === '<') {\n        // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state\n        if (s.length === 1) {\n          emitError(context, 5 /* ErrorCodes.EOF_BEFORE_TAG_NAME */, 1);\n        } else if (s[1] === '!') {\n          // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state\n          if (startsWith(s, '<!--')) {\n            node = parseComment(context);\n          } else if (startsWith(s, '<!DOCTYPE')) {\n            // Ignore DOCTYPE by a limitation.\n            node = parseBogusComment(context);\n          } else if (startsWith(s, '<![CDATA[')) {\n            if (ns !== 0 /* Namespaces.HTML */) {\n              node = parseCDATA(context, ancestors);\n            } else {\n              emitError(context, 1 /* ErrorCodes.CDATA_IN_HTML_CONTENT */);\n              node = parseBogusComment(context);\n            }\n          } else {\n            emitError(context, 11 /* ErrorCodes.INCORRECTLY_OPENED_COMMENT */);\n            node = parseBogusComment(context);\n          }\n        } else if (s[1] === '/') {\n          // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state\n          if (s.length === 2) {\n            emitError(context, 5 /* ErrorCodes.EOF_BEFORE_TAG_NAME */, 2);\n          } else if (s[2] === '>') {\n            emitError(context, 14 /* ErrorCodes.MISSING_END_TAG_NAME */, 2);\n            advanceBy(context, 3);\n            continue;\n          } else if (/[a-z]/i.test(s[2])) {\n            emitError(context, 23 /* ErrorCodes.X_INVALID_END_TAG */);\n            parseTag(context, 1 /* TagType.End */, parent);\n            continue;\n          } else {\n            emitError(context, 12 /* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);\n            node = parseBogusComment(context);\n          }\n        } else if (/[a-z]/i.test(s[1])) {\n          node = parseElement(context, ancestors);\n          // 2.x <template> with no directive compat\n          if (isCompatEnabled(\"COMPILER_NATIVE_TEMPLATE\" /* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */, context) && node && node.tag === 'template' && !node.props.some(p => p.type === 7 /* NodeTypes.DIRECTIVE */ && isSpecialTemplateDirective(p.name))) {\n             true && warnDeprecation(\"COMPILER_NATIVE_TEMPLATE\" /* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */, context, node.loc);\n            node = node.children;\n          }\n        } else if (s[1] === '?') {\n          emitError(context, 21 /* ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);\n          node = parseBogusComment(context);\n        } else {\n          emitError(context, 12 /* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);\n        }\n      }\n    }\n    if (!node) {\n      node = parseText(context, mode);\n    }\n    if ((0, shared_1.isArray)(node)) {\n      for (let i = 0; i < node.length; i++) {\n        pushNode(nodes, node[i]);\n      }\n    } else {\n      pushNode(nodes, node);\n    }\n  }\n  // Whitespace handling strategy like v2\n  let removedWhitespace = false;\n  if (mode !== 2 /* TextModes.RAWTEXT */ && mode !== 1 /* TextModes.RCDATA */) {\n    const shouldCondense = context.options.whitespace !== 'preserve';\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (node.type === 2 /* NodeTypes.TEXT */) {\n        if (!context.inPre) {\n          if (!/[^\\t\\r\\n\\f ]/.test(node.content)) {\n            const prev = nodes[i - 1];\n            const next = nodes[i + 1];\n            // Remove if:\n            // - the whitespace is the first or last node, or:\n            // - (condense mode) the whitespace is between twos comments, or:\n            // - (condense mode) the whitespace is between comment and element, or:\n            // - (condense mode) the whitespace is between two elements AND contains newline\n            if (!prev || !next || shouldCondense && (prev.type === 3 /* NodeTypes.COMMENT */ && next.type === 3 /* NodeTypes.COMMENT */ || prev.type === 3 /* NodeTypes.COMMENT */ && next.type === 1 /* NodeTypes.ELEMENT */ || prev.type === 1 /* NodeTypes.ELEMENT */ && next.type === 3 /* NodeTypes.COMMENT */ || prev.type === 1 /* NodeTypes.ELEMENT */ && next.type === 1 /* NodeTypes.ELEMENT */ && /[\\r\\n]/.test(node.content))) {\n              removedWhitespace = true;\n              nodes[i] = null;\n            } else {\n              // Otherwise, the whitespace is condensed into a single space\n              node.content = ' ';\n            }\n          } else if (shouldCondense) {\n            // in condense mode, consecutive whitespaces in text are condensed\n            // down to a single space.\n            node.content = node.content.replace(/[\\t\\r\\n\\f ]+/g, ' ');\n          }\n        } else {\n          // #6410 normalize windows newlines in <pre>:\n          // in SSR, browsers normalize server-rendered \\r\\n into a single \\n\n          // in the DOM\n          node.content = node.content.replace(/\\r\\n/g, '\\n');\n        }\n      }\n      // Remove comment nodes if desired by configuration.\n      else if (node.type === 3 /* NodeTypes.COMMENT */ && !context.options.comments) {\n        removedWhitespace = true;\n        nodes[i] = null;\n      }\n    }\n    if (context.inPre && parent && context.options.isPreTag(parent.tag)) {\n      // remove leading newline per html spec\n      // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element\n      const first = nodes[0];\n      if (first && first.type === 2 /* NodeTypes.TEXT */) {\n        first.content = first.content.replace(/^\\r?\\n/, '');\n      }\n    }\n  }\n  return removedWhitespace ? nodes.filter(Boolean) : nodes;\n}\nfunction pushNode(nodes, node) {\n  if (node.type === 2 /* NodeTypes.TEXT */) {\n    const prev = last(nodes);\n    // Merge if both this and the previous node are text and those are\n    // consecutive. This happens for cases like \"a < b\".\n    if (prev && prev.type === 2 /* NodeTypes.TEXT */ && prev.loc.end.offset === node.loc.start.offset) {\n      prev.content += node.content;\n      prev.loc.end = node.loc.end;\n      prev.loc.source += node.loc.source;\n      return;\n    }\n  }\n  nodes.push(node);\n}\nfunction parseCDATA(context, ancestors) {\n  advanceBy(context, 9);\n  const nodes = parseChildren(context, 3 /* TextModes.CDATA */, ancestors);\n  if (context.source.length === 0) {\n    emitError(context, 6 /* ErrorCodes.EOF_IN_CDATA */);\n  } else {\n    advanceBy(context, 3);\n  }\n  return nodes;\n}\nfunction parseComment(context) {\n  const start = getCursor(context);\n  let content;\n  // Regular comment.\n  const match = /--(\\!)?>/.exec(context.source);\n  if (!match) {\n    content = context.source.slice(4);\n    advanceBy(context, context.source.length);\n    emitError(context, 7 /* ErrorCodes.EOF_IN_COMMENT */);\n  } else {\n    if (match.index <= 3) {\n      emitError(context, 0 /* ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT */);\n    }\n\n    if (match[1]) {\n      emitError(context, 10 /* ErrorCodes.INCORRECTLY_CLOSED_COMMENT */);\n    }\n\n    content = context.source.slice(4, match.index);\n    // Advancing with reporting nested comments.\n    const s = context.source.slice(0, match.index);\n    let prevIndex = 1,\n      nestedIndex = 0;\n    while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {\n      advanceBy(context, nestedIndex - prevIndex + 1);\n      if (nestedIndex + 4 < s.length) {\n        emitError(context, 16 /* ErrorCodes.NESTED_COMMENT */);\n      }\n\n      prevIndex = nestedIndex + 1;\n    }\n    advanceBy(context, match.index + match[0].length - prevIndex + 1);\n  }\n  return {\n    type: 3 /* NodeTypes.COMMENT */,\n    content,\n    loc: getSelection(context, start)\n  };\n}\nfunction parseBogusComment(context) {\n  const start = getCursor(context);\n  const contentStart = context.source[1] === '?' ? 1 : 2;\n  let content;\n  const closeIndex = context.source.indexOf('>');\n  if (closeIndex === -1) {\n    content = context.source.slice(contentStart);\n    advanceBy(context, context.source.length);\n  } else {\n    content = context.source.slice(contentStart, closeIndex);\n    advanceBy(context, closeIndex + 1);\n  }\n  return {\n    type: 3 /* NodeTypes.COMMENT */,\n    content,\n    loc: getSelection(context, start)\n  };\n}\nfunction parseElement(context, ancestors) {\n  // Start tag.\n  const wasInPre = context.inPre;\n  const wasInVPre = context.inVPre;\n  const parent = last(ancestors);\n  const element = parseTag(context, 0 /* TagType.Start */, parent);\n  const isPreBoundary = context.inPre && !wasInPre;\n  const isVPreBoundary = context.inVPre && !wasInVPre;\n  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {\n    // #4030 self-closing <pre> tag\n    if (isPreBoundary) {\n      context.inPre = false;\n    }\n    if (isVPreBoundary) {\n      context.inVPre = false;\n    }\n    return element;\n  }\n  // Children.\n  ancestors.push(element);\n  const mode = context.options.getTextMode(element, parent);\n  const children = parseChildren(context, mode, ancestors);\n  ancestors.pop();\n  // 2.x inline-template compat\n  {\n    const inlineTemplateProp = element.props.find(p => p.type === 6 /* NodeTypes.ATTRIBUTE */ && p.name === 'inline-template');\n    if (inlineTemplateProp && checkCompatEnabled(\"COMPILER_INLINE_TEMPLATE\" /* CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE */, context, inlineTemplateProp.loc)) {\n      const loc = getSelection(context, element.loc.end);\n      inlineTemplateProp.value = {\n        type: 2 /* NodeTypes.TEXT */,\n        content: loc.source,\n        loc\n      };\n    }\n  }\n  element.children = children;\n  // End tag.\n  if (startsWithEndTagOpen(context.source, element.tag)) {\n    parseTag(context, 1 /* TagType.End */, parent);\n  } else {\n    emitError(context, 24 /* ErrorCodes.X_MISSING_END_TAG */, 0, element.loc.start);\n    if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {\n      const first = children[0];\n      if (first && startsWith(first.loc.source, '<!--')) {\n        emitError(context, 8 /* ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);\n      }\n    }\n  }\n\n  element.loc = getSelection(context, element.loc.start);\n  if (isPreBoundary) {\n    context.inPre = false;\n  }\n  if (isVPreBoundary) {\n    context.inVPre = false;\n  }\n  return element;\n}\nconst isSpecialTemplateDirective = /*#__PURE__*/(0, shared_1.makeMap)(`if,else,else-if,for,slot`);\nfunction parseTag(context, type, parent) {\n  // Tag open.\n  const start = getCursor(context);\n  const match = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source);\n  const tag = match[1];\n  const ns = context.options.getNamespace(tag, parent);\n  advanceBy(context, match[0].length);\n  advanceSpaces(context);\n  // save current state in case we need to re-parse attributes with v-pre\n  const cursor = getCursor(context);\n  const currentSource = context.source;\n  // check <pre> tag\n  if (context.options.isPreTag(tag)) {\n    context.inPre = true;\n  }\n  // Attributes.\n  let props = parseAttributes(context, type);\n  // check v-pre\n  if (type === 0 /* TagType.Start */ && !context.inVPre && props.some(p => p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'pre')) {\n    context.inVPre = true;\n    // reset context\n    (0, shared_1.extend)(context, cursor);\n    context.source = currentSource;\n    // re-parse attrs and filter out v-pre itself\n    props = parseAttributes(context, type).filter(p => p.name !== 'v-pre');\n  }\n  // Tag close.\n  let isSelfClosing = false;\n  if (context.source.length === 0) {\n    emitError(context, 9 /* ErrorCodes.EOF_IN_TAG */);\n  } else {\n    isSelfClosing = startsWith(context.source, '/>');\n    if (type === 1 /* TagType.End */ && isSelfClosing) {\n      emitError(context, 4 /* ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS */);\n    }\n\n    advanceBy(context, isSelfClosing ? 2 : 1);\n  }\n  if (type === 1 /* TagType.End */) {\n    return;\n  }\n  // 2.x deprecation checks\n  if ( true && isCompatEnabled(\"COMPILER_V_IF_V_FOR_PRECEDENCE\" /* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */, context)) {\n    let hasIf = false;\n    let hasFor = false;\n    for (let i = 0; i < props.length; i++) {\n      const p = props[i];\n      if (p.type === 7 /* NodeTypes.DIRECTIVE */) {\n        if (p.name === 'if') {\n          hasIf = true;\n        } else if (p.name === 'for') {\n          hasFor = true;\n        }\n      }\n      if (hasIf && hasFor) {\n        warnDeprecation(\"COMPILER_V_IF_V_FOR_PRECEDENCE\" /* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */, context, getSelection(context, start));\n        break;\n      }\n    }\n  }\n  let tagType = 0 /* ElementTypes.ELEMENT */;\n  if (!context.inVPre) {\n    if (tag === 'slot') {\n      tagType = 2 /* ElementTypes.SLOT */;\n    } else if (tag === 'template') {\n      if (props.some(p => p.type === 7 /* NodeTypes.DIRECTIVE */ && isSpecialTemplateDirective(p.name))) {\n        tagType = 3 /* ElementTypes.TEMPLATE */;\n      }\n    } else if (isComponent(tag, props, context)) {\n      tagType = 1 /* ElementTypes.COMPONENT */;\n    }\n  }\n\n  return {\n    type: 1 /* NodeTypes.ELEMENT */,\n    ns,\n    tag,\n    tagType,\n    props,\n    isSelfClosing,\n    children: [],\n    loc: getSelection(context, start),\n    codegenNode: undefined // to be created during transform phase\n  };\n}\n\nfunction isComponent(tag, props, context) {\n  const options = context.options;\n  if (options.isCustomElement(tag)) {\n    return false;\n  }\n  if (tag === 'component' || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options.isBuiltInComponent && options.isBuiltInComponent(tag) || options.isNativeTag && !options.isNativeTag(tag)) {\n    return true;\n  }\n  // at this point the tag should be a native tag, but check for potential \"is\"\n  // casting\n  for (let i = 0; i < props.length; i++) {\n    const p = props[i];\n    if (p.type === 6 /* NodeTypes.ATTRIBUTE */) {\n      if (p.name === 'is' && p.value) {\n        if (p.value.content.startsWith('vue:')) {\n          return true;\n        } else if (checkCompatEnabled(\"COMPILER_IS_ON_ELEMENT\" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context, p.loc)) {\n          return true;\n        }\n      }\n    } else {\n      // directive\n      // v-is (TODO Deprecate)\n      if (p.name === 'is') {\n        return true;\n      } else if (\n      // :is on plain element - only treat as component in compat mode\n      p.name === 'bind' && isStaticArgOf(p.arg, 'is') && true && checkCompatEnabled(\"COMPILER_IS_ON_ELEMENT\" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context, p.loc)) {\n        return true;\n      }\n    }\n  }\n}\nfunction parseAttributes(context, type) {\n  const props = [];\n  const attributeNames = new Set();\n  while (context.source.length > 0 && !startsWith(context.source, '>') && !startsWith(context.source, '/>')) {\n    if (startsWith(context.source, '/')) {\n      emitError(context, 22 /* ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG */);\n      advanceBy(context, 1);\n      advanceSpaces(context);\n      continue;\n    }\n    if (type === 1 /* TagType.End */) {\n      emitError(context, 3 /* ErrorCodes.END_TAG_WITH_ATTRIBUTES */);\n    }\n\n    const attr = parseAttribute(context, attributeNames);\n    // Trim whitespace between class\n    // https://github.com/vuejs/core/issues/4251\n    if (attr.type === 6 /* NodeTypes.ATTRIBUTE */ && attr.value && attr.name === 'class') {\n      attr.value.content = attr.value.content.replace(/\\s+/g, ' ').trim();\n    }\n    if (type === 0 /* TagType.Start */) {\n      props.push(attr);\n    }\n    if (/^[^\\t\\r\\n\\f />]/.test(context.source)) {\n      emitError(context, 15 /* ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);\n    }\n\n    advanceSpaces(context);\n  }\n  return props;\n}\nfunction parseAttribute(context, nameSet) {\n  // Name.\n  const start = getCursor(context);\n  const match = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/.exec(context.source);\n  const name = match[0];\n  if (nameSet.has(name)) {\n    emitError(context, 2 /* ErrorCodes.DUPLICATE_ATTRIBUTE */);\n  }\n\n  nameSet.add(name);\n  if (name[0] === '=') {\n    emitError(context, 19 /* ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);\n  }\n\n  {\n    const pattern = /[\"'<]/g;\n    let m;\n    while (m = pattern.exec(name)) {\n      emitError(context, 17 /* ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);\n    }\n  }\n  advanceBy(context, name.length);\n  // Value\n  let value = undefined;\n  if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) {\n    advanceSpaces(context);\n    advanceBy(context, 1);\n    advanceSpaces(context);\n    value = parseAttributeValue(context);\n    if (!value) {\n      emitError(context, 13 /* ErrorCodes.MISSING_ATTRIBUTE_VALUE */);\n    }\n  }\n\n  const loc = getSelection(context, start);\n  if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\\.|@|#)/.test(name)) {\n    const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^\\.|^@|^#)(\\[[^\\]]+\\]|[^\\.]+))?(.+)?$/i.exec(name);\n    let isPropShorthand = startsWith(name, '.');\n    let dirName = match[1] || (isPropShorthand || startsWith(name, ':') ? 'bind' : startsWith(name, '@') ? 'on' : 'slot');\n    let arg;\n    if (match[2]) {\n      const isSlot = dirName === 'slot';\n      const startOffset = name.lastIndexOf(match[2]);\n      const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length + (isSlot && match[3] || '').length));\n      let content = match[2];\n      let isStatic = true;\n      if (content.startsWith('[')) {\n        isStatic = false;\n        if (!content.endsWith(']')) {\n          emitError(context, 27 /* ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);\n          content = content.slice(1);\n        } else {\n          content = content.slice(1, content.length - 1);\n        }\n      } else if (isSlot) {\n        // #1241 special case for v-slot: vuetify relies extensively on slot\n        // names containing dots. v-slot doesn't have any modifiers and Vue 2.x\n        // supports such usage so we are keeping it consistent with 2.x.\n        content += match[3] || '';\n      }\n      arg = {\n        type: 4 /* NodeTypes.SIMPLE_EXPRESSION */,\n        content,\n        isStatic,\n        constType: isStatic ? 3 /* ConstantTypes.CAN_STRINGIFY */ : 0 /* ConstantTypes.NOT_CONSTANT */,\n        loc\n      };\n    }\n    if (value && value.isQuoted) {\n      const valueLoc = value.loc;\n      valueLoc.start.offset++;\n      valueLoc.start.column++;\n      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);\n      valueLoc.source = valueLoc.source.slice(1, -1);\n    }\n    const modifiers = match[3] ? match[3].slice(1).split('.') : [];\n    if (isPropShorthand) modifiers.push('prop');\n    // 2.x compat v-bind:foo.sync -> v-model:foo\n    if (dirName === 'bind' && arg) {\n      if (modifiers.includes('sync') && checkCompatEnabled(\"COMPILER_V_BIND_SYNC\" /* CompilerDeprecationTypes.COMPILER_V_BIND_SYNC */, context, loc, arg.loc.source)) {\n        dirName = 'model';\n        modifiers.splice(modifiers.indexOf('sync'), 1);\n      }\n      if ( true && modifiers.includes('prop')) {\n        checkCompatEnabled(\"COMPILER_V_BIND_PROP\" /* CompilerDeprecationTypes.COMPILER_V_BIND_PROP */, context, loc);\n      }\n    }\n    return {\n      type: 7 /* NodeTypes.DIRECTIVE */,\n      name: dirName,\n      exp: value && {\n        type: 4 /* NodeTypes.SIMPLE_EXPRESSION */,\n        content: value.content,\n        isStatic: false,\n        // Treat as non-constant by default. This can be potentially set to\n        // other values by `transformExpression` to make it eligible for hoisting.\n        constType: 0 /* ConstantTypes.NOT_CONSTANT */,\n        loc: value.loc\n      },\n      arg,\n      modifiers,\n      loc\n    };\n  }\n  // missing directive name or illegal directive name\n  if (!context.inVPre && startsWith(name, 'v-')) {\n    emitError(context, 26 /* ErrorCodes.X_MISSING_DIRECTIVE_NAME */);\n  }\n\n  return {\n    type: 6 /* NodeTypes.ATTRIBUTE */,\n    name,\n    value: value && {\n      type: 2 /* NodeTypes.TEXT */,\n      content: value.content,\n      loc: value.loc\n    },\n    loc\n  };\n}\nfunction parseAttributeValue(context) {\n  const start = getCursor(context);\n  let content;\n  const quote = context.source[0];\n  const isQuoted = quote === `\"` || quote === `'`;\n  if (isQuoted) {\n    // Quoted value.\n    advanceBy(context, 1);\n    const endIndex = context.source.indexOf(quote);\n    if (endIndex === -1) {\n      content = parseTextData(context, context.source.length, 4 /* TextModes.ATTRIBUTE_VALUE */);\n    } else {\n      content = parseTextData(context, endIndex, 4 /* TextModes.ATTRIBUTE_VALUE */);\n      advanceBy(context, 1);\n    }\n  } else {\n    // Unquoted\n    const match = /^[^\\t\\r\\n\\f >]+/.exec(context.source);\n    if (!match) {\n      return undefined;\n    }\n    const unexpectedChars = /[\"'<=`]/g;\n    let m;\n    while (m = unexpectedChars.exec(match[0])) {\n      emitError(context, 18 /* ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);\n    }\n    content = parseTextData(context, match[0].length, 4 /* TextModes.ATTRIBUTE_VALUE */);\n  }\n\n  return {\n    content,\n    isQuoted,\n    loc: getSelection(context, start)\n  };\n}\nfunction parseInterpolation(context, mode) {\n  const [open, close] = context.options.delimiters;\n  const closeIndex = context.source.indexOf(close, open.length);\n  if (closeIndex === -1) {\n    emitError(context, 25 /* ErrorCodes.X_MISSING_INTERPOLATION_END */);\n    return undefined;\n  }\n  const start = getCursor(context);\n  advanceBy(context, open.length);\n  const innerStart = getCursor(context);\n  const innerEnd = getCursor(context);\n  const rawContentLength = closeIndex - open.length;\n  const rawContent = context.source.slice(0, rawContentLength);\n  const preTrimContent = parseTextData(context, rawContentLength, mode);\n  const content = preTrimContent.trim();\n  const startOffset = preTrimContent.indexOf(content);\n  if (startOffset > 0) {\n    advancePositionWithMutation(innerStart, rawContent, startOffset);\n  }\n  const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);\n  advancePositionWithMutation(innerEnd, rawContent, endOffset);\n  advanceBy(context, close.length);\n  return {\n    type: 5 /* NodeTypes.INTERPOLATION */,\n    content: {\n      type: 4 /* NodeTypes.SIMPLE_EXPRESSION */,\n      isStatic: false,\n      // Set `isConstant` to false by default and will decide in transformExpression\n      constType: 0 /* ConstantTypes.NOT_CONSTANT */,\n      content,\n      loc: getSelection(context, innerStart, innerEnd)\n    },\n    loc: getSelection(context, start)\n  };\n}\nfunction parseText(context, mode) {\n  const endTokens = mode === 3 /* TextModes.CDATA */ ? [']]>'] : ['<', context.options.delimiters[0]];\n  let endIndex = context.source.length;\n  for (let i = 0; i < endTokens.length; i++) {\n    const index = context.source.indexOf(endTokens[i], 1);\n    if (index !== -1 && endIndex > index) {\n      endIndex = index;\n    }\n  }\n  const start = getCursor(context);\n  const content = parseTextData(context, endIndex, mode);\n  return {\n    type: 2 /* NodeTypes.TEXT */,\n    content,\n    loc: getSelection(context, start)\n  };\n}\n/**\n * Get text data with a given length from the current location.\n * This translates HTML entities in the text data.\n */\nfunction parseTextData(context, length, mode) {\n  const rawText = context.source.slice(0, length);\n  advanceBy(context, length);\n  if (mode === 2 /* TextModes.RAWTEXT */ || mode === 3 /* TextModes.CDATA */ || !rawText.includes('&')) {\n    return rawText;\n  } else {\n    // DATA or RCDATA containing \"&\"\". Entity decoding required.\n    return context.options.decodeEntities(rawText, mode === 4 /* TextModes.ATTRIBUTE_VALUE */);\n  }\n}\n\nfunction getCursor(context) {\n  const {\n    column,\n    line,\n    offset\n  } = context;\n  return {\n    column,\n    line,\n    offset\n  };\n}\nfunction getSelection(context, start, end) {\n  end = end || getCursor(context);\n  return {\n    start,\n    end,\n    source: context.originalSource.slice(start.offset, end.offset)\n  };\n}\nfunction last(xs) {\n  return xs[xs.length - 1];\n}\nfunction startsWith(source, searchString) {\n  return source.startsWith(searchString);\n}\nfunction advanceBy(context, numberOfCharacters) {\n  const {\n    source\n  } = context;\n  advancePositionWithMutation(context, source, numberOfCharacters);\n  context.source = source.slice(numberOfCharacters);\n}\nfunction advanceSpaces(context) {\n  const match = /^[\\t\\r\\n\\f ]+/.exec(context.source);\n  if (match) {\n    advanceBy(context, match[0].length);\n  }\n}\nfunction getNewPosition(context, start, numberOfCharacters) {\n  return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);\n}\nfunction emitError(context, code, offset) {\n  let loc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : getCursor(context);\n  if (offset) {\n    loc.offset += offset;\n    loc.column += offset;\n  }\n  context.options.onError(createCompilerError(code, {\n    start: loc,\n    end: loc,\n    source: ''\n  }));\n}\nfunction isEnd(context, mode, ancestors) {\n  const s = context.source;\n  switch (mode) {\n    case 0 /* TextModes.DATA */:\n      if (startsWith(s, '</')) {\n        // TODO: probably bad performance\n        for (let i = ancestors.length - 1; i >= 0; --i) {\n          if (startsWithEndTagOpen(s, ancestors[i].tag)) {\n            return true;\n          }\n        }\n      }\n      break;\n    case 1 /* TextModes.RCDATA */:\n    case 2 /* TextModes.RAWTEXT */:\n      {\n        const parent = last(ancestors);\n        if (parent && startsWithEndTagOpen(s, parent.tag)) {\n          return true;\n        }\n        break;\n      }\n    case 3 /* TextModes.CDATA */:\n      if (startsWith(s, ']]>')) {\n        return true;\n      }\n      break;\n  }\n  return !s;\n}\nfunction startsWithEndTagOpen(source, tag) {\n  return startsWith(source, '</') && source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() && /[\\t\\r\\n\\f />]/.test(source[2 + tag.length] || '>');\n}\nfunction hoistStatic(root, context) {\n  walk(root, context,\n  // Root node is unfortunately non-hoistable due to potential parent\n  // fallthrough attributes.\n  isSingleElementRoot(root, root.children[0]));\n}\nfunction isSingleElementRoot(root, child) {\n  const {\n    children\n  } = root;\n  return children.length === 1 && child.type === 1 /* NodeTypes.ELEMENT */ && !isSlotOutlet(child);\n}\nfunction walk(node, context) {\n  let doNotHoistNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const {\n    children\n  } = node;\n  const originalCount = children.length;\n  let hoistedCount = 0;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    // only plain elements & text calls are eligible for hoisting.\n    if (child.type === 1 /* NodeTypes.ELEMENT */ && child.tagType === 0 /* ElementTypes.ELEMENT */) {\n      const constantType = doNotHoistNode ? 0 /* ConstantTypes.NOT_CONSTANT */ : getConstantType(child, context);\n      if (constantType > 0 /* ConstantTypes.NOT_CONSTANT */) {\n        if (constantType >= 2 /* ConstantTypes.CAN_HOIST */) {\n          child.codegenNode.patchFlag = -1 /* PatchFlags.HOISTED */ + ( true ? ` /* HOISTED */` : 0);\n          child.codegenNode = context.hoist(child.codegenNode);\n          hoistedCount++;\n          continue;\n        }\n      } else {\n        // node may contain dynamic children, but its props may be eligible for\n        // hoisting.\n        const codegenNode = child.codegenNode;\n        if (codegenNode.type === 13 /* NodeTypes.VNODE_CALL */) {\n          const flag = getPatchFlag(codegenNode);\n          if ((!flag || flag === 512 /* PatchFlags.NEED_PATCH */ || flag === 1 /* PatchFlags.TEXT */) && getGeneratedPropsConstantType(child, context) >= 2 /* ConstantTypes.CAN_HOIST */) {\n            const props = getNodeProps(child);\n            if (props) {\n              codegenNode.props = context.hoist(props);\n            }\n          }\n          if (codegenNode.dynamicProps) {\n            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);\n          }\n        }\n      }\n    }\n    // walk further\n    if (child.type === 1 /* NodeTypes.ELEMENT */) {\n      const isComponent = child.tagType === 1 /* ElementTypes.COMPONENT */;\n      if (isComponent) {\n        context.scopes.vSlot++;\n      }\n      walk(child, context);\n      if (isComponent) {\n        context.scopes.vSlot--;\n      }\n    } else if (child.type === 11 /* NodeTypes.FOR */) {\n      // Do not hoist v-for single child because it has to be a block\n      walk(child, context, child.children.length === 1);\n    } else if (child.type === 9 /* NodeTypes.IF */) {\n      for (let i = 0; i < child.branches.length; i++) {\n        // Do not hoist v-if single child because it has to be a block\n        walk(child.branches[i], context, child.branches[i].children.length === 1);\n      }\n    }\n  }\n  if (hoistedCount && context.transformHoist) {\n    context.transformHoist(children, context, node);\n  }\n  // all children were hoisted - the entire children array is hoistable.\n  if (hoistedCount && hoistedCount === originalCount && node.type === 1 /* NodeTypes.ELEMENT */ && node.tagType === 0 /* ElementTypes.ELEMENT */ && node.codegenNode && node.codegenNode.type === 13 /* NodeTypes.VNODE_CALL */ && (0, shared_1.isArray)(node.codegenNode.children)) {\n    node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));\n  }\n}\nfunction getConstantType(node, context) {\n  const {\n    constantCache\n  } = context;\n  switch (node.type) {\n    case 1 /* NodeTypes.ELEMENT */:\n      if (node.tagType !== 0 /* ElementTypes.ELEMENT */) {\n        return 0 /* ConstantTypes.NOT_CONSTANT */;\n      }\n\n      const cached = constantCache.get(node);\n      if (cached !== undefined) {\n        return cached;\n      }\n      const codegenNode = node.codegenNode;\n      if (codegenNode.type !== 13 /* NodeTypes.VNODE_CALL */) {\n        return 0 /* ConstantTypes.NOT_CONSTANT */;\n      }\n\n      if (codegenNode.isBlock && node.tag !== 'svg' && node.tag !== 'foreignObject') {\n        return 0 /* ConstantTypes.NOT_CONSTANT */;\n      }\n\n      const flag = getPatchFlag(codegenNode);\n      if (!flag) {\n        let returnType = 3 /* ConstantTypes.CAN_STRINGIFY */;\n        // Element itself has no patch flag. However we still need to check:\n        // 1. Even for a node with no patch flag, it is possible for it to contain\n        // non-hoistable expressions that refers to scope variables, e.g. compiler\n        // injected keys or cached event handlers. Therefore we need to always\n        // check the codegenNode's props to be sure.\n        const generatedPropsType = getGeneratedPropsConstantType(node, context);\n        if (generatedPropsType === 0 /* ConstantTypes.NOT_CONSTANT */) {\n          constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);\n          return 0 /* ConstantTypes.NOT_CONSTANT */;\n        }\n\n        if (generatedPropsType < returnType) {\n          returnType = generatedPropsType;\n        }\n        // 2. its children.\n        for (let i = 0; i < node.children.length; i++) {\n          const childType = getConstantType(node.children[i], context);\n          if (childType === 0 /* ConstantTypes.NOT_CONSTANT */) {\n            constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);\n            return 0 /* ConstantTypes.NOT_CONSTANT */;\n          }\n\n          if (childType < returnType) {\n            returnType = childType;\n          }\n        }\n        // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0\n        // type, check if any of the props can cause the type to be lowered\n        // we can skip can_patch because it's guaranteed by the absence of a\n        // patchFlag.\n        if (returnType > 1 /* ConstantTypes.CAN_SKIP_PATCH */) {\n          for (let i = 0; i < node.props.length; i++) {\n            const p = node.props[i];\n            if (p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'bind' && p.exp) {\n              const expType = getConstantType(p.exp, context);\n              if (expType === 0 /* ConstantTypes.NOT_CONSTANT */) {\n                constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);\n                return 0 /* ConstantTypes.NOT_CONSTANT */;\n              }\n\n              if (expType < returnType) {\n                returnType = expType;\n              }\n            }\n          }\n        }\n        // only svg/foreignObject could be block here, however if they are\n        // static then they don't need to be blocks since there will be no\n        // nested updates.\n        if (codegenNode.isBlock) {\n          // except set custom directives.\n          for (let i = 0; i < node.props.length; i++) {\n            const p = node.props[i];\n            if (p.type === 7 /* NodeTypes.DIRECTIVE */) {\n              constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);\n              return 0 /* ConstantTypes.NOT_CONSTANT */;\n            }\n          }\n\n          context.removeHelper(OPEN_BLOCK);\n          context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));\n          codegenNode.isBlock = false;\n          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));\n        }\n        constantCache.set(node, returnType);\n        return returnType;\n      } else {\n        constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);\n        return 0 /* ConstantTypes.NOT_CONSTANT */;\n      }\n\n    case 2 /* NodeTypes.TEXT */:\n    case 3 /* NodeTypes.COMMENT */:\n      return 3 /* ConstantTypes.CAN_STRINGIFY */;\n    case 9 /* NodeTypes.IF */:\n    case 11 /* NodeTypes.FOR */:\n    case 10 /* NodeTypes.IF_BRANCH */:\n      return 0 /* ConstantTypes.NOT_CONSTANT */;\n    case 5 /* NodeTypes.INTERPOLATION */:\n    case 12 /* NodeTypes.TEXT_CALL */:\n      return getConstantType(node.content, context);\n    case 4 /* NodeTypes.SIMPLE_EXPRESSION */:\n      return node.constType;\n    case 8 /* NodeTypes.COMPOUND_EXPRESSION */:\n      let returnType = 3 /* ConstantTypes.CAN_STRINGIFY */;\n      for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        if ((0, shared_1.isString)(child) || (0, shared_1.isSymbol)(child)) {\n          continue;\n        }\n        const childType = getConstantType(child, context);\n        if (childType === 0 /* ConstantTypes.NOT_CONSTANT */) {\n          return 0 /* ConstantTypes.NOT_CONSTANT */;\n        } else if (childType < returnType) {\n          returnType = childType;\n        }\n      }\n      return returnType;\n    default:\n      if (true) ;\n      return 0 /* ConstantTypes.NOT_CONSTANT */;\n  }\n}\n\nexports.getConstantType = getConstantType;\nconst allowHoistedHelperSet = new Set([NORMALIZE_CLASS, NORMALIZE_STYLE, NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);\nfunction getConstantTypeOfHelperCall(value, context) {\n  if (value.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */ && !(0, shared_1.isString)(value.callee) && allowHoistedHelperSet.has(value.callee)) {\n    const arg = value.arguments[0];\n    if (arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n      return getConstantType(arg, context);\n    } else if (arg.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {\n      // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`\n      return getConstantTypeOfHelperCall(arg, context);\n    }\n  }\n  return 0 /* ConstantTypes.NOT_CONSTANT */;\n}\n\nfunction getGeneratedPropsConstantType(node, context) {\n  let returnType = 3 /* ConstantTypes.CAN_STRINGIFY */;\n  const props = getNodeProps(node);\n  if (props && props.type === 15 /* NodeTypes.JS_OBJECT_EXPRESSION */) {\n    const {\n      properties\n    } = props;\n    for (let i = 0; i < properties.length; i++) {\n      const {\n        key,\n        value\n      } = properties[i];\n      const keyType = getConstantType(key, context);\n      if (keyType === 0 /* ConstantTypes.NOT_CONSTANT */) {\n        return keyType;\n      }\n      if (keyType < returnType) {\n        returnType = keyType;\n      }\n      let valueType;\n      if (value.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n        valueType = getConstantType(value, context);\n      } else if (value.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {\n        // some helper calls can be hoisted,\n        // such as the `normalizeProps` generated by the compiler for pre-normalize class,\n        // in this case we need to respect the ConstantType of the helper's arguments\n        valueType = getConstantTypeOfHelperCall(value, context);\n      } else {\n        valueType = 0 /* ConstantTypes.NOT_CONSTANT */;\n      }\n\n      if (valueType === 0 /* ConstantTypes.NOT_CONSTANT */) {\n        return valueType;\n      }\n      if (valueType < returnType) {\n        returnType = valueType;\n      }\n    }\n  }\n  return returnType;\n}\nfunction getNodeProps(node) {\n  const codegenNode = node.codegenNode;\n  if (codegenNode.type === 13 /* NodeTypes.VNODE_CALL */) {\n    return codegenNode.props;\n  }\n}\nfunction getPatchFlag(node) {\n  const flag = node.patchFlag;\n  return flag ? parseInt(flag, 10) : undefined;\n}\nfunction createTransformContext(root, _ref2) {\n  let {\n    filename = '',\n    prefixIdentifiers = false,\n    hoistStatic = false,\n    cacheHandlers = false,\n    nodeTransforms = [],\n    directiveTransforms = {},\n    transformHoist = null,\n    isBuiltInComponent = shared_1.NOOP,\n    isCustomElement = shared_1.NOOP,\n    expressionPlugins = [],\n    scopeId = null,\n    slotted = true,\n    ssr = false,\n    inSSR = false,\n    ssrCssVars = ``,\n    bindingMetadata = shared_1.EMPTY_OBJ,\n    inline = false,\n    isTS = false,\n    onError = defaultOnError,\n    onWarn = defaultOnWarn,\n    compatConfig\n  } = _ref2;\n  const nameMatch = filename.replace(/\\?.*$/, '').match(/([^/\\\\]+)\\.\\w+$/);\n  const context = {\n    // options\n    selfName: nameMatch && (0, shared_1.capitalize)((0, shared_1.camelize)(nameMatch[1])),\n    prefixIdentifiers,\n    hoistStatic,\n    cacheHandlers,\n    nodeTransforms,\n    directiveTransforms,\n    transformHoist,\n    isBuiltInComponent,\n    isCustomElement,\n    expressionPlugins,\n    scopeId,\n    slotted,\n    ssr,\n    inSSR,\n    ssrCssVars,\n    bindingMetadata,\n    inline,\n    isTS,\n    onError,\n    onWarn,\n    compatConfig,\n    // state\n    root,\n    helpers: new Map(),\n    components: new Set(),\n    directives: new Set(),\n    hoists: [],\n    imports: [],\n    constantCache: new Map(),\n    temps: 0,\n    cached: 0,\n    identifiers: Object.create(null),\n    scopes: {\n      vFor: 0,\n      vSlot: 0,\n      vPre: 0,\n      vOnce: 0\n    },\n    parent: null,\n    currentNode: root,\n    childIndex: 0,\n    inVOnce: false,\n    // methods\n    helper(name) {\n      const count = context.helpers.get(name) || 0;\n      context.helpers.set(name, count + 1);\n      return name;\n    },\n    removeHelper(name) {\n      const count = context.helpers.get(name);\n      if (count) {\n        const currentCount = count - 1;\n        if (!currentCount) {\n          context.helpers.delete(name);\n        } else {\n          context.helpers.set(name, currentCount);\n        }\n      }\n    },\n    helperString(name) {\n      return `_${helperNameMap[context.helper(name)]}`;\n    },\n    replaceNode(node) {\n      /* istanbul ignore if */\n      if (true) {\n        if (!context.currentNode) {\n          throw new Error(`Node being replaced is already removed.`);\n        }\n        if (!context.parent) {\n          throw new Error(`Cannot replace root node.`);\n        }\n      }\n      context.parent.children[context.childIndex] = context.currentNode = node;\n    },\n    removeNode(node) {\n      if ( true && !context.parent) {\n        throw new Error(`Cannot remove root node.`);\n      }\n      const list = context.parent.children;\n      const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;\n      /* istanbul ignore if */\n      if ( true && removalIndex < 0) {\n        throw new Error(`node being removed is not a child of current parent`);\n      }\n      if (!node || node === context.currentNode) {\n        // current node removed\n        context.currentNode = null;\n        context.onNodeRemoved();\n      } else {\n        // sibling node removed\n        if (context.childIndex > removalIndex) {\n          context.childIndex--;\n          context.onNodeRemoved();\n        }\n      }\n      context.parent.children.splice(removalIndex, 1);\n    },\n    onNodeRemoved: () => {},\n    addIdentifiers(exp) {},\n    removeIdentifiers(exp) {},\n    hoist(exp) {\n      if ((0, shared_1.isString)(exp)) exp = createSimpleExpression(exp);\n      context.hoists.push(exp);\n      const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2 /* ConstantTypes.CAN_HOIST */);\n      identifier.hoisted = exp;\n      return identifier;\n    },\n    cache(exp) {\n      let isVNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return createCacheExpression(context.cached++, exp, isVNode);\n    }\n  };\n  {\n    context.filters = new Set();\n  }\n  return context;\n}\nexports.createTransformContext = createTransformContext;\nfunction transform(root, options) {\n  const context = createTransformContext(root, options);\n  traverseNode(root, context);\n  if (options.hoistStatic) {\n    hoistStatic(root, context);\n  }\n  if (!options.ssr) {\n    createRootCodegen(root, context);\n  }\n  // finalize meta information\n  root.helpers = new Set([...context.helpers.keys()]);\n  root.components = [...context.components];\n  root.directives = [...context.directives];\n  root.imports = context.imports;\n  root.hoists = context.hoists;\n  root.temps = context.temps;\n  root.cached = context.cached;\n  {\n    root.filters = [...context.filters];\n  }\n}\nexports.transform = transform;\nfunction createRootCodegen(root, context) {\n  const {\n    helper\n  } = context;\n  const {\n    children\n  } = root;\n  if (children.length === 1) {\n    const child = children[0];\n    // if the single child is an element, turn it into a block.\n    if (isSingleElementRoot(root, child) && child.codegenNode) {\n      // single element root is never hoisted so codegenNode will never be\n      // SimpleExpressionNode\n      const codegenNode = child.codegenNode;\n      if (codegenNode.type === 13 /* NodeTypes.VNODE_CALL */) {\n        makeBlock(codegenNode, context);\n      }\n      root.codegenNode = codegenNode;\n    } else {\n      // - single <slot/>, IfNode, ForNode: already blocks.\n      // - single text node: always patched.\n      // root codegen falls through via genNode()\n      root.codegenNode = child;\n    }\n  } else if (children.length > 1) {\n    // root has multiple nodes - return a fragment block.\n    let patchFlag = 64 /* PatchFlags.STABLE_FRAGMENT */;\n    let patchFlagText = shared_1.PatchFlagNames[64 /* PatchFlags.STABLE_FRAGMENT */];\n    // check if the fragment actually contains a single valid child with\n    // the rest being comments\n    if ( true && children.filter(c => c.type !== 3 /* NodeTypes.COMMENT */).length === 1) {\n      patchFlag |= 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */;\n      patchFlagText += `, ${shared_1.PatchFlagNames[2048 /* PatchFlags.DEV_ROOT_FRAGMENT */]}`;\n    }\n    root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, patchFlag + ( true ? ` /* ${patchFlagText} */` : 0), undefined, undefined, true, undefined, false /* isComponent */);\n  } else ;\n}\nfunction traverseChildren(parent, context) {\n  let i = 0;\n  const nodeRemoved = () => {\n    i--;\n  };\n  for (; i < parent.children.length; i++) {\n    const child = parent.children[i];\n    if ((0, shared_1.isString)(child)) continue;\n    context.parent = parent;\n    context.childIndex = i;\n    context.onNodeRemoved = nodeRemoved;\n    traverseNode(child, context);\n  }\n}\nfunction traverseNode(node, context) {\n  context.currentNode = node;\n  // apply transform plugins\n  const {\n    nodeTransforms\n  } = context;\n  const exitFns = [];\n  for (let i = 0; i < nodeTransforms.length; i++) {\n    const onExit = nodeTransforms[i](node, context);\n    if (onExit) {\n      if ((0, shared_1.isArray)(onExit)) {\n        exitFns.push(...onExit);\n      } else {\n        exitFns.push(onExit);\n      }\n    }\n    if (!context.currentNode) {\n      // node was removed\n      return;\n    } else {\n      // node may have been replaced\n      node = context.currentNode;\n    }\n  }\n  switch (node.type) {\n    case 3 /* NodeTypes.COMMENT */:\n      if (!context.ssr) {\n        // inject import for the Comment symbol, which is needed for creating\n        // comment nodes with `createVNode`\n        context.helper(CREATE_COMMENT);\n      }\n      break;\n    case 5 /* NodeTypes.INTERPOLATION */:\n      // no need to traverse, but we need to inject toString helper\n      if (!context.ssr) {\n        context.helper(TO_DISPLAY_STRING);\n      }\n      break;\n    // for container types, further traverse downwards\n    case 9 /* NodeTypes.IF */:\n      for (let i = 0; i < node.branches.length; i++) {\n        traverseNode(node.branches[i], context);\n      }\n      break;\n    case 10 /* NodeTypes.IF_BRANCH */:\n    case 11 /* NodeTypes.FOR */:\n    case 1 /* NodeTypes.ELEMENT */:\n    case 0 /* NodeTypes.ROOT */:\n      traverseChildren(node, context);\n      break;\n  }\n  // exit transforms\n  context.currentNode = node;\n  let i = exitFns.length;\n  while (i--) {\n    exitFns[i]();\n  }\n}\nexports.traverseNode = traverseNode;\nfunction createStructuralDirectiveTransform(name, fn) {\n  const matches = (0, shared_1.isString)(name) ? n => n === name : n => name.test(n);\n  return (node, context) => {\n    if (node.type === 1 /* NodeTypes.ELEMENT */) {\n      const {\n        props\n      } = node;\n      // structural directive transforms are not concerned with slots\n      // as they are handled separately in vSlot.ts\n      if (node.tagType === 3 /* ElementTypes.TEMPLATE */ && props.some(isVSlot)) {\n        return;\n      }\n      const exitFns = [];\n      for (let i = 0; i < props.length; i++) {\n        const prop = props[i];\n        if (prop.type === 7 /* NodeTypes.DIRECTIVE */ && matches(prop.name)) {\n          // structural directives are removed to avoid infinite recursion\n          // also we remove them *before* applying so that it can further\n          // traverse itself in case it moves the node around\n          props.splice(i, 1);\n          i--;\n          const onExit = fn(node, prop, context);\n          if (onExit) exitFns.push(onExit);\n        }\n      }\n      return exitFns;\n    }\n  };\n}\nexports.createStructuralDirectiveTransform = createStructuralDirectiveTransform;\nconst PURE_ANNOTATION = `/*#__PURE__*/`;\nconst aliasHelper = s => `${helperNameMap[s]}: _${helperNameMap[s]}`;\nfunction createCodegenContext(ast, _ref3) {\n  let {\n    mode = 'function',\n    prefixIdentifiers = mode === 'module',\n    sourceMap = false,\n    filename = `template.vue.html`,\n    scopeId = null,\n    optimizeImports = false,\n    runtimeGlobalName = `Vue`,\n    runtimeModuleName = `vue`,\n    ssrRuntimeModuleName = 'vue/server-renderer',\n    ssr = false,\n    isTS = false,\n    inSSR = false\n  } = _ref3;\n  const context = {\n    mode,\n    prefixIdentifiers,\n    sourceMap,\n    filename,\n    scopeId,\n    optimizeImports,\n    runtimeGlobalName,\n    runtimeModuleName,\n    ssrRuntimeModuleName,\n    ssr,\n    isTS,\n    inSSR,\n    source: ast.loc.source,\n    code: ``,\n    column: 1,\n    line: 1,\n    offset: 0,\n    indentLevel: 0,\n    pure: false,\n    map: undefined,\n    helper(key) {\n      return `_${helperNameMap[key]}`;\n    },\n    push(code, node) {\n      context.code += code;\n    },\n    indent() {\n      newline(++context.indentLevel);\n    },\n    deindent() {\n      let withoutNewLine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (withoutNewLine) {\n        --context.indentLevel;\n      } else {\n        newline(--context.indentLevel);\n      }\n    },\n    newline() {\n      newline(context.indentLevel);\n    }\n  };\n  function newline(n) {\n    context.push('\\n' + `  `.repeat(n));\n  }\n  return context;\n}\nfunction generate(ast) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const context = createCodegenContext(ast, options);\n  if (options.onContextCreated) options.onContextCreated(context);\n  const {\n    mode,\n    push,\n    prefixIdentifiers,\n    indent,\n    deindent,\n    newline,\n    scopeId,\n    ssr\n  } = context;\n  const helpers = Array.from(ast.helpers);\n  const hasHelpers = helpers.length > 0;\n  const useWithBlock = !prefixIdentifiers && mode !== 'module';\n  const isSetupInlined = !true;\n  // preambles\n  // in setup() inline mode, the preamble is generated in a sub context\n  // and returned separately.\n  const preambleContext = isSetupInlined ? createCodegenContext(ast, options) : context;\n  {\n    genFunctionPreamble(ast, preambleContext);\n  }\n  // enter render function\n  const functionName = ssr ? `ssrRender` : `render`;\n  const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache'];\n  const signature = args.join(', ');\n  {\n    push(`function ${functionName}(${signature}) {`);\n  }\n  indent();\n  if (useWithBlock) {\n    push(`with (_ctx) {`);\n    indent();\n    // function mode const declarations should be inside with block\n    // also they should be renamed to avoid collision with user properties\n    if (hasHelpers) {\n      push(`const { ${helpers.map(aliasHelper).join(', ')} } = _Vue`);\n      push(`\\n`);\n      newline();\n    }\n  }\n  // generate asset resolution statements\n  if (ast.components.length) {\n    genAssets(ast.components, 'component', context);\n    if (ast.directives.length || ast.temps > 0) {\n      newline();\n    }\n  }\n  if (ast.directives.length) {\n    genAssets(ast.directives, 'directive', context);\n    if (ast.temps > 0) {\n      newline();\n    }\n  }\n  if (ast.filters && ast.filters.length) {\n    newline();\n    genAssets(ast.filters, 'filter', context);\n    newline();\n  }\n  if (ast.temps > 0) {\n    push(`let `);\n    for (let i = 0; i < ast.temps; i++) {\n      push(`${i > 0 ? `, ` : ``}_temp${i}`);\n    }\n  }\n  if (ast.components.length || ast.directives.length || ast.temps) {\n    push(`\\n`);\n    newline();\n  }\n  // generate the VNode tree expression\n  if (!ssr) {\n    push(`return `);\n  }\n  if (ast.codegenNode) {\n    genNode(ast.codegenNode, context);\n  } else {\n    push(`null`);\n  }\n  if (useWithBlock) {\n    deindent();\n    push(`}`);\n  }\n  deindent();\n  push(`}`);\n  return {\n    ast,\n    code: context.code,\n    preamble: isSetupInlined ? preambleContext.code : ``,\n    // SourceMapGenerator does have toJSON() method but it's not in the types\n    map: context.map ? context.map.toJSON() : undefined\n  };\n}\nexports.generate = generate;\nfunction genFunctionPreamble(ast, context) {\n  const {\n    ssr,\n    prefixIdentifiers,\n    push,\n    newline,\n    runtimeModuleName,\n    runtimeGlobalName,\n    ssrRuntimeModuleName\n  } = context;\n  const VueBinding = runtimeGlobalName;\n  // Generate const declaration for helpers\n  // In prefix mode, we place the const declaration at top so it's done\n  // only once; But if we not prefixing, we place the declaration inside the\n  // with block so it doesn't incur the `in` check cost for every helper access.\n  const helpers = Array.from(ast.helpers);\n  if (helpers.length > 0) {\n    {\n      // \"with\" mode.\n      // save Vue in a separate variable to avoid collision\n      push(`const _Vue = ${VueBinding}\\n`);\n      // in \"with\" mode, helpers are declared inside the with block to avoid\n      // has check cost, but hoists are lifted out of the function - we need\n      // to provide the helper here.\n      if (ast.hoists.length) {\n        const staticHelpers = [CREATE_VNODE, CREATE_ELEMENT_VNODE, CREATE_COMMENT, CREATE_TEXT, CREATE_STATIC].filter(helper => helpers.includes(helper)).map(aliasHelper).join(', ');\n        push(`const { ${staticHelpers} } = _Vue\\n`);\n      }\n    }\n  }\n  genHoists(ast.hoists, context);\n  newline();\n  push(`return `);\n}\nfunction genAssets(assets, type, _ref4) {\n  let {\n    helper,\n    push,\n    newline,\n    isTS\n  } = _ref4;\n  const resolver = helper(type === 'filter' ? RESOLVE_FILTER : type === 'component' ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);\n  for (let i = 0; i < assets.length; i++) {\n    let id = assets[i];\n    // potential component implicit self-reference inferred from SFC filename\n    const maybeSelfReference = id.endsWith('__self');\n    if (maybeSelfReference) {\n      id = id.slice(0, -6);\n    }\n    push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);\n    if (i < assets.length - 1) {\n      newline();\n    }\n  }\n}\nfunction genHoists(hoists, context) {\n  if (!hoists.length) {\n    return;\n  }\n  context.pure = true;\n  const {\n    push,\n    newline,\n    helper,\n    scopeId,\n    mode\n  } = context;\n  newline();\n  for (let i = 0; i < hoists.length; i++) {\n    const exp = hoists[i];\n    if (exp) {\n      push(`const _hoisted_${i + 1} = ${``}`);\n      genNode(exp, context);\n      newline();\n    }\n  }\n  context.pure = false;\n}\nfunction isText(n) {\n  return (0, shared_1.isString)(n) || n.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ || n.type === 2 /* NodeTypes.TEXT */ || n.type === 5 /* NodeTypes.INTERPOLATION */ || n.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */;\n}\n\nfunction genNodeListAsArray(nodes, context) {\n  const multilines = nodes.length > 3 ||  true && nodes.some(n => (0, shared_1.isArray)(n) || !isText(n));\n  context.push(`[`);\n  multilines && context.indent();\n  genNodeList(nodes, context, multilines);\n  multilines && context.deindent();\n  context.push(`]`);\n}\nfunction genNodeList(nodes, context) {\n  let multilines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let comma = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  const {\n    push,\n    newline\n  } = context;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ((0, shared_1.isString)(node)) {\n      push(node);\n    } else if ((0, shared_1.isArray)(node)) {\n      genNodeListAsArray(node, context);\n    } else {\n      genNode(node, context);\n    }\n    if (i < nodes.length - 1) {\n      if (multilines) {\n        comma && push(',');\n        newline();\n      } else {\n        comma && push(', ');\n      }\n    }\n  }\n}\nfunction genNode(node, context) {\n  if ((0, shared_1.isString)(node)) {\n    context.push(node);\n    return;\n  }\n  if ((0, shared_1.isSymbol)(node)) {\n    context.push(context.helper(node));\n    return;\n  }\n  switch (node.type) {\n    case 1 /* NodeTypes.ELEMENT */:\n    case 9 /* NodeTypes.IF */:\n    case 11 /* NodeTypes.FOR */:\n       true && assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. ` + `Apply appropriate transforms first.`);\n      genNode(node.codegenNode, context);\n      break;\n    case 2 /* NodeTypes.TEXT */:\n      genText(node, context);\n      break;\n    case 4 /* NodeTypes.SIMPLE_EXPRESSION */:\n      genExpression(node, context);\n      break;\n    case 5 /* NodeTypes.INTERPOLATION */:\n      genInterpolation(node, context);\n      break;\n    case 12 /* NodeTypes.TEXT_CALL */:\n      genNode(node.codegenNode, context);\n      break;\n    case 8 /* NodeTypes.COMPOUND_EXPRESSION */:\n      genCompoundExpression(node, context);\n      break;\n    case 3 /* NodeTypes.COMMENT */:\n      genComment(node, context);\n      break;\n    case 13 /* NodeTypes.VNODE_CALL */:\n      genVNodeCall(node, context);\n      break;\n    case 14 /* NodeTypes.JS_CALL_EXPRESSION */:\n      genCallExpression(node, context);\n      break;\n    case 15 /* NodeTypes.JS_OBJECT_EXPRESSION */:\n      genObjectExpression(node, context);\n      break;\n    case 17 /* NodeTypes.JS_ARRAY_EXPRESSION */:\n      genArrayExpression(node, context);\n      break;\n    case 18 /* NodeTypes.JS_FUNCTION_EXPRESSION */:\n      genFunctionExpression(node, context);\n      break;\n    case 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */:\n      genConditionalExpression(node, context);\n      break;\n    case 20 /* NodeTypes.JS_CACHE_EXPRESSION */:\n      genCacheExpression(node, context);\n      break;\n    case 21 /* NodeTypes.JS_BLOCK_STATEMENT */:\n      genNodeList(node.body, context, true, false);\n      break;\n    // SSR only types\n    case 22 /* NodeTypes.JS_TEMPLATE_LITERAL */:\n      break;\n    case 23 /* NodeTypes.JS_IF_STATEMENT */:\n      break;\n    case 24 /* NodeTypes.JS_ASSIGNMENT_EXPRESSION */:\n      break;\n    case 25 /* NodeTypes.JS_SEQUENCE_EXPRESSION */:\n      break;\n    case 26 /* NodeTypes.JS_RETURN_STATEMENT */:\n      break;\n    /* istanbul ignore next */\n    case 10 /* NodeTypes.IF_BRANCH */:\n      // noop\n      break;\n    default:\n      if (true) {\n        assert(false, `unhandled codegen node type: ${node.type}`);\n        // make sure we exhaust all possible types\n        const exhaustiveCheck = node;\n        return exhaustiveCheck;\n      }\n  }\n}\nfunction genText(node, context) {\n  context.push(JSON.stringify(node.content), node);\n}\nfunction genExpression(node, context) {\n  const {\n    content,\n    isStatic\n  } = node;\n  context.push(isStatic ? JSON.stringify(content) : content, node);\n}\nfunction genInterpolation(node, context) {\n  const {\n    push,\n    helper,\n    pure\n  } = context;\n  if (pure) push(PURE_ANNOTATION);\n  push(`${helper(TO_DISPLAY_STRING)}(`);\n  genNode(node.content, context);\n  push(`)`);\n}\nfunction genCompoundExpression(node, context) {\n  for (let i = 0; i < node.children.length; i++) {\n    const child = node.children[i];\n    if ((0, shared_1.isString)(child)) {\n      context.push(child);\n    } else {\n      genNode(child, context);\n    }\n  }\n}\nfunction genExpressionAsPropertyKey(node, context) {\n  const {\n    push\n  } = context;\n  if (node.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */) {\n    push(`[`);\n    genCompoundExpression(node, context);\n    push(`]`);\n  } else if (node.isStatic) {\n    // only quote keys if necessary\n    const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);\n    push(text, node);\n  } else {\n    push(`[${node.content}]`, node);\n  }\n}\nfunction genComment(node, context) {\n  const {\n    push,\n    helper,\n    pure\n  } = context;\n  if (pure) {\n    push(PURE_ANNOTATION);\n  }\n  push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);\n}\nfunction genVNodeCall(node, context) {\n  const {\n    push,\n    helper,\n    pure\n  } = context;\n  const {\n    tag,\n    props,\n    children,\n    patchFlag,\n    dynamicProps,\n    directives,\n    isBlock,\n    disableTracking,\n    isComponent\n  } = node;\n  if (directives) {\n    push(helper(WITH_DIRECTIVES) + `(`);\n  }\n  if (isBlock) {\n    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);\n  }\n  if (pure) {\n    push(PURE_ANNOTATION);\n  }\n  const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent) : getVNodeHelper(context.inSSR, isComponent);\n  push(helper(callHelper) + `(`, node);\n  genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);\n  push(`)`);\n  if (isBlock) {\n    push(`)`);\n  }\n  if (directives) {\n    push(`, `);\n    genNode(directives, context);\n    push(`)`);\n  }\n}\nfunction genNullableArgs(args) {\n  let i = args.length;\n  while (i--) {\n    if (args[i] != null) break;\n  }\n  return args.slice(0, i + 1).map(arg => arg || `null`);\n}\n// JavaScript\nfunction genCallExpression(node, context) {\n  const {\n    push,\n    helper,\n    pure\n  } = context;\n  const callee = (0, shared_1.isString)(node.callee) ? node.callee : helper(node.callee);\n  if (pure) {\n    push(PURE_ANNOTATION);\n  }\n  push(callee + `(`, node);\n  genNodeList(node.arguments, context);\n  push(`)`);\n}\nfunction genObjectExpression(node, context) {\n  const {\n    push,\n    indent,\n    deindent,\n    newline\n  } = context;\n  const {\n    properties\n  } = node;\n  if (!properties.length) {\n    push(`{}`, node);\n    return;\n  }\n  const multilines = properties.length > 1 ||  true && properties.some(p => p.value.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */);\n  push(multilines ? `{` : `{ `);\n  multilines && indent();\n  for (let i = 0; i < properties.length; i++) {\n    const {\n      key,\n      value\n    } = properties[i];\n    // key\n    genExpressionAsPropertyKey(key, context);\n    push(`: `);\n    // value\n    genNode(value, context);\n    if (i < properties.length - 1) {\n      // will only reach this if it's multilines\n      push(`,`);\n      newline();\n    }\n  }\n  multilines && deindent();\n  push(multilines ? `}` : ` }`);\n}\nfunction genArrayExpression(node, context) {\n  genNodeListAsArray(node.elements, context);\n}\nfunction genFunctionExpression(node, context) {\n  const {\n    push,\n    indent,\n    deindent\n  } = context;\n  const {\n    params,\n    returns,\n    body,\n    newline,\n    isSlot\n  } = node;\n  if (isSlot) {\n    // wrap slot functions with owner context\n    push(`_${helperNameMap[WITH_CTX]}(`);\n  }\n  push(`(`, node);\n  if ((0, shared_1.isArray)(params)) {\n    genNodeList(params, context);\n  } else if (params) {\n    genNode(params, context);\n  }\n  push(`) => `);\n  if (newline || body) {\n    push(`{`);\n    indent();\n  }\n  if (returns) {\n    if (newline) {\n      push(`return `);\n    }\n    if ((0, shared_1.isArray)(returns)) {\n      genNodeListAsArray(returns, context);\n    } else {\n      genNode(returns, context);\n    }\n  } else if (body) {\n    genNode(body, context);\n  }\n  if (newline || body) {\n    deindent();\n    push(`}`);\n  }\n  if (isSlot) {\n    if (node.isNonScopedSlot) {\n      push(`, undefined, true`);\n    }\n    push(`)`);\n  }\n}\nfunction genConditionalExpression(node, context) {\n  const {\n    test,\n    consequent,\n    alternate,\n    newline: needNewline\n  } = node;\n  const {\n    push,\n    indent,\n    deindent,\n    newline\n  } = context;\n  if (test.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n    const needsParens = !isSimpleIdentifier(test.content);\n    needsParens && push(`(`);\n    genExpression(test, context);\n    needsParens && push(`)`);\n  } else {\n    push(`(`);\n    genNode(test, context);\n    push(`)`);\n  }\n  needNewline && indent();\n  context.indentLevel++;\n  needNewline || push(` `);\n  push(`? `);\n  genNode(consequent, context);\n  context.indentLevel--;\n  needNewline && newline();\n  needNewline || push(` `);\n  push(`: `);\n  const isNested = alternate.type === 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */;\n  if (!isNested) {\n    context.indentLevel++;\n  }\n  genNode(alternate, context);\n  if (!isNested) {\n    context.indentLevel--;\n  }\n  needNewline && deindent(true /* without newline */);\n}\n\nfunction genCacheExpression(node, context) {\n  const {\n    push,\n    helper,\n    indent,\n    deindent,\n    newline\n  } = context;\n  push(`_cache[${node.index}] || (`);\n  if (node.isVNode) {\n    indent();\n    push(`${helper(SET_BLOCK_TRACKING)}(-1),`);\n    newline();\n  }\n  push(`_cache[${node.index}] = `);\n  genNode(node.value, context);\n  if (node.isVNode) {\n    push(`,`);\n    newline();\n    push(`${helper(SET_BLOCK_TRACKING)}(1),`);\n    newline();\n    push(`_cache[${node.index}]`);\n    deindent();\n  }\n  push(`)`);\n}\nfunction walkIdentifiers(root, onIdentifier) {\n  let includeAll = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let parentStack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let knownIds = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Object.create(null);\n  {\n    return;\n  }\n}\nexports.walkIdentifiers = walkIdentifiers;\nfunction isReferencedIdentifier(id, parent, parentStack) {\n  {\n    return false;\n  }\n}\nexports.isReferencedIdentifier = isReferencedIdentifier;\nfunction isInDestructureAssignment(parent, parentStack) {\n  if (parent && (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')) {\n    let i = parentStack.length;\n    while (i--) {\n      const p = parentStack[i];\n      if (p.type === 'AssignmentExpression') {\n        return true;\n      } else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {\n        break;\n      }\n    }\n  }\n  return false;\n}\nexports.isInDestructureAssignment = isInDestructureAssignment;\nfunction walkFunctionParams(node, onIdent) {\n  for (const p of node.params) {\n    for (const id of extractIdentifiers(p)) {\n      onIdent(id);\n    }\n  }\n}\nexports.walkFunctionParams = walkFunctionParams;\nfunction walkBlockDeclarations(block, onIdent) {\n  for (const stmt of block.body) {\n    if (stmt.type === 'VariableDeclaration') {\n      if (stmt.declare) continue;\n      for (const decl of stmt.declarations) {\n        for (const id of extractIdentifiers(decl.id)) {\n          onIdent(id);\n        }\n      }\n    } else if (stmt.type === 'FunctionDeclaration' || stmt.type === 'ClassDeclaration') {\n      if (stmt.declare || !stmt.id) continue;\n      onIdent(stmt.id);\n    }\n  }\n}\nexports.walkBlockDeclarations = walkBlockDeclarations;\nfunction extractIdentifiers(param) {\n  let nodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  switch (param.type) {\n    case 'Identifier':\n      nodes.push(param);\n      break;\n    case 'MemberExpression':\n      let object = param;\n      while (object.type === 'MemberExpression') {\n        object = object.object;\n      }\n      nodes.push(object);\n      break;\n    case 'ObjectPattern':\n      for (const prop of param.properties) {\n        if (prop.type === 'RestElement') {\n          extractIdentifiers(prop.argument, nodes);\n        } else {\n          extractIdentifiers(prop.value, nodes);\n        }\n      }\n      break;\n    case 'ArrayPattern':\n      param.elements.forEach(element => {\n        if (element) extractIdentifiers(element, nodes);\n      });\n      break;\n    case 'RestElement':\n      extractIdentifiers(param.argument, nodes);\n      break;\n    case 'AssignmentPattern':\n      extractIdentifiers(param.left, nodes);\n      break;\n  }\n  return nodes;\n}\nexports.extractIdentifiers = extractIdentifiers;\nconst isFunctionType = node => {\n  return /Function(?:Expression|Declaration)$|Method$/.test(node.type);\n};\nexports.isFunctionType = isFunctionType;\nconst isStaticProperty = node => node && (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') && !node.computed;\nexports.isStaticProperty = isStaticProperty;\nconst isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;\nexports.isStaticPropertyKey = isStaticPropertyKey;\n// these keywords should not appear inside expressions, but operators like\n// 'typeof', 'instanceof', and 'in' are allowed\nconst prohibitedKeywordRE = new RegExp('\\\\b' + ('arguments,await,break,case,catch,class,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,import,let,new,' + 'return,super,switch,throw,try,var,void,while,with,yield').split(',').join('\\\\b|\\\\b') + '\\\\b');\n// strip strings in expressions\nconst stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n/**\n * Validate a non-prefixed expression.\n * This is only called when using the in-browser runtime compiler since it\n * doesn't prefix expressions.\n */\nfunction validateBrowserExpression(node, context) {\n  let asParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let asRawStatements = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const exp = node.content;\n  // empty expressions are validated per-directive since some directives\n  // do allow empty expressions.\n  if (!exp.trim()) {\n    return;\n  }\n  try {\n    new Function(asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);\n  } catch (e) {\n    let message = e.message;\n    const keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      message = `avoid using JavaScript keyword as property name: \"${keywordMatch[0]}\"`;\n    }\n    context.onError(createCompilerError(45 /* ErrorCodes.X_INVALID_EXPRESSION */, node.loc, undefined, message));\n  }\n}\nconst transformExpression = (node, context) => {\n  if (node.type === 5 /* NodeTypes.INTERPOLATION */) {\n    node.content = processExpression(node.content, context);\n  } else if (node.type === 1 /* NodeTypes.ELEMENT */) {\n    // handle directives on element\n    for (let i = 0; i < node.props.length; i++) {\n      const dir = node.props[i];\n      // do not process for v-on & v-for since they are special handled\n      if (dir.type === 7 /* NodeTypes.DIRECTIVE */ && dir.name !== 'for') {\n        const exp = dir.exp;\n        const arg = dir.arg;\n        // do not process exp if this is v-on:arg - we need special handling\n        // for wrapping inline statements.\n        if (exp && exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ && !(dir.name === 'on' && arg)) {\n          dir.exp = processExpression(exp, context,\n          // slot args must be processed as function params\n          dir.name === 'slot');\n        }\n        if (arg && arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ && !arg.isStatic) {\n          dir.arg = processExpression(arg, context);\n        }\n      }\n    }\n  }\n};\nexports.transformExpression = transformExpression;\n// Important: since this function uses Node.js only dependencies, it should\n// always be used with a leading !true check so that it can be\n// tree-shaken from the browser build.\nfunction processExpression(node, context) {\n  let asParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let asRawStatements = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let localVars = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Object.create(context.identifiers);\n  {\n    if (true) {\n      // simple in-browser validation (same logic in 2.x)\n      validateBrowserExpression(node, context, asParams, asRawStatements);\n    }\n    return node;\n  }\n}\nexports.processExpression = processExpression;\nfunction stringifyExpression(exp) {\n  if ((0, shared_1.isString)(exp)) {\n    return exp;\n  } else if (exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n    return exp.content;\n  } else {\n    return exp.children.map(stringifyExpression).join('');\n  }\n}\nexports.stringifyExpression = stringifyExpression;\nconst transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {\n  return processIf(node, dir, context, (ifNode, branch, isRoot) => {\n    // #1587: We need to dynamically increment the key based on the current\n    // node's sibling nodes, since chained v-if/else branches are\n    // rendered at the same depth\n    const siblings = context.parent.children;\n    let i = siblings.indexOf(ifNode);\n    let key = 0;\n    while (i-- >= 0) {\n      const sibling = siblings[i];\n      if (sibling && sibling.type === 9 /* NodeTypes.IF */) {\n        key += sibling.branches.length;\n      }\n    }\n    // Exit callback. Complete the codegenNode when all children have been\n    // transformed.\n    return () => {\n      if (isRoot) {\n        ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);\n      } else {\n        // attach this branch's codegen node to the v-if root.\n        const parentCondition = getParentCondition(ifNode.codegenNode);\n        parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);\n      }\n    };\n  });\n});\n// target-agnostic transform used for both Client and SSR\nfunction processIf(node, dir, context, processCodegen) {\n  if (dir.name !== 'else' && (!dir.exp || !dir.exp.content.trim())) {\n    const loc = dir.exp ? dir.exp.loc : node.loc;\n    context.onError(createCompilerError(28 /* ErrorCodes.X_V_IF_NO_EXPRESSION */, dir.loc));\n    dir.exp = createSimpleExpression(`true`, false, loc);\n  }\n  if ( true && dir.exp) {\n    validateBrowserExpression(dir.exp, context);\n  }\n  if (dir.name === 'if') {\n    const branch = createIfBranch(node, dir);\n    const ifNode = {\n      type: 9 /* NodeTypes.IF */,\n      loc: node.loc,\n      branches: [branch]\n    };\n    context.replaceNode(ifNode);\n    if (processCodegen) {\n      return processCodegen(ifNode, branch, true);\n    }\n  } else {\n    // locate the adjacent v-if\n    const siblings = context.parent.children;\n    const comments = [];\n    let i = siblings.indexOf(node);\n    while (i-- >= -1) {\n      const sibling = siblings[i];\n      if (sibling && sibling.type === 3 /* NodeTypes.COMMENT */) {\n        context.removeNode(sibling);\n         true && comments.unshift(sibling);\n        continue;\n      }\n      if (sibling && sibling.type === 2 /* NodeTypes.TEXT */ && !sibling.content.trim().length) {\n        context.removeNode(sibling);\n        continue;\n      }\n      if (sibling && sibling.type === 9 /* NodeTypes.IF */) {\n        // Check if v-else was followed by v-else-if\n        if (dir.name === 'else-if' && sibling.branches[sibling.branches.length - 1].condition === undefined) {\n          context.onError(createCompilerError(30 /* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */, node.loc));\n        }\n        // move the node to the if node's branches\n        context.removeNode();\n        const branch = createIfBranch(node, dir);\n        if ( true && comments.length &&\n        // #3619 ignore comments if the v-if is direct child of <transition>\n        !(context.parent && context.parent.type === 1 /* NodeTypes.ELEMENT */ && isBuiltInType(context.parent.tag, 'transition'))) {\n          branch.children = [...comments, ...branch.children];\n        }\n        // check if user is forcing same key on different branches\n        if (true) {\n          const key = branch.userKey;\n          if (key) {\n            sibling.branches.forEach(_ref5 => {\n              let {\n                userKey\n              } = _ref5;\n              if (isSameKey(userKey, key)) {\n                context.onError(createCompilerError(29 /* ErrorCodes.X_V_IF_SAME_KEY */, branch.userKey.loc));\n              }\n            });\n          }\n        }\n        sibling.branches.push(branch);\n        const onExit = processCodegen && processCodegen(sibling, branch, false);\n        // since the branch was removed, it will not be traversed.\n        // make sure to traverse here.\n        traverseNode(branch, context);\n        // call on exit\n        if (onExit) onExit();\n        // make sure to reset currentNode after traversal to indicate this\n        // node has been removed.\n        context.currentNode = null;\n      } else {\n        context.onError(createCompilerError(30 /* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */, node.loc));\n      }\n      break;\n    }\n  }\n}\nexports.processIf = processIf;\nfunction createIfBranch(node, dir) {\n  const isTemplateIf = node.tagType === 3 /* ElementTypes.TEMPLATE */;\n  return {\n    type: 10 /* NodeTypes.IF_BRANCH */,\n    loc: node.loc,\n    condition: dir.name === 'else' ? undefined : dir.exp,\n    children: isTemplateIf && !findDir(node, 'for') ? node.children : [node],\n    userKey: findProp(node, `key`),\n    isTemplateIf\n  };\n}\nfunction createCodegenNodeForBranch(branch, keyIndex, context) {\n  if (branch.condition) {\n    return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context),\n    // make sure to pass in asBlock: true so that the comment node call\n    // closes the current block.\n    createCallExpression(context.helper(CREATE_COMMENT), [ true ? '\"v-if\"' : 0, 'true']));\n  } else {\n    return createChildrenCodegenNode(branch, keyIndex, context);\n  }\n}\nfunction createChildrenCodegenNode(branch, keyIndex, context) {\n  const {\n    helper\n  } = context;\n  const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2 /* ConstantTypes.CAN_HOIST */));\n  const {\n    children\n  } = branch;\n  const firstChild = children[0];\n  const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1 /* NodeTypes.ELEMENT */;\n  if (needFragmentWrapper) {\n    if (children.length === 1 && firstChild.type === 11 /* NodeTypes.FOR */) {\n      // optimize away nested fragments when child is a ForNode\n      const vnodeCall = firstChild.codegenNode;\n      injectProp(vnodeCall, keyProperty, context);\n      return vnodeCall;\n    } else {\n      let patchFlag = 64 /* PatchFlags.STABLE_FRAGMENT */;\n      let patchFlagText = shared_1.PatchFlagNames[64 /* PatchFlags.STABLE_FRAGMENT */];\n      // check if the fragment actually contains a single valid child with\n      // the rest being comments\n      if ( true && !branch.isTemplateIf && children.filter(c => c.type !== 3 /* NodeTypes.COMMENT */).length === 1) {\n        patchFlag |= 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */;\n        patchFlagText += `, ${shared_1.PatchFlagNames[2048 /* PatchFlags.DEV_ROOT_FRAGMENT */]}`;\n      }\n      return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + ( true ? ` /* ${patchFlagText} */` : 0), undefined, undefined, true, false, false /* isComponent */, branch.loc);\n    }\n  } else {\n    const ret = firstChild.codegenNode;\n    const vnodeCall = getMemoedVNodeCall(ret);\n    // Change createVNode to createBlock.\n    if (vnodeCall.type === 13 /* NodeTypes.VNODE_CALL */) {\n      makeBlock(vnodeCall, context);\n    }\n    // inject branch key\n    injectProp(vnodeCall, keyProperty, context);\n    return ret;\n  }\n}\nfunction isSameKey(a, b) {\n  if (!a || a.type !== b.type) {\n    return false;\n  }\n  if (a.type === 6 /* NodeTypes.ATTRIBUTE */) {\n    if (a.value.content !== b.value.content) {\n      return false;\n    }\n  } else {\n    // directive\n    const exp = a.exp;\n    const branchExp = b.exp;\n    if (exp.type !== branchExp.type) {\n      return false;\n    }\n    if (exp.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */ || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getParentCondition(node) {\n  while (true) {\n    if (node.type === 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */) {\n      if (node.alternate.type === 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */) {\n        node = node.alternate;\n      } else {\n        return node;\n      }\n    } else if (node.type === 20 /* NodeTypes.JS_CACHE_EXPRESSION */) {\n      node = node.value;\n    }\n  }\n}\nconst transformFor = createStructuralDirectiveTransform('for', (node, dir, context) => {\n  const {\n    helper,\n    removeHelper\n  } = context;\n  return processFor(node, dir, context, forNode => {\n    // create the loop render function expression now, and add the\n    // iterator on exit after all children have been traversed\n    const renderExp = createCallExpression(helper(RENDER_LIST), [forNode.source]);\n    const isTemplate = isTemplateNode(node);\n    const memo = findDir(node, 'memo');\n    const keyProp = findProp(node, `key`);\n    const keyExp = keyProp && (keyProp.type === 6 /* NodeTypes.ATTRIBUTE */ ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);\n    const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;\n    const isStableFragment = forNode.source.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ && forNode.source.constType > 0 /* ConstantTypes.NOT_CONSTANT */;\n    const fragmentFlag = isStableFragment ? 64 /* PatchFlags.STABLE_FRAGMENT */ : keyProp ? 128 /* PatchFlags.KEYED_FRAGMENT */ : 256 /* PatchFlags.UNKEYED_FRAGMENT */;\n    forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, fragmentFlag + ( true ? ` /* ${shared_1.PatchFlagNames[fragmentFlag]} */` : 0), undefined, undefined, true /* isBlock */, !isStableFragment /* disableTracking */, false /* isComponent */, node.loc);\n    return () => {\n      // finish the codegen now that all children have been traversed\n      let childBlock;\n      const {\n        children\n      } = forNode;\n      // check <template v-for> key placement\n      if (( true) && isTemplate) {\n        node.children.some(c => {\n          if (c.type === 1 /* NodeTypes.ELEMENT */) {\n            const key = findProp(c, 'key');\n            if (key) {\n              context.onError(createCompilerError(33 /* ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT */, key.loc));\n              return true;\n            }\n          }\n        });\n      }\n      const needFragmentWrapper = children.length !== 1 || children[0].type !== 1 /* NodeTypes.ELEMENT */;\n      const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] // api-extractor somehow fails to infer this\n      : null;\n      if (slotOutlet) {\n        // <slot v-for=\"...\"> or <template v-for=\"...\"><slot/></template>\n        childBlock = slotOutlet.codegenNode;\n        if (isTemplate && keyProperty) {\n          // <template v-for=\"...\" :key=\"...\"><slot/></template>\n          // we need to inject the key to the renderSlot() call.\n          // the props for renderSlot is passed as the 3rd argument.\n          injectProp(childBlock, keyProperty, context);\n        }\n      } else if (needFragmentWrapper) {\n        // <template v-for=\"...\"> with text or multi-elements\n        // should generate a fragment block for each loop\n        childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, 64 /* PatchFlags.STABLE_FRAGMENT */ + ( true ? ` /* ${shared_1.PatchFlagNames[64 /* PatchFlags.STABLE_FRAGMENT */]} */` : 0), undefined, undefined, true, undefined, false /* isComponent */);\n      } else {\n        // Normal element v-for. Directly use the child's codegenNode\n        // but mark it as a block.\n        childBlock = children[0].codegenNode;\n        if (isTemplate && keyProperty) {\n          injectProp(childBlock, keyProperty, context);\n        }\n        if (childBlock.isBlock !== !isStableFragment) {\n          if (childBlock.isBlock) {\n            // switch from block to vnode\n            removeHelper(OPEN_BLOCK);\n            removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));\n          } else {\n            // switch from vnode to block\n            removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));\n          }\n        }\n        childBlock.isBlock = !isStableFragment;\n        if (childBlock.isBlock) {\n          helper(OPEN_BLOCK);\n          helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));\n        } else {\n          helper(getVNodeHelper(context.inSSR, childBlock.isComponent));\n        }\n      }\n      if (memo) {\n        const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [createSimpleExpression(`_cached`)]));\n        loop.body = createBlockStatement([createCompoundExpression([`const _memo = (`, memo.exp, `)`]), createCompoundExpression([`if (_cached`, ...(keyExp ? [` && _cached.key === `, keyExp] : []), ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`]), createCompoundExpression([`const _item = `, childBlock]), createSimpleExpression(`_item.memo = _memo`), createSimpleExpression(`return _item`)]);\n        renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));\n      } else {\n        renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true /* force newline */));\n      }\n    };\n  });\n});\n// target-agnostic transform used for both Client and SSR\nfunction processFor(node, dir, context, processCodegen) {\n  if (!dir.exp) {\n    context.onError(createCompilerError(31 /* ErrorCodes.X_V_FOR_NO_EXPRESSION */, dir.loc));\n    return;\n  }\n  const parseResult = parseForExpression(\n  // can only be simple expression because vFor transform is applied\n  // before expression transform.\n  dir.exp, context);\n  if (!parseResult) {\n    context.onError(createCompilerError(32 /* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */, dir.loc));\n    return;\n  }\n  const {\n    addIdentifiers,\n    removeIdentifiers,\n    scopes\n  } = context;\n  const {\n    source,\n    value,\n    key,\n    index\n  } = parseResult;\n  const forNode = {\n    type: 11 /* NodeTypes.FOR */,\n    loc: dir.loc,\n    source,\n    valueAlias: value,\n    keyAlias: key,\n    objectIndexAlias: index,\n    parseResult,\n    children: isTemplateNode(node) ? node.children : [node]\n  };\n  context.replaceNode(forNode);\n  // bookkeeping\n  scopes.vFor++;\n  const onExit = processCodegen && processCodegen(forNode);\n  return () => {\n    scopes.vFor--;\n    if (onExit) onExit();\n  };\n}\nexports.processFor = processFor;\nconst forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n// This regex doesn't cover the case if key or index aliases have destructuring,\n// but those do not make sense in the first place, so this works in practice.\nconst forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nconst stripParensRE = /^\\(|\\)$/g;\nfunction parseForExpression(input, context) {\n  const loc = input.loc;\n  const exp = input.content;\n  const inMatch = exp.match(forAliasRE);\n  if (!inMatch) return;\n  const [, LHS, RHS] = inMatch;\n  const result = {\n    source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),\n    value: undefined,\n    key: undefined,\n    index: undefined\n  };\n  if (true) {\n    validateBrowserExpression(result.source, context);\n  }\n  let valueContent = LHS.trim().replace(stripParensRE, '').trim();\n  const trimmedOffset = LHS.indexOf(valueContent);\n  const iteratorMatch = valueContent.match(forIteratorRE);\n  if (iteratorMatch) {\n    valueContent = valueContent.replace(forIteratorRE, '').trim();\n    const keyContent = iteratorMatch[1].trim();\n    let keyOffset;\n    if (keyContent) {\n      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);\n      result.key = createAliasExpression(loc, keyContent, keyOffset);\n      if (true) {\n        validateBrowserExpression(result.key, context, true);\n      }\n    }\n    if (iteratorMatch[2]) {\n      const indexContent = iteratorMatch[2].trim();\n      if (indexContent) {\n        result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length));\n        if (true) {\n          validateBrowserExpression(result.index, context, true);\n        }\n      }\n    }\n  }\n  if (valueContent) {\n    result.value = createAliasExpression(loc, valueContent, trimmedOffset);\n    if (true) {\n      validateBrowserExpression(result.value, context, true);\n    }\n  }\n  return result;\n}\nfunction createAliasExpression(range, content, offset) {\n  return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));\n}\nfunction createForLoopParams(_ref6) {\n  let {\n    value,\n    key,\n    index\n  } = _ref6;\n  let memoArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return createParamsList([value, key, index, ...memoArgs]);\n}\nexports.createForLoopParams = createForLoopParams;\nfunction createParamsList(args) {\n  let i = args.length;\n  while (i--) {\n    if (args[i]) break;\n  }\n  return args.slice(0, i + 1).map((arg, i) => arg || createSimpleExpression(`_`.repeat(i + 1), false));\n}\nconst defaultFallback = createSimpleExpression(`undefined`, false);\n// A NodeTransform that:\n// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed\n//    by transformExpression. This is only applied in non-browser builds with\n//    { prefixIdentifiers: true }.\n// 2. Track v-slot depths so that we know a slot is inside another slot.\n//    Note the exit callback is executed before buildSlots() on the same node,\n//    so only nested slots see positive numbers.\nconst trackSlotScopes = (node, context) => {\n  if (node.type === 1 /* NodeTypes.ELEMENT */ && (node.tagType === 1 /* ElementTypes.COMPONENT */ || node.tagType === 3 /* ElementTypes.TEMPLATE */)) {\n    // We are only checking non-empty v-slot here\n    // since we only care about slots that introduce scope variables.\n    const vSlot = findDir(node, 'slot');\n    if (vSlot) {\n      vSlot.exp;\n      context.scopes.vSlot++;\n      return () => {\n        context.scopes.vSlot--;\n      };\n    }\n  }\n};\nexports.trackSlotScopes = trackSlotScopes;\n// A NodeTransform that tracks scope identifiers for scoped slots with v-for.\n// This transform is only applied in non-browser builds with { prefixIdentifiers: true }\nconst trackVForSlotScopes = (node, context) => {\n  let vFor;\n  if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, 'for'))) {\n    const result = vFor.parseResult = parseForExpression(vFor.exp, context);\n    if (result) {\n      const {\n        value,\n        key,\n        index\n      } = result;\n      const {\n        addIdentifiers,\n        removeIdentifiers\n      } = context;\n      value && addIdentifiers(value);\n      key && addIdentifiers(key);\n      index && addIdentifiers(index);\n      return () => {\n        value && removeIdentifiers(value);\n        key && removeIdentifiers(key);\n        index && removeIdentifiers(index);\n      };\n    }\n  }\n};\nexports.trackVForSlotScopes = trackVForSlotScopes;\nconst buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false /* newline */, true /* isSlot */, children.length ? children[0].loc : loc);\n// Instead of being a DirectiveTransform, v-slot processing is called during\n// transformElement to build the slots object for a component.\nfunction buildSlots(node, context) {\n  let buildSlotFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : buildClientSlotFn;\n  context.helper(WITH_CTX);\n  const {\n    children,\n    loc\n  } = node;\n  const slotsProperties = [];\n  const dynamicSlots = [];\n  // If the slot is inside a v-for or another v-slot, force it to be dynamic\n  // since it likely uses a scope variable.\n  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;\n  // 1. Check for slot with slotProps on component itself.\n  //    <Comp v-slot=\"{ prop }\"/>\n  const onComponentSlot = findDir(node, 'slot', true);\n  if (onComponentSlot) {\n    const {\n      arg,\n      exp\n    } = onComponentSlot;\n    if (arg && !isStaticExp(arg)) {\n      hasDynamicSlots = true;\n    }\n    slotsProperties.push(createObjectProperty(arg || createSimpleExpression('default', true), buildSlotFn(exp, children, loc)));\n  }\n  // 2. Iterate through children and check for template slots\n  //    <template v-slot:foo=\"{ prop }\">\n  let hasTemplateSlots = false;\n  let hasNamedDefaultSlot = false;\n  const implicitDefaultChildren = [];\n  const seenSlotNames = new Set();\n  let conditionalBranchIndex = 0;\n  for (let i = 0; i < children.length; i++) {\n    const slotElement = children[i];\n    let slotDir;\n    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, 'slot', true))) {\n      // not a <template v-slot>, skip.\n      if (slotElement.type !== 3 /* NodeTypes.COMMENT */) {\n        implicitDefaultChildren.push(slotElement);\n      }\n      continue;\n    }\n    if (onComponentSlot) {\n      // already has on-component slot - this is incorrect usage.\n      context.onError(createCompilerError(37 /* ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE */, slotDir.loc));\n      break;\n    }\n    hasTemplateSlots = true;\n    const {\n      children: slotChildren,\n      loc: slotLoc\n    } = slotElement;\n    const {\n      arg: slotName = createSimpleExpression(`default`, true),\n      exp: slotProps,\n      loc: dirLoc\n    } = slotDir;\n    // check if name is dynamic.\n    let staticSlotName;\n    if (isStaticExp(slotName)) {\n      staticSlotName = slotName ? slotName.content : `default`;\n    } else {\n      hasDynamicSlots = true;\n    }\n    const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);\n    // check if this slot is conditional (v-if/v-for)\n    let vIf;\n    let vElse;\n    let vFor;\n    if (vIf = findDir(slotElement, 'if')) {\n      hasDynamicSlots = true;\n      dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback));\n    } else if (vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */)) {\n      // find adjacent v-if\n      let j = i;\n      let prev;\n      while (j--) {\n        prev = children[j];\n        if (prev.type !== 3 /* NodeTypes.COMMENT */) {\n          break;\n        }\n      }\n      if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {\n        // remove node\n        children.splice(i, 1);\n        i--;\n        // attach this slot to previous conditional\n        let conditional = dynamicSlots[dynamicSlots.length - 1];\n        while (conditional.alternate.type === 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */) {\n          conditional = conditional.alternate;\n        }\n        conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback) : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);\n      } else {\n        context.onError(createCompilerError(30 /* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */, vElse.loc));\n      }\n    } else if (vFor = findDir(slotElement, 'for')) {\n      hasDynamicSlots = true;\n      const parseResult = vFor.parseResult || parseForExpression(vFor.exp, context);\n      if (parseResult) {\n        // Render the dynamic slots as an array and add it to the createSlot()\n        // args. The runtime knows how to handle it appropriately.\n        dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [parseResult.source, createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true /* force newline */)]));\n      } else {\n        context.onError(createCompilerError(32 /* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */, vFor.loc));\n      }\n    } else {\n      // check duplicate static names\n      if (staticSlotName) {\n        if (seenSlotNames.has(staticSlotName)) {\n          context.onError(createCompilerError(38 /* ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES */, dirLoc));\n          continue;\n        }\n        seenSlotNames.add(staticSlotName);\n        if (staticSlotName === 'default') {\n          hasNamedDefaultSlot = true;\n        }\n      }\n      slotsProperties.push(createObjectProperty(slotName, slotFunction));\n    }\n  }\n  if (!onComponentSlot) {\n    const buildDefaultSlotProperty = (props, children) => {\n      const fn = buildSlotFn(props, children, loc);\n      if (context.compatConfig) {\n        fn.isNonScopedSlot = true;\n      }\n      return createObjectProperty(`default`, fn);\n    };\n    if (!hasTemplateSlots) {\n      // implicit default slot (on component)\n      slotsProperties.push(buildDefaultSlotProperty(undefined, children));\n    } else if (implicitDefaultChildren.length &&\n    // #3766\n    // with whitespace: 'preserve', whitespaces between slots will end up in\n    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.\n    implicitDefaultChildren.some(node => isNonWhitespaceContent(node))) {\n      // implicit default slot (mixed with named slots)\n      if (hasNamedDefaultSlot) {\n        context.onError(createCompilerError(39 /* ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */, implicitDefaultChildren[0].loc));\n      } else {\n        slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));\n      }\n    }\n  }\n  const slotFlag = hasDynamicSlots ? 2 /* SlotFlags.DYNAMIC */ : hasForwardedSlots(node.children) ? 3 /* SlotFlags.FORWARDED */ : 1 /* SlotFlags.STABLE */;\n  let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`,\n  // 2 = compiled but dynamic = can skip normalization, but must run diff\n  // 1 = compiled and static = can skip normalization AND diff as optimized\n  createSimpleExpression(slotFlag + ( true ? ` /* ${shared_1.slotFlagsText[slotFlag]} */` : 0), false))), loc);\n  if (dynamicSlots.length) {\n    slots = createCallExpression(context.helper(CREATE_SLOTS), [slots, createArrayExpression(dynamicSlots)]);\n  }\n  return {\n    slots,\n    hasDynamicSlots\n  };\n}\nexports.buildSlots = buildSlots;\nfunction buildDynamicSlot(name, fn, index) {\n  const props = [createObjectProperty(`name`, name), createObjectProperty(`fn`, fn)];\n  if (index != null) {\n    props.push(createObjectProperty(`key`, createSimpleExpression(String(index), true)));\n  }\n  return createObjectExpression(props);\n}\nfunction hasForwardedSlots(children) {\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    switch (child.type) {\n      case 1 /* NodeTypes.ELEMENT */:\n        if (child.tagType === 2 /* ElementTypes.SLOT */ || hasForwardedSlots(child.children)) {\n          return true;\n        }\n        break;\n      case 9 /* NodeTypes.IF */:\n        if (hasForwardedSlots(child.branches)) return true;\n        break;\n      case 10 /* NodeTypes.IF_BRANCH */:\n      case 11 /* NodeTypes.FOR */:\n        if (hasForwardedSlots(child.children)) return true;\n        break;\n    }\n  }\n  return false;\n}\nfunction isNonWhitespaceContent(node) {\n  if (node.type !== 2 /* NodeTypes.TEXT */ && node.type !== 12 /* NodeTypes.TEXT_CALL */) return true;\n  return node.type === 2 /* NodeTypes.TEXT */ ? !!node.content.trim() : isNonWhitespaceContent(node.content);\n}\n// some directive transforms (e.g. v-model) may return a symbol for runtime\n// import, which should be used instead of a resolveDirective call.\nconst directiveImportMap = new WeakMap();\n// generate a JavaScript AST for this element's codegen\nconst transformElement = (node, context) => {\n  // perform the work on exit, after all child expressions have been\n  // processed and merged.\n  return function postTransformElement() {\n    node = context.currentNode;\n    if (!(node.type === 1 /* NodeTypes.ELEMENT */ && (node.tagType === 0 /* ElementTypes.ELEMENT */ || node.tagType === 1 /* ElementTypes.COMPONENT */))) {\n      return;\n    }\n    const {\n      tag,\n      props\n    } = node;\n    const isComponent = node.tagType === 1 /* ElementTypes.COMPONENT */;\n    // The goal of the transform is to create a codegenNode implementing the\n    // VNodeCall interface.\n    let vnodeTag = isComponent ? resolveComponentType(node, context) : `\"${tag}\"`;\n    const isDynamicComponent = (0, shared_1.isObject)(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;\n    let vnodeProps;\n    let vnodeChildren;\n    let vnodePatchFlag;\n    let patchFlag = 0;\n    let vnodeDynamicProps;\n    let dynamicPropNames;\n    let vnodeDirectives;\n    let shouldUseBlock =\n    // dynamic component may resolve to plain elements\n    isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent && (\n    // <svg> and <foreignObject> must be forced into blocks so that block\n    // updates inside get proper isSVG flag at runtime. (#639, #643)\n    // This is technically web-specific, but splitting the logic out of core\n    // leads to too much unnecessary complexity.\n    tag === 'svg' || tag === 'foreignObject');\n    // props\n    if (props.length > 0) {\n      const propsBuildResult = buildProps(node, context, undefined, isComponent, isDynamicComponent);\n      vnodeProps = propsBuildResult.props;\n      patchFlag = propsBuildResult.patchFlag;\n      dynamicPropNames = propsBuildResult.dynamicPropNames;\n      const directives = propsBuildResult.directives;\n      vnodeDirectives = directives && directives.length ? createArrayExpression(directives.map(dir => buildDirectiveArgs(dir, context))) : undefined;\n      if (propsBuildResult.shouldUseBlock) {\n        shouldUseBlock = true;\n      }\n    }\n    // children\n    if (node.children.length > 0) {\n      if (vnodeTag === KEEP_ALIVE) {\n        // Although a built-in component, we compile KeepAlive with raw children\n        // instead of slot functions so that it can be used inside Transition\n        // or other Transition-wrapping HOCs.\n        // To ensure correct updates with block optimizations, we need to:\n        // 1. Force keep-alive into a block. This avoids its children being\n        //    collected by a parent block.\n        shouldUseBlock = true;\n        // 2. Force keep-alive to always be updated, since it uses raw children.\n        patchFlag |= 1024 /* PatchFlags.DYNAMIC_SLOTS */;\n        if ( true && node.children.length > 1) {\n          context.onError(createCompilerError(46 /* ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN */, {\n            start: node.children[0].loc.start,\n            end: node.children[node.children.length - 1].loc.end,\n            source: ''\n          }));\n        }\n      }\n      const shouldBuildAsSlots = isComponent &&\n      // Teleport is not a real component and has dedicated runtime handling\n      vnodeTag !== TELEPORT &&\n      // explained above.\n      vnodeTag !== KEEP_ALIVE;\n      if (shouldBuildAsSlots) {\n        const {\n          slots,\n          hasDynamicSlots\n        } = buildSlots(node, context);\n        vnodeChildren = slots;\n        if (hasDynamicSlots) {\n          patchFlag |= 1024 /* PatchFlags.DYNAMIC_SLOTS */;\n        }\n      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {\n        const child = node.children[0];\n        const type = child.type;\n        // check for dynamic text children\n        const hasDynamicTextChild = type === 5 /* NodeTypes.INTERPOLATION */ || type === 8 /* NodeTypes.COMPOUND_EXPRESSION */;\n        if (hasDynamicTextChild && getConstantType(child, context) === 0 /* ConstantTypes.NOT_CONSTANT */) {\n          patchFlag |= 1 /* PatchFlags.TEXT */;\n        }\n        // pass directly if the only child is a text node\n        // (plain / interpolation / expression)\n        if (hasDynamicTextChild || type === 2 /* NodeTypes.TEXT */) {\n          vnodeChildren = child;\n        } else {\n          vnodeChildren = node.children;\n        }\n      } else {\n        vnodeChildren = node.children;\n      }\n    }\n    // patchFlag & dynamicPropNames\n    if (patchFlag !== 0) {\n      if (true) {\n        if (patchFlag < 0) {\n          // special flags (negative and mutually exclusive)\n          vnodePatchFlag = patchFlag + ` /* ${shared_1.PatchFlagNames[patchFlag]} */`;\n        } else {\n          // bitwise flags\n          const flagNames = Object.keys(shared_1.PatchFlagNames).map(Number).filter(n => n > 0 && patchFlag & n).map(n => shared_1.PatchFlagNames[n]).join(`, `);\n          vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;\n        }\n      } else {}\n      if (dynamicPropNames && dynamicPropNames.length) {\n        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);\n      }\n    }\n    node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* disableTracking */, isComponent, node.loc);\n  };\n};\nexports.transformElement = transformElement;\nfunction resolveComponentType(node, context) {\n  let ssr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let {\n    tag\n  } = node;\n  // 1. dynamic component\n  const isExplicitDynamic = isComponentTag(tag);\n  const isProp = findProp(node, 'is');\n  if (isProp) {\n    if (isExplicitDynamic || isCompatEnabled(\"COMPILER_IS_ON_ELEMENT\" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context)) {\n      const exp = isProp.type === 6 /* NodeTypes.ATTRIBUTE */ ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;\n      if (exp) {\n        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [exp]);\n      }\n    } else if (isProp.type === 6 /* NodeTypes.ATTRIBUTE */ && isProp.value.content.startsWith('vue:')) {\n      // <button is=\"vue:xxx\">\n      // if not <component>, only is value that starts with \"vue:\" will be\n      // treated as component by the parse phase and reach here, unless it's\n      // compat mode where all is values are considered components\n      tag = isProp.value.content.slice(4);\n    }\n  }\n  // 1.5 v-is (TODO: Deprecate)\n  const isDir = !isExplicitDynamic && findDir(node, 'is');\n  if (isDir && isDir.exp) {\n    return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [isDir.exp]);\n  }\n  // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)\n  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);\n  if (builtIn) {\n    // built-ins are simply fallthroughs / have special handling during ssr\n    // so we don't need to import their runtime equivalents\n    if (!ssr) context.helper(builtIn);\n    return builtIn;\n  }\n  // 5. user component (resolve)\n  context.helper(RESOLVE_COMPONENT);\n  context.components.add(tag);\n  return toValidAssetId(tag, `component`);\n}\nexports.resolveComponentType = resolveComponentType;\nfunction buildProps(node, context) {\n  let props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : node.props;\n  let isComponent = arguments.length > 3 ? arguments[3] : undefined;\n  let isDynamicComponent = arguments.length > 4 ? arguments[4] : undefined;\n  let ssr = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  const {\n    tag,\n    loc: elementLoc,\n    children\n  } = node;\n  let properties = [];\n  const mergeArgs = [];\n  const runtimeDirectives = [];\n  const hasChildren = children.length > 0;\n  let shouldUseBlock = false;\n  // patchFlag analysis\n  let patchFlag = 0;\n  let hasRef = false;\n  let hasClassBinding = false;\n  let hasStyleBinding = false;\n  let hasHydrationEventBinding = false;\n  let hasDynamicKeys = false;\n  let hasVnodeHook = false;\n  const dynamicPropNames = [];\n  const pushMergeArg = arg => {\n    if (properties.length) {\n      mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));\n      properties = [];\n    }\n    if (arg) mergeArgs.push(arg);\n  };\n  const analyzePatchFlag = _ref7 => {\n    let {\n      key,\n      value\n    } = _ref7;\n    if (isStaticExp(key)) {\n      const name = key.content;\n      const isEventHandler = (0, shared_1.isOn)(name);\n      if (isEventHandler && (!isComponent || isDynamicComponent) &&\n      // omit the flag for click handlers because hydration gives click\n      // dedicated fast path.\n      name.toLowerCase() !== 'onclick' &&\n      // omit v-model handlers\n      name !== 'onUpdate:modelValue' &&\n      // omit onVnodeXXX hooks\n      !(0, shared_1.isReservedProp)(name)) {\n        hasHydrationEventBinding = true;\n      }\n      if (isEventHandler && (0, shared_1.isReservedProp)(name)) {\n        hasVnodeHook = true;\n      }\n      if (value.type === 20 /* NodeTypes.JS_CACHE_EXPRESSION */ || (value.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ || value.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */) && getConstantType(value, context) > 0) {\n        // skip if the prop is a cached handler or has constant value\n        return;\n      }\n      if (name === 'ref') {\n        hasRef = true;\n      } else if (name === 'class') {\n        hasClassBinding = true;\n      } else if (name === 'style') {\n        hasStyleBinding = true;\n      } else if (name !== 'key' && !dynamicPropNames.includes(name)) {\n        dynamicPropNames.push(name);\n      }\n      // treat the dynamic class and style binding of the component as dynamic props\n      if (isComponent && (name === 'class' || name === 'style') && !dynamicPropNames.includes(name)) {\n        dynamicPropNames.push(name);\n      }\n    } else {\n      hasDynamicKeys = true;\n    }\n  };\n  for (let i = 0; i < props.length; i++) {\n    // static attribute\n    const prop = props[i];\n    if (prop.type === 6 /* NodeTypes.ATTRIBUTE */) {\n      const {\n        loc,\n        name,\n        value\n      } = prop;\n      let isStatic = true;\n      if (name === 'ref') {\n        hasRef = true;\n        if (context.scopes.vFor > 0) {\n          properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));\n        }\n      }\n      // skip is on <component>, or is=\"vue:xxx\"\n      if (name === 'is' && (isComponentTag(tag) || value && value.content.startsWith('vue:') || isCompatEnabled(\"COMPILER_IS_ON_ELEMENT\" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context))) {\n        continue;\n      }\n      properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : '', isStatic, value ? value.loc : loc)));\n    } else {\n      // directives\n      const {\n        name,\n        arg,\n        exp,\n        loc\n      } = prop;\n      const isVBind = name === 'bind';\n      const isVOn = name === 'on';\n      // skip v-slot - it is handled by its dedicated transform.\n      if (name === 'slot') {\n        if (!isComponent) {\n          context.onError(createCompilerError(40 /* ErrorCodes.X_V_SLOT_MISPLACED */, loc));\n        }\n        continue;\n      }\n      // skip v-once/v-memo - they are handled by dedicated transforms.\n      if (name === 'once' || name === 'memo') {\n        continue;\n      }\n      // skip v-is and :is on <component>\n      if (name === 'is' || isVBind && isStaticArgOf(arg, 'is') && (isComponentTag(tag) || isCompatEnabled(\"COMPILER_IS_ON_ELEMENT\" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context))) {\n        continue;\n      }\n      // skip v-on in SSR compilation\n      if (isVOn && ssr) {\n        continue;\n      }\n      if (\n      // #938: elements with dynamic keys should be forced into blocks\n      isVBind && isStaticArgOf(arg, 'key') ||\n      // inline before-update hooks need to force block so that it is invoked\n      // before children\n      isVOn && hasChildren && isStaticArgOf(arg, 'vue:before-update')) {\n        shouldUseBlock = true;\n      }\n      if (isVBind && isStaticArgOf(arg, 'ref') && context.scopes.vFor > 0) {\n        properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));\n      }\n      // special case for v-bind and v-on with no argument\n      if (!arg && (isVBind || isVOn)) {\n        hasDynamicKeys = true;\n        if (exp) {\n          if (isVBind) {\n            // have to merge early for compat build check\n            pushMergeArg();\n            {\n              // 2.x v-bind object order compat\n              if (true) {\n                const hasOverridableKeys = mergeArgs.some(arg => {\n                  if (arg.type === 15 /* NodeTypes.JS_OBJECT_EXPRESSION */) {\n                    return arg.properties.some(_ref8 => {\n                      let {\n                        key\n                      } = _ref8;\n                      if (key.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */ || !key.isStatic) {\n                        return true;\n                      }\n                      return key.content !== 'class' && key.content !== 'style' && !(0, shared_1.isOn)(key.content);\n                    });\n                  } else {\n                    // dynamic expression\n                    return true;\n                  }\n                });\n                if (hasOverridableKeys) {\n                  checkCompatEnabled(\"COMPILER_V_BIND_OBJECT_ORDER\" /* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */, context, loc);\n                }\n              }\n              if (isCompatEnabled(\"COMPILER_V_BIND_OBJECT_ORDER\" /* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */, context)) {\n                mergeArgs.unshift(exp);\n                continue;\n              }\n            }\n            mergeArgs.push(exp);\n          } else {\n            // v-on=\"obj\" -> toHandlers(obj)\n            pushMergeArg({\n              type: 14 /* NodeTypes.JS_CALL_EXPRESSION */,\n              loc,\n              callee: context.helper(TO_HANDLERS),\n              arguments: isComponent ? [exp] : [exp, `true`]\n            });\n          }\n        } else {\n          context.onError(createCompilerError(isVBind ? 34 /* ErrorCodes.X_V_BIND_NO_EXPRESSION */ : 35 /* ErrorCodes.X_V_ON_NO_EXPRESSION */, loc));\n        }\n        continue;\n      }\n      const directiveTransform = context.directiveTransforms[name];\n      if (directiveTransform) {\n        // has built-in directive transform.\n        const {\n          props,\n          needRuntime\n        } = directiveTransform(prop, node, context);\n        !ssr && props.forEach(analyzePatchFlag);\n        if (isVOn && arg && !isStaticExp(arg)) {\n          pushMergeArg(createObjectExpression(props, elementLoc));\n        } else {\n          properties.push(...props);\n        }\n        if (needRuntime) {\n          runtimeDirectives.push(prop);\n          if ((0, shared_1.isSymbol)(needRuntime)) {\n            directiveImportMap.set(prop, needRuntime);\n          }\n        }\n      } else if (!(0, shared_1.isBuiltInDirective)(name)) {\n        // no built-in transform, this is a user custom directive.\n        runtimeDirectives.push(prop);\n        // custom dirs may use beforeUpdate so they need to force blocks\n        // to ensure before-update gets called before children update\n        if (hasChildren) {\n          shouldUseBlock = true;\n        }\n      }\n    }\n  }\n  let propsExpression = undefined;\n  // has v-bind=\"object\" or v-on=\"object\", wrap with mergeProps\n  if (mergeArgs.length) {\n    // close up any not-yet-merged props\n    pushMergeArg();\n    if (mergeArgs.length > 1) {\n      propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);\n    } else {\n      // single v-bind with nothing else - no need for a mergeProps call\n      propsExpression = mergeArgs[0];\n    }\n  } else if (properties.length) {\n    propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);\n  }\n  // patchFlag analysis\n  if (hasDynamicKeys) {\n    patchFlag |= 16 /* PatchFlags.FULL_PROPS */;\n  } else {\n    if (hasClassBinding && !isComponent) {\n      patchFlag |= 2 /* PatchFlags.CLASS */;\n    }\n\n    if (hasStyleBinding && !isComponent) {\n      patchFlag |= 4 /* PatchFlags.STYLE */;\n    }\n\n    if (dynamicPropNames.length) {\n      patchFlag |= 8 /* PatchFlags.PROPS */;\n    }\n\n    if (hasHydrationEventBinding) {\n      patchFlag |= 32 /* PatchFlags.HYDRATE_EVENTS */;\n    }\n  }\n\n  if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32 /* PatchFlags.HYDRATE_EVENTS */) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {\n    patchFlag |= 512 /* PatchFlags.NEED_PATCH */;\n  }\n  // pre-normalize props, SSR is skipped for now\n  if (!context.inSSR && propsExpression) {\n    switch (propsExpression.type) {\n      case 15 /* NodeTypes.JS_OBJECT_EXPRESSION */:\n        // means that there is no v-bind,\n        // but still need to deal with dynamic key binding\n        let classKeyIndex = -1;\n        let styleKeyIndex = -1;\n        let hasDynamicKey = false;\n        for (let i = 0; i < propsExpression.properties.length; i++) {\n          const key = propsExpression.properties[i].key;\n          if (isStaticExp(key)) {\n            if (key.content === 'class') {\n              classKeyIndex = i;\n            } else if (key.content === 'style') {\n              styleKeyIndex = i;\n            }\n          } else if (!key.isHandlerKey) {\n            hasDynamicKey = true;\n          }\n        }\n        const classProp = propsExpression.properties[classKeyIndex];\n        const styleProp = propsExpression.properties[styleKeyIndex];\n        // no dynamic key\n        if (!hasDynamicKey) {\n          if (classProp && !isStaticExp(classProp.value)) {\n            classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);\n          }\n          if (styleProp && (\n          // the static style is compiled into an object,\n          // so use `hasStyleBinding` to ensure that it is a dynamic style binding\n          hasStyleBinding || styleProp.value.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ && styleProp.value.content.trim()[0] === `[` ||\n          // v-bind:style and style both exist,\n          // v-bind:style with static literal object\n          styleProp.value.type === 17 /* NodeTypes.JS_ARRAY_EXPRESSION */)) {\n            styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);\n          }\n        } else {\n          // dynamic key binding, wrap with `normalizeProps`\n          propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);\n        }\n        break;\n      case 14 /* NodeTypes.JS_CALL_EXPRESSION */:\n        // mergeProps call, do nothing\n        break;\n      default:\n        // single v-bind\n        propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [propsExpression])]);\n        break;\n    }\n  }\n  return {\n    props: propsExpression,\n    directives: runtimeDirectives,\n    patchFlag,\n    dynamicPropNames,\n    shouldUseBlock\n  };\n}\nexports.buildProps = buildProps;\n// Dedupe props in an object literal.\n// Literal duplicated attributes would have been warned during the parse phase,\n// however, it's possible to encounter duplicated `onXXX` handlers with different\n// modifiers. We also need to merge static and dynamic class / style attributes.\n// - onXXX handlers / style: merge into array\n// - class: merge into single expression with concatenation\nfunction dedupeProperties(properties) {\n  const knownProps = new Map();\n  const deduped = [];\n  for (let i = 0; i < properties.length; i++) {\n    const prop = properties[i];\n    // dynamic keys are always allowed\n    if (prop.key.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */ || !prop.key.isStatic) {\n      deduped.push(prop);\n      continue;\n    }\n    const name = prop.key.content;\n    const existing = knownProps.get(name);\n    if (existing) {\n      if (name === 'style' || name === 'class' || (0, shared_1.isOn)(name)) {\n        mergeAsArray(existing, prop);\n      }\n      // unexpected duplicate, should have emitted error during parse\n    } else {\n      knownProps.set(name, prop);\n      deduped.push(prop);\n    }\n  }\n  return deduped;\n}\nfunction mergeAsArray(existing, incoming) {\n  if (existing.value.type === 17 /* NodeTypes.JS_ARRAY_EXPRESSION */) {\n    existing.value.elements.push(incoming.value);\n  } else {\n    existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);\n  }\n}\nfunction buildDirectiveArgs(dir, context) {\n  const dirArgs = [];\n  const runtime = directiveImportMap.get(dir);\n  if (runtime) {\n    // built-in directive with runtime\n    dirArgs.push(context.helperString(runtime));\n  } else {\n    {\n      // inject statement for resolving directive\n      context.helper(RESOLVE_DIRECTIVE);\n      context.directives.add(dir.name);\n      dirArgs.push(toValidAssetId(dir.name, `directive`));\n    }\n  }\n  const {\n    loc\n  } = dir;\n  if (dir.exp) dirArgs.push(dir.exp);\n  if (dir.arg) {\n    if (!dir.exp) {\n      dirArgs.push(`void 0`);\n    }\n    dirArgs.push(dir.arg);\n  }\n  if (Object.keys(dir.modifiers).length) {\n    if (!dir.arg) {\n      if (!dir.exp) {\n        dirArgs.push(`void 0`);\n      }\n      dirArgs.push(`void 0`);\n    }\n    const trueExpression = createSimpleExpression(`true`, false, loc);\n    dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, trueExpression)), loc));\n  }\n  return createArrayExpression(dirArgs, dir.loc);\n}\nexports.buildDirectiveArgs = buildDirectiveArgs;\nfunction stringifyDynamicPropNames(props) {\n  let propsNamesString = `[`;\n  for (let i = 0, l = props.length; i < l; i++) {\n    propsNamesString += JSON.stringify(props[i]);\n    if (i < l - 1) propsNamesString += ', ';\n  }\n  return propsNamesString + `]`;\n}\nfunction isComponentTag(tag) {\n  return tag === 'component' || tag === 'Component';\n}\n true ? Object.freeze({}) : 0;\n true ? Object.freeze([]) : 0;\nconst cacheStringFunction = fn => {\n  const cache = Object.create(null);\n  return str => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n};\nconst camelizeRE = /-(\\w)/g;\n/**\n * @private\n */\nconst camelize = cacheStringFunction(str => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : '');\n});\nconst transformSlotOutlet = (node, context) => {\n  if (isSlotOutlet(node)) {\n    const {\n      children,\n      loc\n    } = node;\n    const {\n      slotName,\n      slotProps\n    } = processSlotOutlet(node, context);\n    const slotArgs = [context.prefixIdentifiers ? `_ctx.$slots` : `$slots`, slotName, '{}', 'undefined', 'true'];\n    let expectedLen = 2;\n    if (slotProps) {\n      slotArgs[2] = slotProps;\n      expectedLen = 3;\n    }\n    if (children.length) {\n      slotArgs[3] = createFunctionExpression([], children, false, false, loc);\n      expectedLen = 4;\n    }\n    if (context.scopeId && !context.slotted) {\n      expectedLen = 5;\n    }\n    slotArgs.splice(expectedLen); // remove unused arguments\n    node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);\n  }\n};\nfunction processSlotOutlet(node, context) {\n  let slotName = `\"default\"`;\n  let slotProps = undefined;\n  const nonNameProps = [];\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i];\n    if (p.type === 6 /* NodeTypes.ATTRIBUTE */) {\n      if (p.value) {\n        if (p.name === 'name') {\n          slotName = JSON.stringify(p.value.content);\n        } else {\n          p.name = camelize(p.name);\n          nonNameProps.push(p);\n        }\n      }\n    } else {\n      if (p.name === 'bind' && isStaticArgOf(p.arg, 'name')) {\n        if (p.exp) slotName = p.exp;\n      } else {\n        if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {\n          p.arg.content = camelize(p.arg.content);\n        }\n        nonNameProps.push(p);\n      }\n    }\n  }\n  if (nonNameProps.length > 0) {\n    const {\n      props,\n      directives\n    } = buildProps(node, context, nonNameProps, false, false);\n    slotProps = props;\n    if (directives.length) {\n      context.onError(createCompilerError(36 /* ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */, directives[0].loc));\n    }\n  }\n  return {\n    slotName,\n    slotProps\n  };\n}\nexports.processSlotOutlet = processSlotOutlet;\nconst fnExpRE = /^\\s*([\\w$_]+|(async\\s*)?\\([^)]*?\\))\\s*(:[^=]+)?=>|^\\s*(async\\s+)?function(?:\\s+[\\w$]+)?\\s*\\(/;\nconst transformOn = (dir, node, context, augmentor) => {\n  const {\n    loc,\n    modifiers,\n    arg\n  } = dir;\n  if (!dir.exp && !modifiers.length) {\n    context.onError(createCompilerError(35 /* ErrorCodes.X_V_ON_NO_EXPRESSION */, loc));\n  }\n  let eventName;\n  if (arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n    if (arg.isStatic) {\n      let rawName = arg.content;\n      // TODO deprecate @vnodeXXX usage\n      if (rawName.startsWith('vue:')) {\n        rawName = `vnode-${rawName.slice(4)}`;\n      }\n      const eventString = node.tagType !== 0 /* ElementTypes.ELEMENT */ || rawName.startsWith('vnode') || !/[A-Z]/.test(rawName) ?\n      // for non-element and vnode lifecycle event listeners, auto convert\n      // it to camelCase. See issue #2249\n      (0, shared_1.toHandlerKey)((0, shared_1.camelize)(rawName)) :\n      // preserve case for plain element listeners that have uppercase\n      // letters, as these may be custom elements' custom events\n      `on:${rawName}`;\n      eventName = createSimpleExpression(eventString, true, arg.loc);\n    } else {\n      // #2388\n      eventName = createCompoundExpression([`${context.helperString(TO_HANDLER_KEY)}(`, arg, `)`]);\n    }\n  } else {\n    // already a compound expression.\n    eventName = arg;\n    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);\n    eventName.children.push(`)`);\n  }\n  // handler processing\n  let exp = dir.exp;\n  if (exp && !exp.content.trim()) {\n    exp = undefined;\n  }\n  let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;\n  if (exp) {\n    const isMemberExp = isMemberExpression(exp.content);\n    const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));\n    const hasMultipleStatements = exp.content.includes(`;`);\n    if (true) {\n      validateBrowserExpression(exp, context, false, hasMultipleStatements);\n    }\n    if (isInlineStatement || shouldCache && isMemberExp) {\n      // wrap inline statement in a function expression\n      exp = createCompoundExpression([`${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`, exp, hasMultipleStatements ? `}` : `)`]);\n    }\n  }\n  let ret = {\n    props: [createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))]\n  };\n  // apply extended compiler augmentor\n  if (augmentor) {\n    ret = augmentor(ret);\n  }\n  if (shouldCache) {\n    // cache handlers so that it's always the same handler being passed down.\n    // this avoids unnecessary re-renders when users use inline handlers on\n    // components.\n    ret.props[0].value = context.cache(ret.props[0].value);\n  }\n  // mark the key as handler for props normalization check\n  ret.props.forEach(p => p.key.isHandlerKey = true);\n  return ret;\n};\nexports.transformOn = transformOn;\n// v-bind without arg is handled directly in ./transformElements.ts due to it affecting\n// codegen for the entire props object. This transform here is only for v-bind\n// *with* args.\nconst transformBind = (dir, _node, context) => {\n  const {\n    exp,\n    modifiers,\n    loc\n  } = dir;\n  const arg = dir.arg;\n  if (arg.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n    arg.children.unshift(`(`);\n    arg.children.push(`) || \"\"`);\n  } else if (!arg.isStatic) {\n    arg.content = `${arg.content} || \"\"`;\n  }\n  // .sync is replaced by v-model:arg\n  if (modifiers.includes('camel')) {\n    if (arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n      if (arg.isStatic) {\n        arg.content = (0, shared_1.camelize)(arg.content);\n      } else {\n        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;\n      }\n    } else {\n      arg.children.unshift(`${context.helperString(CAMELIZE)}(`);\n      arg.children.push(`)`);\n    }\n  }\n  if (!context.inSSR) {\n    if (modifiers.includes('prop')) {\n      injectPrefix(arg, '.');\n    }\n    if (modifiers.includes('attr')) {\n      injectPrefix(arg, '^');\n    }\n  }\n  if (!exp || exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ && !exp.content.trim()) {\n    context.onError(createCompilerError(34 /* ErrorCodes.X_V_BIND_NO_EXPRESSION */, loc));\n    return {\n      props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]\n    };\n  }\n  return {\n    props: [createObjectProperty(arg, exp)]\n  };\n};\nexports.transformBind = transformBind;\nconst injectPrefix = (arg, prefix) => {\n  if (arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n    if (arg.isStatic) {\n      arg.content = prefix + arg.content;\n    } else {\n      arg.content = `\\`${prefix}\\${${arg.content}}\\``;\n    }\n  } else {\n    arg.children.unshift(`'${prefix}' + (`);\n    arg.children.push(`)`);\n  }\n};\n// Merge adjacent text nodes and expressions into a single expression\n// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.\nconst transformText = (node, context) => {\n  if (node.type === 0 /* NodeTypes.ROOT */ || node.type === 1 /* NodeTypes.ELEMENT */ || node.type === 11 /* NodeTypes.FOR */ || node.type === 10 /* NodeTypes.IF_BRANCH */) {\n    // perform the transform on node exit so that all expressions have already\n    // been processed.\n    return () => {\n      const children = node.children;\n      let currentContainer = undefined;\n      let hasText = false;\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        if (isText$1(child)) {\n          hasText = true;\n          for (let j = i + 1; j < children.length; j++) {\n            const next = children[j];\n            if (isText$1(next)) {\n              if (!currentContainer) {\n                currentContainer = children[i] = createCompoundExpression([child], child.loc);\n              }\n              // merge adjacent text node into current\n              currentContainer.children.push(` + `, next);\n              children.splice(j, 1);\n              j--;\n            } else {\n              currentContainer = undefined;\n              break;\n            }\n          }\n        }\n      }\n      if (!hasText ||\n      // if this is a plain element with a single text child, leave it\n      // as-is since the runtime has dedicated fast path for this by directly\n      // setting textContent of the element.\n      // for component root it's always normalized anyway.\n      children.length === 1 && (node.type === 0 /* NodeTypes.ROOT */ || node.type === 1 /* NodeTypes.ELEMENT */ && node.tagType === 0 /* ElementTypes.ELEMENT */ &&\n      // #3756\n      // custom directives can potentially add DOM elements arbitrarily,\n      // we need to avoid setting textContent of the element at runtime\n      // to avoid accidentally overwriting the DOM elements added\n      // by the user through custom directives.\n      !node.props.find(p => p.type === 7 /* NodeTypes.DIRECTIVE */ && !context.directiveTransforms[p.name]) &&\n      // in compat mode, <template> tags with no special directives\n      // will be rendered as a fragment so its children must be\n      // converted into vnodes.\n      !(node.tag === 'template'))) {\n        return;\n      }\n      // pre-convert text nodes into createTextVNode(text) calls to avoid\n      // runtime normalization.\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        if (isText$1(child) || child.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */) {\n          const callArgs = [];\n          // createTextVNode defaults to single whitespace, so if it is a\n          // single space the code could be an empty call to save bytes.\n          if (child.type !== 2 /* NodeTypes.TEXT */ || child.content !== ' ') {\n            callArgs.push(child);\n          }\n          // mark dynamic text with flag so it gets patched inside a block\n          if (!context.ssr && getConstantType(child, context) === 0 /* ConstantTypes.NOT_CONSTANT */) {\n            callArgs.push(1 /* PatchFlags.TEXT */ + ( true ? ` /* ${shared_1.PatchFlagNames[1 /* PatchFlags.TEXT */]} */` : 0));\n          }\n          children[i] = {\n            type: 12 /* NodeTypes.TEXT_CALL */,\n            content: child,\n            loc: child.loc,\n            codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)\n          };\n        }\n      }\n    };\n  }\n};\nconst seen$1 = new WeakSet();\nconst transformOnce = (node, context) => {\n  if (node.type === 1 /* NodeTypes.ELEMENT */ && findDir(node, 'once', true)) {\n    if (seen$1.has(node) || context.inVOnce) {\n      return;\n    }\n    seen$1.add(node);\n    context.inVOnce = true;\n    context.helper(SET_BLOCK_TRACKING);\n    return () => {\n      context.inVOnce = false;\n      const cur = context.currentNode;\n      if (cur.codegenNode) {\n        cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */);\n      }\n    };\n  }\n};\n\nconst transformModel = (dir, node, context) => {\n  const {\n    exp,\n    arg\n  } = dir;\n  if (!exp) {\n    context.onError(createCompilerError(41 /* ErrorCodes.X_V_MODEL_NO_EXPRESSION */, dir.loc));\n    return createTransformProps();\n  }\n  const rawExp = exp.loc.source;\n  const expString = exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ ? exp.content : rawExp;\n  // im SFC <script setup> inline mode, the exp may have been transformed into\n  // _unref(exp)\n  const bindingType = context.bindingMetadata[rawExp];\n  // check props\n  if (bindingType === \"props\" /* BindingTypes.PROPS */ || bindingType === \"props-aliased\" /* BindingTypes.PROPS_ALIASED */) {\n    context.onError(createCompilerError(44 /* ErrorCodes.X_V_MODEL_ON_PROPS */, exp.loc));\n    return createTransformProps();\n  }\n  const maybeRef = !true;\n  if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {\n    context.onError(createCompilerError(42 /* ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION */, exp.loc));\n    return createTransformProps();\n  }\n  const propName = arg ? arg : createSimpleExpression('modelValue', true);\n  const eventName = arg ? isStaticExp(arg) ? `onUpdate:${(0, shared_1.camelize)(arg.content)}` : createCompoundExpression(['\"onUpdate:\" + ', arg]) : `onUpdate:modelValue`;\n  let assignmentExp;\n  const eventArg = context.isTS ? `($event: any)` : `$event`;\n  {\n    assignmentExp = createCompoundExpression([`${eventArg} => ((`, exp, `) = $event)`]);\n  }\n  const props = [\n  // modelValue: foo\n  createObjectProperty(propName, dir.exp),\n  // \"onUpdate:modelValue\": $event => (foo = $event)\n  createObjectProperty(eventName, assignmentExp)];\n  // modelModifiers: { foo: true, \"bar-baz\": true }\n  if (dir.modifiers.length && node.tagType === 1 /* ElementTypes.COMPONENT */) {\n    const modifiers = dir.modifiers.map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);\n    const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + \"Modifiers\"']) : `modelModifiers`;\n    props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2 /* ConstantTypes.CAN_HOIST */)));\n  }\n\n  return createTransformProps(props);\n};\nexports.transformModel = transformModel;\nfunction createTransformProps() {\n  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return {\n    props\n  };\n}\nconst validDivisionCharRE = /[\\w).+\\-_$\\]]/;\nconst transformFilter = (node, context) => {\n  if (!isCompatEnabled(\"COMPILER_FILTER\" /* CompilerDeprecationTypes.COMPILER_FILTERS */, context)) {\n    return;\n  }\n  if (node.type === 5 /* NodeTypes.INTERPOLATION */) {\n    // filter rewrite is applied before expression transform so only\n    // simple expressions are possible at this stage\n    rewriteFilter(node.content, context);\n  }\n  if (node.type === 1 /* NodeTypes.ELEMENT */) {\n    node.props.forEach(prop => {\n      if (prop.type === 7 /* NodeTypes.DIRECTIVE */ && prop.name !== 'for' && prop.exp) {\n        rewriteFilter(prop.exp, context);\n      }\n    });\n  }\n};\nfunction rewriteFilter(node, context) {\n  if (node.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n    parseFilter(node, context);\n  } else {\n    for (let i = 0; i < node.children.length; i++) {\n      const child = node.children[i];\n      if (typeof child !== 'object') continue;\n      if (child.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n        parseFilter(child, context);\n      } else if (child.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */) {\n        rewriteFilter(node, context);\n      } else if (child.type === 5 /* NodeTypes.INTERPOLATION */) {\n        rewriteFilter(child.content, context);\n      }\n    }\n  }\n}\nfunction parseFilter(node, context) {\n  const exp = node.content;\n  let inSingle = false;\n  let inDouble = false;\n  let inTemplateString = false;\n  let inRegex = false;\n  let curly = 0;\n  let square = 0;\n  let paren = 0;\n  let lastFilterIndex = 0;\n  let c,\n    prev,\n    i,\n    expression,\n    filters = [];\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5c) inSingle = false;\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5c) inDouble = false;\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5c) inTemplateString = false;\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5c) inRegex = false;\n    } else if (c === 0x7c &&\n    // pipe\n    exp.charCodeAt(i + 1) !== 0x7c && exp.charCodeAt(i - 1) !== 0x7c && !curly && !square && !paren) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22:\n          inDouble = true;\n          break;\n        // \"\n        case 0x27:\n          inSingle = true;\n          break;\n        // '\n        case 0x60:\n          inTemplateString = true;\n          break;\n        // `\n        case 0x28:\n          paren++;\n          break;\n        // (\n        case 0x29:\n          paren--;\n          break;\n        // )\n        case 0x5b:\n          square++;\n          break;\n        // [\n        case 0x5d:\n          square--;\n          break;\n        // ]\n        case 0x7b:\n          curly++;\n          break;\n        // {\n        case 0x7d:\n          curly--;\n          break;\n        // }\n      }\n\n      if (c === 0x2f) {\n        // /\n        let j = i - 1;\n        let p;\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') break;\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n  function pushFilter() {\n    filters.push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n  if (filters.length) {\n     true && warnDeprecation(\"COMPILER_FILTER\" /* CompilerDeprecationTypes.COMPILER_FILTERS */, context, node.loc);\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i], context);\n    }\n    node.content = expression;\n  }\n}\nfunction wrapFilter(exp, filter, context) {\n  context.helper(RESOLVE_FILTER);\n  const i = filter.indexOf('(');\n  if (i < 0) {\n    context.filters.add(filter);\n    return `${toValidAssetId(filter, 'filter')}(${exp})`;\n  } else {\n    const name = filter.slice(0, i);\n    const args = filter.slice(i + 1);\n    context.filters.add(name);\n    return `${toValidAssetId(name, 'filter')}(${exp}${args !== ')' ? ',' + args : args}`;\n  }\n}\nconst seen = new WeakSet();\nconst transformMemo = (node, context) => {\n  if (node.type === 1 /* NodeTypes.ELEMENT */) {\n    const dir = findDir(node, 'memo');\n    if (!dir || seen.has(node)) {\n      return;\n    }\n    seen.add(node);\n    return () => {\n      const codegenNode = node.codegenNode || context.currentNode.codegenNode;\n      if (codegenNode && codegenNode.type === 13 /* NodeTypes.VNODE_CALL */) {\n        // non-component sub tree should be turned into a block\n        if (node.tagType !== 1 /* ElementTypes.COMPONENT */) {\n          makeBlock(codegenNode, context);\n        }\n        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [dir.exp, createFunctionExpression(undefined, codegenNode), `_cache`, String(context.cached++)]);\n      }\n    };\n  }\n};\nfunction getBaseTransformPreset(prefixIdentifiers) {\n  return [[transformOnce, transformIf, transformMemo, transformFor, ...[transformFilter], ...( true ? [transformExpression] : 0), transformSlotOutlet, transformElement, trackSlotScopes, transformText], {\n    on: transformOn,\n    bind: transformBind,\n    model: transformModel\n  }];\n}\nexports.getBaseTransformPreset = getBaseTransformPreset;\n// we name it `baseCompile` so that higher order compilers like\n// @vue/compiler-dom can export `compile` while re-exporting everything else.\nfunction baseCompile(template) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const onError = options.onError || defaultOnError;\n  const isModuleMode = options.mode === 'module';\n  /* istanbul ignore if */\n  {\n    if (options.prefixIdentifiers === true) {\n      onError(createCompilerError(47 /* ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED */));\n    } else if (isModuleMode) {\n      onError(createCompilerError(48 /* ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED */));\n    }\n  }\n\n  const prefixIdentifiers = !true;\n  if (options.cacheHandlers) {\n    onError(createCompilerError(49 /* ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED */));\n  }\n\n  if (options.scopeId && !isModuleMode) {\n    onError(createCompilerError(50 /* ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED */));\n  }\n\n  const ast = (0, shared_1.isString)(template) ? baseParse(template, options) : template;\n  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();\n  transform(ast, (0, shared_1.extend)({}, options, {\n    prefixIdentifiers,\n    nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || []) // user transforms\n    ],\n\n    directiveTransforms: (0, shared_1.extend)({}, directiveTransforms, options.directiveTransforms || {} // user transforms\n    )\n  }));\n\n  return generate(ast, (0, shared_1.extend)({}, options, {\n    prefixIdentifiers\n  }));\n}\nexports.baseCompile = baseCompile;\nconst noopDirectiveTransform = () => ({\n  props: []\n});\nexports.noopDirectiveTransform = noopDirectiveTransform;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS9jb21waWxlci1jb3JlL2Rpc3QvY29tcGlsZXItY29yZS5lc20tYnVuZGxlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRkE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUxBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBRUE7O0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBRkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBV0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFLQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQUE7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYWIvLi9ub2RlX21vZHVsZXMvQHZ1ZS9jb21waWxlci1jb3JlL2Rpc3QvY29tcGlsZXItY29yZS5lc20tYnVuZGxlci5qcz8yYmVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVBcnJheUV4cHJlc3Npb24gPSBleHBvcnRzLmNoZWNrQ29tcGF0RW5hYmxlZCA9IGV4cG9ydHMuYnVpbGRTbG90cyA9IGV4cG9ydHMuYnVpbGRQcm9wcyA9IGV4cG9ydHMuYnVpbGREaXJlY3RpdmVBcmdzID0gZXhwb3J0cy5iYXNlUGFyc2UgPSBleHBvcnRzLmJhc2VDb21waWxlID0gZXhwb3J0cy5hc3NlcnQgPSBleHBvcnRzLmFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbiA9IGV4cG9ydHMuYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lID0gZXhwb3J0cy5XSVRIX01FTU8gPSBleHBvcnRzLldJVEhfRElSRUNUSVZFUyA9IGV4cG9ydHMuV0lUSF9DVFggPSBleHBvcnRzLlVOUkVGID0gZXhwb3J0cy5UT19IQU5ETEVSX0tFWSA9IGV4cG9ydHMuVE9fSEFORExFUlMgPSBleHBvcnRzLlRPX0RJU1BMQVlfU1RSSU5HID0gZXhwb3J0cy5URUxFUE9SVCA9IGV4cG9ydHMuU1VTUEVOU0UgPSBleHBvcnRzLlNFVF9CTE9DS19UUkFDS0lORyA9IGV4cG9ydHMuUkVTT0xWRV9GSUxURVIgPSBleHBvcnRzLlJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQgPSBleHBvcnRzLlJFU09MVkVfRElSRUNUSVZFID0gZXhwb3J0cy5SRVNPTFZFX0NPTVBPTkVOVCA9IGV4cG9ydHMuUkVOREVSX1NMT1QgPSBleHBvcnRzLlJFTkRFUl9MSVNUID0gZXhwb3J0cy5QVVNIX1NDT1BFX0lEID0gZXhwb3J0cy5QT1BfU0NPUEVfSUQgPSBleHBvcnRzLk9QRU5fQkxPQ0sgPSBleHBvcnRzLk5PUk1BTElaRV9TVFlMRSA9IGV4cG9ydHMuTk9STUFMSVpFX1BST1BTID0gZXhwb3J0cy5OT1JNQUxJWkVfQ0xBU1MgPSBleHBvcnRzLk1FUkdFX1BST1BTID0gZXhwb3J0cy5LRUVQX0FMSVZFID0gZXhwb3J0cy5JU19SRUYgPSBleHBvcnRzLklTX01FTU9fU0FNRSA9IGV4cG9ydHMuR1VBUkRfUkVBQ1RJVkVfUFJPUFMgPSBleHBvcnRzLkZSQUdNRU5UID0gZXhwb3J0cy5DUkVBVEVfVk5PREUgPSBleHBvcnRzLkNSRUFURV9URVhUID0gZXhwb3J0cy5DUkVBVEVfU1RBVElDID0gZXhwb3J0cy5DUkVBVEVfU0xPVFMgPSBleHBvcnRzLkNSRUFURV9FTEVNRU5UX1ZOT0RFID0gZXhwb3J0cy5DUkVBVEVfRUxFTUVOVF9CTE9DSyA9IGV4cG9ydHMuQ1JFQVRFX0NPTU1FTlQgPSBleHBvcnRzLkNSRUFURV9CTE9DSyA9IGV4cG9ydHMuQ0FQSVRBTElaRSA9IGV4cG9ydHMuQ0FNRUxJWkUgPSBleHBvcnRzLkJBU0VfVFJBTlNJVElPTiA9IGV4cG9ydHMuZ2VuZXJhdGVDb2RlRnJhbWUgPSB2b2lkIDA7XG5leHBvcnRzLmlzVGVtcGxhdGVOb2RlID0gZXhwb3J0cy5pc1N0YXRpY1Byb3BlcnR5S2V5ID0gZXhwb3J0cy5pc1N0YXRpY1Byb3BlcnR5ID0gZXhwb3J0cy5pc1N0YXRpY0V4cCA9IGV4cG9ydHMuaXNTdGF0aWNBcmdPZiA9IGV4cG9ydHMuaXNTbG90T3V0bGV0ID0gZXhwb3J0cy5pc1NpbXBsZUlkZW50aWZpZXIgPSBleHBvcnRzLmlzUmVmZXJlbmNlZElkZW50aWZpZXIgPSBleHBvcnRzLmlzTWVtYmVyRXhwcmVzc2lvbk5vZGUgPSBleHBvcnRzLmlzTWVtYmVyRXhwcmVzc2lvbkJyb3dzZXIgPSBleHBvcnRzLmlzTWVtYmVyRXhwcmVzc2lvbiA9IGV4cG9ydHMuaXNJbkRlc3RydWN0dXJlQXNzaWdubWVudCA9IGV4cG9ydHMuaXNGdW5jdGlvblR5cGUgPSBleHBvcnRzLmlzQ29yZUNvbXBvbmVudCA9IGV4cG9ydHMuaXNCdWlsdEluVHlwZSA9IGV4cG9ydHMuaW5qZWN0UHJvcCA9IGV4cG9ydHMuaGVscGVyTmFtZU1hcCA9IGV4cG9ydHMuaGFzU2NvcGVSZWYgPSBleHBvcnRzLmhhc0R5bmFtaWNLZXlWQmluZCA9IGV4cG9ydHMuZ2V0Vk5vZGVIZWxwZXIgPSBleHBvcnRzLmdldFZOb2RlQmxvY2tIZWxwZXIgPSBleHBvcnRzLmdldE1lbW9lZFZOb2RlQ2FsbCA9IGV4cG9ydHMuZ2V0SW5uZXJSYW5nZSA9IGV4cG9ydHMuZ2V0Q29uc3RhbnRUeXBlID0gZXhwb3J0cy5nZXRCYXNlVHJhbnNmb3JtUHJlc2V0ID0gZXhwb3J0cy5nZW5lcmF0ZSA9IGV4cG9ydHMuZmluZFByb3AgPSBleHBvcnRzLmZpbmREaXIgPSBleHBvcnRzLmV4dHJhY3RJZGVudGlmaWVycyA9IGV4cG9ydHMuY3JlYXRlVk5vZGVDYWxsID0gZXhwb3J0cy5jcmVhdGVUcmFuc2Zvcm1Db250ZXh0ID0gZXhwb3J0cy5jcmVhdGVUZW1wbGF0ZUxpdGVyYWwgPSBleHBvcnRzLmNyZWF0ZVN0cnVjdHVyYWxEaXJlY3RpdmVUcmFuc2Zvcm0gPSBleHBvcnRzLmNyZWF0ZVNpbXBsZUV4cHJlc3Npb24gPSBleHBvcnRzLmNyZWF0ZVNlcXVlbmNlRXhwcmVzc2lvbiA9IGV4cG9ydHMuY3JlYXRlUm9vdCA9IGV4cG9ydHMuY3JlYXRlUmV0dXJuU3RhdGVtZW50ID0gZXhwb3J0cy5jcmVhdGVPYmplY3RQcm9wZXJ0eSA9IGV4cG9ydHMuY3JlYXRlT2JqZWN0RXhwcmVzc2lvbiA9IGV4cG9ydHMuY3JlYXRlSW50ZXJwb2xhdGlvbiA9IGV4cG9ydHMuY3JlYXRlSWZTdGF0ZW1lbnQgPSBleHBvcnRzLmNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbiA9IGV4cG9ydHMuY3JlYXRlRm9yTG9vcFBhcmFtcyA9IGV4cG9ydHMuY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gZXhwb3J0cy5jcmVhdGVDb21wb3VuZEV4cHJlc3Npb24gPSBleHBvcnRzLmNyZWF0ZUNvbXBpbGVyRXJyb3IgPSBleHBvcnRzLmNyZWF0ZUNhbGxFeHByZXNzaW9uID0gZXhwb3J0cy5jcmVhdGVDYWNoZUV4cHJlc3Npb24gPSBleHBvcnRzLmNyZWF0ZUJsb2NrU3RhdGVtZW50ID0gZXhwb3J0cy5jcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbiA9IHZvaWQgMDtcbmV4cG9ydHMud2FybkRlcHJlY2F0aW9uID0gZXhwb3J0cy53YWxrSWRlbnRpZmllcnMgPSBleHBvcnRzLndhbGtGdW5jdGlvblBhcmFtcyA9IGV4cG9ydHMud2Fsa0Jsb2NrRGVjbGFyYXRpb25zID0gZXhwb3J0cy50cmF2ZXJzZU5vZGUgPSBleHBvcnRzLnRyYW5zZm9ybU9uID0gZXhwb3J0cy50cmFuc2Zvcm1Nb2RlbCA9IGV4cG9ydHMudHJhbnNmb3JtRXhwcmVzc2lvbiA9IGV4cG9ydHMudHJhbnNmb3JtRWxlbWVudCA9IGV4cG9ydHMudHJhbnNmb3JtQmluZCA9IGV4cG9ydHMudHJhbnNmb3JtID0gZXhwb3J0cy50cmFja1ZGb3JTbG90U2NvcGVzID0gZXhwb3J0cy50cmFja1Nsb3RTY29wZXMgPSBleHBvcnRzLnRvVmFsaWRBc3NldElkID0gZXhwb3J0cy5zdHJpbmdpZnlFeHByZXNzaW9uID0gZXhwb3J0cy5yZXNvbHZlQ29tcG9uZW50VHlwZSA9IGV4cG9ydHMucmVnaXN0ZXJSdW50aW1lSGVscGVycyA9IGV4cG9ydHMucHJvY2Vzc1Nsb3RPdXRsZXQgPSBleHBvcnRzLnByb2Nlc3NJZiA9IGV4cG9ydHMucHJvY2Vzc0ZvciA9IGV4cG9ydHMucHJvY2Vzc0V4cHJlc3Npb24gPSBleHBvcnRzLm5vb3BEaXJlY3RpdmVUcmFuc2Zvcm0gPSBleHBvcnRzLm1ha2VCbG9jayA9IGV4cG9ydHMubG9jU3R1YiA9IGV4cG9ydHMuaXNWU2xvdCA9IGV4cG9ydHMuaXNUZXh0ID0gdm9pZCAwO1xuY29uc3Qgc2hhcmVkXzEgPSByZXF1aXJlKFwiQHZ1ZS9zaGFyZWRcIik7XG52YXIgc2hhcmVkXzIgPSByZXF1aXJlKFwiQHZ1ZS9zaGFyZWRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZW5lcmF0ZUNvZGVGcmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcmVkXzIuZ2VuZXJhdGVDb2RlRnJhbWU7IH0gfSk7XG5mdW5jdGlvbiBkZWZhdWx0T25FcnJvcihlcnJvcikge1xuICAgIHRocm93IGVycm9yO1xufVxuZnVuY3Rpb24gZGVmYXVsdE9uV2Fybihtc2cpIHtcbiAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY29uc29sZS53YXJuKGBbVnVlIHdhcm5dICR7bXNnLm1lc3NhZ2V9YCk7XG59XG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckVycm9yKGNvZGUsIGxvYywgbWVzc2FnZXMsIGFkZGl0aW9uYWxNZXNzYWdlKSB7XG4gICAgY29uc3QgbXNnID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICF0cnVlXG4gICAgICAgID8gKG1lc3NhZ2VzIHx8IGVycm9yTWVzc2FnZXMpW2NvZGVdICsgKGFkZGl0aW9uYWxNZXNzYWdlIHx8IGBgKVxuICAgICAgICA6IGNvZGU7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgU3ludGF4RXJyb3IoU3RyaW5nKG1zZykpO1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICAgIGVycm9yLmxvYyA9IGxvYztcbiAgICByZXR1cm4gZXJyb3I7XG59XG5leHBvcnRzLmNyZWF0ZUNvbXBpbGVyRXJyb3IgPSBjcmVhdGVDb21waWxlckVycm9yO1xuY29uc3QgZXJyb3JNZXNzYWdlcyA9IHtcbiAgICAvLyBwYXJzZSBlcnJvcnNcbiAgICBbMCAvKiBFcnJvckNvZGVzLkFCUlVQVF9DTE9TSU5HX09GX0VNUFRZX0NPTU1FTlQgKi9dOiAnSWxsZWdhbCBjb21tZW50LicsXG4gICAgWzEgLyogRXJyb3JDb2Rlcy5DREFUQV9JTl9IVE1MX0NPTlRFTlQgKi9dOiAnQ0RBVEEgc2VjdGlvbiBpcyBhbGxvd2VkIG9ubHkgaW4gWE1MIGNvbnRleHQuJyxcbiAgICBbMiAvKiBFcnJvckNvZGVzLkRVUExJQ0FURV9BVFRSSUJVVEUgKi9dOiAnRHVwbGljYXRlIGF0dHJpYnV0ZS4nLFxuICAgIFszIC8qIEVycm9yQ29kZXMuRU5EX1RBR19XSVRIX0FUVFJJQlVURVMgKi9dOiAnRW5kIHRhZyBjYW5ub3QgaGF2ZSBhdHRyaWJ1dGVzLicsXG4gICAgWzQgLyogRXJyb3JDb2Rlcy5FTkRfVEFHX1dJVEhfVFJBSUxJTkdfU09MSURVUyAqL106IFwiSWxsZWdhbCAnLycgaW4gdGFncy5cIixcbiAgICBbNSAvKiBFcnJvckNvZGVzLkVPRl9CRUZPUkVfVEFHX05BTUUgKi9dOiAnVW5leHBlY3RlZCBFT0YgaW4gdGFnLicsXG4gICAgWzYgLyogRXJyb3JDb2Rlcy5FT0ZfSU5fQ0RBVEEgKi9dOiAnVW5leHBlY3RlZCBFT0YgaW4gQ0RBVEEgc2VjdGlvbi4nLFxuICAgIFs3IC8qIEVycm9yQ29kZXMuRU9GX0lOX0NPTU1FTlQgKi9dOiAnVW5leHBlY3RlZCBFT0YgaW4gY29tbWVudC4nLFxuICAgIFs4IC8qIEVycm9yQ29kZXMuRU9GX0lOX1NDUklQVF9IVE1MX0NPTU1FTlRfTElLRV9URVhUICovXTogJ1VuZXhwZWN0ZWQgRU9GIGluIHNjcmlwdC4nLFxuICAgIFs5IC8qIEVycm9yQ29kZXMuRU9GX0lOX1RBRyAqL106ICdVbmV4cGVjdGVkIEVPRiBpbiB0YWcuJyxcbiAgICBbMTAgLyogRXJyb3JDb2Rlcy5JTkNPUlJFQ1RMWV9DTE9TRURfQ09NTUVOVCAqL106ICdJbmNvcnJlY3RseSBjbG9zZWQgY29tbWVudC4nLFxuICAgIFsxMSAvKiBFcnJvckNvZGVzLklOQ09SUkVDVExZX09QRU5FRF9DT01NRU5UICovXTogJ0luY29ycmVjdGx5IG9wZW5lZCBjb21tZW50LicsXG4gICAgWzEyIC8qIEVycm9yQ29kZXMuSU5WQUxJRF9GSVJTVF9DSEFSQUNURVJfT0ZfVEFHX05BTUUgKi9dOiBcIklsbGVnYWwgdGFnIG5hbWUuIFVzZSAnJmx0OycgdG8gcHJpbnQgJzwnLlwiLFxuICAgIFsxMyAvKiBFcnJvckNvZGVzLk1JU1NJTkdfQVRUUklCVVRFX1ZBTFVFICovXTogJ0F0dHJpYnV0ZSB2YWx1ZSB3YXMgZXhwZWN0ZWQuJyxcbiAgICBbMTQgLyogRXJyb3JDb2Rlcy5NSVNTSU5HX0VORF9UQUdfTkFNRSAqL106ICdFbmQgdGFnIG5hbWUgd2FzIGV4cGVjdGVkLicsXG4gICAgWzE1IC8qIEVycm9yQ29kZXMuTUlTU0lOR19XSElURVNQQUNFX0JFVFdFRU5fQVRUUklCVVRFUyAqL106ICdXaGl0ZXNwYWNlIHdhcyBleHBlY3RlZC4nLFxuICAgIFsxNiAvKiBFcnJvckNvZGVzLk5FU1RFRF9DT01NRU5UICovXTogXCJVbmV4cGVjdGVkICc8IS0tJyBpbiBjb21tZW50LlwiLFxuICAgIFsxNyAvKiBFcnJvckNvZGVzLlVORVhQRUNURURfQ0hBUkFDVEVSX0lOX0FUVFJJQlVURV9OQU1FICovXTogJ0F0dHJpYnV0ZSBuYW1lIGNhbm5vdCBjb250YWluIFUrMDAyMiAoXCIpLCBVKzAwMjcgKFxcJyksIGFuZCBVKzAwM0MgKDwpLicsXG4gICAgWzE4IC8qIEVycm9yQ29kZXMuVU5FWFBFQ1RFRF9DSEFSQUNURVJfSU5fVU5RVU9URURfQVRUUklCVVRFX1ZBTFVFICovXTogJ1VucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZSBjYW5ub3QgY29udGFpbiBVKzAwMjIgKFwiKSwgVSswMDI3IChcXCcpLCBVKzAwM0MgKDwpLCBVKzAwM0QgKD0pLCBhbmQgVSswMDYwIChgKS4nLFxuICAgIFsxOSAvKiBFcnJvckNvZGVzLlVORVhQRUNURURfRVFVQUxTX1NJR05fQkVGT1JFX0FUVFJJQlVURV9OQU1FICovXTogXCJBdHRyaWJ1dGUgbmFtZSBjYW5ub3Qgc3RhcnQgd2l0aCAnPScuXCIsXG4gICAgWzIxIC8qIEVycm9yQ29kZXMuVU5FWFBFQ1RFRF9RVUVTVElPTl9NQVJLX0lOU1RFQURfT0ZfVEFHX05BTUUgKi9dOiBcIic8PycgaXMgYWxsb3dlZCBvbmx5IGluIFhNTCBjb250ZXh0LlwiLFxuICAgIFsyMCAvKiBFcnJvckNvZGVzLlVORVhQRUNURURfTlVMTF9DSEFSQUNURVIgKi9dOiBgVW5leHBlY3RlZCBudWxsIGNoYXJhY3Rlci5gLFxuICAgIFsyMiAvKiBFcnJvckNvZGVzLlVORVhQRUNURURfU09MSURVU19JTl9UQUcgKi9dOiBcIklsbGVnYWwgJy8nIGluIHRhZ3MuXCIsXG4gICAgLy8gVnVlLXNwZWNpZmljIHBhcnNlIGVycm9yc1xuICAgIFsyMyAvKiBFcnJvckNvZGVzLlhfSU5WQUxJRF9FTkRfVEFHICovXTogJ0ludmFsaWQgZW5kIHRhZy4nLFxuICAgIFsyNCAvKiBFcnJvckNvZGVzLlhfTUlTU0lOR19FTkRfVEFHICovXTogJ0VsZW1lbnQgaXMgbWlzc2luZyBlbmQgdGFnLicsXG4gICAgWzI1IC8qIEVycm9yQ29kZXMuWF9NSVNTSU5HX0lOVEVSUE9MQVRJT05fRU5EICovXTogJ0ludGVycG9sYXRpb24gZW5kIHNpZ24gd2FzIG5vdCBmb3VuZC4nLFxuICAgIFsyNyAvKiBFcnJvckNvZGVzLlhfTUlTU0lOR19EWU5BTUlDX0RJUkVDVElWRV9BUkdVTUVOVF9FTkQgKi9dOiAnRW5kIGJyYWNrZXQgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IHdhcyBub3QgZm91bmQuICcgK1xuICAgICAgICAnTm90ZSB0aGF0IGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IGNhbm5vdCBjb250YWluIHNwYWNlcy4nLFxuICAgIFsyNiAvKiBFcnJvckNvZGVzLlhfTUlTU0lOR19ESVJFQ1RJVkVfTkFNRSAqL106ICdMZWdhbCBkaXJlY3RpdmUgbmFtZSB3YXMgZXhwZWN0ZWQuJyxcbiAgICAvLyB0cmFuc2Zvcm0gZXJyb3JzXG4gICAgWzI4IC8qIEVycm9yQ29kZXMuWF9WX0lGX05PX0VYUFJFU1NJT04gKi9dOiBgdi1pZi92LWVsc2UtaWYgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXG4gICAgWzI5IC8qIEVycm9yQ29kZXMuWF9WX0lGX1NBTUVfS0VZICovXTogYHYtaWYvZWxzZSBicmFuY2hlcyBtdXN0IHVzZSB1bmlxdWUga2V5cy5gLFxuICAgIFszMCAvKiBFcnJvckNvZGVzLlhfVl9FTFNFX05PX0FESkFDRU5UX0lGICovXTogYHYtZWxzZS92LWVsc2UtaWYgaGFzIG5vIGFkamFjZW50IHYtaWYgb3Igdi1lbHNlLWlmLmAsXG4gICAgWzMxIC8qIEVycm9yQ29kZXMuWF9WX0ZPUl9OT19FWFBSRVNTSU9OICovXTogYHYtZm9yIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxuICAgIFszMiAvKiBFcnJvckNvZGVzLlhfVl9GT1JfTUFMRk9STUVEX0VYUFJFU1NJT04gKi9dOiBgdi1mb3IgaGFzIGludmFsaWQgZXhwcmVzc2lvbi5gLFxuICAgIFszMyAvKiBFcnJvckNvZGVzLlhfVl9GT1JfVEVNUExBVEVfS0VZX1BMQUNFTUVOVCAqL106IGA8dGVtcGxhdGUgdi1mb3I+IGtleSBzaG91bGQgYmUgcGxhY2VkIG9uIHRoZSA8dGVtcGxhdGU+IHRhZy5gLFxuICAgIFszNCAvKiBFcnJvckNvZGVzLlhfVl9CSU5EX05PX0VYUFJFU1NJT04gKi9dOiBgdi1iaW5kIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxuICAgIFszNSAvKiBFcnJvckNvZGVzLlhfVl9PTl9OT19FWFBSRVNTSU9OICovXTogYHYtb24gaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXG4gICAgWzM2IC8qIEVycm9yQ29kZXMuWF9WX1NMT1RfVU5FWFBFQ1RFRF9ESVJFQ1RJVkVfT05fU0xPVF9PVVRMRVQgKi9dOiBgVW5leHBlY3RlZCBjdXN0b20gZGlyZWN0aXZlIG9uIDxzbG90PiBvdXRsZXQuYCxcbiAgICBbMzcgLyogRXJyb3JDb2Rlcy5YX1ZfU0xPVF9NSVhFRF9TTE9UX1VTQUdFICovXTogYE1peGVkIHYtc2xvdCB1c2FnZSBvbiBib3RoIHRoZSBjb21wb25lbnQgYW5kIG5lc3RlZCA8dGVtcGxhdGU+LiBgICtcbiAgICAgICAgYFdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIG5hbWVkIHNsb3RzLCBhbGwgc2xvdHMgc2hvdWxkIHVzZSA8dGVtcGxhdGU+IGAgK1xuICAgICAgICBgc3ludGF4IHRvIGF2b2lkIHNjb3BlIGFtYmlndWl0eS5gLFxuICAgIFszOCAvKiBFcnJvckNvZGVzLlhfVl9TTE9UX0RVUExJQ0FURV9TTE9UX05BTUVTICovXTogYER1cGxpY2F0ZSBzbG90IG5hbWVzIGZvdW5kLiBgLFxuICAgIFszOSAvKiBFcnJvckNvZGVzLlhfVl9TTE9UX0VYVFJBTkVPVVNfREVGQVVMVF9TTE9UX0NISUxEUkVOICovXTogYEV4dHJhbmVvdXMgY2hpbGRyZW4gZm91bmQgd2hlbiBjb21wb25lbnQgYWxyZWFkeSBoYXMgZXhwbGljaXRseSBuYW1lZCBgICtcbiAgICAgICAgYGRlZmF1bHQgc2xvdC4gVGhlc2UgY2hpbGRyZW4gd2lsbCBiZSBpZ25vcmVkLmAsXG4gICAgWzQwIC8qIEVycm9yQ29kZXMuWF9WX1NMT1RfTUlTUExBQ0VEICovXTogYHYtc2xvdCBjYW4gb25seSBiZSB1c2VkIG9uIGNvbXBvbmVudHMgb3IgPHRlbXBsYXRlPiB0YWdzLmAsXG4gICAgWzQxIC8qIEVycm9yQ29kZXMuWF9WX01PREVMX05PX0VYUFJFU1NJT04gKi9dOiBgdi1tb2RlbCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcbiAgICBbNDIgLyogRXJyb3JDb2Rlcy5YX1ZfTU9ERUxfTUFMRk9STUVEX0VYUFJFU1NJT04gKi9dOiBgdi1tb2RlbCB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgSmF2YVNjcmlwdCBtZW1iZXIgZXhwcmVzc2lvbi5gLFxuICAgIFs0MyAvKiBFcnJvckNvZGVzLlhfVl9NT0RFTF9PTl9TQ09QRV9WQVJJQUJMRSAqL106IGB2LW1vZGVsIGNhbm5vdCBiZSB1c2VkIG9uIHYtZm9yIG9yIHYtc2xvdCBzY29wZSB2YXJpYWJsZXMgYmVjYXVzZSB0aGV5IGFyZSBub3Qgd3JpdGFibGUuYCxcbiAgICBbNDQgLyogRXJyb3JDb2Rlcy5YX1ZfTU9ERUxfT05fUFJPUFMgKi9dOiBgdi1tb2RlbCBjYW5ub3QgYmUgdXNlZCBvbiBhIHByb3AsIGJlY2F1c2UgbG9jYWwgcHJvcCBiaW5kaW5ncyBhcmUgbm90IHdyaXRhYmxlLlxcblVzZSBhIHYtYmluZCBiaW5kaW5nIGNvbWJpbmVkIHdpdGggYSB2LW9uIGxpc3RlbmVyIHRoYXQgZW1pdHMgdXBkYXRlOnggZXZlbnQgaW5zdGVhZC5gLFxuICAgIFs0NSAvKiBFcnJvckNvZGVzLlhfSU5WQUxJRF9FWFBSRVNTSU9OICovXTogYEVycm9yIHBhcnNpbmcgSmF2YVNjcmlwdCBleHByZXNzaW9uOiBgLFxuICAgIFs0NiAvKiBFcnJvckNvZGVzLlhfS0VFUF9BTElWRV9JTlZBTElEX0NISUxEUkVOICovXTogYDxLZWVwQWxpdmU+IGV4cGVjdHMgZXhhY3RseSBvbmUgY2hpbGQgY29tcG9uZW50LmAsXG4gICAgLy8gZ2VuZXJpYyBlcnJvcnNcbiAgICBbNDcgLyogRXJyb3JDb2Rlcy5YX1BSRUZJWF9JRF9OT1RfU1VQUE9SVEVEICovXTogYFwicHJlZml4SWRlbnRpZmllcnNcIiBvcHRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJ1aWxkIG9mIGNvbXBpbGVyLmAsXG4gICAgWzQ4IC8qIEVycm9yQ29kZXMuWF9NT0RVTEVfTU9ERV9OT1RfU1VQUE9SVEVEICovXTogYEVTIG1vZHVsZSBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBjb21waWxlci5gLFxuICAgIFs0OSAvKiBFcnJvckNvZGVzLlhfQ0FDSEVfSEFORExFUl9OT1RfU1VQUE9SVEVEICovXTogYFwiY2FjaGVIYW5kbGVyc1wiIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCB3aGVuIHRoZSBcInByZWZpeElkZW50aWZpZXJzXCIgb3B0aW9uIGlzIGVuYWJsZWQuYCxcbiAgICBbNTAgLyogRXJyb3JDb2Rlcy5YX1NDT1BFX0lEX05PVF9TVVBQT1JURUQgKi9dOiBgXCJzY29wZUlkXCIgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGluIG1vZHVsZSBtb2RlLmAsXG4gICAgLy8ganVzdCB0byBmdWxmaWxsIHR5cGVzXG4gICAgWzUxIC8qIEVycm9yQ29kZXMuX19FWFRFTkRfUE9JTlRfXyAqL106IGBgXG59O1xuY29uc3QgRlJBR01FTlQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYEZyYWdtZW50YCA6IGBgKTtcbmV4cG9ydHMuRlJBR01FTlQgPSBGUkFHTUVOVDtcbmNvbnN0IFRFTEVQT1JUID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBUZWxlcG9ydGAgOiBgYCk7XG5leHBvcnRzLlRFTEVQT1JUID0gVEVMRVBPUlQ7XG5jb25zdCBTVVNQRU5TRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgU3VzcGVuc2VgIDogYGApO1xuZXhwb3J0cy5TVVNQRU5TRSA9IFNVU1BFTlNFO1xuY29uc3QgS0VFUF9BTElWRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgS2VlcEFsaXZlYCA6IGBgKTtcbmV4cG9ydHMuS0VFUF9BTElWRSA9IEtFRVBfQUxJVkU7XG5jb25zdCBCQVNFX1RSQU5TSVRJT04gPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYEJhc2VUcmFuc2l0aW9uYCA6IGBgKTtcbmV4cG9ydHMuQkFTRV9UUkFOU0lUSU9OID0gQkFTRV9UUkFOU0lUSU9OO1xuY29uc3QgT1BFTl9CTE9DSyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgb3BlbkJsb2NrYCA6IGBgKTtcbmV4cG9ydHMuT1BFTl9CTE9DSyA9IE9QRU5fQkxPQ0s7XG5jb25zdCBDUkVBVEVfQkxPQ0sgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZUJsb2NrYCA6IGBgKTtcbmV4cG9ydHMuQ1JFQVRFX0JMT0NLID0gQ1JFQVRFX0JMT0NLO1xuY29uc3QgQ1JFQVRFX0VMRU1FTlRfQkxPQ0sgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZUVsZW1lbnRCbG9ja2AgOiBgYCk7XG5leHBvcnRzLkNSRUFURV9FTEVNRU5UX0JMT0NLID0gQ1JFQVRFX0VMRU1FTlRfQkxPQ0s7XG5jb25zdCBDUkVBVEVfVk5PREUgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZVZOb2RlYCA6IGBgKTtcbmV4cG9ydHMuQ1JFQVRFX1ZOT0RFID0gQ1JFQVRFX1ZOT0RFO1xuY29uc3QgQ1JFQVRFX0VMRU1FTlRfVk5PREUgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZUVsZW1lbnRWTm9kZWAgOiBgYCk7XG5leHBvcnRzLkNSRUFURV9FTEVNRU5UX1ZOT0RFID0gQ1JFQVRFX0VMRU1FTlRfVk5PREU7XG5jb25zdCBDUkVBVEVfQ09NTUVOVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlQ29tbWVudFZOb2RlYCA6IGBgKTtcbmV4cG9ydHMuQ1JFQVRFX0NPTU1FTlQgPSBDUkVBVEVfQ09NTUVOVDtcbmNvbnN0IENSRUFURV9URVhUID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVUZXh0Vk5vZGVgIDogYGApO1xuZXhwb3J0cy5DUkVBVEVfVEVYVCA9IENSRUFURV9URVhUO1xuY29uc3QgQ1JFQVRFX1NUQVRJQyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlU3RhdGljVk5vZGVgIDogYGApO1xuZXhwb3J0cy5DUkVBVEVfU1RBVElDID0gQ1JFQVRFX1NUQVRJQztcbmNvbnN0IFJFU09MVkVfQ09NUE9ORU5UID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZXNvbHZlQ29tcG9uZW50YCA6IGBgKTtcbmV4cG9ydHMuUkVTT0xWRV9DT01QT05FTlQgPSBSRVNPTFZFX0NPTVBPTkVOVDtcbmNvbnN0IFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlc29sdmVEeW5hbWljQ29tcG9uZW50YCA6IGBgKTtcbmV4cG9ydHMuUkVTT0xWRV9EWU5BTUlDX0NPTVBPTkVOVCA9IFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQ7XG5jb25zdCBSRVNPTFZFX0RJUkVDVElWRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcmVzb2x2ZURpcmVjdGl2ZWAgOiBgYCk7XG5leHBvcnRzLlJFU09MVkVfRElSRUNUSVZFID0gUkVTT0xWRV9ESVJFQ1RJVkU7XG5jb25zdCBSRVNPTFZFX0ZJTFRFUiA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcmVzb2x2ZUZpbHRlcmAgOiBgYCk7XG5leHBvcnRzLlJFU09MVkVfRklMVEVSID0gUkVTT0xWRV9GSUxURVI7XG5jb25zdCBXSVRIX0RJUkVDVElWRVMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHdpdGhEaXJlY3RpdmVzYCA6IGBgKTtcbmV4cG9ydHMuV0lUSF9ESVJFQ1RJVkVTID0gV0lUSF9ESVJFQ1RJVkVTO1xuY29uc3QgUkVOREVSX0xJU1QgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlbmRlckxpc3RgIDogYGApO1xuZXhwb3J0cy5SRU5ERVJfTElTVCA9IFJFTkRFUl9MSVNUO1xuY29uc3QgUkVOREVSX1NMT1QgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlbmRlclNsb3RgIDogYGApO1xuZXhwb3J0cy5SRU5ERVJfU0xPVCA9IFJFTkRFUl9TTE9UO1xuY29uc3QgQ1JFQVRFX1NMT1RTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVTbG90c2AgOiBgYCk7XG5leHBvcnRzLkNSRUFURV9TTE9UUyA9IENSRUFURV9TTE9UUztcbmNvbnN0IFRPX0RJU1BMQVlfU1RSSU5HID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB0b0Rpc3BsYXlTdHJpbmdgIDogYGApO1xuZXhwb3J0cy5UT19ESVNQTEFZX1NUUklORyA9IFRPX0RJU1BMQVlfU1RSSU5HO1xuY29uc3QgTUVSR0VfUFJPUFMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYG1lcmdlUHJvcHNgIDogYGApO1xuZXhwb3J0cy5NRVJHRV9QUk9QUyA9IE1FUkdFX1BST1BTO1xuY29uc3QgTk9STUFMSVpFX0NMQVNTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBub3JtYWxpemVDbGFzc2AgOiBgYCk7XG5leHBvcnRzLk5PUk1BTElaRV9DTEFTUyA9IE5PUk1BTElaRV9DTEFTUztcbmNvbnN0IE5PUk1BTElaRV9TVFlMRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgbm9ybWFsaXplU3R5bGVgIDogYGApO1xuZXhwb3J0cy5OT1JNQUxJWkVfU1RZTEUgPSBOT1JNQUxJWkVfU1RZTEU7XG5jb25zdCBOT1JNQUxJWkVfUFJPUFMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYG5vcm1hbGl6ZVByb3BzYCA6IGBgKTtcbmV4cG9ydHMuTk9STUFMSVpFX1BST1BTID0gTk9STUFMSVpFX1BST1BTO1xuY29uc3QgR1VBUkRfUkVBQ1RJVkVfUFJPUFMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGd1YXJkUmVhY3RpdmVQcm9wc2AgOiBgYCk7XG5leHBvcnRzLkdVQVJEX1JFQUNUSVZFX1BST1BTID0gR1VBUkRfUkVBQ1RJVkVfUFJPUFM7XG5jb25zdCBUT19IQU5ETEVSUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdG9IYW5kbGVyc2AgOiBgYCk7XG5leHBvcnRzLlRPX0hBTkRMRVJTID0gVE9fSEFORExFUlM7XG5jb25zdCBDQU1FTElaRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY2FtZWxpemVgIDogYGApO1xuZXhwb3J0cy5DQU1FTElaRSA9IENBTUVMSVpFO1xuY29uc3QgQ0FQSVRBTElaRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY2FwaXRhbGl6ZWAgOiBgYCk7XG5leHBvcnRzLkNBUElUQUxJWkUgPSBDQVBJVEFMSVpFO1xuY29uc3QgVE9fSEFORExFUl9LRVkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHRvSGFuZGxlcktleWAgOiBgYCk7XG5leHBvcnRzLlRPX0hBTkRMRVJfS0VZID0gVE9fSEFORExFUl9LRVk7XG5jb25zdCBTRVRfQkxPQ0tfVFJBQ0tJTkcgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHNldEJsb2NrVHJhY2tpbmdgIDogYGApO1xuZXhwb3J0cy5TRVRfQkxPQ0tfVFJBQ0tJTkcgPSBTRVRfQkxPQ0tfVFJBQ0tJTkc7XG5jb25zdCBQVVNIX1NDT1BFX0lEID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBwdXNoU2NvcGVJZGAgOiBgYCk7XG5leHBvcnRzLlBVU0hfU0NPUEVfSUQgPSBQVVNIX1NDT1BFX0lEO1xuY29uc3QgUE9QX1NDT1BFX0lEID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBwb3BTY29wZUlkYCA6IGBgKTtcbmV4cG9ydHMuUE9QX1NDT1BFX0lEID0gUE9QX1NDT1BFX0lEO1xuY29uc3QgV0lUSF9DVFggPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHdpdGhDdHhgIDogYGApO1xuZXhwb3J0cy5XSVRIX0NUWCA9IFdJVEhfQ1RYO1xuY29uc3QgVU5SRUYgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHVucmVmYCA6IGBgKTtcbmV4cG9ydHMuVU5SRUYgPSBVTlJFRjtcbmNvbnN0IElTX1JFRiA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgaXNSZWZgIDogYGApO1xuZXhwb3J0cy5JU19SRUYgPSBJU19SRUY7XG5jb25zdCBXSVRIX01FTU8gPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHdpdGhNZW1vYCA6IGBgKTtcbmV4cG9ydHMuV0lUSF9NRU1PID0gV0lUSF9NRU1PO1xuY29uc3QgSVNfTUVNT19TQU1FID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBpc01lbW9TYW1lYCA6IGBgKTtcbmV4cG9ydHMuSVNfTUVNT19TQU1FID0gSVNfTUVNT19TQU1FO1xuLy8gTmFtZSBtYXBwaW5nIGZvciBydW50aW1lIGhlbHBlcnMgdGhhdCBuZWVkIHRvIGJlIGltcG9ydGVkIGZyb20gJ3Z1ZScgaW5cbi8vIGdlbmVyYXRlZCBjb2RlLiBNYWtlIHN1cmUgdGhlc2UgYXJlIGNvcnJlY3RseSBleHBvcnRlZCBpbiB0aGUgcnVudGltZSFcbmNvbnN0IGhlbHBlck5hbWVNYXAgPSB7XG4gICAgW0ZSQUdNRU5UXTogYEZyYWdtZW50YCxcbiAgICBbVEVMRVBPUlRdOiBgVGVsZXBvcnRgLFxuICAgIFtTVVNQRU5TRV06IGBTdXNwZW5zZWAsXG4gICAgW0tFRVBfQUxJVkVdOiBgS2VlcEFsaXZlYCxcbiAgICBbQkFTRV9UUkFOU0lUSU9OXTogYEJhc2VUcmFuc2l0aW9uYCxcbiAgICBbT1BFTl9CTE9DS106IGBvcGVuQmxvY2tgLFxuICAgIFtDUkVBVEVfQkxPQ0tdOiBgY3JlYXRlQmxvY2tgLFxuICAgIFtDUkVBVEVfRUxFTUVOVF9CTE9DS106IGBjcmVhdGVFbGVtZW50QmxvY2tgLFxuICAgIFtDUkVBVEVfVk5PREVdOiBgY3JlYXRlVk5vZGVgLFxuICAgIFtDUkVBVEVfRUxFTUVOVF9WTk9ERV06IGBjcmVhdGVFbGVtZW50Vk5vZGVgLFxuICAgIFtDUkVBVEVfQ09NTUVOVF06IGBjcmVhdGVDb21tZW50Vk5vZGVgLFxuICAgIFtDUkVBVEVfVEVYVF06IGBjcmVhdGVUZXh0Vk5vZGVgLFxuICAgIFtDUkVBVEVfU1RBVElDXTogYGNyZWF0ZVN0YXRpY1ZOb2RlYCxcbiAgICBbUkVTT0xWRV9DT01QT05FTlRdOiBgcmVzb2x2ZUNvbXBvbmVudGAsXG4gICAgW1JFU09MVkVfRFlOQU1JQ19DT01QT05FTlRdOiBgcmVzb2x2ZUR5bmFtaWNDb21wb25lbnRgLFxuICAgIFtSRVNPTFZFX0RJUkVDVElWRV06IGByZXNvbHZlRGlyZWN0aXZlYCxcbiAgICBbUkVTT0xWRV9GSUxURVJdOiBgcmVzb2x2ZUZpbHRlcmAsXG4gICAgW1dJVEhfRElSRUNUSVZFU106IGB3aXRoRGlyZWN0aXZlc2AsXG4gICAgW1JFTkRFUl9MSVNUXTogYHJlbmRlckxpc3RgLFxuICAgIFtSRU5ERVJfU0xPVF06IGByZW5kZXJTbG90YCxcbiAgICBbQ1JFQVRFX1NMT1RTXTogYGNyZWF0ZVNsb3RzYCxcbiAgICBbVE9fRElTUExBWV9TVFJJTkddOiBgdG9EaXNwbGF5U3RyaW5nYCxcbiAgICBbTUVSR0VfUFJPUFNdOiBgbWVyZ2VQcm9wc2AsXG4gICAgW05PUk1BTElaRV9DTEFTU106IGBub3JtYWxpemVDbGFzc2AsXG4gICAgW05PUk1BTElaRV9TVFlMRV06IGBub3JtYWxpemVTdHlsZWAsXG4gICAgW05PUk1BTElaRV9QUk9QU106IGBub3JtYWxpemVQcm9wc2AsXG4gICAgW0dVQVJEX1JFQUNUSVZFX1BST1BTXTogYGd1YXJkUmVhY3RpdmVQcm9wc2AsXG4gICAgW1RPX0hBTkRMRVJTXTogYHRvSGFuZGxlcnNgLFxuICAgIFtDQU1FTElaRV06IGBjYW1lbGl6ZWAsXG4gICAgW0NBUElUQUxJWkVdOiBgY2FwaXRhbGl6ZWAsXG4gICAgW1RPX0hBTkRMRVJfS0VZXTogYHRvSGFuZGxlcktleWAsXG4gICAgW1NFVF9CTE9DS19UUkFDS0lOR106IGBzZXRCbG9ja1RyYWNraW5nYCxcbiAgICBbUFVTSF9TQ09QRV9JRF06IGBwdXNoU2NvcGVJZGAsXG4gICAgW1BPUF9TQ09QRV9JRF06IGBwb3BTY29wZUlkYCxcbiAgICBbV0lUSF9DVFhdOiBgd2l0aEN0eGAsXG4gICAgW1VOUkVGXTogYHVucmVmYCxcbiAgICBbSVNfUkVGXTogYGlzUmVmYCxcbiAgICBbV0lUSF9NRU1PXTogYHdpdGhNZW1vYCxcbiAgICBbSVNfTUVNT19TQU1FXTogYGlzTWVtb1NhbWVgXG59O1xuZXhwb3J0cy5oZWxwZXJOYW1lTWFwID0gaGVscGVyTmFtZU1hcDtcbmZ1bmN0aW9uIHJlZ2lzdGVyUnVudGltZUhlbHBlcnMoaGVscGVycykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaGVscGVycykuZm9yRWFjaChzID0+IHtcbiAgICAgICAgaGVscGVyTmFtZU1hcFtzXSA9IGhlbHBlcnNbc107XG4gICAgfSk7XG59XG5leHBvcnRzLnJlZ2lzdGVyUnVudGltZUhlbHBlcnMgPSByZWdpc3RlclJ1bnRpbWVIZWxwZXJzO1xuLy8gQVNUIFV0aWxpdGllcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFNvbWUgZXhwcmVzc2lvbnMsIGUuZy4gc2VxdWVuY2UgYW5kIGNvbmRpdGlvbmFsIGV4cHJlc3Npb25zLCBhcmUgbmV2ZXJcbi8vIGFzc29jaWF0ZWQgd2l0aCB0ZW1wbGF0ZSBub2Rlcywgc28gdGhlaXIgc291cmNlIGxvY2F0aW9ucyBhcmUganVzdCBhIHN0dWIuXG4vLyBDb250YWluZXIgdHlwZXMgbGlrZSBDb21wb3VuZEV4cHJlc3Npb24gYWxzbyBkb24ndCBuZWVkIGEgcmVhbCBsb2NhdGlvbi5cbmNvbnN0IGxvY1N0dWIgPSB7XG4gICAgc291cmNlOiAnJyxcbiAgICBzdGFydDogeyBsaW5lOiAxLCBjb2x1bW46IDEsIG9mZnNldDogMCB9LFxuICAgIGVuZDogeyBsaW5lOiAxLCBjb2x1bW46IDEsIG9mZnNldDogMCB9XG59O1xuZXhwb3J0cy5sb2NTdHViID0gbG9jU3R1YjtcbmZ1bmN0aW9uIGNyZWF0ZVJvb3QoY2hpbGRyZW4sIGxvYyA9IGxvY1N0dWIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAwIC8qIE5vZGVUeXBlcy5ST09UICovLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgaGVscGVyczogbmV3IFNldCgpLFxuICAgICAgICBjb21wb25lbnRzOiBbXSxcbiAgICAgICAgZGlyZWN0aXZlczogW10sXG4gICAgICAgIGhvaXN0czogW10sXG4gICAgICAgIGltcG9ydHM6IFtdLFxuICAgICAgICBjYWNoZWQ6IDAsXG4gICAgICAgIHRlbXBzOiAwLFxuICAgICAgICBjb2RlZ2VuTm9kZTogdW5kZWZpbmVkLFxuICAgICAgICBsb2NcbiAgICB9O1xufVxuZXhwb3J0cy5jcmVhdGVSb290ID0gY3JlYXRlUm9vdDtcbmZ1bmN0aW9uIGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCB0YWcsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIGRpcmVjdGl2ZXMsIGlzQmxvY2sgPSBmYWxzZSwgZGlzYWJsZVRyYWNraW5nID0gZmFsc2UsIGlzQ29tcG9uZW50ID0gZmFsc2UsIGxvYyA9IGxvY1N0dWIpIHtcbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgICBpZiAoaXNCbG9jaykge1xuICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoT1BFTl9CTE9DSyk7XG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihnZXRWTm9kZUJsb2NrSGVscGVyKGNvbnRleHQuaW5TU1IsIGlzQ29tcG9uZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihnZXRWTm9kZUhlbHBlcihjb250ZXh0LmluU1NSLCBpc0NvbXBvbmVudCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJlY3RpdmVzKSB7XG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihXSVRIX0RJUkVDVElWRVMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDEzIC8qIE5vZGVUeXBlcy5WTk9ERV9DQUxMICovLFxuICAgICAgICB0YWcsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgcGF0Y2hGbGFnLFxuICAgICAgICBkeW5hbWljUHJvcHMsXG4gICAgICAgIGRpcmVjdGl2ZXMsXG4gICAgICAgIGlzQmxvY2ssXG4gICAgICAgIGRpc2FibGVUcmFja2luZyxcbiAgICAgICAgaXNDb21wb25lbnQsXG4gICAgICAgIGxvY1xuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZVZOb2RlQ2FsbCA9IGNyZWF0ZVZOb2RlQ2FsbDtcbmZ1bmN0aW9uIGNyZWF0ZUFycmF5RXhwcmVzc2lvbihlbGVtZW50cywgbG9jID0gbG9jU3R1Yikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDE3IC8qIE5vZGVUeXBlcy5KU19BUlJBWV9FWFBSRVNTSU9OICovLFxuICAgICAgICBsb2MsXG4gICAgICAgIGVsZW1lbnRzXG4gICAgfTtcbn1cbmV4cG9ydHMuY3JlYXRlQXJyYXlFeHByZXNzaW9uID0gY3JlYXRlQXJyYXlFeHByZXNzaW9uO1xuZnVuY3Rpb24gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihwcm9wZXJ0aWVzLCBsb2MgPSBsb2NTdHViKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMTUgLyogTm9kZVR5cGVzLkpTX09CSkVDVF9FWFBSRVNTSU9OICovLFxuICAgICAgICBsb2MsXG4gICAgICAgIHByb3BlcnRpZXNcbiAgICB9O1xufVxuZXhwb3J0cy5jcmVhdGVPYmplY3RFeHByZXNzaW9uID0gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbjtcbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdFByb3BlcnR5KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAxNiAvKiBOb2RlVHlwZXMuSlNfUFJPUEVSVFkgKi8sXG4gICAgICAgIGxvYzogbG9jU3R1YixcbiAgICAgICAga2V5OiAoMCwgc2hhcmVkXzEuaXNTdHJpbmcpKGtleSkgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGtleSwgdHJ1ZSkgOiBrZXksXG4gICAgICAgIHZhbHVlXG4gICAgfTtcbn1cbmV4cG9ydHMuY3JlYXRlT2JqZWN0UHJvcGVydHkgPSBjcmVhdGVPYmplY3RQcm9wZXJ0eTtcbmZ1bmN0aW9uIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oY29udGVudCwgaXNTdGF0aWMgPSBmYWxzZSwgbG9jID0gbG9jU3R1YiwgY29uc3RUeXBlID0gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovLFxuICAgICAgICBsb2MsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGlzU3RhdGljLFxuICAgICAgICBjb25zdFR5cGU6IGlzU3RhdGljID8gMyAvKiBDb25zdGFudFR5cGVzLkNBTl9TVFJJTkdJRlkgKi8gOiBjb25zdFR5cGVcbiAgICB9O1xufVxuZXhwb3J0cy5jcmVhdGVTaW1wbGVFeHByZXNzaW9uID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbjtcbmZ1bmN0aW9uIGNyZWF0ZUludGVycG9sYXRpb24oY29udGVudCwgbG9jKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogNSAvKiBOb2RlVHlwZXMuSU5URVJQT0xBVElPTiAqLyxcbiAgICAgICAgbG9jLFxuICAgICAgICBjb250ZW50OiAoMCwgc2hhcmVkXzEuaXNTdHJpbmcpKGNvbnRlbnQpXG4gICAgICAgICAgICA/IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oY29udGVudCwgZmFsc2UsIGxvYylcbiAgICAgICAgICAgIDogY29udGVudFxuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZUludGVycG9sYXRpb24gPSBjcmVhdGVJbnRlcnBvbGF0aW9uO1xuZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKGNoaWxkcmVuLCBsb2MgPSBsb2NTdHViKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogOCAvKiBOb2RlVHlwZXMuQ09NUE9VTkRfRVhQUkVTU0lPTiAqLyxcbiAgICAgICAgbG9jLFxuICAgICAgICBjaGlsZHJlblxuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbiA9IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbjtcbmZ1bmN0aW9uIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNhbGxlZSwgYXJncyA9IFtdLCBsb2MgPSBsb2NTdHViKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMTQgLyogTm9kZVR5cGVzLkpTX0NBTExfRVhQUkVTU0lPTiAqLyxcbiAgICAgICAgbG9jLFxuICAgICAgICBjYWxsZWUsXG4gICAgICAgIGFyZ3VtZW50czogYXJnc1xuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZUNhbGxFeHByZXNzaW9uID0gY3JlYXRlQ2FsbEV4cHJlc3Npb247XG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24ocGFyYW1zLCByZXR1cm5zID0gdW5kZWZpbmVkLCBuZXdsaW5lID0gZmFsc2UsIGlzU2xvdCA9IGZhbHNlLCBsb2MgPSBsb2NTdHViKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMTggLyogTm9kZVR5cGVzLkpTX0ZVTkNUSU9OX0VYUFJFU1NJT04gKi8sXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcmV0dXJucyxcbiAgICAgICAgbmV3bGluZSxcbiAgICAgICAgaXNTbG90LFxuICAgICAgICBsb2NcbiAgICB9O1xufVxuZXhwb3J0cy5jcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24gPSBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb247XG5mdW5jdGlvbiBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24odGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlLCBuZXdsaW5lID0gdHJ1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDE5IC8qIE5vZGVUeXBlcy5KU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovLFxuICAgICAgICB0ZXN0LFxuICAgICAgICBjb25zZXF1ZW50LFxuICAgICAgICBhbHRlcm5hdGUsXG4gICAgICAgIG5ld2xpbmUsXG4gICAgICAgIGxvYzogbG9jU3R1YlxuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbjtcbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlRXhwcmVzc2lvbihpbmRleCwgdmFsdWUsIGlzVk5vZGUgPSBmYWxzZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDIwIC8qIE5vZGVUeXBlcy5KU19DQUNIRV9FWFBSRVNTSU9OICovLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGlzVk5vZGUsXG4gICAgICAgIGxvYzogbG9jU3R1YlxuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZUNhY2hlRXhwcmVzc2lvbiA9IGNyZWF0ZUNhY2hlRXhwcmVzc2lvbjtcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrU3RhdGVtZW50KGJvZHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAyMSAvKiBOb2RlVHlwZXMuSlNfQkxPQ0tfU1RBVEVNRU5UICovLFxuICAgICAgICBib2R5LFxuICAgICAgICBsb2M6IGxvY1N0dWJcbiAgICB9O1xufVxuZXhwb3J0cy5jcmVhdGVCbG9ja1N0YXRlbWVudCA9IGNyZWF0ZUJsb2NrU3RhdGVtZW50O1xuZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGVMaXRlcmFsKGVsZW1lbnRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMjIgLyogTm9kZVR5cGVzLkpTX1RFTVBMQVRFX0xJVEVSQUwgKi8sXG4gICAgICAgIGVsZW1lbnRzLFxuICAgICAgICBsb2M6IGxvY1N0dWJcbiAgICB9O1xufVxuZXhwb3J0cy5jcmVhdGVUZW1wbGF0ZUxpdGVyYWwgPSBjcmVhdGVUZW1wbGF0ZUxpdGVyYWw7XG5mdW5jdGlvbiBjcmVhdGVJZlN0YXRlbWVudCh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAyMyAvKiBOb2RlVHlwZXMuSlNfSUZfU1RBVEVNRU5UICovLFxuICAgICAgICB0ZXN0LFxuICAgICAgICBjb25zZXF1ZW50LFxuICAgICAgICBhbHRlcm5hdGUsXG4gICAgICAgIGxvYzogbG9jU3R1YlxuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZUlmU3RhdGVtZW50ID0gY3JlYXRlSWZTdGF0ZW1lbnQ7XG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbihsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDI0IC8qIE5vZGVUeXBlcy5KU19BU1NJR05NRU5UX0VYUFJFU1NJT04gKi8sXG4gICAgICAgIGxlZnQsXG4gICAgICAgIHJpZ2h0LFxuICAgICAgICBsb2M6IGxvY1N0dWJcbiAgICB9O1xufVxuZXhwb3J0cy5jcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbiA9IGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uO1xuZnVuY3Rpb24gY3JlYXRlU2VxdWVuY2VFeHByZXNzaW9uKGV4cHJlc3Npb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMjUgLyogTm9kZVR5cGVzLkpTX1NFUVVFTkNFX0VYUFJFU1NJT04gKi8sXG4gICAgICAgIGV4cHJlc3Npb25zLFxuICAgICAgICBsb2M6IGxvY1N0dWJcbiAgICB9O1xufVxuZXhwb3J0cy5jcmVhdGVTZXF1ZW5jZUV4cHJlc3Npb24gPSBjcmVhdGVTZXF1ZW5jZUV4cHJlc3Npb247XG5mdW5jdGlvbiBjcmVhdGVSZXR1cm5TdGF0ZW1lbnQocmV0dXJucykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDI2IC8qIE5vZGVUeXBlcy5KU19SRVRVUk5fU1RBVEVNRU5UICovLFxuICAgICAgICByZXR1cm5zLFxuICAgICAgICBsb2M6IGxvY1N0dWJcbiAgICB9O1xufVxuZXhwb3J0cy5jcmVhdGVSZXR1cm5TdGF0ZW1lbnQgPSBjcmVhdGVSZXR1cm5TdGF0ZW1lbnQ7XG5jb25zdCBpc1N0YXRpY0V4cCA9IChwKSA9PiBwLnR5cGUgPT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovICYmIHAuaXNTdGF0aWM7XG5leHBvcnRzLmlzU3RhdGljRXhwID0gaXNTdGF0aWNFeHA7XG5jb25zdCBpc0J1aWx0SW5UeXBlID0gKHRhZywgZXhwZWN0ZWQpID0+IHRhZyA9PT0gZXhwZWN0ZWQgfHwgdGFnID09PSAoMCwgc2hhcmVkXzEuaHlwaGVuYXRlKShleHBlY3RlZCk7XG5leHBvcnRzLmlzQnVpbHRJblR5cGUgPSBpc0J1aWx0SW5UeXBlO1xuZnVuY3Rpb24gaXNDb3JlQ29tcG9uZW50KHRhZykge1xuICAgIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgJ1RlbGVwb3J0JykpIHtcbiAgICAgICAgcmV0dXJuIFRFTEVQT1JUO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgJ1N1c3BlbnNlJykpIHtcbiAgICAgICAgcmV0dXJuIFNVU1BFTlNFO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgJ0tlZXBBbGl2ZScpKSB7XG4gICAgICAgIHJldHVybiBLRUVQX0FMSVZFO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgJ0Jhc2VUcmFuc2l0aW9uJykpIHtcbiAgICAgICAgcmV0dXJuIEJBU0VfVFJBTlNJVElPTjtcbiAgICB9XG59XG5leHBvcnRzLmlzQ29yZUNvbXBvbmVudCA9IGlzQ29yZUNvbXBvbmVudDtcbmNvbnN0IG5vbklkZW50aWZpZXJSRSA9IC9eXFxkfFteXFwkXFx3XS87XG5jb25zdCBpc1NpbXBsZUlkZW50aWZpZXIgPSAobmFtZSkgPT4gIW5vbklkZW50aWZpZXJSRS50ZXN0KG5hbWUpO1xuZXhwb3J0cy5pc1NpbXBsZUlkZW50aWZpZXIgPSBpc1NpbXBsZUlkZW50aWZpZXI7XG5jb25zdCB2YWxpZEZpcnN0SWRlbnRDaGFyUkUgPSAvW0EtWmEtel8kXFx4QTAtXFx1RkZGRl0vO1xuY29uc3QgdmFsaWRJZGVudENoYXJSRSA9IC9bXFwuXFw/XFx3JFxceEEwLVxcdUZGRkZdLztcbmNvbnN0IHdoaXRlc3BhY2VSRSA9IC9cXHMrWy5bXVxccyp8XFxzKlsuW11cXHMrL2c7XG4vKipcbiAqIFNpbXBsZSBsZXhlciB0byBjaGVjayBpZiBhbiBleHByZXNzaW9uIGlzIGEgbWVtYmVyIGV4cHJlc3Npb24uIFRoaXMgaXNcbiAqIGxheCBhbmQgb25seSBjaGVja3MgdmFsaWRpdHkgYXQgdGhlIHJvb3QgbGV2ZWwgKGkuZS4gZG9lcyBub3QgdmFsaWRhdGUgZXhwc1xuICogaW5zaWRlIHNxdWFyZSBicmFja2V0cyksIGJ1dCBpdCdzIG9rIHNpbmNlIHRoZXNlIGFyZSBvbmx5IHVzZWQgb24gdGVtcGxhdGVcbiAqIGV4cHJlc3Npb25zIGFuZCBmYWxzZSBwb3NpdGl2ZXMgYXJlIGludmFsaWQgZXhwcmVzc2lvbnMgaW4gdGhlIGZpcnN0IHBsYWNlLlxuICovXG5jb25zdCBpc01lbWJlckV4cHJlc3Npb25Ccm93c2VyID0gKHBhdGgpID0+IHtcbiAgICAvLyByZW1vdmUgd2hpdGVzcGFjZXMgYXJvdW5kIC4gb3IgWyBmaXJzdFxuICAgIHBhdGggPSBwYXRoLnRyaW0oKS5yZXBsYWNlKHdoaXRlc3BhY2VSRSwgcyA9PiBzLnRyaW0oKSk7XG4gICAgbGV0IHN0YXRlID0gMCAvKiBNZW1iZXJFeHBMZXhTdGF0ZS5pbk1lbWJlckV4cCAqLztcbiAgICBsZXQgc3RhdGVTdGFjayA9IFtdO1xuICAgIGxldCBjdXJyZW50T3BlbkJyYWNrZXRDb3VudCA9IDA7XG4gICAgbGV0IGN1cnJlbnRPcGVuUGFyZW5zQ291bnQgPSAwO1xuICAgIGxldCBjdXJyZW50U3RyaW5nVHlwZSA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSBwYXRoLmNoYXJBdChpKTtcbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIE1lbWJlckV4cExleFN0YXRlLmluTWVtYmVyRXhwICovOlxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVTdGFjay5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAxIC8qIE1lbWJlckV4cExleFN0YXRlLmluQnJhY2tldHMgKi87XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPcGVuQnJhY2tldENvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09ICcoJykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZVN0YWNrLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDIgLyogTWVtYmVyRXhwTGV4U3RhdGUuaW5QYXJlbnMgKi87XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPcGVuUGFyZW5zQ291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIShpID09PSAwID8gdmFsaWRGaXJzdElkZW50Q2hhclJFIDogdmFsaWRJZGVudENoYXJSRSkudGVzdChjaGFyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxIC8qIE1lbWJlckV4cExleFN0YXRlLmluQnJhY2tldHMgKi86XG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09IGAnYCB8fCBjaGFyID09PSBgXCJgIHx8IGNoYXIgPT09ICdgJykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZVN0YWNrLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDMgLyogTWVtYmVyRXhwTGV4U3RhdGUuaW5TdHJpbmcgKi87XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHJpbmdUeXBlID0gY2hhcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gYFtgKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPcGVuQnJhY2tldENvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IGBdYCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIS0tY3VycmVudE9wZW5CcmFja2V0Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhdGVTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMiAvKiBNZW1iZXJFeHBMZXhTdGF0ZS5pblBhcmVucyAqLzpcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gYCdgIHx8IGNoYXIgPT09IGBcImAgfHwgY2hhciA9PT0gJ2AnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlU3RhY2sucHVzaChzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMyAvKiBNZW1iZXJFeHBMZXhTdGF0ZS5pblN0cmluZyAqLztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0cmluZ1R5cGUgPSBjaGFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSBgKGApIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE9wZW5QYXJlbnNDb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSBgKWApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGV4cCBlbmRzIGFzIGEgY2FsbCB0aGVuIGl0IHNob3VsZCBub3QgYmUgY29uc2lkZXJlZCB2YWxpZFxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gcGF0aC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEtLWN1cnJlbnRPcGVuUGFyZW5zQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhdGVTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMyAvKiBNZW1iZXJFeHBMZXhTdGF0ZS5pblN0cmluZyAqLzpcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gY3VycmVudFN0cmluZ1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RyaW5nVHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhY3VycmVudE9wZW5CcmFja2V0Q291bnQgJiYgIWN1cnJlbnRPcGVuUGFyZW5zQ291bnQ7XG59O1xuZXhwb3J0cy5pc01lbWJlckV4cHJlc3Npb25Ccm93c2VyID0gaXNNZW1iZXJFeHByZXNzaW9uQnJvd3NlcjtcbmNvbnN0IGlzTWVtYmVyRXhwcmVzc2lvbk5vZGUgPSBzaGFyZWRfMS5OT09QO1xuZXhwb3J0cy5pc01lbWJlckV4cHJlc3Npb25Ob2RlID0gaXNNZW1iZXJFeHByZXNzaW9uTm9kZTtcbmNvbnN0IGlzTWVtYmVyRXhwcmVzc2lvbiA9IGlzTWVtYmVyRXhwcmVzc2lvbkJyb3dzZXI7XG5leHBvcnRzLmlzTWVtYmVyRXhwcmVzc2lvbiA9IGlzTWVtYmVyRXhwcmVzc2lvbjtcbmZ1bmN0aW9uIGdldElubmVyUmFuZ2UobG9jLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIGNvbnN0IHNvdXJjZSA9IGxvYy5zb3VyY2Uuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgIGNvbnN0IG5ld0xvYyA9IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICBzdGFydDogYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lKGxvYy5zdGFydCwgbG9jLnNvdXJjZSwgb2Zmc2V0KSxcbiAgICAgICAgZW5kOiBsb2MuZW5kXG4gICAgfTtcbiAgICBpZiAobGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgbmV3TG9jLmVuZCA9IGFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZShsb2Muc3RhcnQsIGxvYy5zb3VyY2UsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBuZXdMb2M7XG59XG5leHBvcnRzLmdldElubmVyUmFuZ2UgPSBnZXRJbm5lclJhbmdlO1xuZnVuY3Rpb24gYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lKHBvcywgc291cmNlLCBudW1iZXJPZkNoYXJhY3RlcnMgPSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbigoMCwgc2hhcmVkXzEuZXh0ZW5kKSh7fSwgcG9zKSwgc291cmNlLCBudW1iZXJPZkNoYXJhY3RlcnMpO1xufVxuZXhwb3J0cy5hZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUgPSBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmU7XG4vLyBhZHZhbmNlIGJ5IG11dGF0aW9uIHdpdGhvdXQgY2xvbmluZyAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpLCBzaW5jZSB0aGlzXG4vLyBnZXRzIGNhbGxlZCBhIGxvdCBpbiB0aGUgcGFyc2VyXG5mdW5jdGlvbiBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24ocG9zLCBzb3VyY2UsIG51bWJlck9mQ2hhcmFjdGVycyA9IHNvdXJjZS5sZW5ndGgpIHtcbiAgICBsZXQgbGluZXNDb3VudCA9IDA7XG4gICAgbGV0IGxhc3ROZXdMaW5lUG9zID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkNoYXJhY3RlcnM7IGkrKykge1xuICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaSkgPT09IDEwIC8qIG5ld2xpbmUgY2hhciBjb2RlICovKSB7XG4gICAgICAgICAgICBsaW5lc0NvdW50Kys7XG4gICAgICAgICAgICBsYXN0TmV3TGluZVBvcyA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcG9zLm9mZnNldCArPSBudW1iZXJPZkNoYXJhY3RlcnM7XG4gICAgcG9zLmxpbmUgKz0gbGluZXNDb3VudDtcbiAgICBwb3MuY29sdW1uID1cbiAgICAgICAgbGFzdE5ld0xpbmVQb3MgPT09IC0xXG4gICAgICAgICAgICA/IHBvcy5jb2x1bW4gKyBudW1iZXJPZkNoYXJhY3RlcnNcbiAgICAgICAgICAgIDogbnVtYmVyT2ZDaGFyYWN0ZXJzIC0gbGFzdE5ld0xpbmVQb3M7XG4gICAgcmV0dXJuIHBvcztcbn1cbmV4cG9ydHMuYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uID0gYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uO1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCBgdW5leHBlY3RlZCBjb21waWxlciBjb25kaXRpb25gKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbmZ1bmN0aW9uIGZpbmREaXIobm9kZSwgbmFtZSwgYWxsb3dFbXB0eSA9IGZhbHNlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xuICAgICAgICBpZiAocC50eXBlID09PSA3IC8qIE5vZGVUeXBlcy5ESVJFQ1RJVkUgKi8gJiZcbiAgICAgICAgICAgIChhbGxvd0VtcHR5IHx8IHAuZXhwKSAmJlxuICAgICAgICAgICAgKCgwLCBzaGFyZWRfMS5pc1N0cmluZykobmFtZSkgPyBwLm5hbWUgPT09IG5hbWUgOiBuYW1lLnRlc3QocC5uYW1lKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5maW5kRGlyID0gZmluZERpcjtcbmZ1bmN0aW9uIGZpbmRQcm9wKG5vZGUsIG5hbWUsIGR5bmFtaWNPbmx5ID0gZmFsc2UsIGFsbG93RW1wdHkgPSBmYWxzZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcbiAgICAgICAgaWYgKHAudHlwZSA9PT0gNiAvKiBOb2RlVHlwZXMuQVRUUklCVVRFICovKSB7XG4gICAgICAgICAgICBpZiAoZHluYW1pY09ubHkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocC5uYW1lID09PSBuYW1lICYmIChwLnZhbHVlIHx8IGFsbG93RW1wdHkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocC5uYW1lID09PSAnYmluZCcgJiZcbiAgICAgICAgICAgIChwLmV4cCB8fCBhbGxvd0VtcHR5KSAmJlxuICAgICAgICAgICAgaXNTdGF0aWNBcmdPZihwLmFyZywgbmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5maW5kUHJvcCA9IGZpbmRQcm9wO1xuZnVuY3Rpb24gaXNTdGF0aWNBcmdPZihhcmcsIG5hbWUpIHtcbiAgICByZXR1cm4gISEoYXJnICYmIGlzU3RhdGljRXhwKGFyZykgJiYgYXJnLmNvbnRlbnQgPT09IG5hbWUpO1xufVxuZXhwb3J0cy5pc1N0YXRpY0FyZ09mID0gaXNTdGF0aWNBcmdPZjtcbmZ1bmN0aW9uIGhhc0R5bmFtaWNLZXlWQmluZChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUucHJvcHMuc29tZShwID0+IHAudHlwZSA9PT0gNyAvKiBOb2RlVHlwZXMuRElSRUNUSVZFICovICYmXG4gICAgICAgIHAubmFtZSA9PT0gJ2JpbmQnICYmXG4gICAgICAgICghcC5hcmcgfHwgLy8gdi1iaW5kPVwib2JqXCJcbiAgICAgICAgICAgIHAuYXJnLnR5cGUgIT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovIHx8IC8vIHYtYmluZDpbX2N0eC5mb29dXG4gICAgICAgICAgICAhcC5hcmcuaXNTdGF0aWMpIC8vIHYtYmluZDpbZm9vXVxuICAgICk7XG59XG5leHBvcnRzLmhhc0R5bmFtaWNLZXlWQmluZCA9IGhhc0R5bmFtaWNLZXlWQmluZDtcbmZ1bmN0aW9uIGlzVGV4dCQxKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSA1IC8qIE5vZGVUeXBlcy5JTlRFUlBPTEFUSU9OICovIHx8IG5vZGUudHlwZSA9PT0gMiAvKiBOb2RlVHlwZXMuVEVYVCAqLztcbn1cbmV4cG9ydHMuaXNUZXh0ID0gaXNUZXh0JDE7XG5mdW5jdGlvbiBpc1ZTbG90KHApIHtcbiAgICByZXR1cm4gcC50eXBlID09PSA3IC8qIE5vZGVUeXBlcy5ESVJFQ1RJVkUgKi8gJiYgcC5uYW1lID09PSAnc2xvdCc7XG59XG5leHBvcnRzLmlzVlNsb3QgPSBpc1ZTbG90O1xuZnVuY3Rpb24gaXNUZW1wbGF0ZU5vZGUobm9kZSkge1xuICAgIHJldHVybiAobm9kZS50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovICYmIG5vZGUudGFnVHlwZSA9PT0gMyAvKiBFbGVtZW50VHlwZXMuVEVNUExBVEUgKi8pO1xufVxuZXhwb3J0cy5pc1RlbXBsYXRlTm9kZSA9IGlzVGVtcGxhdGVOb2RlO1xuZnVuY3Rpb24gaXNTbG90T3V0bGV0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovICYmIG5vZGUudGFnVHlwZSA9PT0gMiAvKiBFbGVtZW50VHlwZXMuU0xPVCAqLztcbn1cbmV4cG9ydHMuaXNTbG90T3V0bGV0ID0gaXNTbG90T3V0bGV0O1xuZnVuY3Rpb24gZ2V0Vk5vZGVIZWxwZXIoc3NyLCBpc0NvbXBvbmVudCkge1xuICAgIHJldHVybiBzc3IgfHwgaXNDb21wb25lbnQgPyBDUkVBVEVfVk5PREUgOiBDUkVBVEVfRUxFTUVOVF9WTk9ERTtcbn1cbmV4cG9ydHMuZ2V0Vk5vZGVIZWxwZXIgPSBnZXRWTm9kZUhlbHBlcjtcbmZ1bmN0aW9uIGdldFZOb2RlQmxvY2tIZWxwZXIoc3NyLCBpc0NvbXBvbmVudCkge1xuICAgIHJldHVybiBzc3IgfHwgaXNDb21wb25lbnQgPyBDUkVBVEVfQkxPQ0sgOiBDUkVBVEVfRUxFTUVOVF9CTE9DSztcbn1cbmV4cG9ydHMuZ2V0Vk5vZGVCbG9ja0hlbHBlciA9IGdldFZOb2RlQmxvY2tIZWxwZXI7XG5jb25zdCBwcm9wc0hlbHBlclNldCA9IG5ldyBTZXQoW05PUk1BTElaRV9QUk9QUywgR1VBUkRfUkVBQ1RJVkVfUFJPUFNdKTtcbmZ1bmN0aW9uIGdldFVubm9ybWFsaXplZFByb3BzKHByb3BzLCBjYWxsUGF0aCA9IFtdKSB7XG4gICAgaWYgKHByb3BzICYmXG4gICAgICAgICEoMCwgc2hhcmVkXzEuaXNTdHJpbmcpKHByb3BzKSAmJlxuICAgICAgICBwcm9wcy50eXBlID09PSAxNCAvKiBOb2RlVHlwZXMuSlNfQ0FMTF9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgIGNvbnN0IGNhbGxlZSA9IHByb3BzLmNhbGxlZTtcbiAgICAgICAgaWYgKCEoMCwgc2hhcmVkXzEuaXNTdHJpbmcpKGNhbGxlZSkgJiYgcHJvcHNIZWxwZXJTZXQuaGFzKGNhbGxlZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRVbm5vcm1hbGl6ZWRQcm9wcyhwcm9wcy5hcmd1bWVudHNbMF0sIGNhbGxQYXRoLmNvbmNhdChwcm9wcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbcHJvcHMsIGNhbGxQYXRoXTtcbn1cbmZ1bmN0aW9uIGluamVjdFByb3Aobm9kZSwgcHJvcCwgY29udGV4dCkge1xuICAgIGxldCBwcm9wc1dpdGhJbmplY3Rpb247XG4gICAgLyoqXG4gICAgICogMS4gbWVyZ2VQcm9wcyguLi4pXG4gICAgICogMi4gdG9IYW5kbGVycyguLi4pXG4gICAgICogMy4gbm9ybWFsaXplUHJvcHMoLi4uKVxuICAgICAqIDQuIG5vcm1hbGl6ZVByb3BzKGd1YXJkUmVhY3RpdmVQcm9wcyguLi4pKVxuICAgICAqXG4gICAgICogd2UgbmVlZCB0byBnZXQgdGhlIHJlYWwgcHJvcHMgYmVmb3JlIG5vcm1hbGl6YXRpb25cbiAgICAgKi9cbiAgICBsZXQgcHJvcHMgPSBub2RlLnR5cGUgPT09IDEzIC8qIE5vZGVUeXBlcy5WTk9ERV9DQUxMICovID8gbm9kZS5wcm9wcyA6IG5vZGUuYXJndW1lbnRzWzJdO1xuICAgIGxldCBjYWxsUGF0aCA9IFtdO1xuICAgIGxldCBwYXJlbnRDYWxsO1xuICAgIGlmIChwcm9wcyAmJlxuICAgICAgICAhKDAsIHNoYXJlZF8xLmlzU3RyaW5nKShwcm9wcykgJiZcbiAgICAgICAgcHJvcHMudHlwZSA9PT0gMTQgLyogTm9kZVR5cGVzLkpTX0NBTExfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICBjb25zdCByZXQgPSBnZXRVbm5vcm1hbGl6ZWRQcm9wcyhwcm9wcyk7XG4gICAgICAgIHByb3BzID0gcmV0WzBdO1xuICAgICAgICBjYWxsUGF0aCA9IHJldFsxXTtcbiAgICAgICAgcGFyZW50Q2FsbCA9IGNhbGxQYXRoW2NhbGxQYXRoLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBpZiAocHJvcHMgPT0gbnVsbCB8fCAoMCwgc2hhcmVkXzEuaXNTdHJpbmcpKHByb3BzKSkge1xuICAgICAgICBwcm9wc1dpdGhJbmplY3Rpb24gPSBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtwcm9wXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3BzLnR5cGUgPT09IDE0IC8qIE5vZGVUeXBlcy5KU19DQUxMX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgLy8gbWVyZ2VkIHByb3BzLi4uIGFkZCBvdXJzXG4gICAgICAgIC8vIG9ubHkgaW5qZWN0IGtleSB0byBvYmplY3QgbGl0ZXJhbCBpZiBpdCdzIHRoZSBmaXJzdCBhcmd1bWVudCBzbyB0aGF0XG4gICAgICAgIC8vIGlmIGRvZXNuJ3Qgb3ZlcnJpZGUgdXNlciBwcm92aWRlZCBrZXlzXG4gICAgICAgIGNvbnN0IGZpcnN0ID0gcHJvcHMuYXJndW1lbnRzWzBdO1xuICAgICAgICBpZiAoISgwLCBzaGFyZWRfMS5pc1N0cmluZykoZmlyc3QpICYmIGZpcnN0LnR5cGUgPT09IDE1IC8qIE5vZGVUeXBlcy5KU19PQkpFQ1RfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICAgICAgLy8gIzY2MzFcbiAgICAgICAgICAgIGlmICghaGFzUHJvcChwcm9wLCBmaXJzdCkpIHtcbiAgICAgICAgICAgICAgICBmaXJzdC5wcm9wZXJ0aWVzLnVuc2hpZnQocHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuY2FsbGVlID09PSBUT19IQU5ETEVSUykge1xuICAgICAgICAgICAgICAgIC8vICMyMzY2XG4gICAgICAgICAgICAgICAgcHJvcHNXaXRoSW5qZWN0aW9uID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoTUVSR0VfUFJPUFMpLCBbXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW3Byb3BdKSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3BzLmFyZ3VtZW50cy51bnNoaWZ0KGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW3Byb3BdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgIXByb3BzV2l0aEluamVjdGlvbiAmJiAocHJvcHNXaXRoSW5qZWN0aW9uID0gcHJvcHMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9wcy50eXBlID09PSAxNSAvKiBOb2RlVHlwZXMuSlNfT0JKRUNUX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgaWYgKCFoYXNQcm9wKHByb3AsIHByb3BzKSkge1xuICAgICAgICAgICAgcHJvcHMucHJvcGVydGllcy51bnNoaWZ0KHByb3ApO1xuICAgICAgICB9XG4gICAgICAgIHByb3BzV2l0aEluamVjdGlvbiA9IHByb3BzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gc2luZ2xlIHYtYmluZCB3aXRoIGV4cHJlc3Npb24sIHJldHVybiBhIG1lcmdlZCByZXBsYWNlbWVudFxuICAgICAgICBwcm9wc1dpdGhJbmplY3Rpb24gPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihNRVJHRV9QUk9QUyksIFtcbiAgICAgICAgICAgIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW3Byb3BdKSxcbiAgICAgICAgICAgIHByb3BzXG4gICAgICAgIF0pO1xuICAgICAgICAvLyBpbiB0aGUgY2FzZSBvZiBuZXN0ZWQgaGVscGVyIGNhbGwsIGUuZy4gYG5vcm1hbGl6ZVByb3BzKGd1YXJkUmVhY3RpdmVQcm9wcyhwcm9wcykpYCxcbiAgICAgICAgLy8gaXQgd2lsbCBiZSByZXdyaXR0ZW4gYXMgYG5vcm1hbGl6ZVByb3BzKG1lcmdlUHJvcHMoeyBrZXk6IDAgfSwgcHJvcHMpKWAsXG4gICAgICAgIC8vIHRoZSBgZ3VhcmRSZWFjdGl2ZVByb3BzYCB3aWxsIG5vIGxvbmdlciBiZSBuZWVkZWRcbiAgICAgICAgaWYgKHBhcmVudENhbGwgJiYgcGFyZW50Q2FsbC5jYWxsZWUgPT09IEdVQVJEX1JFQUNUSVZFX1BST1BTKSB7XG4gICAgICAgICAgICBwYXJlbnRDYWxsID0gY2FsbFBhdGhbY2FsbFBhdGgubGVuZ3RoIC0gMl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMTMgLyogTm9kZVR5cGVzLlZOT0RFX0NBTEwgKi8pIHtcbiAgICAgICAgaWYgKHBhcmVudENhbGwpIHtcbiAgICAgICAgICAgIHBhcmVudENhbGwuYXJndW1lbnRzWzBdID0gcHJvcHNXaXRoSW5qZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5wcm9wcyA9IHByb3BzV2l0aEluamVjdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHBhcmVudENhbGwpIHtcbiAgICAgICAgICAgIHBhcmVudENhbGwuYXJndW1lbnRzWzBdID0gcHJvcHNXaXRoSW5qZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5hcmd1bWVudHNbMl0gPSBwcm9wc1dpdGhJbmplY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmluamVjdFByb3AgPSBpbmplY3RQcm9wO1xuLy8gY2hlY2sgZXhpc3Rpbmcga2V5IHRvIGF2b2lkIG92ZXJyaWRpbmcgdXNlciBwcm92aWRlZCBrZXlzXG5mdW5jdGlvbiBoYXNQcm9wKHByb3AsIHByb3BzKSB7XG4gICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICAgIGlmIChwcm9wLmtleS50eXBlID09PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICBjb25zdCBwcm9wS2V5TmFtZSA9IHByb3Aua2V5LmNvbnRlbnQ7XG4gICAgICAgIHJlc3VsdCA9IHByb3BzLnByb3BlcnRpZXMuc29tZShwID0+IHAua2V5LnR5cGUgPT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovICYmXG4gICAgICAgICAgICBwLmtleS5jb250ZW50ID09PSBwcm9wS2V5TmFtZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b1ZhbGlkQXNzZXRJZChuYW1lLCB0eXBlKSB7XG4gICAgLy8gc2VlIGlzc3VlIzQ0MjIsIHdlIG5lZWQgYWRkaW5nIGlkZW50aWZpZXIgb24gdmFsaWRBc3NldElkIGlmIHZhcmlhYmxlIGBuYW1lYCBoYXMgc3BlY2lmaWMgY2hhcmFjdGVyXG4gICAgcmV0dXJuIGBfJHt0eXBlfV8ke25hbWUucmVwbGFjZSgvW15cXHddL2csIChzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiBzZWFyY2hWYWx1ZSA9PT0gJy0nID8gJ18nIDogbmFtZS5jaGFyQ29kZUF0KHJlcGxhY2VWYWx1ZSkudG9TdHJpbmcoKTtcbiAgICB9KX1gO1xufVxuZXhwb3J0cy50b1ZhbGlkQXNzZXRJZCA9IHRvVmFsaWRBc3NldElkO1xuLy8gQ2hlY2sgaWYgYSBub2RlIGNvbnRhaW5zIGV4cHJlc3Npb25zIHRoYXQgcmVmZXJlbmNlIGN1cnJlbnQgY29udGV4dCBzY29wZSBpZHNcbmZ1bmN0aW9uIGhhc1Njb3BlUmVmKG5vZGUsIGlkcykge1xuICAgIGlmICghbm9kZSB8fCBPYmplY3Qua2V5cyhpZHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLzpcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwLnR5cGUgPT09IDcgLyogTm9kZVR5cGVzLkRJUkVDVElWRSAqLyAmJlxuICAgICAgICAgICAgICAgICAgICAoaGFzU2NvcGVSZWYocC5hcmcsIGlkcykgfHwgaGFzU2NvcGVSZWYocC5leHAsIGlkcykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLnNvbWUoYyA9PiBoYXNTY29wZVJlZihjLCBpZHMpKTtcbiAgICAgICAgY2FzZSAxMSAvKiBOb2RlVHlwZXMuRk9SICovOlxuICAgICAgICAgICAgaWYgKGhhc1Njb3BlUmVmKG5vZGUuc291cmNlLCBpZHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5zb21lKGMgPT4gaGFzU2NvcGVSZWYoYywgaWRzKSk7XG4gICAgICAgIGNhc2UgOSAvKiBOb2RlVHlwZXMuSUYgKi86XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5icmFuY2hlcy5zb21lKGIgPT4gaGFzU2NvcGVSZWYoYiwgaWRzKSk7XG4gICAgICAgIGNhc2UgMTAgLyogTm9kZVR5cGVzLklGX0JSQU5DSCAqLzpcbiAgICAgICAgICAgIGlmIChoYXNTY29wZVJlZihub2RlLmNvbmRpdGlvbiwgaWRzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4uc29tZShjID0+IGhhc1Njb3BlUmVmKGMsIGlkcykpO1xuICAgICAgICBjYXNlIDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovOlxuICAgICAgICAgICAgcmV0dXJuICghbm9kZS5pc1N0YXRpYyAmJlxuICAgICAgICAgICAgICAgIGlzU2ltcGxlSWRlbnRpZmllcihub2RlLmNvbnRlbnQpICYmXG4gICAgICAgICAgICAgICAgISFpZHNbbm9kZS5jb250ZW50XSk7XG4gICAgICAgIGNhc2UgOCAvKiBOb2RlVHlwZXMuQ09NUE9VTkRfRVhQUkVTU0lPTiAqLzpcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLnNvbWUoYyA9PiAoMCwgc2hhcmVkXzEuaXNPYmplY3QpKGMpICYmIGhhc1Njb3BlUmVmKGMsIGlkcykpO1xuICAgICAgICBjYXNlIDUgLyogTm9kZVR5cGVzLklOVEVSUE9MQVRJT04gKi86XG4gICAgICAgIGNhc2UgMTIgLyogTm9kZVR5cGVzLlRFWFRfQ0FMTCAqLzpcbiAgICAgICAgICAgIHJldHVybiBoYXNTY29wZVJlZihub2RlLmNvbnRlbnQsIGlkcyk7XG4gICAgICAgIGNhc2UgMiAvKiBOb2RlVHlwZXMuVEVYVCAqLzpcbiAgICAgICAgY2FzZSAzIC8qIE5vZGVUeXBlcy5DT01NRU5UICovOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSlcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5oYXNTY29wZVJlZiA9IGhhc1Njb3BlUmVmO1xuZnVuY3Rpb24gZ2V0TWVtb2VkVk5vZGVDYWxsKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSAxNCAvKiBOb2RlVHlwZXMuSlNfQ0FMTF9FWFBSRVNTSU9OICovICYmIG5vZGUuY2FsbGVlID09PSBXSVRIX01FTU8pIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuYXJndW1lbnRzWzFdLnJldHVybnM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG59XG5leHBvcnRzLmdldE1lbW9lZFZOb2RlQ2FsbCA9IGdldE1lbW9lZFZOb2RlQ2FsbDtcbmZ1bmN0aW9uIG1ha2VCbG9jayhub2RlLCB7IGhlbHBlciwgcmVtb3ZlSGVscGVyLCBpblNTUiB9KSB7XG4gICAgaWYgKCFub2RlLmlzQmxvY2spIHtcbiAgICAgICAgbm9kZS5pc0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgcmVtb3ZlSGVscGVyKGdldFZOb2RlSGVscGVyKGluU1NSLCBub2RlLmlzQ29tcG9uZW50KSk7XG4gICAgICAgIGhlbHBlcihPUEVOX0JMT0NLKTtcbiAgICAgICAgaGVscGVyKGdldFZOb2RlQmxvY2tIZWxwZXIoaW5TU1IsIG5vZGUuaXNDb21wb25lbnQpKTtcbiAgICB9XG59XG5leHBvcnRzLm1ha2VCbG9jayA9IG1ha2VCbG9jaztcbmNvbnN0IGRlcHJlY2F0aW9uRGF0YSA9IHtcbiAgICBbXCJDT01QSUxFUl9JU19PTl9FTEVNRU5UXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX0lTX09OX0VMRU1FTlQgKi9dOiB7XG4gICAgICAgIG1lc3NhZ2U6IGBQbGF0Zm9ybS1uYXRpdmUgZWxlbWVudHMgd2l0aCBcImlzXCIgcHJvcCB3aWxsIG5vIGxvbmdlciBiZSBgICtcbiAgICAgICAgICAgIGB0cmVhdGVkIGFzIGNvbXBvbmVudHMgaW4gVnVlIDMgdW5sZXNzIHRoZSBcImlzXCIgdmFsdWUgaXMgZXhwbGljaXRseSBgICtcbiAgICAgICAgICAgIGBwcmVmaXhlZCB3aXRoIFwidnVlOlwiLmAsXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9jdXN0b20tZWxlbWVudHMtaW50ZXJvcC5odG1sYFxuICAgIH0sXG4gICAgW1wiQ09NUElMRVJfVl9CSU5EX1NZTkNcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfVl9CSU5EX1NZTkMgKi9dOiB7XG4gICAgICAgIG1lc3NhZ2U6IGtleSA9PiBgLnN5bmMgbW9kaWZpZXIgZm9yIHYtYmluZCBoYXMgYmVlbiByZW1vdmVkLiBVc2Ugdi1tb2RlbCB3aXRoIGAgK1xuICAgICAgICAgICAgYGFyZ3VtZW50IGluc3RlYWQuIFxcYHYtYmluZDoke2tleX0uc3luY1xcYCBzaG91bGQgYmUgY2hhbmdlZCB0byBgICtcbiAgICAgICAgICAgIGBcXGB2LW1vZGVsOiR7a2V5fVxcYC5gLFxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvdi1tb2RlbC5odG1sYFxuICAgIH0sXG4gICAgW1wiQ09NUElMRVJfVl9CSU5EX1BST1BcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfVl9CSU5EX1BST1AgKi9dOiB7XG4gICAgICAgIG1lc3NhZ2U6IGAucHJvcCBtb2RpZmllciBmb3Igdi1iaW5kIGhhcyBiZWVuIHJlbW92ZWQgYW5kIG5vIGxvbmdlciBuZWNlc3NhcnkuIGAgK1xuICAgICAgICAgICAgYFZ1ZSAzIHdpbGwgYXV0b21hdGljYWxseSBzZXQgYSBiaW5kaW5nIGFzIERPTSBwcm9wZXJ0eSB3aGVuIGFwcHJvcHJpYXRlLmBcbiAgICB9LFxuICAgIFtcIkNPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVJcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfVl9CSU5EX09CSkVDVF9PUkRFUiAqL106IHtcbiAgICAgICAgbWVzc2FnZTogYHYtYmluZD1cIm9ialwiIHVzYWdlIGlzIG5vdyBvcmRlciBzZW5zaXRpdmUgYW5kIGJlaGF2ZXMgbGlrZSBKYXZhU2NyaXB0IGAgK1xuICAgICAgICAgICAgYG9iamVjdCBzcHJlYWQ6IGl0IHdpbGwgbm93IG92ZXJ3cml0ZSBhbiBleGlzdGluZyBub24tbWVyZ2VhYmxlIGF0dHJpYnV0ZSBgICtcbiAgICAgICAgICAgIGB0aGF0IGFwcGVhcnMgYmVmb3JlIHYtYmluZCBpbiB0aGUgY2FzZSBvZiBjb25mbGljdC4gYCArXG4gICAgICAgICAgICBgVG8gcmV0YWluIDIueCBiZWhhdmlvciwgbW92ZSB2LWJpbmQgdG8gbWFrZSBpdCB0aGUgZmlyc3QgYXR0cmlidXRlLiBgICtcbiAgICAgICAgICAgIGBZb3UgY2FuIGFsc28gc3VwcHJlc3MgdGhpcyB3YXJuaW5nIGlmIHRoZSB1c2FnZSBpcyBpbnRlbmRlZC5gLFxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvdi1iaW5kLmh0bWxgXG4gICAgfSxcbiAgICBbXCJDT01QSUxFUl9WX09OX05BVElWRVwiIC8qIENvbXBpbGVyRGVwcmVjYXRpb25UeXBlcy5DT01QSUxFUl9WX09OX05BVElWRSAqL106IHtcbiAgICAgICAgbWVzc2FnZTogYC5uYXRpdmUgbW9kaWZpZXIgZm9yIHYtb24gaGFzIGJlZW4gcmVtb3ZlZCBhcyBpcyBubyBsb25nZXIgbmVjZXNzYXJ5LmAsXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy92LW9uLW5hdGl2ZS1tb2RpZmllci1yZW1vdmVkLmh0bWxgXG4gICAgfSxcbiAgICBbXCJDT01QSUxFUl9WX0lGX1ZfRk9SX1BSRUNFREVOQ0VcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfVl9JRl9WX0ZPUl9QUkVDRURFTkNFICovXToge1xuICAgICAgICBtZXNzYWdlOiBgdi1pZiAvIHYtZm9yIHByZWNlZGVuY2Ugd2hlbiB1c2VkIG9uIHRoZSBzYW1lIGVsZW1lbnQgaGFzIGNoYW5nZWQgYCArXG4gICAgICAgICAgICBgaW4gVnVlIDM6IHYtaWYgbm93IHRha2VzIGhpZ2hlciBwcmVjZWRlbmNlIGFuZCB3aWxsIG5vIGxvbmdlciBoYXZlIGAgK1xuICAgICAgICAgICAgYGFjY2VzcyB0byB2LWZvciBzY29wZSB2YXJpYWJsZXMuIEl0IGlzIGJlc3QgdG8gYXZvaWQgdGhlIGFtYmlndWl0eSBgICtcbiAgICAgICAgICAgIGB3aXRoIDx0ZW1wbGF0ZT4gdGFncyBvciB1c2UgYSBjb21wdXRlZCBwcm9wZXJ0eSB0aGF0IGZpbHRlcnMgdi1mb3IgYCArXG4gICAgICAgICAgICBgZGF0YSBzb3VyY2UuYCxcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL3YtaWYtdi1mb3IuaHRtbGBcbiAgICB9LFxuICAgIFtcIkNPTVBJTEVSX05BVElWRV9URU1QTEFURVwiIC8qIENvbXBpbGVyRGVwcmVjYXRpb25UeXBlcy5DT01QSUxFUl9OQVRJVkVfVEVNUExBVEUgKi9dOiB7XG4gICAgICAgIG1lc3NhZ2U6IGA8dGVtcGxhdGU+IHdpdGggbm8gc3BlY2lhbCBkaXJlY3RpdmVzIHdpbGwgcmVuZGVyIGFzIGEgbmF0aXZlIHRlbXBsYXRlIGAgK1xuICAgICAgICAgICAgYGVsZW1lbnQgaW5zdGVhZCBvZiBpdHMgaW5uZXIgY29udGVudCBpbiBWdWUgMy5gXG4gICAgfSxcbiAgICBbXCJDT01QSUxFUl9JTkxJTkVfVEVNUExBVEVcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfSU5MSU5FX1RFTVBMQVRFICovXToge1xuICAgICAgICBtZXNzYWdlOiBgXCJpbmxpbmUtdGVtcGxhdGVcIiBoYXMgYmVlbiByZW1vdmVkIGluIFZ1ZSAzLmAsXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9pbmxpbmUtdGVtcGxhdGUtYXR0cmlidXRlLmh0bWxgXG4gICAgfSxcbiAgICBbXCJDT01QSUxFUl9GSUxURVJcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfRklMVEVSUyAqL106IHtcbiAgICAgICAgbWVzc2FnZTogYGZpbHRlcnMgaGF2ZSBiZWVuIHJlbW92ZWQgaW4gVnVlIDMuIGAgK1xuICAgICAgICAgICAgYFRoZSBcInxcIiBzeW1ib2wgd2lsbCBiZSB0cmVhdGVkIGFzIG5hdGl2ZSBKYXZhU2NyaXB0IGJpdHdpc2UgT1Igb3BlcmF0b3IuIGAgK1xuICAgICAgICAgICAgYFVzZSBtZXRob2QgY2FsbHMgb3IgY29tcHV0ZWQgcHJvcGVydGllcyBpbnN0ZWFkLmAsXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9maWx0ZXJzLmh0bWxgXG4gICAgfVxufTtcbmZ1bmN0aW9uIGdldENvbXBhdFZhbHVlKGtleSwgY29udGV4dCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IGNvbnRleHQub3B0aW9uc1xuICAgICAgICA/IGNvbnRleHQub3B0aW9ucy5jb21wYXRDb25maWdcbiAgICAgICAgOiBjb250ZXh0LmNvbXBhdENvbmZpZztcbiAgICBjb25zdCB2YWx1ZSA9IGNvbmZpZyAmJiBjb25maWdba2V5XTtcbiAgICBpZiAoa2V5ID09PSAnTU9ERScpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IDM7IC8vIGNvbXBpbGVyIGRlZmF1bHRzIHRvIHYzIGJlaGF2aW9yXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNDb21wYXRFbmFibGVkKGtleSwgY29udGV4dCkge1xuICAgIGNvbnN0IG1vZGUgPSBnZXRDb21wYXRWYWx1ZSgnTU9ERScsIGNvbnRleHQpO1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0Q29tcGF0VmFsdWUoa2V5LCBjb250ZXh0KTtcbiAgICAvLyBpbiB2MyBtb2RlLCBvbmx5IGVuYWJsZSBpZiBleHBsaWNpdGx5IHNldCB0byB0cnVlXG4gICAgLy8gb3RoZXJ3aXNlIGVuYWJsZSBmb3IgYW55IG5vbi1mYWxzZSB2YWx1ZVxuICAgIHJldHVybiBtb2RlID09PSAzID8gdmFsdWUgPT09IHRydWUgOiB2YWx1ZSAhPT0gZmFsc2U7XG59XG5mdW5jdGlvbiBjaGVja0NvbXBhdEVuYWJsZWQoa2V5LCBjb250ZXh0LCBsb2MsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBlbmFibGVkID0gaXNDb21wYXRFbmFibGVkKGtleSwgY29udGV4dCk7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBlbmFibGVkKSB7XG4gICAgICAgIHdhcm5EZXByZWNhdGlvbihrZXksIGNvbnRleHQsIGxvYywgLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBlbmFibGVkO1xufVxuZXhwb3J0cy5jaGVja0NvbXBhdEVuYWJsZWQgPSBjaGVja0NvbXBhdEVuYWJsZWQ7XG5mdW5jdGlvbiB3YXJuRGVwcmVjYXRpb24oa2V5LCBjb250ZXh0LCBsb2MsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCB2YWwgPSBnZXRDb21wYXRWYWx1ZShrZXksIGNvbnRleHQpO1xuICAgIGlmICh2YWwgPT09ICdzdXBwcmVzcy13YXJuaW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgbWVzc2FnZSwgbGluayB9ID0gZGVwcmVjYXRpb25EYXRhW2tleV07XG4gICAgY29uc3QgbXNnID0gYChkZXByZWNhdGlvbiAke2tleX0pICR7dHlwZW9mIG1lc3NhZ2UgPT09ICdmdW5jdGlvbicgPyBtZXNzYWdlKC4uLmFyZ3MpIDogbWVzc2FnZX0ke2xpbmsgPyBgXFxuICBEZXRhaWxzOiAke2xpbmt9YCA6IGBgfWA7XG4gICAgY29uc3QgZXJyID0gbmV3IFN5bnRheEVycm9yKG1zZyk7XG4gICAgZXJyLmNvZGUgPSBrZXk7XG4gICAgaWYgKGxvYylcbiAgICAgICAgZXJyLmxvYyA9IGxvYztcbiAgICBjb250ZXh0Lm9uV2FybihlcnIpO1xufVxuZXhwb3J0cy53YXJuRGVwcmVjYXRpb24gPSB3YXJuRGVwcmVjYXRpb247XG4vLyBUaGUgZGVmYXVsdCBkZWNvZGVyIG9ubHkgcHJvdmlkZXMgZXNjYXBlcyBmb3IgY2hhcmFjdGVycyByZXNlcnZlZCBhcyBwYXJ0IG9mXG4vLyB0aGUgdGVtcGxhdGUgc3ludGF4LCBhbmQgaXMgb25seSB1c2VkIGlmIHRoZSBjdXN0b20gcmVuZGVyZXIgZGlkIG5vdCBwcm92aWRlXG4vLyBhIHBsYXRmb3JtLXNwZWNpZmljIGRlY29kZXIuXG5jb25zdCBkZWNvZGVSRSA9IC8mKGd0fGx0fGFtcHxhcG9zfHF1b3QpOy9nO1xuY29uc3QgZGVjb2RlTWFwID0ge1xuICAgIGd0OiAnPicsXG4gICAgbHQ6ICc8JyxcbiAgICBhbXA6ICcmJyxcbiAgICBhcG9zOiBcIidcIixcbiAgICBxdW90OiAnXCInXG59O1xuY29uc3QgZGVmYXVsdFBhcnNlck9wdGlvbnMgPSB7XG4gICAgZGVsaW1pdGVyczogW2B7e2AsIGB9fWBdLFxuICAgIGdldE5hbWVzcGFjZTogKCkgPT4gMCAvKiBOYW1lc3BhY2VzLkhUTUwgKi8sXG4gICAgZ2V0VGV4dE1vZGU6ICgpID0+IDAgLyogVGV4dE1vZGVzLkRBVEEgKi8sXG4gICAgaXNWb2lkVGFnOiBzaGFyZWRfMS5OTyxcbiAgICBpc1ByZVRhZzogc2hhcmVkXzEuTk8sXG4gICAgaXNDdXN0b21FbGVtZW50OiBzaGFyZWRfMS5OTyxcbiAgICBkZWNvZGVFbnRpdGllczogKHJhd1RleHQpID0+IHJhd1RleHQucmVwbGFjZShkZWNvZGVSRSwgKF8sIHAxKSA9PiBkZWNvZGVNYXBbcDFdKSxcbiAgICBvbkVycm9yOiBkZWZhdWx0T25FcnJvcixcbiAgICBvbldhcm46IGRlZmF1bHRPbldhcm4sXG4gICAgY29tbWVudHM6IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxufTtcbmZ1bmN0aW9uIGJhc2VQYXJzZShjb250ZW50LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlUGFyc2VyQ29udGV4dChjb250ZW50LCBvcHRpb25zKTtcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcbiAgICByZXR1cm4gY3JlYXRlUm9vdChwYXJzZUNoaWxkcmVuKGNvbnRleHQsIDAgLyogVGV4dE1vZGVzLkRBVEEgKi8sIFtdKSwgZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KSk7XG59XG5leHBvcnRzLmJhc2VQYXJzZSA9IGJhc2VQYXJzZTtcbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlckNvbnRleHQoY29udGVudCwgcmF3T3B0aW9ucykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSAoMCwgc2hhcmVkXzEuZXh0ZW5kKSh7fSwgZGVmYXVsdFBhcnNlck9wdGlvbnMpO1xuICAgIGxldCBrZXk7XG4gICAgZm9yIChrZXkgaW4gcmF3T3B0aW9ucykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIG9wdGlvbnNba2V5XSA9XG4gICAgICAgICAgICByYXdPcHRpb25zW2tleV0gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFBhcnNlck9wdGlvbnNba2V5XVxuICAgICAgICAgICAgICAgIDogcmF3T3B0aW9uc1trZXldO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBvcHRpb25zLFxuICAgICAgICBjb2x1bW46IDEsXG4gICAgICAgIGxpbmU6IDEsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgb3JpZ2luYWxTb3VyY2U6IGNvbnRlbnQsXG4gICAgICAgIHNvdXJjZTogY29udGVudCxcbiAgICAgICAgaW5QcmU6IGZhbHNlLFxuICAgICAgICBpblZQcmU6IGZhbHNlLFxuICAgICAgICBvbldhcm46IG9wdGlvbnMub25XYXJuXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2hpbGRyZW4oY29udGV4dCwgbW9kZSwgYW5jZXN0b3JzKSB7XG4gICAgY29uc3QgcGFyZW50ID0gbGFzdChhbmNlc3RvcnMpO1xuICAgIGNvbnN0IG5zID0gcGFyZW50ID8gcGFyZW50Lm5zIDogMCAvKiBOYW1lc3BhY2VzLkhUTUwgKi87XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICB3aGlsZSAoIWlzRW5kKGNvbnRleHQsIG1vZGUsIGFuY2VzdG9ycykpIHtcbiAgICAgICAgY29uc3QgcyA9IGNvbnRleHQuc291cmNlO1xuICAgICAgICBsZXQgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1vZGUgPT09IDAgLyogVGV4dE1vZGVzLkRBVEEgKi8gfHwgbW9kZSA9PT0gMSAvKiBUZXh0TW9kZXMuUkNEQVRBICovKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuaW5WUHJlICYmIHN0YXJ0c1dpdGgocywgY29udGV4dC5vcHRpb25zLmRlbGltaXRlcnNbMF0pKSB7XG4gICAgICAgICAgICAgICAgLy8gJ3t7J1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUludGVycG9sYXRpb24oY29udGV4dCwgbW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlID09PSAwIC8qIFRleHRNb2Rlcy5EQVRBICovICYmIHNbMF0gPT09ICc8Jykge1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCN0YWctb3Blbi1zdGF0ZVxuICAgICAgICAgICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgNSAvKiBFcnJvckNvZGVzLkVPRl9CRUZPUkVfVEFHX05BTUUgKi8sIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzWzFdID09PSAnIScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI21hcmt1cC1kZWNsYXJhdGlvbi1vcGVuLXN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydHNXaXRoKHMsICc8IS0tJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUNvbW1lbnQoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnRzV2l0aChzLCAnPCFET0NUWVBFJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBET0NUWVBFIGJ5IGEgbGltaXRhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFydHNXaXRoKHMsICc8IVtDREFUQVsnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5zICE9PSAwIC8qIE5hbWVzcGFjZXMuSFRNTCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUNEQVRBKGNvbnRleHQsIGFuY2VzdG9ycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMSAvKiBFcnJvckNvZGVzLkNEQVRBX0lOX0hUTUxfQ09OVEVOVCAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDExIC8qIEVycm9yQ29kZXMuSU5DT1JSRUNUTFlfT1BFTkVEX0NPTU1FTlQgKi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNbMV0gPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjZW5kLXRhZy1vcGVuLXN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDUgLyogRXJyb3JDb2Rlcy5FT0ZfQkVGT1JFX1RBR19OQU1FICovLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzWzJdID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxNCAvKiBFcnJvckNvZGVzLk1JU1NJTkdfRU5EX1RBR19OQU1FICovLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9bYS16XS9pLnRlc3Qoc1syXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyMyAvKiBFcnJvckNvZGVzLlhfSU5WQUxJRF9FTkRfVEFHICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlVGFnKGNvbnRleHQsIDEgLyogVGFnVHlwZS5FbmQgKi8sIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxMiAvKiBFcnJvckNvZGVzLklOVkFMSURfRklSU1RfQ0hBUkFDVEVSX09GX1RBR19OQU1FICovLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgvW2Etel0vaS50ZXN0KHNbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUVsZW1lbnQoY29udGV4dCwgYW5jZXN0b3JzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gMi54IDx0ZW1wbGF0ZT4gd2l0aCBubyBkaXJlY3RpdmUgY29tcGF0XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9OQVRJVkVfVEVNUExBVEVcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFICovLCBjb250ZXh0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50YWcgPT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFub2RlLnByb3BzLnNvbWUocCA9PiBwLnR5cGUgPT09IDcgLyogTm9kZVR5cGVzLkRJUkVDVElWRSAqLyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU3BlY2lhbFRlbXBsYXRlRGlyZWN0aXZlKHAubmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuRGVwcmVjYXRpb24oXCJDT01QSUxFUl9OQVRJVkVfVEVNUExBVEVcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFICovLCBjb250ZXh0LCBub2RlLmxvYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzWzFdID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDIxIC8qIEVycm9yQ29kZXMuVU5FWFBFQ1RFRF9RVUVTVElPTl9NQVJLX0lOU1RFQURfT0ZfVEFHX05BTUUgKi8sIDEpO1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VCb2d1c0NvbW1lbnQoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTIgLyogRXJyb3JDb2Rlcy5JTlZBTElEX0ZJUlNUX0NIQVJBQ1RFUl9PRl9UQUdfTkFNRSAqLywgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgbm9kZSA9IHBhcnNlVGV4dChjb250ZXh0LCBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIHNoYXJlZF8xLmlzQXJyYXkpKG5vZGUpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwdXNoTm9kZShub2Rlcywgbm9kZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwdXNoTm9kZShub2Rlcywgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV2hpdGVzcGFjZSBoYW5kbGluZyBzdHJhdGVneSBsaWtlIHYyXG4gICAgbGV0IHJlbW92ZWRXaGl0ZXNwYWNlID0gZmFsc2U7XG4gICAgaWYgKG1vZGUgIT09IDIgLyogVGV4dE1vZGVzLlJBV1RFWFQgKi8gJiYgbW9kZSAhPT0gMSAvKiBUZXh0TW9kZXMuUkNEQVRBICovKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZENvbmRlbnNlID0gY29udGV4dC5vcHRpb25zLndoaXRlc3BhY2UgIT09ICdwcmVzZXJ2ZSc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IDIgLyogTm9kZVR5cGVzLlRFWFQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQuaW5QcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEvW15cXHRcXHJcXG5cXGYgXS8udGVzdChub2RlLmNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gbm9kZXNbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5vZGVzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBpZjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gdGhlIHdoaXRlc3BhY2UgaXMgdGhlIGZpcnN0IG9yIGxhc3Qgbm9kZSwgb3I6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAtIChjb25kZW5zZSBtb2RlKSB0aGUgd2hpdGVzcGFjZSBpcyBiZXR3ZWVuIHR3b3MgY29tbWVudHMsIG9yOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSAoY29uZGVuc2UgbW9kZSkgdGhlIHdoaXRlc3BhY2UgaXMgYmV0d2VlbiBjb21tZW50IGFuZCBlbGVtZW50LCBvcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gKGNvbmRlbnNlIG1vZGUpIHRoZSB3aGl0ZXNwYWNlIGlzIGJldHdlZW4gdHdvIGVsZW1lbnRzIEFORCBjb250YWlucyBuZXdsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXYgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhbmV4dCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzaG91bGRDb25kZW5zZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHByZXYudHlwZSA9PT0gMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC50eXBlID09PSAzIC8qIE5vZGVUeXBlcy5DT01NRU5UICovKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHByZXYudHlwZSA9PT0gMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwcmV2LnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnR5cGUgPT09IDMgLyogTm9kZVR5cGVzLkNPTU1FTlQgKi8pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocHJldi50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgL1tcXHJcXG5dLy50ZXN0KG5vZGUuY29udGVudCkpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkV2hpdGVzcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgd2hpdGVzcGFjZSBpcyBjb25kZW5zZWQgaW50byBhIHNpbmdsZSBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY29udGVudCA9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzaG91bGRDb25kZW5zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gY29uZGVuc2UgbW9kZSwgY29uc2VjdXRpdmUgd2hpdGVzcGFjZXMgaW4gdGV4dCBhcmUgY29uZGVuc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb3duIHRvIGEgc2luZ2xlIHNwYWNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50ID0gbm9kZS5jb250ZW50LnJlcGxhY2UoL1tcXHRcXHJcXG5cXGYgXSsvZywgJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gIzY0MTAgbm9ybWFsaXplIHdpbmRvd3MgbmV3bGluZXMgaW4gPHByZT46XG4gICAgICAgICAgICAgICAgICAgIC8vIGluIFNTUiwgYnJvd3NlcnMgbm9ybWFsaXplIHNlcnZlci1yZW5kZXJlZCBcXHJcXG4gaW50byBhIHNpbmdsZSBcXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIERPTVxuICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnQgPSBub2RlLmNvbnRlbnQucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgY29tbWVudCBub2RlcyBpZiBkZXNpcmVkIGJ5IGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09IDMgLyogTm9kZVR5cGVzLkNPTU1FTlQgKi8gJiYgIWNvbnRleHQub3B0aW9ucy5jb21tZW50cykge1xuICAgICAgICAgICAgICAgIHJlbW92ZWRXaGl0ZXNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQuaW5QcmUgJiYgcGFyZW50ICYmIGNvbnRleHQub3B0aW9ucy5pc1ByZVRhZyhwYXJlbnQudGFnKSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGxlYWRpbmcgbmV3bGluZSBwZXIgaHRtbCBzcGVjXG4gICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9ncm91cGluZy1jb250ZW50Lmh0bWwjdGhlLXByZS1lbGVtZW50XG4gICAgICAgICAgICBjb25zdCBmaXJzdCA9IG5vZGVzWzBdO1xuICAgICAgICAgICAgaWYgKGZpcnN0ICYmIGZpcnN0LnR5cGUgPT09IDIgLyogTm9kZVR5cGVzLlRFWFQgKi8pIHtcbiAgICAgICAgICAgICAgICBmaXJzdC5jb250ZW50ID0gZmlyc3QuY29udGVudC5yZXBsYWNlKC9eXFxyP1xcbi8sICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVtb3ZlZFdoaXRlc3BhY2UgPyBub2Rlcy5maWx0ZXIoQm9vbGVhbikgOiBub2Rlcztcbn1cbmZ1bmN0aW9uIHB1c2hOb2RlKG5vZGVzLCBub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMiAvKiBOb2RlVHlwZXMuVEVYVCAqLykge1xuICAgICAgICBjb25zdCBwcmV2ID0gbGFzdChub2Rlcyk7XG4gICAgICAgIC8vIE1lcmdlIGlmIGJvdGggdGhpcyBhbmQgdGhlIHByZXZpb3VzIG5vZGUgYXJlIHRleHQgYW5kIHRob3NlIGFyZVxuICAgICAgICAvLyBjb25zZWN1dGl2ZS4gVGhpcyBoYXBwZW5zIGZvciBjYXNlcyBsaWtlIFwiYSA8IGJcIi5cbiAgICAgICAgaWYgKHByZXYgJiZcbiAgICAgICAgICAgIHByZXYudHlwZSA9PT0gMiAvKiBOb2RlVHlwZXMuVEVYVCAqLyAmJlxuICAgICAgICAgICAgcHJldi5sb2MuZW5kLm9mZnNldCA9PT0gbm9kZS5sb2Muc3RhcnQub2Zmc2V0KSB7XG4gICAgICAgICAgICBwcmV2LmNvbnRlbnQgKz0gbm9kZS5jb250ZW50O1xuICAgICAgICAgICAgcHJldi5sb2MuZW5kID0gbm9kZS5sb2MuZW5kO1xuICAgICAgICAgICAgcHJldi5sb2Muc291cmNlICs9IG5vZGUubG9jLnNvdXJjZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xufVxuZnVuY3Rpb24gcGFyc2VDREFUQShjb250ZXh0LCBhbmNlc3RvcnMpIHtcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgOSk7XG4gICAgY29uc3Qgbm9kZXMgPSBwYXJzZUNoaWxkcmVuKGNvbnRleHQsIDMgLyogVGV4dE1vZGVzLkNEQVRBICovLCBhbmNlc3RvcnMpO1xuICAgIGlmIChjb250ZXh0LnNvdXJjZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDYgLyogRXJyb3JDb2Rlcy5FT0ZfSU5fQ0RBVEEgKi8pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDMpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG59XG5mdW5jdGlvbiBwYXJzZUNvbW1lbnQoY29udGV4dCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xuICAgIGxldCBjb250ZW50O1xuICAgIC8vIFJlZ3VsYXIgY29tbWVudC5cbiAgICBjb25zdCBtYXRjaCA9IC8tLShcXCEpPz4vLmV4ZWMoY29udGV4dC5zb3VyY2UpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgY29udGVudCA9IGNvbnRleHQuc291cmNlLnNsaWNlKDQpO1xuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgY29udGV4dC5zb3VyY2UubGVuZ3RoKTtcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDcgLyogRXJyb3JDb2Rlcy5FT0ZfSU5fQ09NTUVOVCAqLyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobWF0Y2guaW5kZXggPD0gMykge1xuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDAgLyogRXJyb3JDb2Rlcy5BQlJVUFRfQ0xPU0lOR19PRl9FTVBUWV9DT01NRU5UICovKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxMCAvKiBFcnJvckNvZGVzLklOQ09SUkVDVExZX0NMT1NFRF9DT01NRU5UICovKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZW50ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoNCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICAvLyBBZHZhbmNpbmcgd2l0aCByZXBvcnRpbmcgbmVzdGVkIGNvbW1lbnRzLlxuICAgICAgICBjb25zdCBzID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoMCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICBsZXQgcHJldkluZGV4ID0gMSwgbmVzdGVkSW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoKG5lc3RlZEluZGV4ID0gcy5pbmRleE9mKCc8IS0tJywgcHJldkluZGV4KSkgIT09IC0xKSB7XG4gICAgICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgbmVzdGVkSW5kZXggLSBwcmV2SW5kZXggKyAxKTtcbiAgICAgICAgICAgIGlmIChuZXN0ZWRJbmRleCArIDQgPCBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxNiAvKiBFcnJvckNvZGVzLk5FU1RFRF9DT01NRU5UICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZJbmRleCA9IG5lc3RlZEluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggLSBwcmV2SW5kZXggKyAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLyxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpIHtcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcbiAgICBjb25zdCBjb250ZW50U3RhcnQgPSBjb250ZXh0LnNvdXJjZVsxXSA9PT0gJz8nID8gMSA6IDI7XG4gICAgbGV0IGNvbnRlbnQ7XG4gICAgY29uc3QgY2xvc2VJbmRleCA9IGNvbnRleHQuc291cmNlLmluZGV4T2YoJz4nKTtcbiAgICBpZiAoY2xvc2VJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgY29udGVudCA9IGNvbnRleHQuc291cmNlLnNsaWNlKGNvbnRlbnRTdGFydCk7XG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBjb250ZXh0LnNvdXJjZS5sZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29udGVudCA9IGNvbnRleHQuc291cmNlLnNsaWNlKGNvbnRlbnRTdGFydCwgY2xvc2VJbmRleCk7XG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBjbG9zZUluZGV4ICsgMSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDMgLyogTm9kZVR5cGVzLkNPTU1FTlQgKi8sXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KVxuICAgIH07XG59XG5mdW5jdGlvbiBwYXJzZUVsZW1lbnQoY29udGV4dCwgYW5jZXN0b3JzKSB7XG4gICAgLy8gU3RhcnQgdGFnLlxuICAgIGNvbnN0IHdhc0luUHJlID0gY29udGV4dC5pblByZTtcbiAgICBjb25zdCB3YXNJblZQcmUgPSBjb250ZXh0LmluVlByZTtcbiAgICBjb25zdCBwYXJlbnQgPSBsYXN0KGFuY2VzdG9ycyk7XG4gICAgY29uc3QgZWxlbWVudCA9IHBhcnNlVGFnKGNvbnRleHQsIDAgLyogVGFnVHlwZS5TdGFydCAqLywgcGFyZW50KTtcbiAgICBjb25zdCBpc1ByZUJvdW5kYXJ5ID0gY29udGV4dC5pblByZSAmJiAhd2FzSW5QcmU7XG4gICAgY29uc3QgaXNWUHJlQm91bmRhcnkgPSBjb250ZXh0LmluVlByZSAmJiAhd2FzSW5WUHJlO1xuICAgIGlmIChlbGVtZW50LmlzU2VsZkNsb3NpbmcgfHwgY29udGV4dC5vcHRpb25zLmlzVm9pZFRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgLy8gIzQwMzAgc2VsZi1jbG9zaW5nIDxwcmU+IHRhZ1xuICAgICAgICBpZiAoaXNQcmVCb3VuZGFyeSkge1xuICAgICAgICAgICAgY29udGV4dC5pblByZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ZQcmVCb3VuZGFyeSkge1xuICAgICAgICAgICAgY29udGV4dC5pblZQcmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgLy8gQ2hpbGRyZW4uXG4gICAgYW5jZXN0b3JzLnB1c2goZWxlbWVudCk7XG4gICAgY29uc3QgbW9kZSA9IGNvbnRleHQub3B0aW9ucy5nZXRUZXh0TW9kZShlbGVtZW50LCBwYXJlbnQpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyc2VDaGlsZHJlbihjb250ZXh0LCBtb2RlLCBhbmNlc3RvcnMpO1xuICAgIGFuY2VzdG9ycy5wb3AoKTtcbiAgICAvLyAyLnggaW5saW5lLXRlbXBsYXRlIGNvbXBhdFxuICAgIHtcbiAgICAgICAgY29uc3QgaW5saW5lVGVtcGxhdGVQcm9wID0gZWxlbWVudC5wcm9wcy5maW5kKHAgPT4gcC50eXBlID09PSA2IC8qIE5vZGVUeXBlcy5BVFRSSUJVVEUgKi8gJiYgcC5uYW1lID09PSAnaW5saW5lLXRlbXBsYXRlJyk7XG4gICAgICAgIGlmIChpbmxpbmVUZW1wbGF0ZVByb3AgJiZcbiAgICAgICAgICAgIGNoZWNrQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX0lOTElORV9URU1QTEFURVwiIC8qIENvbXBpbGVyRGVwcmVjYXRpb25UeXBlcy5DT01QSUxFUl9JTkxJTkVfVEVNUExBVEUgKi8sIGNvbnRleHQsIGlubGluZVRlbXBsYXRlUHJvcC5sb2MpKSB7XG4gICAgICAgICAgICBjb25zdCBsb2MgPSBnZXRTZWxlY3Rpb24oY29udGV4dCwgZWxlbWVudC5sb2MuZW5kKTtcbiAgICAgICAgICAgIGlubGluZVRlbXBsYXRlUHJvcC52YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAyIC8qIE5vZGVUeXBlcy5URVhUICovLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGxvYy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgbG9jXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnQuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAvLyBFbmQgdGFnLlxuICAgIGlmIChzdGFydHNXaXRoRW5kVGFnT3Blbihjb250ZXh0LnNvdXJjZSwgZWxlbWVudC50YWcpKSB7XG4gICAgICAgIHBhcnNlVGFnKGNvbnRleHQsIDEgLyogVGFnVHlwZS5FbmQgKi8sIHBhcmVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjQgLyogRXJyb3JDb2Rlcy5YX01JU1NJTkdfRU5EX1RBRyAqLywgMCwgZWxlbWVudC5sb2Muc3RhcnQpO1xuICAgICAgICBpZiAoY29udGV4dC5zb3VyY2UubGVuZ3RoID09PSAwICYmIGVsZW1lbnQudGFnLnRvTG93ZXJDYXNlKCkgPT09ICdzY3JpcHQnKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdCA9IGNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgaWYgKGZpcnN0ICYmIHN0YXJ0c1dpdGgoZmlyc3QubG9jLnNvdXJjZSwgJzwhLS0nKSkge1xuICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA4IC8qIEVycm9yQ29kZXMuRU9GX0lOX1NDUklQVF9IVE1MX0NPTU1FTlRfTElLRV9URVhUICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50LmxvYyA9IGdldFNlbGVjdGlvbihjb250ZXh0LCBlbGVtZW50LmxvYy5zdGFydCk7XG4gICAgaWYgKGlzUHJlQm91bmRhcnkpIHtcbiAgICAgICAgY29udGV4dC5pblByZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXNWUHJlQm91bmRhcnkpIHtcbiAgICAgICAgY29udGV4dC5pblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG5jb25zdCBpc1NwZWNpYWxUZW1wbGF0ZURpcmVjdGl2ZSA9IC8qI19fUFVSRV9fKi8gKDAsIHNoYXJlZF8xLm1ha2VNYXApKGBpZixlbHNlLGVsc2UtaWYsZm9yLHNsb3RgKTtcbmZ1bmN0aW9uIHBhcnNlVGFnKGNvbnRleHQsIHR5cGUsIHBhcmVudCkge1xuICAgIC8vIFRhZyBvcGVuLlxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xuICAgIGNvbnN0IG1hdGNoID0gL148XFwvPyhbYS16XVteXFx0XFxyXFxuXFxmIC8+XSopL2kuZXhlYyhjb250ZXh0LnNvdXJjZSk7XG4gICAgY29uc3QgdGFnID0gbWF0Y2hbMV07XG4gICAgY29uc3QgbnMgPSBjb250ZXh0Lm9wdGlvbnMuZ2V0TmFtZXNwYWNlKHRhZywgcGFyZW50KTtcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xuICAgIC8vIHNhdmUgY3VycmVudCBzdGF0ZSBpbiBjYXNlIHdlIG5lZWQgdG8gcmUtcGFyc2UgYXR0cmlidXRlcyB3aXRoIHYtcHJlXG4gICAgY29uc3QgY3Vyc29yID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xuICAgIGNvbnN0IGN1cnJlbnRTb3VyY2UgPSBjb250ZXh0LnNvdXJjZTtcbiAgICAvLyBjaGVjayA8cHJlPiB0YWdcbiAgICBpZiAoY29udGV4dC5vcHRpb25zLmlzUHJlVGFnKHRhZykpIHtcbiAgICAgICAgY29udGV4dC5pblByZSA9IHRydWU7XG4gICAgfVxuICAgIC8vIEF0dHJpYnV0ZXMuXG4gICAgbGV0IHByb3BzID0gcGFyc2VBdHRyaWJ1dGVzKGNvbnRleHQsIHR5cGUpO1xuICAgIC8vIGNoZWNrIHYtcHJlXG4gICAgaWYgKHR5cGUgPT09IDAgLyogVGFnVHlwZS5TdGFydCAqLyAmJlxuICAgICAgICAhY29udGV4dC5pblZQcmUgJiZcbiAgICAgICAgcHJvcHMuc29tZShwID0+IHAudHlwZSA9PT0gNyAvKiBOb2RlVHlwZXMuRElSRUNUSVZFICovICYmIHAubmFtZSA9PT0gJ3ByZScpKSB7XG4gICAgICAgIGNvbnRleHQuaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgLy8gcmVzZXQgY29udGV4dFxuICAgICAgICAoMCwgc2hhcmVkXzEuZXh0ZW5kKShjb250ZXh0LCBjdXJzb3IpO1xuICAgICAgICBjb250ZXh0LnNvdXJjZSA9IGN1cnJlbnRTb3VyY2U7XG4gICAgICAgIC8vIHJlLXBhcnNlIGF0dHJzIGFuZCBmaWx0ZXIgb3V0IHYtcHJlIGl0c2VsZlxuICAgICAgICBwcm9wcyA9IHBhcnNlQXR0cmlidXRlcyhjb250ZXh0LCB0eXBlKS5maWx0ZXIocCA9PiBwLm5hbWUgIT09ICd2LXByZScpO1xuICAgIH1cbiAgICAvLyBUYWcgY2xvc2UuXG4gICAgbGV0IGlzU2VsZkNsb3NpbmcgPSBmYWxzZTtcbiAgICBpZiAoY29udGV4dC5zb3VyY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA5IC8qIEVycm9yQ29kZXMuRU9GX0lOX1RBRyAqLyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpc1NlbGZDbG9zaW5nID0gc3RhcnRzV2l0aChjb250ZXh0LnNvdXJjZSwgJy8+Jyk7XG4gICAgICAgIGlmICh0eXBlID09PSAxIC8qIFRhZ1R5cGUuRW5kICovICYmIGlzU2VsZkNsb3NpbmcpIHtcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA0IC8qIEVycm9yQ29kZXMuRU5EX1RBR19XSVRIX1RSQUlMSU5HX1NPTElEVVMgKi8pO1xuICAgICAgICB9XG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBpc1NlbGZDbG9zaW5nID8gMiA6IDEpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gMSAvKiBUYWdUeXBlLkVuZCAqLykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIDIueCBkZXByZWNhdGlvbiBjaGVja3NcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgIGlzQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRVwiIC8qIENvbXBpbGVyRGVwcmVjYXRpb25UeXBlcy5DT01QSUxFUl9WX0lGX1ZfRk9SX1BSRUNFREVOQ0UgKi8sIGNvbnRleHQpKSB7XG4gICAgICAgIGxldCBoYXNJZiA9IGZhbHNlO1xuICAgICAgICBsZXQgaGFzRm9yID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBwcm9wc1tpXTtcbiAgICAgICAgICAgIGlmIChwLnR5cGUgPT09IDcgLyogTm9kZVR5cGVzLkRJUkVDVElWRSAqLykge1xuICAgICAgICAgICAgICAgIGlmIChwLm5hbWUgPT09ICdpZicpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzSWYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwLm5hbWUgPT09ICdmb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0ZvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0lmICYmIGhhc0Zvcikge1xuICAgICAgICAgICAgICAgIHdhcm5EZXByZWNhdGlvbihcIkNPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRVwiIC8qIENvbXBpbGVyRGVwcmVjYXRpb25UeXBlcy5DT01QSUxFUl9WX0lGX1ZfRk9SX1BSRUNFREVOQ0UgKi8sIGNvbnRleHQsIGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCB0YWdUeXBlID0gMCAvKiBFbGVtZW50VHlwZXMuRUxFTUVOVCAqLztcbiAgICBpZiAoIWNvbnRleHQuaW5WUHJlKSB7XG4gICAgICAgIGlmICh0YWcgPT09ICdzbG90Jykge1xuICAgICAgICAgICAgdGFnVHlwZSA9IDIgLyogRWxlbWVudFR5cGVzLlNMT1QgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuc29tZShwID0+IHAudHlwZSA9PT0gNyAvKiBOb2RlVHlwZXMuRElSRUNUSVZFICovICYmIGlzU3BlY2lhbFRlbXBsYXRlRGlyZWN0aXZlKHAubmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgdGFnVHlwZSA9IDMgLyogRWxlbWVudFR5cGVzLlRFTVBMQVRFICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ29tcG9uZW50KHRhZywgcHJvcHMsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICB0YWdUeXBlID0gMSAvKiBFbGVtZW50VHlwZXMuQ09NUE9ORU5UICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8sXG4gICAgICAgIG5zLFxuICAgICAgICB0YWcsXG4gICAgICAgIHRhZ1R5cGUsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBpc1NlbGZDbG9zaW5nLFxuICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KSxcbiAgICAgICAgY29kZWdlbk5vZGU6IHVuZGVmaW5lZCAvLyB0byBiZSBjcmVhdGVkIGR1cmluZyB0cmFuc2Zvcm0gcGhhc2VcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNDb21wb25lbnQodGFnLCBwcm9wcywgY29udGV4dCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnMuaXNDdXN0b21FbGVtZW50KHRhZykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnY29tcG9uZW50JyB8fFxuICAgICAgICAvXltBLVpdLy50ZXN0KHRhZykgfHxcbiAgICAgICAgaXNDb3JlQ29tcG9uZW50KHRhZykgfHxcbiAgICAgICAgKG9wdGlvbnMuaXNCdWlsdEluQ29tcG9uZW50ICYmIG9wdGlvbnMuaXNCdWlsdEluQ29tcG9uZW50KHRhZykpIHx8XG4gICAgICAgIChvcHRpb25zLmlzTmF0aXZlVGFnICYmICFvcHRpb25zLmlzTmF0aXZlVGFnKHRhZykpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBhdCB0aGlzIHBvaW50IHRoZSB0YWcgc2hvdWxkIGJlIGEgbmF0aXZlIHRhZywgYnV0IGNoZWNrIGZvciBwb3RlbnRpYWwgXCJpc1wiXG4gICAgLy8gY2FzdGluZ1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcCA9IHByb3BzW2ldO1xuICAgICAgICBpZiAocC50eXBlID09PSA2IC8qIE5vZGVUeXBlcy5BVFRSSUJVVEUgKi8pIHtcbiAgICAgICAgICAgIGlmIChwLm5hbWUgPT09ICdpcycgJiYgcC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChwLnZhbHVlLmNvbnRlbnQuc3RhcnRzV2l0aCgndnVlOicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9JU19PTl9FTEVNRU5UXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX0lTX09OX0VMRU1FTlQgKi8sIGNvbnRleHQsIHAubG9jKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBkaXJlY3RpdmVcbiAgICAgICAgICAgIC8vIHYtaXMgKFRPRE8gRGVwcmVjYXRlKVxuICAgICAgICAgICAgaWYgKHAubmFtZSA9PT0gJ2lzJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAvLyA6aXMgb24gcGxhaW4gZWxlbWVudCAtIG9ubHkgdHJlYXQgYXMgY29tcG9uZW50IGluIGNvbXBhdCBtb2RlXG4gICAgICAgICAgICBwLm5hbWUgPT09ICdiaW5kJyAmJlxuICAgICAgICAgICAgICAgIGlzU3RhdGljQXJnT2YocC5hcmcsICdpcycpICYmXG4gICAgICAgICAgICAgICAgdHJ1ZSAmJlxuICAgICAgICAgICAgICAgIGNoZWNrQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfSVNfT05fRUxFTUVOVCAqLywgY29udGV4dCwgcC5sb2MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMoY29udGV4dCwgdHlwZSkge1xuICAgIGNvbnN0IHByb3BzID0gW107XG4gICAgY29uc3QgYXR0cmlidXRlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgd2hpbGUgKGNvbnRleHQuc291cmNlLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgIXN0YXJ0c1dpdGgoY29udGV4dC5zb3VyY2UsICc+JykgJiZcbiAgICAgICAgIXN0YXJ0c1dpdGgoY29udGV4dC5zb3VyY2UsICcvPicpKSB7XG4gICAgICAgIGlmIChzdGFydHNXaXRoKGNvbnRleHQuc291cmNlLCAnLycpKSB7XG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjIgLyogRXJyb3JDb2Rlcy5VTkVYUEVDVEVEX1NPTElEVVNfSU5fVEFHICovKTtcbiAgICAgICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAxKTtcbiAgICAgICAgICAgIGFkdmFuY2VTcGFjZXMoY29udGV4dCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gMSAvKiBUYWdUeXBlLkVuZCAqLykge1xuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDMgLyogRXJyb3JDb2Rlcy5FTkRfVEFHX1dJVEhfQVRUUklCVVRFUyAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0ciA9IHBhcnNlQXR0cmlidXRlKGNvbnRleHQsIGF0dHJpYnV0ZU5hbWVzKTtcbiAgICAgICAgLy8gVHJpbSB3aGl0ZXNwYWNlIGJldHdlZW4gY2xhc3NcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL2NvcmUvaXNzdWVzLzQyNTFcbiAgICAgICAgaWYgKGF0dHIudHlwZSA9PT0gNiAvKiBOb2RlVHlwZXMuQVRUUklCVVRFICovICYmXG4gICAgICAgICAgICBhdHRyLnZhbHVlICYmXG4gICAgICAgICAgICBhdHRyLm5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgIGF0dHIudmFsdWUuY29udGVudCA9IGF0dHIudmFsdWUuY29udGVudC5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAwIC8qIFRhZ1R5cGUuU3RhcnQgKi8pIHtcbiAgICAgICAgICAgIHByb3BzLnB1c2goYXR0cik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9eW15cXHRcXHJcXG5cXGYgLz5dLy50ZXN0KGNvbnRleHQuc291cmNlKSkge1xuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDE1IC8qIEVycm9yQ29kZXMuTUlTU0lOR19XSElURVNQQUNFX0JFVFdFRU5fQVRUUklCVVRFUyAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgYWR2YW5jZVNwYWNlcyhjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BzO1xufVxuZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGUoY29udGV4dCwgbmFtZVNldCkge1xuICAgIC8vIE5hbWUuXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XG4gICAgY29uc3QgbWF0Y2ggPSAvXlteXFx0XFxyXFxuXFxmIC8+XVteXFx0XFxyXFxuXFxmIC8+PV0qLy5leGVjKGNvbnRleHQuc291cmNlKTtcbiAgICBjb25zdCBuYW1lID0gbWF0Y2hbMF07XG4gICAgaWYgKG5hbWVTZXQuaGFzKG5hbWUpKSB7XG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyIC8qIEVycm9yQ29kZXMuRFVQTElDQVRFX0FUVFJJQlVURSAqLyk7XG4gICAgfVxuICAgIG5hbWVTZXQuYWRkKG5hbWUpO1xuICAgIGlmIChuYW1lWzBdID09PSAnPScpIHtcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDE5IC8qIEVycm9yQ29kZXMuVU5FWFBFQ1RFRF9FUVVBTFNfU0lHTl9CRUZPUkVfQVRUUklCVVRFX05BTUUgKi8pO1xuICAgIH1cbiAgICB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSAvW1wiJzxdL2c7XG4gICAgICAgIGxldCBtO1xuICAgICAgICB3aGlsZSAoKG0gPSBwYXR0ZXJuLmV4ZWMobmFtZSkpKSB7XG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTcgLyogRXJyb3JDb2Rlcy5VTkVYUEVDVEVEX0NIQVJBQ1RFUl9JTl9BVFRSSUJVVEVfTkFNRSAqLywgbS5pbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIG5hbWUubGVuZ3RoKTtcbiAgICAvLyBWYWx1ZVxuICAgIGxldCB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAoL15bXFx0XFxyXFxuXFxmIF0qPS8udGVzdChjb250ZXh0LnNvdXJjZSkpIHtcbiAgICAgICAgYWR2YW5jZVNwYWNlcyhjb250ZXh0KTtcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDEpO1xuICAgICAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlQXR0cmlidXRlVmFsdWUoY29udGV4dCk7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxMyAvKiBFcnJvckNvZGVzLk1JU1NJTkdfQVRUUklCVVRFX1ZBTFVFICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsb2MgPSBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpO1xuICAgIGlmICghY29udGV4dC5pblZQcmUgJiYgL14odi1bQS1aYS16MC05LV18OnxcXC58QHwjKS8udGVzdChuYW1lKSkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IC8oPzpedi0oW2EtejAtOS1dKykpPyg/Oig/Ojp8XlxcLnxeQHxeIykoXFxbW15cXF1dK1xcXXxbXlxcLl0rKSk/KC4rKT8kL2kuZXhlYyhuYW1lKTtcbiAgICAgICAgbGV0IGlzUHJvcFNob3J0aGFuZCA9IHN0YXJ0c1dpdGgobmFtZSwgJy4nKTtcbiAgICAgICAgbGV0IGRpck5hbWUgPSBtYXRjaFsxXSB8fFxuICAgICAgICAgICAgKGlzUHJvcFNob3J0aGFuZCB8fCBzdGFydHNXaXRoKG5hbWUsICc6JylcbiAgICAgICAgICAgICAgICA/ICdiaW5kJ1xuICAgICAgICAgICAgICAgIDogc3RhcnRzV2l0aChuYW1lLCAnQCcpXG4gICAgICAgICAgICAgICAgICAgID8gJ29uJ1xuICAgICAgICAgICAgICAgICAgICA6ICdzbG90Jyk7XG4gICAgICAgIGxldCBhcmc7XG4gICAgICAgIGlmIChtYXRjaFsyXSkge1xuICAgICAgICAgICAgY29uc3QgaXNTbG90ID0gZGlyTmFtZSA9PT0gJ3Nsb3QnO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBuYW1lLmxhc3RJbmRleE9mKG1hdGNoWzJdKTtcbiAgICAgICAgICAgIGNvbnN0IGxvYyA9IGdldFNlbGVjdGlvbihjb250ZXh0LCBnZXROZXdQb3NpdGlvbihjb250ZXh0LCBzdGFydCwgc3RhcnRPZmZzZXQpLCBnZXROZXdQb3NpdGlvbihjb250ZXh0LCBzdGFydCwgc3RhcnRPZmZzZXQgKyBtYXRjaFsyXS5sZW5ndGggKyAoKGlzU2xvdCAmJiBtYXRjaFszXSkgfHwgJycpLmxlbmd0aCkpO1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBtYXRjaFsyXTtcbiAgICAgICAgICAgIGxldCBpc1N0YXRpYyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoY29udGVudC5zdGFydHNXaXRoKCdbJykpIHtcbiAgICAgICAgICAgICAgICBpc1N0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICghY29udGVudC5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyNyAvKiBFcnJvckNvZGVzLlhfTUlTU0lOR19EWU5BTUlDX0RJUkVDVElWRV9BUkdVTUVOVF9FTkQgKi8pO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEsIGNvbnRlbnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNTbG90KSB7XG4gICAgICAgICAgICAgICAgLy8gIzEyNDEgc3BlY2lhbCBjYXNlIGZvciB2LXNsb3Q6IHZ1ZXRpZnkgcmVsaWVzIGV4dGVuc2l2ZWx5IG9uIHNsb3RcbiAgICAgICAgICAgICAgICAvLyBuYW1lcyBjb250YWluaW5nIGRvdHMuIHYtc2xvdCBkb2Vzbid0IGhhdmUgYW55IG1vZGlmaWVycyBhbmQgVnVlIDIueFxuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnRzIHN1Y2ggdXNhZ2Ugc28gd2UgYXJlIGtlZXBpbmcgaXQgY29uc2lzdGVudCB3aXRoIDIueC5cbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IG1hdGNoWzNdIHx8ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgaXNTdGF0aWMsXG4gICAgICAgICAgICAgICAgY29uc3RUeXBlOiBpc1N0YXRpY1xuICAgICAgICAgICAgICAgICAgICA/IDMgLyogQ29uc3RhbnRUeXBlcy5DQU5fU1RSSU5HSUZZICovXG4gICAgICAgICAgICAgICAgICAgIDogMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLyxcbiAgICAgICAgICAgICAgICBsb2NcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmlzUXVvdGVkKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUxvYyA9IHZhbHVlLmxvYztcbiAgICAgICAgICAgIHZhbHVlTG9jLnN0YXJ0Lm9mZnNldCsrO1xuICAgICAgICAgICAgdmFsdWVMb2Muc3RhcnQuY29sdW1uKys7XG4gICAgICAgICAgICB2YWx1ZUxvYy5lbmQgPSBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUodmFsdWVMb2Muc3RhcnQsIHZhbHVlLmNvbnRlbnQpO1xuICAgICAgICAgICAgdmFsdWVMb2Muc291cmNlID0gdmFsdWVMb2Muc291cmNlLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RpZmllcnMgPSBtYXRjaFszXSA/IG1hdGNoWzNdLnNsaWNlKDEpLnNwbGl0KCcuJykgOiBbXTtcbiAgICAgICAgaWYgKGlzUHJvcFNob3J0aGFuZClcbiAgICAgICAgICAgIG1vZGlmaWVycy5wdXNoKCdwcm9wJyk7XG4gICAgICAgIC8vIDIueCBjb21wYXQgdi1iaW5kOmZvby5zeW5jIC0+IHYtbW9kZWw6Zm9vXG4gICAgICAgIGlmIChkaXJOYW1lID09PSAnYmluZCcgJiYgYXJnKSB7XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdzeW5jJykgJiZcbiAgICAgICAgICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9WX0JJTkRfU1lOQ1wiIC8qIENvbXBpbGVyRGVwcmVjYXRpb25UeXBlcy5DT01QSUxFUl9WX0JJTkRfU1lOQyAqLywgY29udGV4dCwgbG9jLCBhcmcubG9jLnNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBkaXJOYW1lID0gJ21vZGVsJztcbiAgICAgICAgICAgICAgICBtb2RpZmllcnMuc3BsaWNlKG1vZGlmaWVycy5pbmRleE9mKCdzeW5jJyksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBtb2RpZmllcnMuaW5jbHVkZXMoJ3Byb3AnKSkge1xuICAgICAgICAgICAgICAgIGNoZWNrQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX1ZfQklORF9QUk9QXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX1ZfQklORF9QUk9QICovLCBjb250ZXh0LCBsb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiA3IC8qIE5vZGVUeXBlcy5ESVJFQ1RJVkUgKi8sXG4gICAgICAgICAgICBuYW1lOiBkaXJOYW1lLFxuICAgICAgICAgICAgZXhwOiB2YWx1ZSAmJiB7XG4gICAgICAgICAgICAgICAgdHlwZTogNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8sXG4gICAgICAgICAgICAgICAgY29udGVudDogdmFsdWUuY29udGVudCxcbiAgICAgICAgICAgICAgICBpc1N0YXRpYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgLy8gVHJlYXQgYXMgbm9uLWNvbnN0YW50IGJ5IGRlZmF1bHQuIFRoaXMgY2FuIGJlIHBvdGVudGlhbGx5IHNldCB0b1xuICAgICAgICAgICAgICAgIC8vIG90aGVyIHZhbHVlcyBieSBgdHJhbnNmb3JtRXhwcmVzc2lvbmAgdG8gbWFrZSBpdCBlbGlnaWJsZSBmb3IgaG9pc3RpbmcuXG4gICAgICAgICAgICAgICAgY29uc3RUeXBlOiAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovLFxuICAgICAgICAgICAgICAgIGxvYzogdmFsdWUubG9jXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnLFxuICAgICAgICAgICAgbW9kaWZpZXJzLFxuICAgICAgICAgICAgbG9jXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIG1pc3NpbmcgZGlyZWN0aXZlIG5hbWUgb3IgaWxsZWdhbCBkaXJlY3RpdmUgbmFtZVxuICAgIGlmICghY29udGV4dC5pblZQcmUgJiYgc3RhcnRzV2l0aChuYW1lLCAndi0nKSkge1xuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjYgLyogRXJyb3JDb2Rlcy5YX01JU1NJTkdfRElSRUNUSVZFX05BTUUgKi8pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiA2IC8qIE5vZGVUeXBlcy5BVFRSSUJVVEUgKi8sXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSAmJiB7XG4gICAgICAgICAgICB0eXBlOiAyIC8qIE5vZGVUeXBlcy5URVhUICovLFxuICAgICAgICAgICAgY29udGVudDogdmFsdWUuY29udGVudCxcbiAgICAgICAgICAgIGxvYzogdmFsdWUubG9jXG4gICAgICAgIH0sXG4gICAgICAgIGxvY1xuICAgIH07XG59XG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZVZhbHVlKGNvbnRleHQpIHtcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcbiAgICBsZXQgY29udGVudDtcbiAgICBjb25zdCBxdW90ZSA9IGNvbnRleHQuc291cmNlWzBdO1xuICAgIGNvbnN0IGlzUXVvdGVkID0gcXVvdGUgPT09IGBcImAgfHwgcXVvdGUgPT09IGAnYDtcbiAgICBpZiAoaXNRdW90ZWQpIHtcbiAgICAgICAgLy8gUXVvdGVkIHZhbHVlLlxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgMSk7XG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gY29udGV4dC5zb3VyY2UuaW5kZXhPZihxdW90ZSk7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIGNvbnRleHQuc291cmNlLmxlbmd0aCwgNCAvKiBUZXh0TW9kZXMuQVRUUklCVVRFX1ZBTFVFICovKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIGVuZEluZGV4LCA0IC8qIFRleHRNb2Rlcy5BVFRSSUJVVEVfVkFMVUUgKi8pO1xuICAgICAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBVbnF1b3RlZFxuICAgICAgICBjb25zdCBtYXRjaCA9IC9eW15cXHRcXHJcXG5cXGYgPl0rLy5leGVjKGNvbnRleHQuc291cmNlKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bmV4cGVjdGVkQ2hhcnMgPSAvW1wiJzw9YF0vZztcbiAgICAgICAgbGV0IG07XG4gICAgICAgIHdoaWxlICgobSA9IHVuZXhwZWN0ZWRDaGFycy5leGVjKG1hdGNoWzBdKSkpIHtcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxOCAvKiBFcnJvckNvZGVzLlVORVhQRUNURURfQ0hBUkFDVEVSX0lOX1VOUVVPVEVEX0FUVFJJQlVURV9WQUxVRSAqLywgbS5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudCA9IHBhcnNlVGV4dERhdGEoY29udGV4dCwgbWF0Y2hbMF0ubGVuZ3RoLCA0IC8qIFRleHRNb2Rlcy5BVFRSSUJVVEVfVkFMVUUgKi8pO1xuICAgIH1cbiAgICByZXR1cm4geyBjb250ZW50LCBpc1F1b3RlZCwgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpIH07XG59XG5mdW5jdGlvbiBwYXJzZUludGVycG9sYXRpb24oY29udGV4dCwgbW9kZSkge1xuICAgIGNvbnN0IFtvcGVuLCBjbG9zZV0gPSBjb250ZXh0Lm9wdGlvbnMuZGVsaW1pdGVycztcbiAgICBjb25zdCBjbG9zZUluZGV4ID0gY29udGV4dC5zb3VyY2UuaW5kZXhPZihjbG9zZSwgb3Blbi5sZW5ndGgpO1xuICAgIGlmIChjbG9zZUluZGV4ID09PSAtMSkge1xuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjUgLyogRXJyb3JDb2Rlcy5YX01JU1NJTkdfSU5URVJQT0xBVElPTl9FTkQgKi8pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgb3Blbi5sZW5ndGgpO1xuICAgIGNvbnN0IGlubmVyU3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XG4gICAgY29uc3QgaW5uZXJFbmQgPSBnZXRDdXJzb3IoY29udGV4dCk7XG4gICAgY29uc3QgcmF3Q29udGVudExlbmd0aCA9IGNsb3NlSW5kZXggLSBvcGVuLmxlbmd0aDtcbiAgICBjb25zdCByYXdDb250ZW50ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoMCwgcmF3Q29udGVudExlbmd0aCk7XG4gICAgY29uc3QgcHJlVHJpbUNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIHJhd0NvbnRlbnRMZW5ndGgsIG1vZGUpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBwcmVUcmltQ29udGVudC50cmltKCk7XG4gICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBwcmVUcmltQ29udGVudC5pbmRleE9mKGNvbnRlbnQpO1xuICAgIGlmIChzdGFydE9mZnNldCA+IDApIHtcbiAgICAgICAgYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uKGlubmVyU3RhcnQsIHJhd0NvbnRlbnQsIHN0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZW5kT2Zmc2V0ID0gcmF3Q29udGVudExlbmd0aCAtIChwcmVUcmltQ29udGVudC5sZW5ndGggLSBjb250ZW50Lmxlbmd0aCAtIHN0YXJ0T2Zmc2V0KTtcbiAgICBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24oaW5uZXJFbmQsIHJhd0NvbnRlbnQsIGVuZE9mZnNldCk7XG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIGNsb3NlLmxlbmd0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogNSAvKiBOb2RlVHlwZXMuSU5URVJQT0xBVElPTiAqLyxcbiAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgdHlwZTogNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8sXG4gICAgICAgICAgICBpc1N0YXRpYzogZmFsc2UsXG4gICAgICAgICAgICAvLyBTZXQgYGlzQ29uc3RhbnRgIHRvIGZhbHNlIGJ5IGRlZmF1bHQgYW5kIHdpbGwgZGVjaWRlIGluIHRyYW5zZm9ybUV4cHJlc3Npb25cbiAgICAgICAgICAgIGNvbnN0VHlwZTogMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLyxcbiAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBpbm5lclN0YXJ0LCBpbm5lckVuZClcbiAgICAgICAgfSxcbiAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVGV4dChjb250ZXh0LCBtb2RlKSB7XG4gICAgY29uc3QgZW5kVG9rZW5zID0gbW9kZSA9PT0gMyAvKiBUZXh0TW9kZXMuQ0RBVEEgKi8gPyBbJ11dPiddIDogWyc8JywgY29udGV4dC5vcHRpb25zLmRlbGltaXRlcnNbMF1dO1xuICAgIGxldCBlbmRJbmRleCA9IGNvbnRleHQuc291cmNlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuZFRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpbmRleCA9IGNvbnRleHQuc291cmNlLmluZGV4T2YoZW5kVG9rZW5zW2ldLCAxKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSAmJiBlbmRJbmRleCA+IGluZGV4KSB7XG4gICAgICAgICAgICBlbmRJbmRleCA9IGluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIGVuZEluZGV4LCBtb2RlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAyIC8qIE5vZGVUeXBlcy5URVhUICovLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydClcbiAgICB9O1xufVxuLyoqXG4gKiBHZXQgdGV4dCBkYXRhIHdpdGggYSBnaXZlbiBsZW5ndGggZnJvbSB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqIFRoaXMgdHJhbnNsYXRlcyBIVE1MIGVudGl0aWVzIGluIHRoZSB0ZXh0IGRhdGEuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVGV4dERhdGEoY29udGV4dCwgbGVuZ3RoLCBtb2RlKSB7XG4gICAgY29uc3QgcmF3VGV4dCA9IGNvbnRleHQuc291cmNlLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIGxlbmd0aCk7XG4gICAgaWYgKG1vZGUgPT09IDIgLyogVGV4dE1vZGVzLlJBV1RFWFQgKi8gfHxcbiAgICAgICAgbW9kZSA9PT0gMyAvKiBUZXh0TW9kZXMuQ0RBVEEgKi8gfHxcbiAgICAgICAgIXJhd1RleHQuaW5jbHVkZXMoJyYnKSkge1xuICAgICAgICByZXR1cm4gcmF3VGV4dDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIERBVEEgb3IgUkNEQVRBIGNvbnRhaW5pbmcgXCImXCJcIi4gRW50aXR5IGRlY29kaW5nIHJlcXVpcmVkLlxuICAgICAgICByZXR1cm4gY29udGV4dC5vcHRpb25zLmRlY29kZUVudGl0aWVzKHJhd1RleHQsIG1vZGUgPT09IDQgLyogVGV4dE1vZGVzLkFUVFJJQlVURV9WQUxVRSAqLyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q3Vyc29yKGNvbnRleHQpIHtcbiAgICBjb25zdCB7IGNvbHVtbiwgbGluZSwgb2Zmc2V0IH0gPSBjb250ZXh0O1xuICAgIHJldHVybiB7IGNvbHVtbiwgbGluZSwgb2Zmc2V0IH07XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQsIGVuZCkge1xuICAgIGVuZCA9IGVuZCB8fCBnZXRDdXJzb3IoY29udGV4dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZCxcbiAgICAgICAgc291cmNlOiBjb250ZXh0Lm9yaWdpbmFsU291cmNlLnNsaWNlKHN0YXJ0Lm9mZnNldCwgZW5kLm9mZnNldClcbiAgICB9O1xufVxuZnVuY3Rpb24gbGFzdCh4cykge1xuICAgIHJldHVybiB4c1t4cy5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc291cmNlLCBzZWFyY2hTdHJpbmcpIHtcbiAgICByZXR1cm4gc291cmNlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nKTtcbn1cbmZ1bmN0aW9uIGFkdmFuY2VCeShjb250ZXh0LCBudW1iZXJPZkNoYXJhY3RlcnMpIHtcbiAgICBjb25zdCB7IHNvdXJjZSB9ID0gY29udGV4dDtcbiAgICBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24oY29udGV4dCwgc291cmNlLCBudW1iZXJPZkNoYXJhY3RlcnMpO1xuICAgIGNvbnRleHQuc291cmNlID0gc291cmNlLnNsaWNlKG51bWJlck9mQ2hhcmFjdGVycyk7XG59XG5mdW5jdGlvbiBhZHZhbmNlU3BhY2VzKGNvbnRleHQpIHtcbiAgICBjb25zdCBtYXRjaCA9IC9eW1xcdFxcclxcblxcZiBdKy8uZXhlYyhjb250ZXh0LnNvdXJjZSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBtYXRjaFswXS5sZW5ndGgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldE5ld1Bvc2l0aW9uKGNvbnRleHQsIHN0YXJ0LCBudW1iZXJPZkNoYXJhY3RlcnMpIHtcbiAgICByZXR1cm4gYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lKHN0YXJ0LCBjb250ZXh0Lm9yaWdpbmFsU291cmNlLnNsaWNlKHN0YXJ0Lm9mZnNldCwgbnVtYmVyT2ZDaGFyYWN0ZXJzKSwgbnVtYmVyT2ZDaGFyYWN0ZXJzKTtcbn1cbmZ1bmN0aW9uIGVtaXRFcnJvcihjb250ZXh0LCBjb2RlLCBvZmZzZXQsIGxvYyA9IGdldEN1cnNvcihjb250ZXh0KSkge1xuICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgbG9jLm9mZnNldCArPSBvZmZzZXQ7XG4gICAgICAgIGxvYy5jb2x1bW4gKz0gb2Zmc2V0O1xuICAgIH1cbiAgICBjb250ZXh0Lm9wdGlvbnMub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKGNvZGUsIHtcbiAgICAgICAgc3RhcnQ6IGxvYyxcbiAgICAgICAgZW5kOiBsb2MsXG4gICAgICAgIHNvdXJjZTogJydcbiAgICB9KSk7XG59XG5mdW5jdGlvbiBpc0VuZChjb250ZXh0LCBtb2RlLCBhbmNlc3RvcnMpIHtcbiAgICBjb25zdCBzID0gY29udGV4dC5zb3VyY2U7XG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgIGNhc2UgMCAvKiBUZXh0TW9kZXMuREFUQSAqLzpcbiAgICAgICAgICAgIGlmIChzdGFydHNXaXRoKHMsICc8LycpKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcHJvYmFibHkgYmFkIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGFuY2VzdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRzV2l0aEVuZFRhZ09wZW4ocywgYW5jZXN0b3JzW2ldLnRhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBUZXh0TW9kZXMuUkNEQVRBICovOlxuICAgICAgICBjYXNlIDIgLyogVGV4dE1vZGVzLlJBV1RFWFQgKi86IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGxhc3QoYW5jZXN0b3JzKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgc3RhcnRzV2l0aEVuZFRhZ09wZW4ocywgcGFyZW50LnRhZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMyAvKiBUZXh0TW9kZXMuQ0RBVEEgKi86XG4gICAgICAgICAgICBpZiAoc3RhcnRzV2l0aChzLCAnXV0+JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gIXM7XG59XG5mdW5jdGlvbiBzdGFydHNXaXRoRW5kVGFnT3Blbihzb3VyY2UsIHRhZykge1xuICAgIHJldHVybiAoc3RhcnRzV2l0aChzb3VyY2UsICc8LycpICYmXG4gICAgICAgIHNvdXJjZS5zbGljZSgyLCAyICsgdGFnLmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gdGFnLnRvTG93ZXJDYXNlKCkgJiZcbiAgICAgICAgL1tcXHRcXHJcXG5cXGYgLz5dLy50ZXN0KHNvdXJjZVsyICsgdGFnLmxlbmd0aF0gfHwgJz4nKSk7XG59XG5mdW5jdGlvbiBob2lzdFN0YXRpYyhyb290LCBjb250ZXh0KSB7XG4gICAgd2Fsayhyb290LCBjb250ZXh0LCBcbiAgICAvLyBSb290IG5vZGUgaXMgdW5mb3J0dW5hdGVseSBub24taG9pc3RhYmxlIGR1ZSB0byBwb3RlbnRpYWwgcGFyZW50XG4gICAgLy8gZmFsbHRocm91Z2ggYXR0cmlidXRlcy5cbiAgICBpc1NpbmdsZUVsZW1lbnRSb290KHJvb3QsIHJvb3QuY2hpbGRyZW5bMF0pKTtcbn1cbmZ1bmN0aW9uIGlzU2luZ2xlRWxlbWVudFJvb3Qocm9vdCwgY2hpbGQpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSByb290O1xuICAgIHJldHVybiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGNoaWxkLnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8gJiZcbiAgICAgICAgIWlzU2xvdE91dGxldChjaGlsZCkpO1xufVxuZnVuY3Rpb24gd2Fsayhub2RlLCBjb250ZXh0LCBkb05vdEhvaXN0Tm9kZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gbm9kZTtcbiAgICBjb25zdCBvcmlnaW5hbENvdW50ID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGxldCBob2lzdGVkQ291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgLy8gb25seSBwbGFpbiBlbGVtZW50cyAmIHRleHQgY2FsbHMgYXJlIGVsaWdpYmxlIGZvciBob2lzdGluZy5cbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8gJiZcbiAgICAgICAgICAgIGNoaWxkLnRhZ1R5cGUgPT09IDAgLyogRWxlbWVudFR5cGVzLkVMRU1FTlQgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnN0YW50VHlwZSA9IGRvTm90SG9pc3ROb2RlXG4gICAgICAgICAgICAgICAgPyAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovXG4gICAgICAgICAgICAgICAgOiBnZXRDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGNvbnN0YW50VHlwZSA+IDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uc3RhbnRUeXBlID49IDIgLyogQ29uc3RhbnRUeXBlcy5DQU5fSE9JU1QgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuY29kZWdlbk5vZGUucGF0Y2hGbGFnID1cbiAgICAgICAgICAgICAgICAgICAgICAgIC0xIC8qIFBhdGNoRmxhZ3MuSE9JU1RFRCAqLyArICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qIEhPSVNURUQgKi9gIDogYGApO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5jb2RlZ2VuTm9kZSA9IGNvbnRleHQuaG9pc3QoY2hpbGQuY29kZWdlbk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBob2lzdGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm9kZSBtYXkgY29udGFpbiBkeW5hbWljIGNoaWxkcmVuLCBidXQgaXRzIHByb3BzIG1heSBiZSBlbGlnaWJsZSBmb3JcbiAgICAgICAgICAgICAgICAvLyBob2lzdGluZy5cbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlZ2VuTm9kZSA9IGNoaWxkLmNvZGVnZW5Ob2RlO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlZ2VuTm9kZS50eXBlID09PSAxMyAvKiBOb2RlVHlwZXMuVk5PREVfQ0FMTCAqLykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbGFnID0gZ2V0UGF0Y2hGbGFnKGNvZGVnZW5Ob2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCghZmxhZyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZyA9PT0gNTEyIC8qIFBhdGNoRmxhZ3MuTkVFRF9QQVRDSCAqLyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZyA9PT0gMSAvKiBQYXRjaEZsYWdzLlRFWFQgKi8pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRHZW5lcmF0ZWRQcm9wc0NvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCkgPj1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyIC8qIENvbnN0YW50VHlwZXMuQ0FOX0hPSVNUICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IGdldE5vZGVQcm9wcyhjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlZ2VuTm9kZS5wcm9wcyA9IGNvbnRleHQuaG9pc3QocHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlZ2VuTm9kZS5keW5hbWljUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVnZW5Ob2RlLmR5bmFtaWNQcm9wcyA9IGNvbnRleHQuaG9pc3QoY29kZWdlbk5vZGUuZHluYW1pY1Byb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB3YWxrIGZ1cnRoZXJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IGlzQ29tcG9uZW50ID0gY2hpbGQudGFnVHlwZSA9PT0gMSAvKiBFbGVtZW50VHlwZXMuQ09NUE9ORU5UICovO1xuICAgICAgICAgICAgaWYgKGlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zY29wZXMudlNsb3QrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdhbGsoY2hpbGQsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zY29wZXMudlNsb3QtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSAxMSAvKiBOb2RlVHlwZXMuRk9SICovKSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgaG9pc3Qgdi1mb3Igc2luZ2xlIGNoaWxkIGJlY2F1c2UgaXQgaGFzIHRvIGJlIGEgYmxvY2tcbiAgICAgICAgICAgIHdhbGsoY2hpbGQsIGNvbnRleHQsIGNoaWxkLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gOSAvKiBOb2RlVHlwZXMuSUYgKi8pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGQuYnJhbmNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgaG9pc3Qgdi1pZiBzaW5nbGUgY2hpbGQgYmVjYXVzZSBpdCBoYXMgdG8gYmUgYSBibG9ja1xuICAgICAgICAgICAgICAgIHdhbGsoY2hpbGQuYnJhbmNoZXNbaV0sIGNvbnRleHQsIGNoaWxkLmJyYW5jaGVzW2ldLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhvaXN0ZWRDb3VudCAmJiBjb250ZXh0LnRyYW5zZm9ybUhvaXN0KSB7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtSG9pc3QoY2hpbGRyZW4sIGNvbnRleHQsIG5vZGUpO1xuICAgIH1cbiAgICAvLyBhbGwgY2hpbGRyZW4gd2VyZSBob2lzdGVkIC0gdGhlIGVudGlyZSBjaGlsZHJlbiBhcnJheSBpcyBob2lzdGFibGUuXG4gICAgaWYgKGhvaXN0ZWRDb3VudCAmJlxuICAgICAgICBob2lzdGVkQ291bnQgPT09IG9yaWdpbmFsQ291bnQgJiZcbiAgICAgICAgbm9kZS50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovICYmXG4gICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMCAvKiBFbGVtZW50VHlwZXMuRUxFTUVOVCAqLyAmJlxuICAgICAgICBub2RlLmNvZGVnZW5Ob2RlICYmXG4gICAgICAgIG5vZGUuY29kZWdlbk5vZGUudHlwZSA9PT0gMTMgLyogTm9kZVR5cGVzLlZOT0RFX0NBTEwgKi8gJiZcbiAgICAgICAgKDAsIHNoYXJlZF8xLmlzQXJyYXkpKG5vZGUuY29kZWdlbk5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICAgIG5vZGUuY29kZWdlbk5vZGUuY2hpbGRyZW4gPSBjb250ZXh0LmhvaXN0KGNyZWF0ZUFycmF5RXhwcmVzc2lvbihub2RlLmNvZGVnZW5Ob2RlLmNoaWxkcmVuKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29uc3RhbnRUeXBlKG5vZGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IGNvbnN0YW50Q2FjaGUgfSA9IGNvbnRleHQ7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovOlxuICAgICAgICAgICAgaWYgKG5vZGUudGFnVHlwZSAhPT0gMCAvKiBFbGVtZW50VHlwZXMuRUxFTUVOVCAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gY29uc3RhbnRDYWNoZS5nZXQobm9kZSk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29kZWdlbk5vZGUgPSBub2RlLmNvZGVnZW5Ob2RlO1xuICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgIT09IDEzIC8qIE5vZGVUeXBlcy5WTk9ERV9DQUxMICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29kZWdlbk5vZGUuaXNCbG9jayAmJlxuICAgICAgICAgICAgICAgIG5vZGUudGFnICE9PSAnc3ZnJyAmJlxuICAgICAgICAgICAgICAgIG5vZGUudGFnICE9PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZsYWcgPSBnZXRQYXRjaEZsYWcoY29kZWdlbk5vZGUpO1xuICAgICAgICAgICAgaWYgKCFmbGFnKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJldHVyblR5cGUgPSAzIC8qIENvbnN0YW50VHlwZXMuQ0FOX1NUUklOR0lGWSAqLztcbiAgICAgICAgICAgICAgICAvLyBFbGVtZW50IGl0c2VsZiBoYXMgbm8gcGF0Y2ggZmxhZy4gSG93ZXZlciB3ZSBzdGlsbCBuZWVkIHRvIGNoZWNrOlxuICAgICAgICAgICAgICAgIC8vIDEuIEV2ZW4gZm9yIGEgbm9kZSB3aXRoIG5vIHBhdGNoIGZsYWcsIGl0IGlzIHBvc3NpYmxlIGZvciBpdCB0byBjb250YWluXG4gICAgICAgICAgICAgICAgLy8gbm9uLWhvaXN0YWJsZSBleHByZXNzaW9ucyB0aGF0IHJlZmVycyB0byBzY29wZSB2YXJpYWJsZXMsIGUuZy4gY29tcGlsZXJcbiAgICAgICAgICAgICAgICAvLyBpbmplY3RlZCBrZXlzIG9yIGNhY2hlZCBldmVudCBoYW5kbGVycy4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gYWx3YXlzXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhlIGNvZGVnZW5Ob2RlJ3MgcHJvcHMgdG8gYmUgc3VyZS5cbiAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWRQcm9wc1R5cGUgPSBnZXRHZW5lcmF0ZWRQcm9wc0NvbnN0YW50VHlwZShub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGVkUHJvcHNUeXBlID09PSAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi8pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRlZFByb3BzVHlwZSA8IHJldHVyblR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IGdlbmVyYXRlZFByb3BzVHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gMi4gaXRzIGNoaWxkcmVuLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSBnZXRDb25zdGFudFR5cGUobm9kZS5jaGlsZHJlbltpXSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFR5cGUgPT09IDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkVHlwZSA8IHJldHVyblR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBjaGlsZFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gMy4gaWYgdGhlIHR5cGUgaXMgbm90IGFscmVhZHkgQ0FOX1NLSVBfUEFUQ0ggd2hpY2ggaXMgdGhlIGxvd2VzdCBub24tMFxuICAgICAgICAgICAgICAgIC8vIHR5cGUsIGNoZWNrIGlmIGFueSBvZiB0aGUgcHJvcHMgY2FuIGNhdXNlIHRoZSB0eXBlIHRvIGJlIGxvd2VyZWRcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gc2tpcCBjYW5fcGF0Y2ggYmVjYXVzZSBpdCdzIGd1YXJhbnRlZWQgYnkgdGhlIGFic2VuY2Ugb2YgYVxuICAgICAgICAgICAgICAgIC8vIHBhdGNoRmxhZy5cbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuVHlwZSA+IDEgLyogQ29uc3RhbnRUeXBlcy5DQU5fU0tJUF9QQVRDSCAqLykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gNyAvKiBOb2RlVHlwZXMuRElSRUNUSVZFICovICYmIHAubmFtZSA9PT0gJ2JpbmQnICYmIHAuZXhwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwVHlwZSA9IGdldENvbnN0YW50VHlwZShwLmV4cCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cFR5cGUgPT09IDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwVHlwZSA8IHJldHVyblR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IGV4cFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG9ubHkgc3ZnL2ZvcmVpZ25PYmplY3QgY291bGQgYmUgYmxvY2sgaGVyZSwgaG93ZXZlciBpZiB0aGV5IGFyZVxuICAgICAgICAgICAgICAgIC8vIHN0YXRpYyB0aGVuIHRoZXkgZG9uJ3QgbmVlZCB0byBiZSBibG9ja3Mgc2luY2UgdGhlcmUgd2lsbCBiZSBub1xuICAgICAgICAgICAgICAgIC8vIG5lc3RlZCB1cGRhdGVzLlxuICAgICAgICAgICAgICAgIGlmIChjb2RlZ2VuTm9kZS5pc0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGV4Y2VwdCBzZXQgY3VzdG9tIGRpcmVjdGl2ZXMuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC50eXBlID09PSA3IC8qIE5vZGVUeXBlcy5ESVJFQ1RJVkUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudENhY2hlLnNldChub2RlLCAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZUhlbHBlcihPUEVOX0JMT0NLKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdmVIZWxwZXIoZ2V0Vk5vZGVCbG9ja0hlbHBlcihjb250ZXh0LmluU1NSLCBjb2RlZ2VuTm9kZS5pc0NvbXBvbmVudCkpO1xuICAgICAgICAgICAgICAgICAgICBjb2RlZ2VuTm9kZS5pc0Jsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKGdldFZOb2RlSGVscGVyKGNvbnRleHQuaW5TU1IsIGNvZGVnZW5Ob2RlLmlzQ29tcG9uZW50KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIHJldHVyblR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5UeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgMiAvKiBOb2RlVHlwZXMuVEVYVCAqLzpcbiAgICAgICAgY2FzZSAzIC8qIE5vZGVUeXBlcy5DT01NRU5UICovOlxuICAgICAgICAgICAgcmV0dXJuIDMgLyogQ29uc3RhbnRUeXBlcy5DQU5fU1RSSU5HSUZZICovO1xuICAgICAgICBjYXNlIDkgLyogTm9kZVR5cGVzLklGICovOlxuICAgICAgICBjYXNlIDExIC8qIE5vZGVUeXBlcy5GT1IgKi86XG4gICAgICAgIGNhc2UgMTAgLyogTm9kZVR5cGVzLklGX0JSQU5DSCAqLzpcbiAgICAgICAgICAgIHJldHVybiAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovO1xuICAgICAgICBjYXNlIDUgLyogTm9kZVR5cGVzLklOVEVSUE9MQVRJT04gKi86XG4gICAgICAgIGNhc2UgMTIgLyogTm9kZVR5cGVzLlRFWFRfQ0FMTCAqLzpcbiAgICAgICAgICAgIHJldHVybiBnZXRDb25zdGFudFR5cGUobm9kZS5jb250ZW50LCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLzpcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNvbnN0VHlwZTtcbiAgICAgICAgY2FzZSA4IC8qIE5vZGVUeXBlcy5DT01QT1VORF9FWFBSRVNTSU9OICovOlxuICAgICAgICAgICAgbGV0IHJldHVyblR5cGUgPSAzIC8qIENvbnN0YW50VHlwZXMuQ0FOX1NUUklOR0lGWSAqLztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIHNoYXJlZF8xLmlzU3RyaW5nKShjaGlsZCkgfHwgKDAsIHNoYXJlZF8xLmlzU3ltYm9sKShjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkVHlwZSA9IGdldENvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkVHlwZSA9PT0gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGRUeXBlIDwgcmV0dXJuVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gY2hpbGRUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXR1cm5UeXBlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSlcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICByZXR1cm4gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLztcbiAgICB9XG59XG5leHBvcnRzLmdldENvbnN0YW50VHlwZSA9IGdldENvbnN0YW50VHlwZTtcbmNvbnN0IGFsbG93SG9pc3RlZEhlbHBlclNldCA9IG5ldyBTZXQoW1xuICAgIE5PUk1BTElaRV9DTEFTUyxcbiAgICBOT1JNQUxJWkVfU1RZTEUsXG4gICAgTk9STUFMSVpFX1BST1BTLFxuICAgIEdVQVJEX1JFQUNUSVZFX1BST1BTXG5dKTtcbmZ1bmN0aW9uIGdldENvbnN0YW50VHlwZU9mSGVscGVyQ2FsbCh2YWx1ZSwgY29udGV4dCkge1xuICAgIGlmICh2YWx1ZS50eXBlID09PSAxNCAvKiBOb2RlVHlwZXMuSlNfQ0FMTF9FWFBSRVNTSU9OICovICYmXG4gICAgICAgICEoMCwgc2hhcmVkXzEuaXNTdHJpbmcpKHZhbHVlLmNhbGxlZSkgJiZcbiAgICAgICAgYWxsb3dIb2lzdGVkSGVscGVyU2V0Lmhhcyh2YWx1ZS5jYWxsZWUpKSB7XG4gICAgICAgIGNvbnN0IGFyZyA9IHZhbHVlLmFyZ3VtZW50c1swXTtcbiAgICAgICAgaWYgKGFyZy50eXBlID09PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbnN0YW50VHlwZShhcmcsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZy50eXBlID09PSAxNCAvKiBOb2RlVHlwZXMuSlNfQ0FMTF9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgICAgICAvLyBpbiB0aGUgY2FzZSBvZiBuZXN0ZWQgaGVscGVyIGNhbGwsIGUuZy4gYG5vcm1hbGl6ZVByb3BzKGd1YXJkUmVhY3RpdmVQcm9wcyhleHApKWBcbiAgICAgICAgICAgIHJldHVybiBnZXRDb25zdGFudFR5cGVPZkhlbHBlckNhbGwoYXJnLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLztcbn1cbmZ1bmN0aW9uIGdldEdlbmVyYXRlZFByb3BzQ29uc3RhbnRUeXBlKG5vZGUsIGNvbnRleHQpIHtcbiAgICBsZXQgcmV0dXJuVHlwZSA9IDMgLyogQ29uc3RhbnRUeXBlcy5DQU5fU1RSSU5HSUZZICovO1xuICAgIGNvbnN0IHByb3BzID0gZ2V0Tm9kZVByb3BzKG5vZGUpO1xuICAgIGlmIChwcm9wcyAmJiBwcm9wcy50eXBlID09PSAxNSAvKiBOb2RlVHlwZXMuSlNfT0JKRUNUX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBwcm9wcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICBjb25zdCBrZXlUeXBlID0gZ2V0Q29uc3RhbnRUeXBlKGtleSwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoa2V5VHlwZSA9PT0gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXlUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleVR5cGUgPCByZXR1cm5UeXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IGtleVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsdWVUeXBlO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gZ2V0Q29uc3RhbnRUeXBlKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLnR5cGUgPT09IDE0IC8qIE5vZGVUeXBlcy5KU19DQUxMX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBzb21lIGhlbHBlciBjYWxscyBjYW4gYmUgaG9pc3RlZCxcbiAgICAgICAgICAgICAgICAvLyBzdWNoIGFzIHRoZSBgbm9ybWFsaXplUHJvcHNgIGdlbmVyYXRlZCBieSB0aGUgY29tcGlsZXIgZm9yIHByZS1ub3JtYWxpemUgY2xhc3MsXG4gICAgICAgICAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gcmVzcGVjdCB0aGUgQ29uc3RhbnRUeXBlIG9mIHRoZSBoZWxwZXIncyBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSBnZXRDb25zdGFudFR5cGVPZkhlbHBlckNhbGwodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUgPT09IDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSA8IHJldHVyblR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gdmFsdWVUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5UeXBlO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZVByb3BzKG5vZGUpIHtcbiAgICBjb25zdCBjb2RlZ2VuTm9kZSA9IG5vZGUuY29kZWdlbk5vZGU7XG4gICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzIC8qIE5vZGVUeXBlcy5WTk9ERV9DQUxMICovKSB7XG4gICAgICAgIHJldHVybiBjb2RlZ2VuTm9kZS5wcm9wcztcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRQYXRjaEZsYWcobm9kZSkge1xuICAgIGNvbnN0IGZsYWcgPSBub2RlLnBhdGNoRmxhZztcbiAgICByZXR1cm4gZmxhZyA/IHBhcnNlSW50KGZsYWcsIDEwKSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybUNvbnRleHQocm9vdCwgeyBmaWxlbmFtZSA9ICcnLCBwcmVmaXhJZGVudGlmaWVycyA9IGZhbHNlLCBob2lzdFN0YXRpYyA9IGZhbHNlLCBjYWNoZUhhbmRsZXJzID0gZmFsc2UsIG5vZGVUcmFuc2Zvcm1zID0gW10sIGRpcmVjdGl2ZVRyYW5zZm9ybXMgPSB7fSwgdHJhbnNmb3JtSG9pc3QgPSBudWxsLCBpc0J1aWx0SW5Db21wb25lbnQgPSBzaGFyZWRfMS5OT09QLCBpc0N1c3RvbUVsZW1lbnQgPSBzaGFyZWRfMS5OT09QLCBleHByZXNzaW9uUGx1Z2lucyA9IFtdLCBzY29wZUlkID0gbnVsbCwgc2xvdHRlZCA9IHRydWUsIHNzciA9IGZhbHNlLCBpblNTUiA9IGZhbHNlLCBzc3JDc3NWYXJzID0gYGAsIGJpbmRpbmdNZXRhZGF0YSA9IHNoYXJlZF8xLkVNUFRZX09CSiwgaW5saW5lID0gZmFsc2UsIGlzVFMgPSBmYWxzZSwgb25FcnJvciA9IGRlZmF1bHRPbkVycm9yLCBvbldhcm4gPSBkZWZhdWx0T25XYXJuLCBjb21wYXRDb25maWcgfSkge1xuICAgIGNvbnN0IG5hbWVNYXRjaCA9IGZpbGVuYW1lLnJlcGxhY2UoL1xcPy4qJC8sICcnKS5tYXRjaCgvKFteL1xcXFxdKylcXC5cXHcrJC8pO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIC8vIG9wdGlvbnNcbiAgICAgICAgc2VsZk5hbWU6IG5hbWVNYXRjaCAmJiAoMCwgc2hhcmVkXzEuY2FwaXRhbGl6ZSkoKDAsIHNoYXJlZF8xLmNhbWVsaXplKShuYW1lTWF0Y2hbMV0pKSxcbiAgICAgICAgcHJlZml4SWRlbnRpZmllcnMsXG4gICAgICAgIGhvaXN0U3RhdGljLFxuICAgICAgICBjYWNoZUhhbmRsZXJzLFxuICAgICAgICBub2RlVHJhbnNmb3JtcyxcbiAgICAgICAgZGlyZWN0aXZlVHJhbnNmb3JtcyxcbiAgICAgICAgdHJhbnNmb3JtSG9pc3QsXG4gICAgICAgIGlzQnVpbHRJbkNvbXBvbmVudCxcbiAgICAgICAgaXNDdXN0b21FbGVtZW50LFxuICAgICAgICBleHByZXNzaW9uUGx1Z2lucyxcbiAgICAgICAgc2NvcGVJZCxcbiAgICAgICAgc2xvdHRlZCxcbiAgICAgICAgc3NyLFxuICAgICAgICBpblNTUixcbiAgICAgICAgc3NyQ3NzVmFycyxcbiAgICAgICAgYmluZGluZ01ldGFkYXRhLFxuICAgICAgICBpbmxpbmUsXG4gICAgICAgIGlzVFMsXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIG9uV2FybixcbiAgICAgICAgY29tcGF0Q29uZmlnLFxuICAgICAgICAvLyBzdGF0ZVxuICAgICAgICByb290LFxuICAgICAgICBoZWxwZXJzOiBuZXcgTWFwKCksXG4gICAgICAgIGNvbXBvbmVudHM6IG5ldyBTZXQoKSxcbiAgICAgICAgZGlyZWN0aXZlczogbmV3IFNldCgpLFxuICAgICAgICBob2lzdHM6IFtdLFxuICAgICAgICBpbXBvcnRzOiBbXSxcbiAgICAgICAgY29uc3RhbnRDYWNoZTogbmV3IE1hcCgpLFxuICAgICAgICB0ZW1wczogMCxcbiAgICAgICAgY2FjaGVkOiAwLFxuICAgICAgICBpZGVudGlmaWVyczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgc2NvcGVzOiB7XG4gICAgICAgICAgICB2Rm9yOiAwLFxuICAgICAgICAgICAgdlNsb3Q6IDAsXG4gICAgICAgICAgICB2UHJlOiAwLFxuICAgICAgICAgICAgdk9uY2U6IDBcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICBjdXJyZW50Tm9kZTogcm9vdCxcbiAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgaW5WT25jZTogZmFsc2UsXG4gICAgICAgIC8vIG1ldGhvZHNcbiAgICAgICAgaGVscGVyKG5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gY29udGV4dC5oZWxwZXJzLmdldChuYW1lKSB8fCAwO1xuICAgICAgICAgICAgY29udGV4dC5oZWxwZXJzLnNldChuYW1lLCBjb3VudCArIDEpO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUhlbHBlcihuYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IGNvbnRleHQuaGVscGVycy5nZXQobmFtZSk7XG4gICAgICAgICAgICBpZiAoY291bnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q291bnQgPSBjb3VudCAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5oZWxwZXJzLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuaGVscGVycy5zZXQobmFtZSwgY3VycmVudENvdW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGhlbHBlclN0cmluZyhuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gYF8ke2hlbHBlck5hbWVNYXBbY29udGV4dC5oZWxwZXIobmFtZSldfWA7XG4gICAgICAgIH0sXG4gICAgICAgIHJlcGxhY2VOb2RlKG5vZGUpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5jdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgYmVpbmcgcmVwbGFjZWQgaXMgYWxyZWFkeSByZW1vdmVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlcGxhY2Ugcm9vdCBub2RlLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQucGFyZW50LmNoaWxkcmVuW2NvbnRleHQuY2hpbGRJbmRleF0gPSBjb250ZXh0LmN1cnJlbnROb2RlID0gbm9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlTm9kZShub2RlKSB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjb250ZXh0LnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlbW92ZSByb290IG5vZGUuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsaXN0ID0gY29udGV4dC5wYXJlbnQuY2hpbGRyZW47XG4gICAgICAgICAgICBjb25zdCByZW1vdmFsSW5kZXggPSBub2RlXG4gICAgICAgICAgICAgICAgPyBsaXN0LmluZGV4T2Yobm9kZSlcbiAgICAgICAgICAgICAgICA6IGNvbnRleHQuY3VycmVudE5vZGVcbiAgICAgICAgICAgICAgICAgICAgPyBjb250ZXh0LmNoaWxkSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgOiAtMTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiByZW1vdmFsSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub2RlIGJlaW5nIHJlbW92ZWQgaXMgbm90IGEgY2hpbGQgb2YgY3VycmVudCBwYXJlbnRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbm9kZSB8fCBub2RlID09PSBjb250ZXh0LmN1cnJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBub2RlIHJlbW92ZWRcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnROb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uTm9kZVJlbW92ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNpYmxpbmcgbm9kZSByZW1vdmVkXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuY2hpbGRJbmRleCA+IHJlbW92YWxJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNoaWxkSW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbk5vZGVSZW1vdmVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKHJlbW92YWxJbmRleCwgMSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTm9kZVJlbW92ZWQ6ICgpID0+IHsgfSxcbiAgICAgICAgYWRkSWRlbnRpZmllcnMoZXhwKSB7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUlkZW50aWZpZXJzKGV4cCkge1xuICAgICAgICB9LFxuICAgICAgICBob2lzdChleHApIHtcbiAgICAgICAgICAgIGlmICgoMCwgc2hhcmVkXzEuaXNTdHJpbmcpKGV4cCkpXG4gICAgICAgICAgICAgICAgZXhwID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihleHApO1xuICAgICAgICAgICAgY29udGV4dC5ob2lzdHMucHVzaChleHApO1xuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9ob2lzdGVkXyR7Y29udGV4dC5ob2lzdHMubGVuZ3RofWAsIGZhbHNlLCBleHAubG9jLCAyIC8qIENvbnN0YW50VHlwZXMuQ0FOX0hPSVNUICovKTtcbiAgICAgICAgICAgIGlkZW50aWZpZXIuaG9pc3RlZCA9IGV4cDtcbiAgICAgICAgICAgIHJldHVybiBpZGVudGlmaWVyO1xuICAgICAgICB9LFxuICAgICAgICBjYWNoZShleHAsIGlzVk5vZGUgPSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNhY2hlRXhwcmVzc2lvbihjb250ZXh0LmNhY2hlZCsrLCBleHAsIGlzVk5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB7XG4gICAgICAgIGNvbnRleHQuZmlsdGVycyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5leHBvcnRzLmNyZWF0ZVRyYW5zZm9ybUNvbnRleHQgPSBjcmVhdGVUcmFuc2Zvcm1Db250ZXh0O1xuZnVuY3Rpb24gdHJhbnNmb3JtKHJvb3QsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlVHJhbnNmb3JtQ29udGV4dChyb290LCBvcHRpb25zKTtcbiAgICB0cmF2ZXJzZU5vZGUocm9vdCwgY29udGV4dCk7XG4gICAgaWYgKG9wdGlvbnMuaG9pc3RTdGF0aWMpIHtcbiAgICAgICAgaG9pc3RTdGF0aWMocm9vdCwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5zc3IpIHtcbiAgICAgICAgY3JlYXRlUm9vdENvZGVnZW4ocm9vdCwgY29udGV4dCk7XG4gICAgfVxuICAgIC8vIGZpbmFsaXplIG1ldGEgaW5mb3JtYXRpb25cbiAgICByb290LmhlbHBlcnMgPSBuZXcgU2V0KFsuLi5jb250ZXh0LmhlbHBlcnMua2V5cygpXSk7XG4gICAgcm9vdC5jb21wb25lbnRzID0gWy4uLmNvbnRleHQuY29tcG9uZW50c107XG4gICAgcm9vdC5kaXJlY3RpdmVzID0gWy4uLmNvbnRleHQuZGlyZWN0aXZlc107XG4gICAgcm9vdC5pbXBvcnRzID0gY29udGV4dC5pbXBvcnRzO1xuICAgIHJvb3QuaG9pc3RzID0gY29udGV4dC5ob2lzdHM7XG4gICAgcm9vdC50ZW1wcyA9IGNvbnRleHQudGVtcHM7XG4gICAgcm9vdC5jYWNoZWQgPSBjb250ZXh0LmNhY2hlZDtcbiAgICB7XG4gICAgICAgIHJvb3QuZmlsdGVycyA9IFsuLi5jb250ZXh0LmZpbHRlcnNdO1xuICAgIH1cbn1cbmV4cG9ydHMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuZnVuY3Rpb24gY3JlYXRlUm9vdENvZGVnZW4ocm9vdCwgY29udGV4dCkge1xuICAgIGNvbnN0IHsgaGVscGVyIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHJvb3Q7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuICAgICAgICAvLyBpZiB0aGUgc2luZ2xlIGNoaWxkIGlzIGFuIGVsZW1lbnQsIHR1cm4gaXQgaW50byBhIGJsb2NrLlxuICAgICAgICBpZiAoaXNTaW5nbGVFbGVtZW50Um9vdChyb290LCBjaGlsZCkgJiYgY2hpbGQuY29kZWdlbk5vZGUpIHtcbiAgICAgICAgICAgIC8vIHNpbmdsZSBlbGVtZW50IHJvb3QgaXMgbmV2ZXIgaG9pc3RlZCBzbyBjb2RlZ2VuTm9kZSB3aWxsIG5ldmVyIGJlXG4gICAgICAgICAgICAvLyBTaW1wbGVFeHByZXNzaW9uTm9kZVxuICAgICAgICAgICAgY29uc3QgY29kZWdlbk5vZGUgPSBjaGlsZC5jb2RlZ2VuTm9kZTtcbiAgICAgICAgICAgIGlmIChjb2RlZ2VuTm9kZS50eXBlID09PSAxMyAvKiBOb2RlVHlwZXMuVk5PREVfQ0FMTCAqLykge1xuICAgICAgICAgICAgICAgIG1ha2VCbG9jayhjb2RlZ2VuTm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb290LmNvZGVnZW5Ob2RlID0gY29kZWdlbk5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyAtIHNpbmdsZSA8c2xvdC8+LCBJZk5vZGUsIEZvck5vZGU6IGFscmVhZHkgYmxvY2tzLlxuICAgICAgICAgICAgLy8gLSBzaW5nbGUgdGV4dCBub2RlOiBhbHdheXMgcGF0Y2hlZC5cbiAgICAgICAgICAgIC8vIHJvb3QgY29kZWdlbiBmYWxscyB0aHJvdWdoIHZpYSBnZW5Ob2RlKClcbiAgICAgICAgICAgIHJvb3QuY29kZWdlbk5vZGUgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIHJvb3QgaGFzIG11bHRpcGxlIG5vZGVzIC0gcmV0dXJuIGEgZnJhZ21lbnQgYmxvY2suXG4gICAgICAgIGxldCBwYXRjaEZsYWcgPSA2NCAvKiBQYXRjaEZsYWdzLlNUQUJMRV9GUkFHTUVOVCAqLztcbiAgICAgICAgbGV0IHBhdGNoRmxhZ1RleHQgPSBzaGFyZWRfMS5QYXRjaEZsYWdOYW1lc1s2NCAvKiBQYXRjaEZsYWdzLlNUQUJMRV9GUkFHTUVOVCAqL107XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBmcmFnbWVudCBhY3R1YWxseSBjb250YWlucyBhIHNpbmdsZSB2YWxpZCBjaGlsZCB3aXRoXG4gICAgICAgIC8vIHRoZSByZXN0IGJlaW5nIGNvbW1lbnRzXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgIGNoaWxkcmVuLmZpbHRlcihjID0+IGMudHlwZSAhPT0gMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gMjA0OCAvKiBQYXRjaEZsYWdzLkRFVl9ST09UX0ZSQUdNRU5UICovO1xuICAgICAgICAgICAgcGF0Y2hGbGFnVGV4dCArPSBgLCAke3NoYXJlZF8xLlBhdGNoRmxhZ05hbWVzWzIwNDggLyogUGF0Y2hGbGFncy5ERVZfUk9PVF9GUkFHTUVOVCAqL119YDtcbiAgICAgICAgfVxuICAgICAgICByb290LmNvZGVnZW5Ob2RlID0gY3JlYXRlVk5vZGVDYWxsKGNvbnRleHQsIGhlbHBlcihGUkFHTUVOVCksIHVuZGVmaW5lZCwgcm9vdC5jaGlsZHJlbiwgcGF0Y2hGbGFnICsgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogJHtwYXRjaEZsYWdUZXh0fSAqL2AgOiBgYCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlLCB1bmRlZmluZWQsIGZhbHNlIC8qIGlzQ29tcG9uZW50ICovKTtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICA7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZUNoaWxkcmVuKHBhcmVudCwgY29udGV4dCkge1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBub2RlUmVtb3ZlZCA9ICgpID0+IHtcbiAgICAgICAgaS0tO1xuICAgIH07XG4gICAgZm9yICg7IGkgPCBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgICAgIGlmICgoMCwgc2hhcmVkXzEuaXNTdHJpbmcpKGNoaWxkKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb250ZXh0LnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgY29udGV4dC5jaGlsZEluZGV4ID0gaTtcbiAgICAgICAgY29udGV4dC5vbk5vZGVSZW1vdmVkID0gbm9kZVJlbW92ZWQ7XG4gICAgICAgIHRyYXZlcnNlTm9kZShjaGlsZCwgY29udGV4dCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VOb2RlKG5vZGUsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmN1cnJlbnROb2RlID0gbm9kZTtcbiAgICAvLyBhcHBseSB0cmFuc2Zvcm0gcGx1Z2luc1xuICAgIGNvbnN0IHsgbm9kZVRyYW5zZm9ybXMgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgZXhpdEZucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb25FeGl0ID0gbm9kZVRyYW5zZm9ybXNbaV0obm9kZSwgY29udGV4dCk7XG4gICAgICAgIGlmIChvbkV4aXQpIHtcbiAgICAgICAgICAgIGlmICgoMCwgc2hhcmVkXzEuaXNBcnJheSkob25FeGl0KSkge1xuICAgICAgICAgICAgICAgIGV4aXRGbnMucHVzaCguLi5vbkV4aXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhpdEZucy5wdXNoKG9uRXhpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250ZXh0LmN1cnJlbnROb2RlKSB7XG4gICAgICAgICAgICAvLyBub2RlIHdhcyByZW1vdmVkXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBub2RlIG1heSBoYXZlIGJlZW4gcmVwbGFjZWRcbiAgICAgICAgICAgIG5vZGUgPSBjb250ZXh0LmN1cnJlbnROb2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLzpcbiAgICAgICAgICAgIGlmICghY29udGV4dC5zc3IpIHtcbiAgICAgICAgICAgICAgICAvLyBpbmplY3QgaW1wb3J0IGZvciB0aGUgQ29tbWVudCBzeW1ib2wsIHdoaWNoIGlzIG5lZWRlZCBmb3IgY3JlYXRpbmdcbiAgICAgICAgICAgICAgICAvLyBjb21tZW50IG5vZGVzIHdpdGggYGNyZWF0ZVZOb2RlYFxuICAgICAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKENSRUFURV9DT01NRU5UKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDUgLyogTm9kZVR5cGVzLklOVEVSUE9MQVRJT04gKi86XG4gICAgICAgICAgICAvLyBubyBuZWVkIHRvIHRyYXZlcnNlLCBidXQgd2UgbmVlZCB0byBpbmplY3QgdG9TdHJpbmcgaGVscGVyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuc3NyKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoVE9fRElTUExBWV9TVFJJTkcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGZvciBjb250YWluZXIgdHlwZXMsIGZ1cnRoZXIgdHJhdmVyc2UgZG93bndhcmRzXG4gICAgICAgIGNhc2UgOSAvKiBOb2RlVHlwZXMuSUYgKi86XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuYnJhbmNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZU5vZGUobm9kZS5icmFuY2hlc1tpXSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMCAvKiBOb2RlVHlwZXMuSUZfQlJBTkNIICovOlxuICAgICAgICBjYXNlIDExIC8qIE5vZGVUeXBlcy5GT1IgKi86XG4gICAgICAgIGNhc2UgMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLzpcbiAgICAgICAgY2FzZSAwIC8qIE5vZGVUeXBlcy5ST09UICovOlxuICAgICAgICAgICAgdHJhdmVyc2VDaGlsZHJlbihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBleGl0IHRyYW5zZm9ybXNcbiAgICBjb250ZXh0LmN1cnJlbnROb2RlID0gbm9kZTtcbiAgICBsZXQgaSA9IGV4aXRGbnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgZXhpdEZuc1tpXSgpO1xuICAgIH1cbn1cbmV4cG9ydHMudHJhdmVyc2VOb2RlID0gdHJhdmVyc2VOb2RlO1xuZnVuY3Rpb24gY3JlYXRlU3RydWN0dXJhbERpcmVjdGl2ZVRyYW5zZm9ybShuYW1lLCBmbikge1xuICAgIGNvbnN0IG1hdGNoZXMgPSAoMCwgc2hhcmVkXzEuaXNTdHJpbmcpKG5hbWUpXG4gICAgICAgID8gKG4pID0+IG4gPT09IG5hbWVcbiAgICAgICAgOiAobikgPT4gbmFtZS50ZXN0KG4pO1xuICAgIHJldHVybiAobm9kZSwgY29udGV4dCkgPT4ge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzIH0gPSBub2RlO1xuICAgICAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmUgdHJhbnNmb3JtcyBhcmUgbm90IGNvbmNlcm5lZCB3aXRoIHNsb3RzXG4gICAgICAgICAgICAvLyBhcyB0aGV5IGFyZSBoYW5kbGVkIHNlcGFyYXRlbHkgaW4gdlNsb3QudHNcbiAgICAgICAgICAgIGlmIChub2RlLnRhZ1R5cGUgPT09IDMgLyogRWxlbWVudFR5cGVzLlRFTVBMQVRFICovICYmIHByb3BzLnNvbWUoaXNWU2xvdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleGl0Rm5zID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wLnR5cGUgPT09IDcgLyogTm9kZVR5cGVzLkRJUkVDVElWRSAqLyAmJiBtYXRjaGVzKHByb3AubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmVzIGFyZSByZW1vdmVkIHRvIGF2b2lkIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIHdlIHJlbW92ZSB0aGVtICpiZWZvcmUqIGFwcGx5aW5nIHNvIHRoYXQgaXQgY2FuIGZ1cnRoZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhdmVyc2UgaXRzZWxmIGluIGNhc2UgaXQgbW92ZXMgdGhlIG5vZGUgYXJvdW5kXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbkV4aXQgPSBmbihub2RlLCBwcm9wLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uRXhpdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXRGbnMucHVzaChvbkV4aXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleGl0Rm5zO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMuY3JlYXRlU3RydWN0dXJhbERpcmVjdGl2ZVRyYW5zZm9ybSA9IGNyZWF0ZVN0cnVjdHVyYWxEaXJlY3RpdmVUcmFuc2Zvcm07XG5jb25zdCBQVVJFX0FOTk9UQVRJT04gPSBgLyojX19QVVJFX18qL2A7XG5jb25zdCBhbGlhc0hlbHBlciA9IChzKSA9PiBgJHtoZWxwZXJOYW1lTWFwW3NdfTogXyR7aGVscGVyTmFtZU1hcFtzXX1gO1xuZnVuY3Rpb24gY3JlYXRlQ29kZWdlbkNvbnRleHQoYXN0LCB7IG1vZGUgPSAnZnVuY3Rpb24nLCBwcmVmaXhJZGVudGlmaWVycyA9IG1vZGUgPT09ICdtb2R1bGUnLCBzb3VyY2VNYXAgPSBmYWxzZSwgZmlsZW5hbWUgPSBgdGVtcGxhdGUudnVlLmh0bWxgLCBzY29wZUlkID0gbnVsbCwgb3B0aW1pemVJbXBvcnRzID0gZmFsc2UsIHJ1bnRpbWVHbG9iYWxOYW1lID0gYFZ1ZWAsIHJ1bnRpbWVNb2R1bGVOYW1lID0gYHZ1ZWAsIHNzclJ1bnRpbWVNb2R1bGVOYW1lID0gJ3Z1ZS9zZXJ2ZXItcmVuZGVyZXInLCBzc3IgPSBmYWxzZSwgaXNUUyA9IGZhbHNlLCBpblNTUiA9IGZhbHNlIH0pIHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBtb2RlLFxuICAgICAgICBwcmVmaXhJZGVudGlmaWVycyxcbiAgICAgICAgc291cmNlTWFwLFxuICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgc2NvcGVJZCxcbiAgICAgICAgb3B0aW1pemVJbXBvcnRzLFxuICAgICAgICBydW50aW1lR2xvYmFsTmFtZSxcbiAgICAgICAgcnVudGltZU1vZHVsZU5hbWUsXG4gICAgICAgIHNzclJ1bnRpbWVNb2R1bGVOYW1lLFxuICAgICAgICBzc3IsXG4gICAgICAgIGlzVFMsXG4gICAgICAgIGluU1NSLFxuICAgICAgICBzb3VyY2U6IGFzdC5sb2Muc291cmNlLFxuICAgICAgICBjb2RlOiBgYCxcbiAgICAgICAgY29sdW1uOiAxLFxuICAgICAgICBsaW5lOiAxLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIGluZGVudExldmVsOiAwLFxuICAgICAgICBwdXJlOiBmYWxzZSxcbiAgICAgICAgbWFwOiB1bmRlZmluZWQsXG4gICAgICAgIGhlbHBlcihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBgXyR7aGVscGVyTmFtZU1hcFtrZXldfWA7XG4gICAgICAgIH0sXG4gICAgICAgIHB1c2goY29kZSwgbm9kZSkge1xuICAgICAgICAgICAgY29udGV4dC5jb2RlICs9IGNvZGU7XG4gICAgICAgIH0sXG4gICAgICAgIGluZGVudCgpIHtcbiAgICAgICAgICAgIG5ld2xpbmUoKytjb250ZXh0LmluZGVudExldmVsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVpbmRlbnQod2l0aG91dE5ld0xpbmUgPSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKHdpdGhvdXROZXdMaW5lKSB7XG4gICAgICAgICAgICAgICAgLS1jb250ZXh0LmluZGVudExldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3bGluZSgtLWNvbnRleHQuaW5kZW50TGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBuZXdsaW5lKCkge1xuICAgICAgICAgICAgbmV3bGluZShjb250ZXh0LmluZGVudExldmVsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gbmV3bGluZShuKSB7XG4gICAgICAgIGNvbnRleHQucHVzaCgnXFxuJyArIGAgIGAucmVwZWF0KG4pKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZShhc3QsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDb2RlZ2VuQ29udGV4dChhc3QsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLm9uQ29udGV4dENyZWF0ZWQpXG4gICAgICAgIG9wdGlvbnMub25Db250ZXh0Q3JlYXRlZChjb250ZXh0KTtcbiAgICBjb25zdCB7IG1vZGUsIHB1c2gsIHByZWZpeElkZW50aWZpZXJzLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lLCBzY29wZUlkLCBzc3IgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgaGVscGVycyA9IEFycmF5LmZyb20oYXN0LmhlbHBlcnMpO1xuICAgIGNvbnN0IGhhc0hlbHBlcnMgPSBoZWxwZXJzLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgdXNlV2l0aEJsb2NrID0gIXByZWZpeElkZW50aWZpZXJzICYmIG1vZGUgIT09ICdtb2R1bGUnO1xuICAgIGNvbnN0IGlzU2V0dXBJbmxpbmVkID0gIXRydWU7XG4gICAgLy8gcHJlYW1ibGVzXG4gICAgLy8gaW4gc2V0dXAoKSBpbmxpbmUgbW9kZSwgdGhlIHByZWFtYmxlIGlzIGdlbmVyYXRlZCBpbiBhIHN1YiBjb250ZXh0XG4gICAgLy8gYW5kIHJldHVybmVkIHNlcGFyYXRlbHkuXG4gICAgY29uc3QgcHJlYW1ibGVDb250ZXh0ID0gaXNTZXR1cElubGluZWRcbiAgICAgICAgPyBjcmVhdGVDb2RlZ2VuQ29udGV4dChhc3QsIG9wdGlvbnMpXG4gICAgICAgIDogY29udGV4dDtcbiAgICB7XG4gICAgICAgIGdlbkZ1bmN0aW9uUHJlYW1ibGUoYXN0LCBwcmVhbWJsZUNvbnRleHQpO1xuICAgIH1cbiAgICAvLyBlbnRlciByZW5kZXIgZnVuY3Rpb25cbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBzc3IgPyBgc3NyUmVuZGVyYCA6IGByZW5kZXJgO1xuICAgIGNvbnN0IGFyZ3MgPSBzc3IgPyBbJ19jdHgnLCAnX3B1c2gnLCAnX3BhcmVudCcsICdfYXR0cnMnXSA6IFsnX2N0eCcsICdfY2FjaGUnXTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhcmdzLmpvaW4oJywgJyk7XG4gICAge1xuICAgICAgICBwdXNoKGBmdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0oJHtzaWduYXR1cmV9KSB7YCk7XG4gICAgfVxuICAgIGluZGVudCgpO1xuICAgIGlmICh1c2VXaXRoQmxvY2spIHtcbiAgICAgICAgcHVzaChgd2l0aCAoX2N0eCkge2ApO1xuICAgICAgICBpbmRlbnQoKTtcbiAgICAgICAgLy8gZnVuY3Rpb24gbW9kZSBjb25zdCBkZWNsYXJhdGlvbnMgc2hvdWxkIGJlIGluc2lkZSB3aXRoIGJsb2NrXG4gICAgICAgIC8vIGFsc28gdGhleSBzaG91bGQgYmUgcmVuYW1lZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCB1c2VyIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKGhhc0hlbHBlcnMpIHtcbiAgICAgICAgICAgIHB1c2goYGNvbnN0IHsgJHtoZWxwZXJzLm1hcChhbGlhc0hlbHBlcikuam9pbignLCAnKX0gfSA9IF9WdWVgKTtcbiAgICAgICAgICAgIHB1c2goYFxcbmApO1xuICAgICAgICAgICAgbmV3bGluZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGdlbmVyYXRlIGFzc2V0IHJlc29sdXRpb24gc3RhdGVtZW50c1xuICAgIGlmIChhc3QuY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgZ2VuQXNzZXRzKGFzdC5jb21wb25lbnRzLCAnY29tcG9uZW50JywgY29udGV4dCk7XG4gICAgICAgIGlmIChhc3QuZGlyZWN0aXZlcy5sZW5ndGggfHwgYXN0LnRlbXBzID4gMCkge1xuICAgICAgICAgICAgbmV3bGluZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhc3QuZGlyZWN0aXZlcy5sZW5ndGgpIHtcbiAgICAgICAgZ2VuQXNzZXRzKGFzdC5kaXJlY3RpdmVzLCAnZGlyZWN0aXZlJywgY29udGV4dCk7XG4gICAgICAgIGlmIChhc3QudGVtcHMgPiAwKSB7XG4gICAgICAgICAgICBuZXdsaW5lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFzdC5maWx0ZXJzICYmIGFzdC5maWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICBuZXdsaW5lKCk7XG4gICAgICAgIGdlbkFzc2V0cyhhc3QuZmlsdGVycywgJ2ZpbHRlcicsIGNvbnRleHQpO1xuICAgICAgICBuZXdsaW5lKCk7XG4gICAgfVxuICAgIGlmIChhc3QudGVtcHMgPiAwKSB7XG4gICAgICAgIHB1c2goYGxldCBgKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QudGVtcHM7IGkrKykge1xuICAgICAgICAgICAgcHVzaChgJHtpID4gMCA/IGAsIGAgOiBgYH1fdGVtcCR7aX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXN0LmNvbXBvbmVudHMubGVuZ3RoIHx8IGFzdC5kaXJlY3RpdmVzLmxlbmd0aCB8fCBhc3QudGVtcHMpIHtcbiAgICAgICAgcHVzaChgXFxuYCk7XG4gICAgICAgIG5ld2xpbmUoKTtcbiAgICB9XG4gICAgLy8gZ2VuZXJhdGUgdGhlIFZOb2RlIHRyZWUgZXhwcmVzc2lvblxuICAgIGlmICghc3NyKSB7XG4gICAgICAgIHB1c2goYHJldHVybiBgKTtcbiAgICB9XG4gICAgaWYgKGFzdC5jb2RlZ2VuTm9kZSkge1xuICAgICAgICBnZW5Ob2RlKGFzdC5jb2RlZ2VuTm9kZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwdXNoKGBudWxsYCk7XG4gICAgfVxuICAgIGlmICh1c2VXaXRoQmxvY2spIHtcbiAgICAgICAgZGVpbmRlbnQoKTtcbiAgICAgICAgcHVzaChgfWApO1xuICAgIH1cbiAgICBkZWluZGVudCgpO1xuICAgIHB1c2goYH1gKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhc3QsXG4gICAgICAgIGNvZGU6IGNvbnRleHQuY29kZSxcbiAgICAgICAgcHJlYW1ibGU6IGlzU2V0dXBJbmxpbmVkID8gcHJlYW1ibGVDb250ZXh0LmNvZGUgOiBgYCxcbiAgICAgICAgLy8gU291cmNlTWFwR2VuZXJhdG9yIGRvZXMgaGF2ZSB0b0pTT04oKSBtZXRob2QgYnV0IGl0J3Mgbm90IGluIHRoZSB0eXBlc1xuICAgICAgICBtYXA6IGNvbnRleHQubWFwID8gY29udGV4dC5tYXAudG9KU09OKCkgOiB1bmRlZmluZWRcbiAgICB9O1xufVxuZXhwb3J0cy5nZW5lcmF0ZSA9IGdlbmVyYXRlO1xuZnVuY3Rpb24gZ2VuRnVuY3Rpb25QcmVhbWJsZShhc3QsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IHNzciwgcHJlZml4SWRlbnRpZmllcnMsIHB1c2gsIG5ld2xpbmUsIHJ1bnRpbWVNb2R1bGVOYW1lLCBydW50aW1lR2xvYmFsTmFtZSwgc3NyUnVudGltZU1vZHVsZU5hbWUgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgVnVlQmluZGluZyA9IHJ1bnRpbWVHbG9iYWxOYW1lO1xuICAgIC8vIEdlbmVyYXRlIGNvbnN0IGRlY2xhcmF0aW9uIGZvciBoZWxwZXJzXG4gICAgLy8gSW4gcHJlZml4IG1vZGUsIHdlIHBsYWNlIHRoZSBjb25zdCBkZWNsYXJhdGlvbiBhdCB0b3Agc28gaXQncyBkb25lXG4gICAgLy8gb25seSBvbmNlOyBCdXQgaWYgd2Ugbm90IHByZWZpeGluZywgd2UgcGxhY2UgdGhlIGRlY2xhcmF0aW9uIGluc2lkZSB0aGVcbiAgICAvLyB3aXRoIGJsb2NrIHNvIGl0IGRvZXNuJ3QgaW5jdXIgdGhlIGBpbmAgY2hlY2sgY29zdCBmb3IgZXZlcnkgaGVscGVyIGFjY2Vzcy5cbiAgICBjb25zdCBoZWxwZXJzID0gQXJyYXkuZnJvbShhc3QuaGVscGVycyk7XG4gICAgaWYgKGhlbHBlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB7XG4gICAgICAgICAgICAvLyBcIndpdGhcIiBtb2RlLlxuICAgICAgICAgICAgLy8gc2F2ZSBWdWUgaW4gYSBzZXBhcmF0ZSB2YXJpYWJsZSB0byBhdm9pZCBjb2xsaXNpb25cbiAgICAgICAgICAgIHB1c2goYGNvbnN0IF9WdWUgPSAke1Z1ZUJpbmRpbmd9XFxuYCk7XG4gICAgICAgICAgICAvLyBpbiBcIndpdGhcIiBtb2RlLCBoZWxwZXJzIGFyZSBkZWNsYXJlZCBpbnNpZGUgdGhlIHdpdGggYmxvY2sgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIGhhcyBjaGVjayBjb3N0LCBidXQgaG9pc3RzIGFyZSBsaWZ0ZWQgb3V0IG9mIHRoZSBmdW5jdGlvbiAtIHdlIG5lZWRcbiAgICAgICAgICAgIC8vIHRvIHByb3ZpZGUgdGhlIGhlbHBlciBoZXJlLlxuICAgICAgICAgICAgaWYgKGFzdC5ob2lzdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGljSGVscGVycyA9IFtcbiAgICAgICAgICAgICAgICAgICAgQ1JFQVRFX1ZOT0RFLFxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfRUxFTUVOVF9WTk9ERSxcbiAgICAgICAgICAgICAgICAgICAgQ1JFQVRFX0NPTU1FTlQsXG4gICAgICAgICAgICAgICAgICAgIENSRUFURV9URVhULFxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfU1RBVElDXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGhlbHBlciA9PiBoZWxwZXJzLmluY2x1ZGVzKGhlbHBlcikpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoYWxpYXNIZWxwZXIpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICAgICAgICAgIHB1c2goYGNvbnN0IHsgJHtzdGF0aWNIZWxwZXJzfSB9ID0gX1Z1ZVxcbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdlbkhvaXN0cyhhc3QuaG9pc3RzLCBjb250ZXh0KTtcbiAgICBuZXdsaW5lKCk7XG4gICAgcHVzaChgcmV0dXJuIGApO1xufVxuZnVuY3Rpb24gZ2VuQXNzZXRzKGFzc2V0cywgdHlwZSwgeyBoZWxwZXIsIHB1c2gsIG5ld2xpbmUsIGlzVFMgfSkge1xuICAgIGNvbnN0IHJlc29sdmVyID0gaGVscGVyKHR5cGUgPT09ICdmaWx0ZXInXG4gICAgICAgID8gUkVTT0xWRV9GSUxURVJcbiAgICAgICAgOiB0eXBlID09PSAnY29tcG9uZW50J1xuICAgICAgICAgICAgPyBSRVNPTFZFX0NPTVBPTkVOVFxuICAgICAgICAgICAgOiBSRVNPTFZFX0RJUkVDVElWRSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGlkID0gYXNzZXRzW2ldO1xuICAgICAgICAvLyBwb3RlbnRpYWwgY29tcG9uZW50IGltcGxpY2l0IHNlbGYtcmVmZXJlbmNlIGluZmVycmVkIGZyb20gU0ZDIGZpbGVuYW1lXG4gICAgICAgIGNvbnN0IG1heWJlU2VsZlJlZmVyZW5jZSA9IGlkLmVuZHNXaXRoKCdfX3NlbGYnKTtcbiAgICAgICAgaWYgKG1heWJlU2VsZlJlZmVyZW5jZSkge1xuICAgICAgICAgICAgaWQgPSBpZC5zbGljZSgwLCAtNik7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaChgY29uc3QgJHt0b1ZhbGlkQXNzZXRJZChpZCwgdHlwZSl9ID0gJHtyZXNvbHZlcn0oJHtKU09OLnN0cmluZ2lmeShpZCl9JHttYXliZVNlbGZSZWZlcmVuY2UgPyBgLCB0cnVlYCA6IGBgfSkke2lzVFMgPyBgIWAgOiBgYH1gKTtcbiAgICAgICAgaWYgKGkgPCBhc3NldHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgbmV3bGluZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2VuSG9pc3RzKGhvaXN0cywgY29udGV4dCkge1xuICAgIGlmICghaG9pc3RzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQucHVyZSA9IHRydWU7XG4gICAgY29uc3QgeyBwdXNoLCBuZXdsaW5lLCBoZWxwZXIsIHNjb3BlSWQsIG1vZGUgfSA9IGNvbnRleHQ7XG4gICAgbmV3bGluZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9pc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGV4cCA9IGhvaXN0c1tpXTtcbiAgICAgICAgaWYgKGV4cCkge1xuICAgICAgICAgICAgcHVzaChgY29uc3QgX2hvaXN0ZWRfJHtpICsgMX0gPSAke2BgfWApO1xuICAgICAgICAgICAgZ2VuTm9kZShleHAsIGNvbnRleHQpO1xuICAgICAgICAgICAgbmV3bGluZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnRleHQucHVyZSA9IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNUZXh0KG4pIHtcbiAgICByZXR1cm4gKCgwLCBzaGFyZWRfMS5pc1N0cmluZykobikgfHxcbiAgICAgICAgbi50eXBlID09PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLyB8fFxuICAgICAgICBuLnR5cGUgPT09IDIgLyogTm9kZVR5cGVzLlRFWFQgKi8gfHxcbiAgICAgICAgbi50eXBlID09PSA1IC8qIE5vZGVUeXBlcy5JTlRFUlBPTEFUSU9OICovIHx8XG4gICAgICAgIG4udHlwZSA9PT0gOCAvKiBOb2RlVHlwZXMuQ09NUE9VTkRfRVhQUkVTU0lPTiAqLyk7XG59XG5mdW5jdGlvbiBnZW5Ob2RlTGlzdEFzQXJyYXkobm9kZXMsIGNvbnRleHQpIHtcbiAgICBjb25zdCBtdWx0aWxpbmVzID0gbm9kZXMubGVuZ3RoID4gMyB8fFxuICAgICAgICAoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkgJiYgbm9kZXMuc29tZShuID0+ICgwLCBzaGFyZWRfMS5pc0FycmF5KShuKSB8fCAhaXNUZXh0KG4pKSk7XG4gICAgY29udGV4dC5wdXNoKGBbYCk7XG4gICAgbXVsdGlsaW5lcyAmJiBjb250ZXh0LmluZGVudCgpO1xuICAgIGdlbk5vZGVMaXN0KG5vZGVzLCBjb250ZXh0LCBtdWx0aWxpbmVzKTtcbiAgICBtdWx0aWxpbmVzICYmIGNvbnRleHQuZGVpbmRlbnQoKTtcbiAgICBjb250ZXh0LnB1c2goYF1gKTtcbn1cbmZ1bmN0aW9uIGdlbk5vZGVMaXN0KG5vZGVzLCBjb250ZXh0LCBtdWx0aWxpbmVzID0gZmFsc2UsIGNvbW1hID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgcHVzaCwgbmV3bGluZSB9ID0gY29udGV4dDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKCgwLCBzaGFyZWRfMS5pc1N0cmluZykobm9kZSkpIHtcbiAgICAgICAgICAgIHB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIHNoYXJlZF8xLmlzQXJyYXkpKG5vZGUpKSB7XG4gICAgICAgICAgICBnZW5Ob2RlTGlzdEFzQXJyYXkobm9kZSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZW5Ob2RlKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgbm9kZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgaWYgKG11bHRpbGluZXMpIHtcbiAgICAgICAgICAgICAgICBjb21tYSAmJiBwdXNoKCcsJyk7XG4gICAgICAgICAgICAgICAgbmV3bGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tbWEgJiYgcHVzaCgnLCAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdlbk5vZGUobm9kZSwgY29udGV4dCkge1xuICAgIGlmICgoMCwgc2hhcmVkXzEuaXNTdHJpbmcpKG5vZGUpKSB7XG4gICAgICAgIGNvbnRleHQucHVzaChub2RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoKDAsIHNoYXJlZF8xLmlzU3ltYm9sKShub2RlKSkge1xuICAgICAgICBjb250ZXh0LnB1c2goY29udGV4dC5oZWxwZXIobm9kZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLzpcbiAgICAgICAgY2FzZSA5IC8qIE5vZGVUeXBlcy5JRiAqLzpcbiAgICAgICAgY2FzZSAxMSAvKiBOb2RlVHlwZXMuRk9SICovOlxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgYXNzZXJ0KG5vZGUuY29kZWdlbk5vZGUgIT0gbnVsbCwgYENvZGVnZW4gbm9kZSBpcyBtaXNzaW5nIGZvciBlbGVtZW50L2lmL2ZvciBub2RlLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYEFwcGx5IGFwcHJvcHJpYXRlIHRyYW5zZm9ybXMgZmlyc3QuYCk7XG4gICAgICAgICAgICBnZW5Ob2RlKG5vZGUuY29kZWdlbk5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMiAvKiBOb2RlVHlwZXMuVEVYVCAqLzpcbiAgICAgICAgICAgIGdlblRleHQobm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLzpcbiAgICAgICAgICAgIGdlbkV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1IC8qIE5vZGVUeXBlcy5JTlRFUlBPTEFUSU9OICovOlxuICAgICAgICAgICAgZ2VuSW50ZXJwb2xhdGlvbihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyIC8qIE5vZGVUeXBlcy5URVhUX0NBTEwgKi86XG4gICAgICAgICAgICBnZW5Ob2RlKG5vZGUuY29kZWdlbk5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOCAvKiBOb2RlVHlwZXMuQ09NUE9VTkRfRVhQUkVTU0lPTiAqLzpcbiAgICAgICAgICAgIGdlbkNvbXBvdW5kRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMgLyogTm9kZVR5cGVzLkNPTU1FTlQgKi86XG4gICAgICAgICAgICBnZW5Db21tZW50KG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTMgLyogTm9kZVR5cGVzLlZOT0RFX0NBTEwgKi86XG4gICAgICAgICAgICBnZW5WTm9kZUNhbGwobm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNCAvKiBOb2RlVHlwZXMuSlNfQ0FMTF9FWFBSRVNTSU9OICovOlxuICAgICAgICAgICAgZ2VuQ2FsbEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNSAvKiBOb2RlVHlwZXMuSlNfT0JKRUNUX0VYUFJFU1NJT04gKi86XG4gICAgICAgICAgICBnZW5PYmplY3RFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTcgLyogTm9kZVR5cGVzLkpTX0FSUkFZX0VYUFJFU1NJT04gKi86XG4gICAgICAgICAgICBnZW5BcnJheUV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOCAvKiBOb2RlVHlwZXMuSlNfRlVOQ1RJT05fRVhQUkVTU0lPTiAqLzpcbiAgICAgICAgICAgIGdlbkZ1bmN0aW9uRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE5IC8qIE5vZGVUeXBlcy5KU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovOlxuICAgICAgICAgICAgZ2VuQ29uZGl0aW9uYWxFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjAgLyogTm9kZVR5cGVzLkpTX0NBQ0hFX0VYUFJFU1NJT04gKi86XG4gICAgICAgICAgICBnZW5DYWNoZUV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMSAvKiBOb2RlVHlwZXMuSlNfQkxPQ0tfU1RBVEVNRU5UICovOlxuICAgICAgICAgICAgZ2VuTm9kZUxpc3Qobm9kZS5ib2R5LCBjb250ZXh0LCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gU1NSIG9ubHkgdHlwZXNcbiAgICAgICAgY2FzZSAyMiAvKiBOb2RlVHlwZXMuSlNfVEVNUExBVEVfTElURVJBTCAqLzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIzIC8qIE5vZGVUeXBlcy5KU19JRl9TVEFURU1FTlQgKi86XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNCAvKiBOb2RlVHlwZXMuSlNfQVNTSUdOTUVOVF9FWFBSRVNTSU9OICovOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjUgLyogTm9kZVR5cGVzLkpTX1NFUVVFTkNFX0VYUFJFU1NJT04gKi86XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNiAvKiBOb2RlVHlwZXMuSlNfUkVUVVJOX1NUQVRFTUVOVCAqLzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBjYXNlIDEwIC8qIE5vZGVUeXBlcy5JRl9CUkFOQ0ggKi86XG4gICAgICAgICAgICAvLyBub29wXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGB1bmhhbmRsZWQgY29kZWdlbiBub2RlIHR5cGU6ICR7bm9kZS50eXBlfWApO1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBleGhhdXN0IGFsbCBwb3NzaWJsZSB0eXBlc1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjayA9IG5vZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aGF1c3RpdmVDaGVjaztcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZW5UZXh0KG5vZGUsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LnB1c2goSlNPTi5zdHJpbmdpZnkobm9kZS5jb250ZW50KSwgbm9kZSk7XG59XG5mdW5jdGlvbiBnZW5FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IGNvbnRlbnQsIGlzU3RhdGljIH0gPSBub2RlO1xuICAgIGNvbnRleHQucHVzaChpc1N0YXRpYyA/IEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpIDogY29udGVudCwgbm9kZSk7XG59XG5mdW5jdGlvbiBnZW5JbnRlcnBvbGF0aW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IHB1c2gsIGhlbHBlciwgcHVyZSB9ID0gY29udGV4dDtcbiAgICBpZiAocHVyZSlcbiAgICAgICAgcHVzaChQVVJFX0FOTk9UQVRJT04pO1xuICAgIHB1c2goYCR7aGVscGVyKFRPX0RJU1BMQVlfU1RSSU5HKX0oYCk7XG4gICAgZ2VuTm9kZShub2RlLmNvbnRlbnQsIGNvbnRleHQpO1xuICAgIHB1c2goYClgKTtcbn1cbmZ1bmN0aW9uIGdlbkNvbXBvdW5kRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKCgwLCBzaGFyZWRfMS5pc1N0cmluZykoY2hpbGQpKSB7XG4gICAgICAgICAgICBjb250ZXh0LnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VuTm9kZShjaGlsZCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZW5FeHByZXNzaW9uQXNQcm9wZXJ0eUtleShub2RlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyBwdXNoIH0gPSBjb250ZXh0O1xuICAgIGlmIChub2RlLnR5cGUgPT09IDggLyogTm9kZVR5cGVzLkNPTVBPVU5EX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgcHVzaChgW2ApO1xuICAgICAgICBnZW5Db21wb3VuZEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XG4gICAgICAgIHB1c2goYF1gKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5pc1N0YXRpYykge1xuICAgICAgICAvLyBvbmx5IHF1b3RlIGtleXMgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGNvbnN0IHRleHQgPSBpc1NpbXBsZUlkZW50aWZpZXIobm9kZS5jb250ZW50KVxuICAgICAgICAgICAgPyBub2RlLmNvbnRlbnRcbiAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkobm9kZS5jb250ZW50KTtcbiAgICAgICAgcHVzaCh0ZXh0LCBub2RlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHB1c2goYFske25vZGUuY29udGVudH1dYCwgbm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2VuQ29tbWVudChub2RlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIHB1cmUgfSA9IGNvbnRleHQ7XG4gICAgaWYgKHB1cmUpIHtcbiAgICAgICAgcHVzaChQVVJFX0FOTk9UQVRJT04pO1xuICAgIH1cbiAgICBwdXNoKGAke2hlbHBlcihDUkVBVEVfQ09NTUVOVCl9KCR7SlNPTi5zdHJpbmdpZnkobm9kZS5jb250ZW50KX0pYCwgbm9kZSk7XG59XG5mdW5jdGlvbiBnZW5WTm9kZUNhbGwobm9kZSwgY29udGV4dCkge1xuICAgIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBwdXJlIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHsgdGFnLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCBkaXJlY3RpdmVzLCBpc0Jsb2NrLCBkaXNhYmxlVHJhY2tpbmcsIGlzQ29tcG9uZW50IH0gPSBub2RlO1xuICAgIGlmIChkaXJlY3RpdmVzKSB7XG4gICAgICAgIHB1c2goaGVscGVyKFdJVEhfRElSRUNUSVZFUykgKyBgKGApO1xuICAgIH1cbiAgICBpZiAoaXNCbG9jaykge1xuICAgICAgICBwdXNoKGAoJHtoZWxwZXIoT1BFTl9CTE9DSyl9KCR7ZGlzYWJsZVRyYWNraW5nID8gYHRydWVgIDogYGB9KSwgYCk7XG4gICAgfVxuICAgIGlmIChwdXJlKSB7XG4gICAgICAgIHB1c2goUFVSRV9BTk5PVEFUSU9OKTtcbiAgICB9XG4gICAgY29uc3QgY2FsbEhlbHBlciA9IGlzQmxvY2tcbiAgICAgICAgPyBnZXRWTm9kZUJsb2NrSGVscGVyKGNvbnRleHQuaW5TU1IsIGlzQ29tcG9uZW50KVxuICAgICAgICA6IGdldFZOb2RlSGVscGVyKGNvbnRleHQuaW5TU1IsIGlzQ29tcG9uZW50KTtcbiAgICBwdXNoKGhlbHBlcihjYWxsSGVscGVyKSArIGAoYCwgbm9kZSk7XG4gICAgZ2VuTm9kZUxpc3QoZ2VuTnVsbGFibGVBcmdzKFt0YWcsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHNdKSwgY29udGV4dCk7XG4gICAgcHVzaChgKWApO1xuICAgIGlmIChpc0Jsb2NrKSB7XG4gICAgICAgIHB1c2goYClgKTtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgcHVzaChgLCBgKTtcbiAgICAgICAgZ2VuTm9kZShkaXJlY3RpdmVzLCBjb250ZXh0KTtcbiAgICAgICAgcHVzaChgKWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdlbk51bGxhYmxlQXJncyhhcmdzKSB7XG4gICAgbGV0IGkgPSBhcmdzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmIChhcmdzW2ldICE9IG51bGwpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3Muc2xpY2UoMCwgaSArIDEpLm1hcChhcmcgPT4gYXJnIHx8IGBudWxsYCk7XG59XG4vLyBKYXZhU2NyaXB0XG5mdW5jdGlvbiBnZW5DYWxsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIHB1cmUgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgY2FsbGVlID0gKDAsIHNoYXJlZF8xLmlzU3RyaW5nKShub2RlLmNhbGxlZSkgPyBub2RlLmNhbGxlZSA6IGhlbHBlcihub2RlLmNhbGxlZSk7XG4gICAgaWYgKHB1cmUpIHtcbiAgICAgICAgcHVzaChQVVJFX0FOTk9UQVRJT04pO1xuICAgIH1cbiAgICBwdXNoKGNhbGxlZSArIGAoYCwgbm9kZSk7XG4gICAgZ2VuTm9kZUxpc3Qobm9kZS5hcmd1bWVudHMsIGNvbnRleHQpO1xuICAgIHB1c2goYClgKTtcbn1cbmZ1bmN0aW9uIGdlbk9iamVjdEV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xuICAgIGNvbnN0IHsgcHVzaCwgaW5kZW50LCBkZWluZGVudCwgbmV3bGluZSB9ID0gY29udGV4dDtcbiAgICBjb25zdCB7IHByb3BlcnRpZXMgfSA9IG5vZGU7XG4gICAgaWYgKCFwcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICBwdXNoKGB7fWAsIG5vZGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG11bHRpbGluZXMgPSBwcm9wZXJ0aWVzLmxlbmd0aCA+IDEgfHxcbiAgICAgICAgKCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpICYmXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnNvbWUocCA9PiBwLnZhbHVlLnR5cGUgIT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovKSk7XG4gICAgcHVzaChtdWx0aWxpbmVzID8gYHtgIDogYHsgYCk7XG4gICAgbXVsdGlsaW5lcyAmJiBpbmRlbnQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAvLyBrZXlcbiAgICAgICAgZ2VuRXhwcmVzc2lvbkFzUHJvcGVydHlLZXkoa2V5LCBjb250ZXh0KTtcbiAgICAgICAgcHVzaChgOiBgKTtcbiAgICAgICAgLy8gdmFsdWVcbiAgICAgICAgZ2VuTm9kZSh2YWx1ZSwgY29udGV4dCk7XG4gICAgICAgIGlmIChpIDwgcHJvcGVydGllcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAvLyB3aWxsIG9ubHkgcmVhY2ggdGhpcyBpZiBpdCdzIG11bHRpbGluZXNcbiAgICAgICAgICAgIHB1c2goYCxgKTtcbiAgICAgICAgICAgIG5ld2xpbmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtdWx0aWxpbmVzICYmIGRlaW5kZW50KCk7XG4gICAgcHVzaChtdWx0aWxpbmVzID8gYH1gIDogYCB9YCk7XG59XG5mdW5jdGlvbiBnZW5BcnJheUV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xuICAgIGdlbk5vZGVMaXN0QXNBcnJheShub2RlLmVsZW1lbnRzLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGdlbkZ1bmN0aW9uRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyBwdXNoLCBpbmRlbnQsIGRlaW5kZW50IH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHsgcGFyYW1zLCByZXR1cm5zLCBib2R5LCBuZXdsaW5lLCBpc1Nsb3QgfSA9IG5vZGU7XG4gICAgaWYgKGlzU2xvdCkge1xuICAgICAgICAvLyB3cmFwIHNsb3QgZnVuY3Rpb25zIHdpdGggb3duZXIgY29udGV4dFxuICAgICAgICBwdXNoKGBfJHtoZWxwZXJOYW1lTWFwW1dJVEhfQ1RYXX0oYCk7XG4gICAgfVxuICAgIHB1c2goYChgLCBub2RlKTtcbiAgICBpZiAoKDAsIHNoYXJlZF8xLmlzQXJyYXkpKHBhcmFtcykpIHtcbiAgICAgICAgZ2VuTm9kZUxpc3QocGFyYW1zLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyYW1zKSB7XG4gICAgICAgIGdlbk5vZGUocGFyYW1zLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcHVzaChgKSA9PiBgKTtcbiAgICBpZiAobmV3bGluZSB8fCBib2R5KSB7XG4gICAgICAgIHB1c2goYHtgKTtcbiAgICAgICAgaW5kZW50KCk7XG4gICAgfVxuICAgIGlmIChyZXR1cm5zKSB7XG4gICAgICAgIGlmIChuZXdsaW5lKSB7XG4gICAgICAgICAgICBwdXNoKGByZXR1cm4gYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBzaGFyZWRfMS5pc0FycmF5KShyZXR1cm5zKSkge1xuICAgICAgICAgICAgZ2VuTm9kZUxpc3RBc0FycmF5KHJldHVybnMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VuTm9kZShyZXR1cm5zLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChib2R5KSB7XG4gICAgICAgIGdlbk5vZGUoYm9keSwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChuZXdsaW5lIHx8IGJvZHkpIHtcbiAgICAgICAgZGVpbmRlbnQoKTtcbiAgICAgICAgcHVzaChgfWApO1xuICAgIH1cbiAgICBpZiAoaXNTbG90KSB7XG4gICAgICAgIGlmIChub2RlLmlzTm9uU2NvcGVkU2xvdCkge1xuICAgICAgICAgICAgcHVzaChgLCB1bmRlZmluZWQsIHRydWVgKTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoKGApYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2VuQ29uZGl0aW9uYWxFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSwgbmV3bGluZTogbmVlZE5ld2xpbmUgfSA9IG5vZGU7XG4gICAgY29uc3QgeyBwdXNoLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lIH0gPSBjb250ZXh0O1xuICAgIGlmICh0ZXN0LnR5cGUgPT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgIGNvbnN0IG5lZWRzUGFyZW5zID0gIWlzU2ltcGxlSWRlbnRpZmllcih0ZXN0LmNvbnRlbnQpO1xuICAgICAgICBuZWVkc1BhcmVucyAmJiBwdXNoKGAoYCk7XG4gICAgICAgIGdlbkV4cHJlc3Npb24odGVzdCwgY29udGV4dCk7XG4gICAgICAgIG5lZWRzUGFyZW5zICYmIHB1c2goYClgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHB1c2goYChgKTtcbiAgICAgICAgZ2VuTm9kZSh0ZXN0LCBjb250ZXh0KTtcbiAgICAgICAgcHVzaChgKWApO1xuICAgIH1cbiAgICBuZWVkTmV3bGluZSAmJiBpbmRlbnQoKTtcbiAgICBjb250ZXh0LmluZGVudExldmVsKys7XG4gICAgbmVlZE5ld2xpbmUgfHwgcHVzaChgIGApO1xuICAgIHB1c2goYD8gYCk7XG4gICAgZ2VuTm9kZShjb25zZXF1ZW50LCBjb250ZXh0KTtcbiAgICBjb250ZXh0LmluZGVudExldmVsLS07XG4gICAgbmVlZE5ld2xpbmUgJiYgbmV3bGluZSgpO1xuICAgIG5lZWROZXdsaW5lIHx8IHB1c2goYCBgKTtcbiAgICBwdXNoKGA6IGApO1xuICAgIGNvbnN0IGlzTmVzdGVkID0gYWx0ZXJuYXRlLnR5cGUgPT09IDE5IC8qIE5vZGVUeXBlcy5KU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovO1xuICAgIGlmICghaXNOZXN0ZWQpIHtcbiAgICAgICAgY29udGV4dC5pbmRlbnRMZXZlbCsrO1xuICAgIH1cbiAgICBnZW5Ob2RlKGFsdGVybmF0ZSwgY29udGV4dCk7XG4gICAgaWYgKCFpc05lc3RlZCkge1xuICAgICAgICBjb250ZXh0LmluZGVudExldmVsLS07XG4gICAgfVxuICAgIG5lZWROZXdsaW5lICYmIGRlaW5kZW50KHRydWUgLyogd2l0aG91dCBuZXdsaW5lICovKTtcbn1cbmZ1bmN0aW9uIGdlbkNhY2hlRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIGluZGVudCwgZGVpbmRlbnQsIG5ld2xpbmUgfSA9IGNvbnRleHQ7XG4gICAgcHVzaChgX2NhY2hlWyR7bm9kZS5pbmRleH1dIHx8IChgKTtcbiAgICBpZiAobm9kZS5pc1ZOb2RlKSB7XG4gICAgICAgIGluZGVudCgpO1xuICAgICAgICBwdXNoKGAke2hlbHBlcihTRVRfQkxPQ0tfVFJBQ0tJTkcpfSgtMSksYCk7XG4gICAgICAgIG5ld2xpbmUoKTtcbiAgICB9XG4gICAgcHVzaChgX2NhY2hlWyR7bm9kZS5pbmRleH1dID0gYCk7XG4gICAgZ2VuTm9kZShub2RlLnZhbHVlLCBjb250ZXh0KTtcbiAgICBpZiAobm9kZS5pc1ZOb2RlKSB7XG4gICAgICAgIHB1c2goYCxgKTtcbiAgICAgICAgbmV3bGluZSgpO1xuICAgICAgICBwdXNoKGAke2hlbHBlcihTRVRfQkxPQ0tfVFJBQ0tJTkcpfSgxKSxgKTtcbiAgICAgICAgbmV3bGluZSgpO1xuICAgICAgICBwdXNoKGBfY2FjaGVbJHtub2RlLmluZGV4fV1gKTtcbiAgICAgICAgZGVpbmRlbnQoKTtcbiAgICB9XG4gICAgcHVzaChgKWApO1xufVxuZnVuY3Rpb24gd2Fsa0lkZW50aWZpZXJzKHJvb3QsIG9uSWRlbnRpZmllciwgaW5jbHVkZUFsbCA9IGZhbHNlLCBwYXJlbnRTdGFjayA9IFtdLCBrbm93bklkcyA9IE9iamVjdC5jcmVhdGUobnVsbCkpIHtcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59XG5leHBvcnRzLndhbGtJZGVudGlmaWVycyA9IHdhbGtJZGVudGlmaWVycztcbmZ1bmN0aW9uIGlzUmVmZXJlbmNlZElkZW50aWZpZXIoaWQsIHBhcmVudCwgcGFyZW50U3RhY2spIHtcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLmlzUmVmZXJlbmNlZElkZW50aWZpZXIgPSBpc1JlZmVyZW5jZWRJZGVudGlmaWVyO1xuZnVuY3Rpb24gaXNJbkRlc3RydWN0dXJlQXNzaWdubWVudChwYXJlbnQsIHBhcmVudFN0YWNrKSB7XG4gICAgaWYgKHBhcmVudCAmJlxuICAgICAgICAocGFyZW50LnR5cGUgPT09ICdPYmplY3RQcm9wZXJ0eScgfHwgcGFyZW50LnR5cGUgPT09ICdBcnJheVBhdHRlcm4nKSkge1xuICAgICAgICBsZXQgaSA9IHBhcmVudFN0YWNrLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgY29uc3QgcCA9IHBhcmVudFN0YWNrW2ldO1xuICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocC50eXBlICE9PSAnT2JqZWN0UHJvcGVydHknICYmICFwLnR5cGUuZW5kc1dpdGgoJ1BhdHRlcm4nKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNJbkRlc3RydWN0dXJlQXNzaWdubWVudCA9IGlzSW5EZXN0cnVjdHVyZUFzc2lnbm1lbnQ7XG5mdW5jdGlvbiB3YWxrRnVuY3Rpb25QYXJhbXMobm9kZSwgb25JZGVudCkge1xuICAgIGZvciAoY29uc3QgcCBvZiBub2RlLnBhcmFtcykge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGV4dHJhY3RJZGVudGlmaWVycyhwKSkge1xuICAgICAgICAgICAgb25JZGVudChpZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLndhbGtGdW5jdGlvblBhcmFtcyA9IHdhbGtGdW5jdGlvblBhcmFtcztcbmZ1bmN0aW9uIHdhbGtCbG9ja0RlY2xhcmF0aW9ucyhibG9jaywgb25JZGVudCkge1xuICAgIGZvciAoY29uc3Qgc3RtdCBvZiBibG9jay5ib2R5KSB7XG4gICAgICAgIGlmIChzdG10LnR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0aW9uJykge1xuICAgICAgICAgICAgaWYgKHN0bXQuZGVjbGFyZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVjbCBvZiBzdG10LmRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaWQgb2YgZXh0cmFjdElkZW50aWZpZXJzKGRlY2wuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uSWRlbnQoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdG10LnR5cGUgPT09ICdGdW5jdGlvbkRlY2xhcmF0aW9uJyB8fFxuICAgICAgICAgICAgc3RtdC50eXBlID09PSAnQ2xhc3NEZWNsYXJhdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChzdG10LmRlY2xhcmUgfHwgIXN0bXQuaWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBvbklkZW50KHN0bXQuaWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy53YWxrQmxvY2tEZWNsYXJhdGlvbnMgPSB3YWxrQmxvY2tEZWNsYXJhdGlvbnM7XG5mdW5jdGlvbiBleHRyYWN0SWRlbnRpZmllcnMocGFyYW0sIG5vZGVzID0gW10pIHtcbiAgICBzd2l0Y2ggKHBhcmFtLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnSWRlbnRpZmllcic6XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNZW1iZXJFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGxldCBvYmplY3QgPSBwYXJhbTtcbiAgICAgICAgICAgIHdoaWxlIChvYmplY3QudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0Lm9iamVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVzLnB1c2gob2JqZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdPYmplY3RQYXR0ZXJuJzpcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBwYXJhbS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gJ1Jlc3RFbGVtZW50Jykge1xuICAgICAgICAgICAgICAgICAgICBleHRyYWN0SWRlbnRpZmllcnMocHJvcC5hcmd1bWVudCwgbm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdElkZW50aWZpZXJzKHByb3AudmFsdWUsIG5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXJyYXlQYXR0ZXJuJzpcbiAgICAgICAgICAgIHBhcmFtLmVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RJZGVudGlmaWVycyhlbGVtZW50LCBub2Rlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdSZXN0RWxlbWVudCc6XG4gICAgICAgICAgICBleHRyYWN0SWRlbnRpZmllcnMocGFyYW0uYXJndW1lbnQsIG5vZGVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBc3NpZ25tZW50UGF0dGVybic6XG4gICAgICAgICAgICBleHRyYWN0SWRlbnRpZmllcnMocGFyYW0ubGVmdCwgbm9kZXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBub2Rlcztcbn1cbmV4cG9ydHMuZXh0cmFjdElkZW50aWZpZXJzID0gZXh0cmFjdElkZW50aWZpZXJzO1xuY29uc3QgaXNGdW5jdGlvblR5cGUgPSAobm9kZSkgPT4ge1xuICAgIHJldHVybiAvRnVuY3Rpb24oPzpFeHByZXNzaW9ufERlY2xhcmF0aW9uKSR8TWV0aG9kJC8udGVzdChub2RlLnR5cGUpO1xufTtcbmV4cG9ydHMuaXNGdW5jdGlvblR5cGUgPSBpc0Z1bmN0aW9uVHlwZTtcbmNvbnN0IGlzU3RhdGljUHJvcGVydHkgPSAobm9kZSkgPT4gbm9kZSAmJlxuICAgIChub2RlLnR5cGUgPT09ICdPYmplY3RQcm9wZXJ0eScgfHwgbm9kZS50eXBlID09PSAnT2JqZWN0TWV0aG9kJykgJiZcbiAgICAhbm9kZS5jb21wdXRlZDtcbmV4cG9ydHMuaXNTdGF0aWNQcm9wZXJ0eSA9IGlzU3RhdGljUHJvcGVydHk7XG5jb25zdCBpc1N0YXRpY1Byb3BlcnR5S2V5ID0gKG5vZGUsIHBhcmVudCkgPT4gaXNTdGF0aWNQcm9wZXJ0eShwYXJlbnQpICYmIHBhcmVudC5rZXkgPT09IG5vZGU7XG5leHBvcnRzLmlzU3RhdGljUHJvcGVydHlLZXkgPSBpc1N0YXRpY1Byb3BlcnR5S2V5O1xuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2Vcbi8vICd0eXBlb2YnLCAnaW5zdGFuY2VvZicsIGFuZCAnaW4nIGFyZSBhbGxvd2VkXG5jb25zdCBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICtcbiAgICAoJ2FyZ3VtZW50cyxhd2FpdCxicmVhayxjYXNlLGNhdGNoLGNsYXNzLGNvbnN0LGNvbnRpbnVlLGRlYnVnZ2VyLGRlZmF1bHQsJyArXG4gICAgICAgICdkZWxldGUsZG8sZWxzZSxleHBvcnQsZXh0ZW5kcyxmaW5hbGx5LGZvcixmdW5jdGlvbixpZixpbXBvcnQsbGV0LG5ldywnICtcbiAgICAgICAgJ3JldHVybixzdXBlcixzd2l0Y2gsdGhyb3csdHJ5LHZhcix2b2lkLHdoaWxlLHdpdGgseWllbGQnKVxuICAgICAgICAuc3BsaXQoJywnKVxuICAgICAgICAuam9pbignXFxcXGJ8XFxcXGInKSArXG4gICAgJ1xcXFxiJyk7XG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXG5jb25zdCBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XG4vKipcbiAqIFZhbGlkYXRlIGEgbm9uLXByZWZpeGVkIGV4cHJlc3Npb24uXG4gKiBUaGlzIGlzIG9ubHkgY2FsbGVkIHdoZW4gdXNpbmcgdGhlIGluLWJyb3dzZXIgcnVudGltZSBjb21waWxlciBzaW5jZSBpdFxuICogZG9lc24ndCBwcmVmaXggZXhwcmVzc2lvbnMuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24obm9kZSwgY29udGV4dCwgYXNQYXJhbXMgPSBmYWxzZSwgYXNSYXdTdGF0ZW1lbnRzID0gZmFsc2UpIHtcbiAgICBjb25zdCBleHAgPSBub2RlLmNvbnRlbnQ7XG4gICAgLy8gZW1wdHkgZXhwcmVzc2lvbnMgYXJlIHZhbGlkYXRlZCBwZXItZGlyZWN0aXZlIHNpbmNlIHNvbWUgZGlyZWN0aXZlc1xuICAgIC8vIGRvIGFsbG93IGVtcHR5IGV4cHJlc3Npb25zLlxuICAgIGlmICghZXhwLnRyaW0oKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIG5ldyBGdW5jdGlvbihhc1Jhd1N0YXRlbWVudHNcbiAgICAgICAgICAgID8gYCAke2V4cH0gYFxuICAgICAgICAgICAgOiBgcmV0dXJuICR7YXNQYXJhbXMgPyBgKCR7ZXhwfSkgPT4ge31gIDogYCgke2V4cH0pYH1gKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBlLm1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IGtleXdvcmRNYXRjaCA9IGV4cFxuICAgICAgICAgICAgLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpXG4gICAgICAgICAgICAubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XG4gICAgICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiJHtrZXl3b3JkTWF0Y2hbMF19XCJgO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQ1IC8qIEVycm9yQ29kZXMuWF9JTlZBTElEX0VYUFJFU1NJT04gKi8sIG5vZGUubG9jLCB1bmRlZmluZWQsIG1lc3NhZ2UpKTtcbiAgICB9XG59XG5jb25zdCB0cmFuc2Zvcm1FeHByZXNzaW9uID0gKG5vZGUsIGNvbnRleHQpID0+IHtcbiAgICBpZiAobm9kZS50eXBlID09PSA1IC8qIE5vZGVUeXBlcy5JTlRFUlBPTEFUSU9OICovKSB7XG4gICAgICAgIG5vZGUuY29udGVudCA9IHByb2Nlc3NFeHByZXNzaW9uKG5vZGUuY29udGVudCwgY29udGV4dCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLykge1xuICAgICAgICAvLyBoYW5kbGUgZGlyZWN0aXZlcyBvbiBlbGVtZW50XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGlyID0gbm9kZS5wcm9wc1tpXTtcbiAgICAgICAgICAgIC8vIGRvIG5vdCBwcm9jZXNzIGZvciB2LW9uICYgdi1mb3Igc2luY2UgdGhleSBhcmUgc3BlY2lhbCBoYW5kbGVkXG4gICAgICAgICAgICBpZiAoZGlyLnR5cGUgPT09IDcgLyogTm9kZVR5cGVzLkRJUkVDVElWRSAqLyAmJiBkaXIubmFtZSAhPT0gJ2ZvcicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHAgPSBkaXIuZXhwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZyA9IGRpci5hcmc7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IHByb2Nlc3MgZXhwIGlmIHRoaXMgaXMgdi1vbjphcmcgLSB3ZSBuZWVkIHNwZWNpYWwgaGFuZGxpbmdcbiAgICAgICAgICAgICAgICAvLyBmb3Igd3JhcHBpbmcgaW5saW5lIHN0YXRlbWVudHMuXG4gICAgICAgICAgICAgICAgaWYgKGV4cCAmJlxuICAgICAgICAgICAgICAgICAgICBleHAudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgIShkaXIubmFtZSA9PT0gJ29uJyAmJiBhcmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpci5leHAgPSBwcm9jZXNzRXhwcmVzc2lvbihleHAsIGNvbnRleHQsIFxuICAgICAgICAgICAgICAgICAgICAvLyBzbG90IGFyZ3MgbXVzdCBiZSBwcm9jZXNzZWQgYXMgZnVuY3Rpb24gcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgIGRpci5uYW1lID09PSAnc2xvdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXJnICYmIGFyZy50eXBlID09PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLyAmJiAhYXJnLmlzU3RhdGljKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpci5hcmcgPSBwcm9jZXNzRXhwcmVzc2lvbihhcmcsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnRzLnRyYW5zZm9ybUV4cHJlc3Npb24gPSB0cmFuc2Zvcm1FeHByZXNzaW9uO1xuLy8gSW1wb3J0YW50OiBzaW5jZSB0aGlzIGZ1bmN0aW9uIHVzZXMgTm9kZS5qcyBvbmx5IGRlcGVuZGVuY2llcywgaXQgc2hvdWxkXG4vLyBhbHdheXMgYmUgdXNlZCB3aXRoIGEgbGVhZGluZyAhdHJ1ZSBjaGVjayBzbyB0aGF0IGl0IGNhbiBiZVxuLy8gdHJlZS1zaGFrZW4gZnJvbSB0aGUgYnJvd3NlciBidWlsZC5cbmZ1bmN0aW9uIHByb2Nlc3NFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQsIFxuLy8gc29tZSBleHByZXNzaW9ucyBsaWtlIHYtc2xvdCBwcm9wcyAmIHYtZm9yIGFsaWFzZXMgc2hvdWxkIGJlIHBhcnNlZCBhc1xuLy8gZnVuY3Rpb24gcGFyYW1zXG5hc1BhcmFtcyA9IGZhbHNlLCBcbi8vIHYtb24gaGFuZGxlciB2YWx1ZXMgbWF5IGNvbnRhaW4gbXVsdGlwbGUgc3RhdGVtZW50c1xuYXNSYXdTdGF0ZW1lbnRzID0gZmFsc2UsIGxvY2FsVmFycyA9IE9iamVjdC5jcmVhdGUoY29udGV4dC5pZGVudGlmaWVycykpIHtcbiAgICB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIC8vIHNpbXBsZSBpbi1icm93c2VyIHZhbGlkYXRpb24gKHNhbWUgbG9naWMgaW4gMi54KVxuICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihub2RlLCBjb250ZXh0LCBhc1BhcmFtcywgYXNSYXdTdGF0ZW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG59XG5leHBvcnRzLnByb2Nlc3NFeHByZXNzaW9uID0gcHJvY2Vzc0V4cHJlc3Npb247XG5mdW5jdGlvbiBzdHJpbmdpZnlFeHByZXNzaW9uKGV4cCkge1xuICAgIGlmICgoMCwgc2hhcmVkXzEuaXNTdHJpbmcpKGV4cCkpIHtcbiAgICAgICAgcmV0dXJuIGV4cDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwLnR5cGUgPT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgIHJldHVybiBleHAuY29udGVudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBleHAuY2hpbGRyZW5cbiAgICAgICAgICAgIC5tYXAoc3RyaW5naWZ5RXhwcmVzc2lvbilcbiAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICB9XG59XG5leHBvcnRzLnN0cmluZ2lmeUV4cHJlc3Npb24gPSBzdHJpbmdpZnlFeHByZXNzaW9uO1xuY29uc3QgdHJhbnNmb3JtSWYgPSBjcmVhdGVTdHJ1Y3R1cmFsRGlyZWN0aXZlVHJhbnNmb3JtKC9eKGlmfGVsc2V8ZWxzZS1pZikkLywgKG5vZGUsIGRpciwgY29udGV4dCkgPT4ge1xuICAgIHJldHVybiBwcm9jZXNzSWYobm9kZSwgZGlyLCBjb250ZXh0LCAoaWZOb2RlLCBicmFuY2gsIGlzUm9vdCkgPT4ge1xuICAgICAgICAvLyAjMTU4NzogV2UgbmVlZCB0byBkeW5hbWljYWxseSBpbmNyZW1lbnQgdGhlIGtleSBiYXNlZCBvbiB0aGUgY3VycmVudFxuICAgICAgICAvLyBub2RlJ3Mgc2libGluZyBub2Rlcywgc2luY2UgY2hhaW5lZCB2LWlmL2Vsc2UgYnJhbmNoZXMgYXJlXG4gICAgICAgIC8vIHJlbmRlcmVkIGF0IHRoZSBzYW1lIGRlcHRoXG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gY29udGV4dC5wYXJlbnQuY2hpbGRyZW47XG4gICAgICAgIGxldCBpID0gc2libGluZ3MuaW5kZXhPZihpZk5vZGUpO1xuICAgICAgICBsZXQga2V5ID0gMDtcbiAgICAgICAgd2hpbGUgKGktLSA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gc2libGluZ3NbaV07XG4gICAgICAgICAgICBpZiAoc2libGluZyAmJiBzaWJsaW5nLnR5cGUgPT09IDkgLyogTm9kZVR5cGVzLklGICovKSB7XG4gICAgICAgICAgICAgICAga2V5ICs9IHNpYmxpbmcuYnJhbmNoZXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEV4aXQgY2FsbGJhY2suIENvbXBsZXRlIHRoZSBjb2RlZ2VuTm9kZSB3aGVuIGFsbCBjaGlsZHJlbiBoYXZlIGJlZW5cbiAgICAgICAgLy8gdHJhbnNmb3JtZWQuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgICAgICAgICAgaWZOb2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlQ29kZWdlbk5vZGVGb3JCcmFuY2goYnJhbmNoLCBrZXksIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYXR0YWNoIHRoaXMgYnJhbmNoJ3MgY29kZWdlbiBub2RlIHRvIHRoZSB2LWlmIHJvb3QuXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Q29uZGl0aW9uID0gZ2V0UGFyZW50Q29uZGl0aW9uKGlmTm9kZS5jb2RlZ2VuTm9kZSk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZGl0aW9uLmFsdGVybmF0ZSA9IGNyZWF0ZUNvZGVnZW5Ob2RlRm9yQnJhbmNoKGJyYW5jaCwga2V5ICsgaWZOb2RlLmJyYW5jaGVzLmxlbmd0aCAtIDEsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xufSk7XG4vLyB0YXJnZXQtYWdub3N0aWMgdHJhbnNmb3JtIHVzZWQgZm9yIGJvdGggQ2xpZW50IGFuZCBTU1JcbmZ1bmN0aW9uIHByb2Nlc3NJZihub2RlLCBkaXIsIGNvbnRleHQsIHByb2Nlc3NDb2RlZ2VuKSB7XG4gICAgaWYgKGRpci5uYW1lICE9PSAnZWxzZScgJiZcbiAgICAgICAgKCFkaXIuZXhwIHx8ICFkaXIuZXhwLmNvbnRlbnQudHJpbSgpKSkge1xuICAgICAgICBjb25zdCBsb2MgPSBkaXIuZXhwID8gZGlyLmV4cC5sb2MgOiBub2RlLmxvYztcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMjggLyogRXJyb3JDb2Rlcy5YX1ZfSUZfTk9fRVhQUkVTU0lPTiAqLywgZGlyLmxvYykpO1xuICAgICAgICBkaXIuZXhwID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgdHJ1ZWAsIGZhbHNlLCBsb2MpO1xuICAgIH1cbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUgJiYgZGlyLmV4cCkge1xuICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKGRpci5leHAsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoZGlyLm5hbWUgPT09ICdpZicpIHtcbiAgICAgICAgY29uc3QgYnJhbmNoID0gY3JlYXRlSWZCcmFuY2gobm9kZSwgZGlyKTtcbiAgICAgICAgY29uc3QgaWZOb2RlID0ge1xuICAgICAgICAgICAgdHlwZTogOSAvKiBOb2RlVHlwZXMuSUYgKi8sXG4gICAgICAgICAgICBsb2M6IG5vZGUubG9jLFxuICAgICAgICAgICAgYnJhbmNoZXM6IFticmFuY2hdXG4gICAgICAgIH07XG4gICAgICAgIGNvbnRleHQucmVwbGFjZU5vZGUoaWZOb2RlKTtcbiAgICAgICAgaWYgKHByb2Nlc3NDb2RlZ2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0NvZGVnZW4oaWZOb2RlLCBicmFuY2gsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBsb2NhdGUgdGhlIGFkamFjZW50IHYtaWZcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBjb250ZXh0LnBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgY29tbWVudHMgPSBbXTtcbiAgICAgICAgbGV0IGkgPSBzaWJsaW5ncy5pbmRleE9mKG5vZGUpO1xuICAgICAgICB3aGlsZSAoaS0tID49IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gc2libGluZ3NbaV07XG4gICAgICAgICAgICBpZiAoc2libGluZyAmJiBzaWJsaW5nLnR5cGUgPT09IDMgLyogTm9kZVR5cGVzLkNPTU1FTlQgKi8pIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZU5vZGUoc2libGluZyk7XG4gICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbW1lbnRzLnVuc2hpZnQoc2libGluZyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2libGluZyAmJlxuICAgICAgICAgICAgICAgIHNpYmxpbmcudHlwZSA9PT0gMiAvKiBOb2RlVHlwZXMuVEVYVCAqLyAmJlxuICAgICAgICAgICAgICAgICFzaWJsaW5nLmNvbnRlbnQudHJpbSgpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlTm9kZShzaWJsaW5nKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcudHlwZSA9PT0gOSAvKiBOb2RlVHlwZXMuSUYgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB2LWVsc2Ugd2FzIGZvbGxvd2VkIGJ5IHYtZWxzZS1pZlxuICAgICAgICAgICAgICAgIGlmIChkaXIubmFtZSA9PT0gJ2Vsc2UtaWYnICYmXG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmcuYnJhbmNoZXNbc2libGluZy5icmFuY2hlcy5sZW5ndGggLSAxXS5jb25kaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMCAvKiBFcnJvckNvZGVzLlhfVl9FTFNFX05PX0FESkFDRU5UX0lGICovLCBub2RlLmxvYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHRoZSBub2RlIHRvIHRoZSBpZiBub2RlJ3MgYnJhbmNoZXNcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZU5vZGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBicmFuY2ggPSBjcmVhdGVJZkJyYW5jaChub2RlLCBkaXIpO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIC8vICMzNjE5IGlnbm9yZSBjb21tZW50cyBpZiB0aGUgdi1pZiBpcyBkaXJlY3QgY2hpbGQgb2YgPHRyYW5zaXRpb24+XG4gICAgICAgICAgICAgICAgICAgICEoY29udGV4dC5wYXJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucGFyZW50LnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQnVpbHRJblR5cGUoY29udGV4dC5wYXJlbnQudGFnLCAndHJhbnNpdGlvbicpKSkge1xuICAgICAgICAgICAgICAgICAgICBicmFuY2guY2hpbGRyZW4gPSBbLi4uY29tbWVudHMsIC4uLmJyYW5jaC5jaGlsZHJlbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHVzZXIgaXMgZm9yY2luZyBzYW1lIGtleSBvbiBkaWZmZXJlbnQgYnJhbmNoZXNcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICF0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGJyYW5jaC51c2VyS2V5O1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nLmJyYW5jaGVzLmZvckVhY2goKHsgdXNlcktleSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2FtZUtleSh1c2VyS2V5LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDI5IC8qIEVycm9yQ29kZXMuWF9WX0lGX1NBTUVfS0VZICovLCBicmFuY2gudXNlcktleS5sb2MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaWJsaW5nLmJyYW5jaGVzLnB1c2goYnJhbmNoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvbkV4aXQgPSBwcm9jZXNzQ29kZWdlbiAmJiBwcm9jZXNzQ29kZWdlbihzaWJsaW5nLCBicmFuY2gsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgYnJhbmNoIHdhcyByZW1vdmVkLCBpdCB3aWxsIG5vdCBiZSB0cmF2ZXJzZWQuXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHRyYXZlcnNlIGhlcmUuXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VOb2RlKGJyYW5jaCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgLy8gY2FsbCBvbiBleGl0XG4gICAgICAgICAgICAgICAgaWYgKG9uRXhpdClcbiAgICAgICAgICAgICAgICAgICAgb25FeGl0KCk7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHJlc2V0IGN1cnJlbnROb2RlIGFmdGVyIHRyYXZlcnNhbCB0byBpbmRpY2F0ZSB0aGlzXG4gICAgICAgICAgICAgICAgLy8gbm9kZSBoYXMgYmVlbiByZW1vdmVkLlxuICAgICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudE5vZGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzAgLyogRXJyb3JDb2Rlcy5YX1ZfRUxTRV9OT19BREpBQ0VOVF9JRiAqLywgbm9kZS5sb2MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5wcm9jZXNzSWYgPSBwcm9jZXNzSWY7XG5mdW5jdGlvbiBjcmVhdGVJZkJyYW5jaChub2RlLCBkaXIpIHtcbiAgICBjb25zdCBpc1RlbXBsYXRlSWYgPSBub2RlLnRhZ1R5cGUgPT09IDMgLyogRWxlbWVudFR5cGVzLlRFTVBMQVRFICovO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDEwIC8qIE5vZGVUeXBlcy5JRl9CUkFOQ0ggKi8sXG4gICAgICAgIGxvYzogbm9kZS5sb2MsXG4gICAgICAgIGNvbmRpdGlvbjogZGlyLm5hbWUgPT09ICdlbHNlJyA/IHVuZGVmaW5lZCA6IGRpci5leHAsXG4gICAgICAgIGNoaWxkcmVuOiBpc1RlbXBsYXRlSWYgJiYgIWZpbmREaXIobm9kZSwgJ2ZvcicpID8gbm9kZS5jaGlsZHJlbiA6IFtub2RlXSxcbiAgICAgICAgdXNlcktleTogZmluZFByb3Aobm9kZSwgYGtleWApLFxuICAgICAgICBpc1RlbXBsYXRlSWZcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ29kZWdlbk5vZGVGb3JCcmFuY2goYnJhbmNoLCBrZXlJbmRleCwgY29udGV4dCkge1xuICAgIGlmIChicmFuY2guY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24oYnJhbmNoLmNvbmRpdGlvbiwgY3JlYXRlQ2hpbGRyZW5Db2RlZ2VuTm9kZShicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KSwgXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBwYXNzIGluIGFzQmxvY2s6IHRydWUgc28gdGhhdCB0aGUgY29tbWVudCBub2RlIGNhbGxcbiAgICAgICAgLy8gY2xvc2VzIHRoZSBjdXJyZW50IGJsb2NrLlxuICAgICAgICBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihDUkVBVEVfQ09NTUVOVCksIFtcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdcInYtaWZcIicgOiAnXCJcIicsXG4gICAgICAgICAgICAndHJ1ZSdcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNoaWxkcmVuQ29kZWdlbk5vZGUoYnJhbmNoLCBrZXlJbmRleCwgY29udGV4dCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW5Db2RlZ2VuTm9kZShicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyBoZWxwZXIgfSA9IGNvbnRleHQ7XG4gICAgY29uc3Qga2V5UHJvcGVydHkgPSBjcmVhdGVPYmplY3RQcm9wZXJ0eShga2V5YCwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgJHtrZXlJbmRleH1gLCBmYWxzZSwgbG9jU3R1YiwgMiAvKiBDb25zdGFudFR5cGVzLkNBTl9IT0lTVCAqLykpO1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IGJyYW5jaDtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gY2hpbGRyZW5bMF07XG4gICAgY29uc3QgbmVlZEZyYWdtZW50V3JhcHBlciA9IGNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBmaXJzdENoaWxkLnR5cGUgIT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi87XG4gICAgaWYgKG5lZWRGcmFnbWVudFdyYXBwZXIpIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBmaXJzdENoaWxkLnR5cGUgPT09IDExIC8qIE5vZGVUeXBlcy5GT1IgKi8pIHtcbiAgICAgICAgICAgIC8vIG9wdGltaXplIGF3YXkgbmVzdGVkIGZyYWdtZW50cyB3aGVuIGNoaWxkIGlzIGEgRm9yTm9kZVxuICAgICAgICAgICAgY29uc3Qgdm5vZGVDYWxsID0gZmlyc3RDaGlsZC5jb2RlZ2VuTm9kZTtcbiAgICAgICAgICAgIGluamVjdFByb3Aodm5vZGVDYWxsLCBrZXlQcm9wZXJ0eSwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gdm5vZGVDYWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHBhdGNoRmxhZyA9IDY0IC8qIFBhdGNoRmxhZ3MuU1RBQkxFX0ZSQUdNRU5UICovO1xuICAgICAgICAgICAgbGV0IHBhdGNoRmxhZ1RleHQgPSBzaGFyZWRfMS5QYXRjaEZsYWdOYW1lc1s2NCAvKiBQYXRjaEZsYWdzLlNUQUJMRV9GUkFHTUVOVCAqL107XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgZnJhZ21lbnQgYWN0dWFsbHkgY29udGFpbnMgYSBzaW5nbGUgdmFsaWQgY2hpbGQgd2l0aFxuICAgICAgICAgICAgLy8gdGhlIHJlc3QgYmVpbmcgY29tbWVudHNcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICAhYnJhbmNoLmlzVGVtcGxhdGVJZiAmJlxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmZpbHRlcihjID0+IGMudHlwZSAhPT0gMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDIwNDggLyogUGF0Y2hGbGFncy5ERVZfUk9PVF9GUkFHTUVOVCAqLztcbiAgICAgICAgICAgICAgICBwYXRjaEZsYWdUZXh0ICs9IGAsICR7c2hhcmVkXzEuUGF0Y2hGbGFnTmFtZXNbMjA0OCAvKiBQYXRjaEZsYWdzLkRFVl9ST09UX0ZSQUdNRU5UICovXX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCBoZWxwZXIoRlJBR01FTlQpLCBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtrZXlQcm9wZXJ0eV0pLCBjaGlsZHJlbiwgcGF0Y2hGbGFnICsgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogJHtwYXRjaEZsYWdUZXh0fSAqL2AgOiBgYCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlLCBmYWxzZSwgZmFsc2UgLyogaXNDb21wb25lbnQgKi8sIGJyYW5jaC5sb2MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCByZXQgPSBmaXJzdENoaWxkLmNvZGVnZW5Ob2RlO1xuICAgICAgICBjb25zdCB2bm9kZUNhbGwgPSBnZXRNZW1vZWRWTm9kZUNhbGwocmV0KTtcbiAgICAgICAgLy8gQ2hhbmdlIGNyZWF0ZVZOb2RlIHRvIGNyZWF0ZUJsb2NrLlxuICAgICAgICBpZiAodm5vZGVDYWxsLnR5cGUgPT09IDEzIC8qIE5vZGVUeXBlcy5WTk9ERV9DQUxMICovKSB7XG4gICAgICAgICAgICBtYWtlQmxvY2sodm5vZGVDYWxsLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbmplY3QgYnJhbmNoIGtleVxuICAgICAgICBpbmplY3RQcm9wKHZub2RlQ2FsbCwga2V5UHJvcGVydHksIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU2FtZUtleShhLCBiKSB7XG4gICAgaWYgKCFhIHx8IGEudHlwZSAhPT0gYi50eXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGEudHlwZSA9PT0gNiAvKiBOb2RlVHlwZXMuQVRUUklCVVRFICovKSB7XG4gICAgICAgIGlmIChhLnZhbHVlLmNvbnRlbnQgIT09IGIudmFsdWUuY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RpdmVcbiAgICAgICAgY29uc3QgZXhwID0gYS5leHA7XG4gICAgICAgIGNvbnN0IGJyYW5jaEV4cCA9IGIuZXhwO1xuICAgICAgICBpZiAoZXhwLnR5cGUgIT09IGJyYW5jaEV4cC50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cC50eXBlICE9PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLyB8fFxuICAgICAgICAgICAgZXhwLmlzU3RhdGljICE9PSBicmFuY2hFeHAuaXNTdGF0aWMgfHxcbiAgICAgICAgICAgIGV4cC5jb250ZW50ICE9PSBicmFuY2hFeHAuY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0UGFyZW50Q29uZGl0aW9uKG5vZGUpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAxOSAvKiBOb2RlVHlwZXMuSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlLnR5cGUgPT09IDE5IC8qIE5vZGVUeXBlcy5KU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAyMCAvKiBOb2RlVHlwZXMuSlNfQ0FDSEVfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCB0cmFuc2Zvcm1Gb3IgPSBjcmVhdGVTdHJ1Y3R1cmFsRGlyZWN0aXZlVHJhbnNmb3JtKCdmb3InLCAobm9kZSwgZGlyLCBjb250ZXh0KSA9PiB7XG4gICAgY29uc3QgeyBoZWxwZXIsIHJlbW92ZUhlbHBlciB9ID0gY29udGV4dDtcbiAgICByZXR1cm4gcHJvY2Vzc0Zvcihub2RlLCBkaXIsIGNvbnRleHQsIGZvck5vZGUgPT4ge1xuICAgICAgICAvLyBjcmVhdGUgdGhlIGxvb3AgcmVuZGVyIGZ1bmN0aW9uIGV4cHJlc3Npb24gbm93LCBhbmQgYWRkIHRoZVxuICAgICAgICAvLyBpdGVyYXRvciBvbiBleGl0IGFmdGVyIGFsbCBjaGlsZHJlbiBoYXZlIGJlZW4gdHJhdmVyc2VkXG4gICAgICAgIGNvbnN0IHJlbmRlckV4cCA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGhlbHBlcihSRU5ERVJfTElTVCksIFtcbiAgICAgICAgICAgIGZvck5vZGUuc291cmNlXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBpc1RlbXBsYXRlID0gaXNUZW1wbGF0ZU5vZGUobm9kZSk7XG4gICAgICAgIGNvbnN0IG1lbW8gPSBmaW5kRGlyKG5vZGUsICdtZW1vJyk7XG4gICAgICAgIGNvbnN0IGtleVByb3AgPSBmaW5kUHJvcChub2RlLCBga2V5YCk7XG4gICAgICAgIGNvbnN0IGtleUV4cCA9IGtleVByb3AgJiZcbiAgICAgICAgICAgIChrZXlQcm9wLnR5cGUgPT09IDYgLyogTm9kZVR5cGVzLkFUVFJJQlVURSAqL1xuICAgICAgICAgICAgICAgID8gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihrZXlQcm9wLnZhbHVlLmNvbnRlbnQsIHRydWUpXG4gICAgICAgICAgICAgICAgOiBrZXlQcm9wLmV4cCk7XG4gICAgICAgIGNvbnN0IGtleVByb3BlcnR5ID0ga2V5UHJvcCA/IGNyZWF0ZU9iamVjdFByb3BlcnR5KGBrZXlgLCBrZXlFeHApIDogbnVsbDtcbiAgICAgICAgY29uc3QgaXNTdGFibGVGcmFnbWVudCA9IGZvck5vZGUuc291cmNlLnR5cGUgPT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovICYmXG4gICAgICAgICAgICBmb3JOb2RlLnNvdXJjZS5jb25zdFR5cGUgPiAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovO1xuICAgICAgICBjb25zdCBmcmFnbWVudEZsYWcgPSBpc1N0YWJsZUZyYWdtZW50XG4gICAgICAgICAgICA/IDY0IC8qIFBhdGNoRmxhZ3MuU1RBQkxFX0ZSQUdNRU5UICovXG4gICAgICAgICAgICA6IGtleVByb3BcbiAgICAgICAgICAgICAgICA/IDEyOCAvKiBQYXRjaEZsYWdzLktFWUVEX0ZSQUdNRU5UICovXG4gICAgICAgICAgICAgICAgOiAyNTYgLyogUGF0Y2hGbGFncy5VTktFWUVEX0ZSQUdNRU5UICovO1xuICAgICAgICBmb3JOb2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlVk5vZGVDYWxsKGNvbnRleHQsIGhlbHBlcihGUkFHTUVOVCksIHVuZGVmaW5lZCwgcmVuZGVyRXhwLCBmcmFnbWVudEZsYWcgK1xuICAgICAgICAgICAgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogJHtzaGFyZWRfMS5QYXRjaEZsYWdOYW1lc1tmcmFnbWVudEZsYWddfSAqL2AgOiBgYCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlIC8qIGlzQmxvY2sgKi8sICFpc1N0YWJsZUZyYWdtZW50IC8qIGRpc2FibGVUcmFja2luZyAqLywgZmFsc2UgLyogaXNDb21wb25lbnQgKi8sIG5vZGUubG9jKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIC8vIGZpbmlzaCB0aGUgY29kZWdlbiBub3cgdGhhdCBhbGwgY2hpbGRyZW4gaGF2ZSBiZWVuIHRyYXZlcnNlZFxuICAgICAgICAgICAgbGV0IGNoaWxkQmxvY2s7XG4gICAgICAgICAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSBmb3JOb2RlO1xuICAgICAgICAgICAgLy8gY2hlY2sgPHRlbXBsYXRlIHYtZm9yPiBrZXkgcGxhY2VtZW50XG4gICAgICAgICAgICBpZiAoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAhdHJ1ZSkgJiYgaXNUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uc29tZShjID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZmluZFByb3AoYywgJ2tleScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMzIC8qIEVycm9yQ29kZXMuWF9WX0ZPUl9URU1QTEFURV9LRVlfUExBQ0VNRU5UICovLCBrZXkubG9jKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5lZWRGcmFnbWVudFdyYXBwZXIgPSBjaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgY2hpbGRyZW5bMF0udHlwZSAhPT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLztcbiAgICAgICAgICAgIGNvbnN0IHNsb3RPdXRsZXQgPSBpc1Nsb3RPdXRsZXQobm9kZSlcbiAgICAgICAgICAgICAgICA/IG5vZGVcbiAgICAgICAgICAgICAgICA6IGlzVGVtcGxhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNTbG90T3V0bGV0KG5vZGUuY2hpbGRyZW5bMF0pXG4gICAgICAgICAgICAgICAgICAgID8gbm9kZS5jaGlsZHJlblswXSAvLyBhcGktZXh0cmFjdG9yIHNvbWVob3cgZmFpbHMgdG8gaW5mZXIgdGhpc1xuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBpZiAoc2xvdE91dGxldCkge1xuICAgICAgICAgICAgICAgIC8vIDxzbG90IHYtZm9yPVwiLi4uXCI+IG9yIDx0ZW1wbGF0ZSB2LWZvcj1cIi4uLlwiPjxzbG90Lz48L3RlbXBsYXRlPlxuICAgICAgICAgICAgICAgIGNoaWxkQmxvY2sgPSBzbG90T3V0bGV0LmNvZGVnZW5Ob2RlO1xuICAgICAgICAgICAgICAgIGlmIChpc1RlbXBsYXRlICYmIGtleVByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDx0ZW1wbGF0ZSB2LWZvcj1cIi4uLlwiIDprZXk9XCIuLi5cIj48c2xvdC8+PC90ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBpbmplY3QgdGhlIGtleSB0byB0aGUgcmVuZGVyU2xvdCgpIGNhbGwuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwcm9wcyBmb3IgcmVuZGVyU2xvdCBpcyBwYXNzZWQgYXMgdGhlIDNyZCBhcmd1bWVudC5cbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0UHJvcChjaGlsZEJsb2NrLCBrZXlQcm9wZXJ0eSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmVlZEZyYWdtZW50V3JhcHBlcikge1xuICAgICAgICAgICAgICAgIC8vIDx0ZW1wbGF0ZSB2LWZvcj1cIi4uLlwiPiB3aXRoIHRleHQgb3IgbXVsdGktZWxlbWVudHNcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgZ2VuZXJhdGUgYSBmcmFnbWVudCBibG9jayBmb3IgZWFjaCBsb29wXG4gICAgICAgICAgICAgICAgY2hpbGRCbG9jayA9IGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCBoZWxwZXIoRlJBR01FTlQpLCBrZXlQcm9wZXJ0eSA/IGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW2tleVByb3BlcnR5XSkgOiB1bmRlZmluZWQsIG5vZGUuY2hpbGRyZW4sIDY0IC8qIFBhdGNoRmxhZ3MuU1RBQkxFX0ZSQUdNRU5UICovICtcbiAgICAgICAgICAgICAgICAgICAgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgIC8qICR7c2hhcmVkXzEuUGF0Y2hGbGFnTmFtZXNbNjQgLyogUGF0Y2hGbGFncy5TVEFCTEVfRlJBR01FTlQgKi9dfSAqL2BcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYGApLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSwgdW5kZWZpbmVkLCBmYWxzZSAvKiBpc0NvbXBvbmVudCAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWwgZWxlbWVudCB2LWZvci4gRGlyZWN0bHkgdXNlIHRoZSBjaGlsZCdzIGNvZGVnZW5Ob2RlXG4gICAgICAgICAgICAgICAgLy8gYnV0IG1hcmsgaXQgYXMgYSBibG9jay5cbiAgICAgICAgICAgICAgICBjaGlsZEJsb2NrID0gY2hpbGRyZW5bMF1cbiAgICAgICAgICAgICAgICAgICAgLmNvZGVnZW5Ob2RlO1xuICAgICAgICAgICAgICAgIGlmIChpc1RlbXBsYXRlICYmIGtleVByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGluamVjdFByb3AoY2hpbGRCbG9jaywga2V5UHJvcGVydHksIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRCbG9jay5pc0Jsb2NrICE9PSAhaXNTdGFibGVGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRCbG9jay5pc0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggZnJvbSBibG9jayB0byB2bm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSGVscGVyKE9QRU5fQkxPQ0spO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSGVscGVyKGdldFZOb2RlQmxvY2tIZWxwZXIoY29udGV4dC5pblNTUiwgY2hpbGRCbG9jay5pc0NvbXBvbmVudCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3dpdGNoIGZyb20gdm5vZGUgdG8gYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUhlbHBlcihnZXRWTm9kZUhlbHBlcihjb250ZXh0LmluU1NSLCBjaGlsZEJsb2NrLmlzQ29tcG9uZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hpbGRCbG9jay5pc0Jsb2NrID0gIWlzU3RhYmxlRnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkQmxvY2suaXNCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICBoZWxwZXIoT1BFTl9CTE9DSyk7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcihnZXRWTm9kZUJsb2NrSGVscGVyKGNvbnRleHQuaW5TU1IsIGNoaWxkQmxvY2suaXNDb21wb25lbnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcihnZXRWTm9kZUhlbHBlcihjb250ZXh0LmluU1NSLCBjaGlsZEJsb2NrLmlzQ29tcG9uZW50KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lbW8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb29wID0gY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKGNyZWF0ZUZvckxvb3BQYXJhbXMoZm9yTm9kZS5wYXJzZVJlc3VsdCwgW1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBfY2FjaGVkYClcbiAgICAgICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICAgICAgbG9vcC5ib2R5ID0gY3JlYXRlQmxvY2tTdGF0ZW1lbnQoW1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW2Bjb25zdCBfbWVtbyA9IChgLCBtZW1vLmV4cCwgYClgXSksXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbXG4gICAgICAgICAgICAgICAgICAgICAgICBgaWYgKF9jYWNoZWRgLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKGtleUV4cCA/IFtgICYmIF9jYWNoZWQua2V5ID09PSBgLCBrZXlFeHBdIDogW10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgYCAmJiAke2NvbnRleHQuaGVscGVyU3RyaW5nKElTX01FTU9fU0FNRSl9KF9jYWNoZWQsIF9tZW1vKSkgcmV0dXJuIF9jYWNoZWRgXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW2Bjb25zdCBfaXRlbSA9IGAsIGNoaWxkQmxvY2tdKSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgX2l0ZW0ubWVtbyA9IF9tZW1vYCksXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHJldHVybiBfaXRlbWApXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgcmVuZGVyRXhwLmFyZ3VtZW50cy5wdXNoKGxvb3AsIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9jYWNoZWApLCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKFN0cmluZyhjb250ZXh0LmNhY2hlZCsrKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyRXhwLmFyZ3VtZW50cy5wdXNoKGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihjcmVhdGVGb3JMb29wUGFyYW1zKGZvck5vZGUucGFyc2VSZXN1bHQpLCBjaGlsZEJsb2NrLCB0cnVlIC8qIGZvcmNlIG5ld2xpbmUgKi8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn0pO1xuLy8gdGFyZ2V0LWFnbm9zdGljIHRyYW5zZm9ybSB1c2VkIGZvciBib3RoIENsaWVudCBhbmQgU1NSXG5mdW5jdGlvbiBwcm9jZXNzRm9yKG5vZGUsIGRpciwgY29udGV4dCwgcHJvY2Vzc0NvZGVnZW4pIHtcbiAgICBpZiAoIWRpci5leHApIHtcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzEgLyogRXJyb3JDb2Rlcy5YX1ZfRk9SX05PX0VYUFJFU1NJT04gKi8sIGRpci5sb2MpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHBhcnNlRm9yRXhwcmVzc2lvbihcbiAgICAvLyBjYW4gb25seSBiZSBzaW1wbGUgZXhwcmVzc2lvbiBiZWNhdXNlIHZGb3IgdHJhbnNmb3JtIGlzIGFwcGxpZWRcbiAgICAvLyBiZWZvcmUgZXhwcmVzc2lvbiB0cmFuc2Zvcm0uXG4gICAgZGlyLmV4cCwgY29udGV4dCk7XG4gICAgaWYgKCFwYXJzZVJlc3VsdCkge1xuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMiAvKiBFcnJvckNvZGVzLlhfVl9GT1JfTUFMRk9STUVEX0VYUFJFU1NJT04gKi8sIGRpci5sb2MpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGFkZElkZW50aWZpZXJzLCByZW1vdmVJZGVudGlmaWVycywgc2NvcGVzIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHsgc291cmNlLCB2YWx1ZSwga2V5LCBpbmRleCB9ID0gcGFyc2VSZXN1bHQ7XG4gICAgY29uc3QgZm9yTm9kZSA9IHtcbiAgICAgICAgdHlwZTogMTEgLyogTm9kZVR5cGVzLkZPUiAqLyxcbiAgICAgICAgbG9jOiBkaXIubG9jLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHZhbHVlQWxpYXM6IHZhbHVlLFxuICAgICAgICBrZXlBbGlhczoga2V5LFxuICAgICAgICBvYmplY3RJbmRleEFsaWFzOiBpbmRleCxcbiAgICAgICAgcGFyc2VSZXN1bHQsXG4gICAgICAgIGNoaWxkcmVuOiBpc1RlbXBsYXRlTm9kZShub2RlKSA/IG5vZGUuY2hpbGRyZW4gOiBbbm9kZV1cbiAgICB9O1xuICAgIGNvbnRleHQucmVwbGFjZU5vZGUoZm9yTm9kZSk7XG4gICAgLy8gYm9va2tlZXBpbmdcbiAgICBzY29wZXMudkZvcisrO1xuICAgIGNvbnN0IG9uRXhpdCA9IHByb2Nlc3NDb2RlZ2VuICYmIHByb2Nlc3NDb2RlZ2VuKGZvck5vZGUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHNjb3Blcy52Rm9yLS07XG4gICAgICAgIGlmIChvbkV4aXQpXG4gICAgICAgICAgICBvbkV4aXQoKTtcbiAgICB9O1xufVxuZXhwb3J0cy5wcm9jZXNzRm9yID0gcHJvY2Vzc0ZvcjtcbmNvbnN0IGZvckFsaWFzUkUgPSAvKFtcXHNcXFNdKj8pXFxzKyg/OmlufG9mKVxccysoW1xcc1xcU10qKS87XG4vLyBUaGlzIHJlZ2V4IGRvZXNuJ3QgY292ZXIgdGhlIGNhc2UgaWYga2V5IG9yIGluZGV4IGFsaWFzZXMgaGF2ZSBkZXN0cnVjdHVyaW5nLFxuLy8gYnV0IHRob3NlIGRvIG5vdCBtYWtlIHNlbnNlIGluIHRoZSBmaXJzdCBwbGFjZSwgc28gdGhpcyB3b3JrcyBpbiBwcmFjdGljZS5cbmNvbnN0IGZvckl0ZXJhdG9yUkUgPSAvLChbXixcXH1cXF1dKikoPzosKFteLFxcfVxcXV0qKSk/JC87XG5jb25zdCBzdHJpcFBhcmVuc1JFID0gL15cXCh8XFwpJC9nO1xuZnVuY3Rpb24gcGFyc2VGb3JFeHByZXNzaW9uKGlucHV0LCBjb250ZXh0KSB7XG4gICAgY29uc3QgbG9jID0gaW5wdXQubG9jO1xuICAgIGNvbnN0IGV4cCA9IGlucHV0LmNvbnRlbnQ7XG4gICAgY29uc3QgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcbiAgICBpZiAoIWluTWF0Y2gpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBbLCBMSFMsIFJIU10gPSBpbk1hdGNoO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgc291cmNlOiBjcmVhdGVBbGlhc0V4cHJlc3Npb24obG9jLCBSSFMudHJpbSgpLCBleHAuaW5kZXhPZihSSFMsIExIUy5sZW5ndGgpKSxcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAga2V5OiB1bmRlZmluZWQsXG4gICAgICAgIGluZGV4OiB1bmRlZmluZWRcbiAgICB9O1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSkge1xuICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKHJlc3VsdC5zb3VyY2UsIGNvbnRleHQpO1xuICAgIH1cbiAgICBsZXQgdmFsdWVDb250ZW50ID0gTEhTLnRyaW0oKS5yZXBsYWNlKHN0cmlwUGFyZW5zUkUsICcnKS50cmltKCk7XG4gICAgY29uc3QgdHJpbW1lZE9mZnNldCA9IExIUy5pbmRleE9mKHZhbHVlQ29udGVudCk7XG4gICAgY29uc3QgaXRlcmF0b3JNYXRjaCA9IHZhbHVlQ29udGVudC5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgICAgICB2YWx1ZUNvbnRlbnQgPSB2YWx1ZUNvbnRlbnQucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJykudHJpbSgpO1xuICAgICAgICBjb25zdCBrZXlDb250ZW50ID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgICAgIGxldCBrZXlPZmZzZXQ7XG4gICAgICAgIGlmIChrZXlDb250ZW50KSB7XG4gICAgICAgICAgICBrZXlPZmZzZXQgPSBleHAuaW5kZXhPZihrZXlDb250ZW50LCB0cmltbWVkT2Zmc2V0ICsgdmFsdWVDb250ZW50Lmxlbmd0aCk7XG4gICAgICAgICAgICByZXN1bHQua2V5ID0gY3JlYXRlQWxpYXNFeHByZXNzaW9uKGxvYywga2V5Q29udGVudCwga2V5T2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24ocmVzdWx0LmtleSwgY29udGV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4Q29udGVudCA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgICAgICAgICAgaWYgKGluZGV4Q29udGVudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5pbmRleCA9IGNyZWF0ZUFsaWFzRXhwcmVzc2lvbihsb2MsIGluZGV4Q29udGVudCwgZXhwLmluZGV4T2YoaW5kZXhDb250ZW50LCByZXN1bHQua2V5XG4gICAgICAgICAgICAgICAgICAgID8ga2V5T2Zmc2V0ICsga2V5Q29udGVudC5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgOiB0cmltbWVkT2Zmc2V0ICsgdmFsdWVDb250ZW50Lmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKHJlc3VsdC5pbmRleCwgY29udGV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh2YWx1ZUNvbnRlbnQpIHtcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gY3JlYXRlQWxpYXNFeHByZXNzaW9uKGxvYywgdmFsdWVDb250ZW50LCB0cmltbWVkT2Zmc2V0KTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0cnVlKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKHJlc3VsdC52YWx1ZSwgY29udGV4dCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFsaWFzRXhwcmVzc2lvbihyYW5nZSwgY29udGVudCwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oY29udGVudCwgZmFsc2UsIGdldElubmVyUmFuZ2UocmFuZ2UsIG9mZnNldCwgY29udGVudC5sZW5ndGgpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZvckxvb3BQYXJhbXMoeyB2YWx1ZSwga2V5LCBpbmRleCB9LCBtZW1vQXJncyA9IFtdKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVBhcmFtc0xpc3QoW3ZhbHVlLCBrZXksIGluZGV4LCAuLi5tZW1vQXJnc10pO1xufVxuZXhwb3J0cy5jcmVhdGVGb3JMb29wUGFyYW1zID0gY3JlYXRlRm9yTG9vcFBhcmFtcztcbmZ1bmN0aW9uIGNyZWF0ZVBhcmFtc0xpc3QoYXJncykge1xuICAgIGxldCBpID0gYXJncy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAoYXJnc1tpXSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gYXJnc1xuICAgICAgICAuc2xpY2UoMCwgaSArIDEpXG4gICAgICAgIC5tYXAoKGFyZywgaSkgPT4gYXJnIHx8IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9gLnJlcGVhdChpICsgMSksIGZhbHNlKSk7XG59XG5jb25zdCBkZWZhdWx0RmFsbGJhY2sgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGB1bmRlZmluZWRgLCBmYWxzZSk7XG4vLyBBIE5vZGVUcmFuc2Zvcm0gdGhhdDpcbi8vIDEuIFRyYWNrcyBzY29wZSBpZGVudGlmaWVycyBmb3Igc2NvcGVkIHNsb3RzIHNvIHRoYXQgdGhleSBkb24ndCBnZXQgcHJlZml4ZWRcbi8vICAgIGJ5IHRyYW5zZm9ybUV4cHJlc3Npb24uIFRoaXMgaXMgb25seSBhcHBsaWVkIGluIG5vbi1icm93c2VyIGJ1aWxkcyB3aXRoXG4vLyAgICB7IHByZWZpeElkZW50aWZpZXJzOiB0cnVlIH0uXG4vLyAyLiBUcmFjayB2LXNsb3QgZGVwdGhzIHNvIHRoYXQgd2Uga25vdyBhIHNsb3QgaXMgaW5zaWRlIGFub3RoZXIgc2xvdC5cbi8vICAgIE5vdGUgdGhlIGV4aXQgY2FsbGJhY2sgaXMgZXhlY3V0ZWQgYmVmb3JlIGJ1aWxkU2xvdHMoKSBvbiB0aGUgc2FtZSBub2RlLFxuLy8gICAgc28gb25seSBuZXN0ZWQgc2xvdHMgc2VlIHBvc2l0aXZlIG51bWJlcnMuXG5jb25zdCB0cmFja1Nsb3RTY29wZXMgPSAobm9kZSwgY29udGV4dCkgPT4ge1xuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8gJiZcbiAgICAgICAgKG5vZGUudGFnVHlwZSA9PT0gMSAvKiBFbGVtZW50VHlwZXMuQ09NUE9ORU5UICovIHx8XG4gICAgICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDMgLyogRWxlbWVudFR5cGVzLlRFTVBMQVRFICovKSkge1xuICAgICAgICAvLyBXZSBhcmUgb25seSBjaGVja2luZyBub24tZW1wdHkgdi1zbG90IGhlcmVcbiAgICAgICAgLy8gc2luY2Ugd2Ugb25seSBjYXJlIGFib3V0IHNsb3RzIHRoYXQgaW50cm9kdWNlIHNjb3BlIHZhcmlhYmxlcy5cbiAgICAgICAgY29uc3QgdlNsb3QgPSBmaW5kRGlyKG5vZGUsICdzbG90Jyk7XG4gICAgICAgIGlmICh2U2xvdCkge1xuICAgICAgICAgICAgdlNsb3QuZXhwO1xuICAgICAgICAgICAgY29udGV4dC5zY29wZXMudlNsb3QrKztcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zY29wZXMudlNsb3QtLTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0cy50cmFja1Nsb3RTY29wZXMgPSB0cmFja1Nsb3RTY29wZXM7XG4vLyBBIE5vZGVUcmFuc2Zvcm0gdGhhdCB0cmFja3Mgc2NvcGUgaWRlbnRpZmllcnMgZm9yIHNjb3BlZCBzbG90cyB3aXRoIHYtZm9yLlxuLy8gVGhpcyB0cmFuc2Zvcm0gaXMgb25seSBhcHBsaWVkIGluIG5vbi1icm93c2VyIGJ1aWxkcyB3aXRoIHsgcHJlZml4SWRlbnRpZmllcnM6IHRydWUgfVxuY29uc3QgdHJhY2tWRm9yU2xvdFNjb3BlcyA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgbGV0IHZGb3I7XG4gICAgaWYgKGlzVGVtcGxhdGVOb2RlKG5vZGUpICYmXG4gICAgICAgIG5vZGUucHJvcHMuc29tZShpc1ZTbG90KSAmJlxuICAgICAgICAodkZvciA9IGZpbmREaXIobm9kZSwgJ2ZvcicpKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSAodkZvci5wYXJzZVJlc3VsdCA9IHBhcnNlRm9yRXhwcmVzc2lvbih2Rm9yLmV4cCwgY29udGV4dCkpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBrZXksIGluZGV4IH0gPSByZXN1bHQ7XG4gICAgICAgICAgICBjb25zdCB7IGFkZElkZW50aWZpZXJzLCByZW1vdmVJZGVudGlmaWVycyB9ID0gY29udGV4dDtcbiAgICAgICAgICAgIHZhbHVlICYmIGFkZElkZW50aWZpZXJzKHZhbHVlKTtcbiAgICAgICAgICAgIGtleSAmJiBhZGRJZGVudGlmaWVycyhrZXkpO1xuICAgICAgICAgICAgaW5kZXggJiYgYWRkSWRlbnRpZmllcnMoaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSAmJiByZW1vdmVJZGVudGlmaWVycyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAga2V5ICYmIHJlbW92ZUlkZW50aWZpZXJzKGtleSk7XG4gICAgICAgICAgICAgICAgaW5kZXggJiYgcmVtb3ZlSWRlbnRpZmllcnMoaW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnRzLnRyYWNrVkZvclNsb3RTY29wZXMgPSB0cmFja1ZGb3JTbG90U2NvcGVzO1xuY29uc3QgYnVpbGRDbGllbnRTbG90Rm4gPSAocHJvcHMsIGNoaWxkcmVuLCBsb2MpID0+IGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihwcm9wcywgY2hpbGRyZW4sIGZhbHNlIC8qIG5ld2xpbmUgKi8sIHRydWUgLyogaXNTbG90ICovLCBjaGlsZHJlbi5sZW5ndGggPyBjaGlsZHJlblswXS5sb2MgOiBsb2MpO1xuLy8gSW5zdGVhZCBvZiBiZWluZyBhIERpcmVjdGl2ZVRyYW5zZm9ybSwgdi1zbG90IHByb2Nlc3NpbmcgaXMgY2FsbGVkIGR1cmluZ1xuLy8gdHJhbnNmb3JtRWxlbWVudCB0byBidWlsZCB0aGUgc2xvdHMgb2JqZWN0IGZvciBhIGNvbXBvbmVudC5cbmZ1bmN0aW9uIGJ1aWxkU2xvdHMobm9kZSwgY29udGV4dCwgYnVpbGRTbG90Rm4gPSBidWlsZENsaWVudFNsb3RGbikge1xuICAgIGNvbnRleHQuaGVscGVyKFdJVEhfQ1RYKTtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBsb2MgfSA9IG5vZGU7XG4gICAgY29uc3Qgc2xvdHNQcm9wZXJ0aWVzID0gW107XG4gICAgY29uc3QgZHluYW1pY1Nsb3RzID0gW107XG4gICAgLy8gSWYgdGhlIHNsb3QgaXMgaW5zaWRlIGEgdi1mb3Igb3IgYW5vdGhlciB2LXNsb3QsIGZvcmNlIGl0IHRvIGJlIGR5bmFtaWNcbiAgICAvLyBzaW5jZSBpdCBsaWtlbHkgdXNlcyBhIHNjb3BlIHZhcmlhYmxlLlxuICAgIGxldCBoYXNEeW5hbWljU2xvdHMgPSBjb250ZXh0LnNjb3Blcy52U2xvdCA+IDAgfHwgY29udGV4dC5zY29wZXMudkZvciA+IDA7XG4gICAgLy8gMS4gQ2hlY2sgZm9yIHNsb3Qgd2l0aCBzbG90UHJvcHMgb24gY29tcG9uZW50IGl0c2VsZi5cbiAgICAvLyAgICA8Q29tcCB2LXNsb3Q9XCJ7IHByb3AgfVwiLz5cbiAgICBjb25zdCBvbkNvbXBvbmVudFNsb3QgPSBmaW5kRGlyKG5vZGUsICdzbG90JywgdHJ1ZSk7XG4gICAgaWYgKG9uQ29tcG9uZW50U2xvdCkge1xuICAgICAgICBjb25zdCB7IGFyZywgZXhwIH0gPSBvbkNvbXBvbmVudFNsb3Q7XG4gICAgICAgIGlmIChhcmcgJiYgIWlzU3RhdGljRXhwKGFyZykpIHtcbiAgICAgICAgICAgIGhhc0R5bmFtaWNTbG90cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc2xvdHNQcm9wZXJ0aWVzLnB1c2goY3JlYXRlT2JqZWN0UHJvcGVydHkoYXJnIHx8IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJ2RlZmF1bHQnLCB0cnVlKSwgYnVpbGRTbG90Rm4oZXhwLCBjaGlsZHJlbiwgbG9jKSkpO1xuICAgIH1cbiAgICAvLyAyLiBJdGVyYXRlIHRocm91Z2ggY2hpbGRyZW4gYW5kIGNoZWNrIGZvciB0ZW1wbGF0ZSBzbG90c1xuICAgIC8vICAgIDx0ZW1wbGF0ZSB2LXNsb3Q6Zm9vPVwieyBwcm9wIH1cIj5cbiAgICBsZXQgaGFzVGVtcGxhdGVTbG90cyA9IGZhbHNlO1xuICAgIGxldCBoYXNOYW1lZERlZmF1bHRTbG90ID0gZmFsc2U7XG4gICAgY29uc3QgaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4gPSBbXTtcbiAgICBjb25zdCBzZWVuU2xvdE5hbWVzID0gbmV3IFNldCgpO1xuICAgIGxldCBjb25kaXRpb25hbEJyYW5jaEluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHNsb3RFbGVtZW50ID0gY2hpbGRyZW5baV07XG4gICAgICAgIGxldCBzbG90RGlyO1xuICAgICAgICBpZiAoIWlzVGVtcGxhdGVOb2RlKHNsb3RFbGVtZW50KSB8fFxuICAgICAgICAgICAgIShzbG90RGlyID0gZmluZERpcihzbG90RWxlbWVudCwgJ3Nsb3QnLCB0cnVlKSkpIHtcbiAgICAgICAgICAgIC8vIG5vdCBhIDx0ZW1wbGF0ZSB2LXNsb3Q+LCBza2lwLlxuICAgICAgICAgICAgaWYgKHNsb3RFbGVtZW50LnR5cGUgIT09IDMgLyogTm9kZVR5cGVzLkNPTU1FTlQgKi8pIHtcbiAgICAgICAgICAgICAgICBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbi5wdXNoKHNsb3RFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkNvbXBvbmVudFNsb3QpIHtcbiAgICAgICAgICAgIC8vIGFscmVhZHkgaGFzIG9uLWNvbXBvbmVudCBzbG90IC0gdGhpcyBpcyBpbmNvcnJlY3QgdXNhZ2UuXG4gICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzNyAvKiBFcnJvckNvZGVzLlhfVl9TTE9UX01JWEVEX1NMT1RfVVNBR0UgKi8sIHNsb3REaXIubG9jKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBoYXNUZW1wbGF0ZVNsb3RzID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogc2xvdENoaWxkcmVuLCBsb2M6IHNsb3RMb2MgfSA9IHNsb3RFbGVtZW50O1xuICAgICAgICBjb25zdCB7IGFyZzogc2xvdE5hbWUgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBkZWZhdWx0YCwgdHJ1ZSksIGV4cDogc2xvdFByb3BzLCBsb2M6IGRpckxvYyB9ID0gc2xvdERpcjtcbiAgICAgICAgLy8gY2hlY2sgaWYgbmFtZSBpcyBkeW5hbWljLlxuICAgICAgICBsZXQgc3RhdGljU2xvdE5hbWU7XG4gICAgICAgIGlmIChpc1N0YXRpY0V4cChzbG90TmFtZSkpIHtcbiAgICAgICAgICAgIHN0YXRpY1Nsb3ROYW1lID0gc2xvdE5hbWUgPyBzbG90TmFtZS5jb250ZW50IDogYGRlZmF1bHRgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzbG90RnVuY3Rpb24gPSBidWlsZFNsb3RGbihzbG90UHJvcHMsIHNsb3RDaGlsZHJlbiwgc2xvdExvYyk7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgc2xvdCBpcyBjb25kaXRpb25hbCAodi1pZi92LWZvcilcbiAgICAgICAgbGV0IHZJZjtcbiAgICAgICAgbGV0IHZFbHNlO1xuICAgICAgICBsZXQgdkZvcjtcbiAgICAgICAgaWYgKCh2SWYgPSBmaW5kRGlyKHNsb3RFbGVtZW50LCAnaWYnKSkpIHtcbiAgICAgICAgICAgIGhhc0R5bmFtaWNTbG90cyA9IHRydWU7XG4gICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24odklmLmV4cCwgYnVpbGREeW5hbWljU2xvdChzbG90TmFtZSwgc2xvdEZ1bmN0aW9uLCBjb25kaXRpb25hbEJyYW5jaEluZGV4KyspLCBkZWZhdWx0RmFsbGJhY2spKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodkVsc2UgPSBmaW5kRGlyKHNsb3RFbGVtZW50LCAvXmVsc2UoLWlmKT8kLywgdHJ1ZSAvKiBhbGxvd0VtcHR5ICovKSkpIHtcbiAgICAgICAgICAgIC8vIGZpbmQgYWRqYWNlbnQgdi1pZlxuICAgICAgICAgICAgbGV0IGogPSBpO1xuICAgICAgICAgICAgbGV0IHByZXY7XG4gICAgICAgICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IGNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2LnR5cGUgIT09IDMgLyogTm9kZVR5cGVzLkNPTU1FTlQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXYgJiYgaXNUZW1wbGF0ZU5vZGUocHJldikgJiYgZmluZERpcihwcmV2LCAnaWYnKSkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBub2RlXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAvLyBhdHRhY2ggdGhpcyBzbG90IHRvIHByZXZpb3VzIGNvbmRpdGlvbmFsXG4gICAgICAgICAgICAgICAgbGV0IGNvbmRpdGlvbmFsID0gZHluYW1pY1Nsb3RzW2R5bmFtaWNTbG90cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29uZGl0aW9uYWwuYWx0ZXJuYXRlLnR5cGUgPT09IDE5IC8qIE5vZGVUeXBlcy5KU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbmFsID0gY29uZGl0aW9uYWwuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25kaXRpb25hbC5hbHRlcm5hdGUgPSB2RWxzZS5leHBcbiAgICAgICAgICAgICAgICAgICAgPyBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24odkVsc2UuZXhwLCBidWlsZER5bmFtaWNTbG90KHNsb3ROYW1lLCBzbG90RnVuY3Rpb24sIGNvbmRpdGlvbmFsQnJhbmNoSW5kZXgrKyksIGRlZmF1bHRGYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgOiBidWlsZER5bmFtaWNTbG90KHNsb3ROYW1lLCBzbG90RnVuY3Rpb24sIGNvbmRpdGlvbmFsQnJhbmNoSW5kZXgrKyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMCAvKiBFcnJvckNvZGVzLlhfVl9FTFNFX05PX0FESkFDRU5UX0lGICovLCB2RWxzZS5sb2MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodkZvciA9IGZpbmREaXIoc2xvdEVsZW1lbnQsICdmb3InKSkpIHtcbiAgICAgICAgICAgIGhhc0R5bmFtaWNTbG90cyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHZGb3IucGFyc2VSZXN1bHQgfHxcbiAgICAgICAgICAgICAgICBwYXJzZUZvckV4cHJlc3Npb24odkZvci5leHAsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHBhcnNlUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSBkeW5hbWljIHNsb3RzIGFzIGFuIGFycmF5IGFuZCBhZGQgaXQgdG8gdGhlIGNyZWF0ZVNsb3QoKVxuICAgICAgICAgICAgICAgIC8vIGFyZ3MuIFRoZSBydW50aW1lIGtub3dzIGhvdyB0byBoYW5kbGUgaXQgYXBwcm9wcmlhdGVseS5cbiAgICAgICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihSRU5ERVJfTElTVCksIFtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VSZXN1bHQuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oY3JlYXRlRm9yTG9vcFBhcmFtcyhwYXJzZVJlc3VsdCksIGJ1aWxkRHluYW1pY1Nsb3Qoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbiksIHRydWUgLyogZm9yY2UgbmV3bGluZSAqLylcbiAgICAgICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMiAvKiBFcnJvckNvZGVzLlhfVl9GT1JfTUFMRk9STUVEX0VYUFJFU1NJT04gKi8sIHZGb3IubG9jKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBjaGVjayBkdXBsaWNhdGUgc3RhdGljIG5hbWVzXG4gICAgICAgICAgICBpZiAoc3RhdGljU2xvdE5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VlblNsb3ROYW1lcy5oYXMoc3RhdGljU2xvdE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM4IC8qIEVycm9yQ29kZXMuWF9WX1NMT1RfRFVQTElDQVRFX1NMT1RfTkFNRVMgKi8sIGRpckxvYykpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VlblNsb3ROYW1lcy5hZGQoc3RhdGljU2xvdE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0aWNTbG90TmFtZSA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc05hbWVkRGVmYXVsdFNsb3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNsb3RzUHJvcGVydGllcy5wdXNoKGNyZWF0ZU9iamVjdFByb3BlcnR5KHNsb3ROYW1lLCBzbG90RnVuY3Rpb24pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW9uQ29tcG9uZW50U2xvdCkge1xuICAgICAgICBjb25zdCBidWlsZERlZmF1bHRTbG90UHJvcGVydHkgPSAocHJvcHMsIGNoaWxkcmVuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmbiA9IGJ1aWxkU2xvdEZuKHByb3BzLCBjaGlsZHJlbiwgbG9jKTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmNvbXBhdENvbmZpZykge1xuICAgICAgICAgICAgICAgIGZuLmlzTm9uU2NvcGVkU2xvdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlT2JqZWN0UHJvcGVydHkoYGRlZmF1bHRgLCBmbik7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghaGFzVGVtcGxhdGVTbG90cykge1xuICAgICAgICAgICAgLy8gaW1wbGljaXQgZGVmYXVsdCBzbG90IChvbiBjb21wb25lbnQpXG4gICAgICAgICAgICBzbG90c1Byb3BlcnRpZXMucHVzaChidWlsZERlZmF1bHRTbG90UHJvcGVydHkodW5kZWZpbmVkLCBjaGlsZHJlbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGltcGxpY2l0RGVmYXVsdENoaWxkcmVuLmxlbmd0aCAmJlxuICAgICAgICAgICAgLy8gIzM3NjZcbiAgICAgICAgICAgIC8vIHdpdGggd2hpdGVzcGFjZTogJ3ByZXNlcnZlJywgd2hpdGVzcGFjZXMgYmV0d2VlbiBzbG90cyB3aWxsIGVuZCB1cCBpblxuICAgICAgICAgICAgLy8gaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4uIElnbm9yZSBpZiBhbGwgaW1wbGljaXQgY2hpbGRyZW4gYXJlIHdoaXRlc3BhY2VzLlxuICAgICAgICAgICAgaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4uc29tZShub2RlID0+IGlzTm9uV2hpdGVzcGFjZUNvbnRlbnQobm9kZSkpKSB7XG4gICAgICAgICAgICAvLyBpbXBsaWNpdCBkZWZhdWx0IHNsb3QgKG1peGVkIHdpdGggbmFtZWQgc2xvdHMpXG4gICAgICAgICAgICBpZiAoaGFzTmFtZWREZWZhdWx0U2xvdCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM5IC8qIEVycm9yQ29kZXMuWF9WX1NMT1RfRVhUUkFORU9VU19ERUZBVUxUX1NMT1RfQ0hJTERSRU4gKi8sIGltcGxpY2l0RGVmYXVsdENoaWxkcmVuWzBdLmxvYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2xvdHNQcm9wZXJ0aWVzLnB1c2goYnVpbGREZWZhdWx0U2xvdFByb3BlcnR5KHVuZGVmaW5lZCwgaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzbG90RmxhZyA9IGhhc0R5bmFtaWNTbG90c1xuICAgICAgICA/IDIgLyogU2xvdEZsYWdzLkRZTkFNSUMgKi9cbiAgICAgICAgOiBoYXNGb3J3YXJkZWRTbG90cyhub2RlLmNoaWxkcmVuKVxuICAgICAgICAgICAgPyAzIC8qIFNsb3RGbGFncy5GT1JXQVJERUQgKi9cbiAgICAgICAgICAgIDogMSAvKiBTbG90RmxhZ3MuU1RBQkxFICovO1xuICAgIGxldCBzbG90cyA9IGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oc2xvdHNQcm9wZXJ0aWVzLmNvbmNhdChjcmVhdGVPYmplY3RQcm9wZXJ0eShgX2AsIFxuICAgIC8vIDIgPSBjb21waWxlZCBidXQgZHluYW1pYyA9IGNhbiBza2lwIG5vcm1hbGl6YXRpb24sIGJ1dCBtdXN0IHJ1biBkaWZmXG4gICAgLy8gMSA9IGNvbXBpbGVkIGFuZCBzdGF0aWMgPSBjYW4gc2tpcCBub3JtYWxpemF0aW9uIEFORCBkaWZmIGFzIG9wdGltaXplZFxuICAgIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oc2xvdEZsYWcgKyAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYCAvKiAke3NoYXJlZF8xLnNsb3RGbGFnc1RleHRbc2xvdEZsYWddfSAqL2AgOiBgYCksIGZhbHNlKSkpLCBsb2MpO1xuICAgIGlmIChkeW5hbWljU2xvdHMubGVuZ3RoKSB7XG4gICAgICAgIHNsb3RzID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoQ1JFQVRFX1NMT1RTKSwgW1xuICAgICAgICAgICAgc2xvdHMsXG4gICAgICAgICAgICBjcmVhdGVBcnJheUV4cHJlc3Npb24oZHluYW1pY1Nsb3RzKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2xvdHMsXG4gICAgICAgIGhhc0R5bmFtaWNTbG90c1xuICAgIH07XG59XG5leHBvcnRzLmJ1aWxkU2xvdHMgPSBidWlsZFNsb3RzO1xuZnVuY3Rpb24gYnVpbGREeW5hbWljU2xvdChuYW1lLCBmbiwgaW5kZXgpIHtcbiAgICBjb25zdCBwcm9wcyA9IFtcbiAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoYG5hbWVgLCBuYW1lKSxcbiAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoYGZuYCwgZm4pXG4gICAgXTtcbiAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICBwcm9wcy5wdXNoKGNyZWF0ZU9iamVjdFByb3BlcnR5KGBrZXlgLCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKFN0cmluZyhpbmRleCksIHRydWUpKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVPYmplY3RFeHByZXNzaW9uKHByb3BzKTtcbn1cbmZ1bmN0aW9uIGhhc0ZvcndhcmRlZFNsb3RzKGNoaWxkcmVuKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBzd2l0Y2ggKGNoaWxkLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLzpcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudGFnVHlwZSA9PT0gMiAvKiBFbGVtZW50VHlwZXMuU0xPVCAqLyB8fFxuICAgICAgICAgICAgICAgICAgICBoYXNGb3J3YXJkZWRTbG90cyhjaGlsZC5jaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA5IC8qIE5vZGVUeXBlcy5JRiAqLzpcbiAgICAgICAgICAgICAgICBpZiAoaGFzRm9yd2FyZGVkU2xvdHMoY2hpbGQuYnJhbmNoZXMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTAgLyogTm9kZVR5cGVzLklGX0JSQU5DSCAqLzpcbiAgICAgICAgICAgIGNhc2UgMTEgLyogTm9kZVR5cGVzLkZPUiAqLzpcbiAgICAgICAgICAgICAgICBpZiAoaGFzRm9yd2FyZGVkU2xvdHMoY2hpbGQuY2hpbGRyZW4pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc05vbldoaXRlc3BhY2VDb250ZW50KG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlICE9PSAyIC8qIE5vZGVUeXBlcy5URVhUICovICYmIG5vZGUudHlwZSAhPT0gMTIgLyogTm9kZVR5cGVzLlRFWFRfQ0FMTCAqLylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gMiAvKiBOb2RlVHlwZXMuVEVYVCAqL1xuICAgICAgICA/ICEhbm9kZS5jb250ZW50LnRyaW0oKVxuICAgICAgICA6IGlzTm9uV2hpdGVzcGFjZUNvbnRlbnQobm9kZS5jb250ZW50KTtcbn1cbi8vIHNvbWUgZGlyZWN0aXZlIHRyYW5zZm9ybXMgKGUuZy4gdi1tb2RlbCkgbWF5IHJldHVybiBhIHN5bWJvbCBmb3IgcnVudGltZVxuLy8gaW1wb3J0LCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkIG9mIGEgcmVzb2x2ZURpcmVjdGl2ZSBjYWxsLlxuY29uc3QgZGlyZWN0aXZlSW1wb3J0TWFwID0gbmV3IFdlYWtNYXAoKTtcbi8vIGdlbmVyYXRlIGEgSmF2YVNjcmlwdCBBU1QgZm9yIHRoaXMgZWxlbWVudCdzIGNvZGVnZW5cbmNvbnN0IHRyYW5zZm9ybUVsZW1lbnQgPSAobm9kZSwgY29udGV4dCkgPT4ge1xuICAgIC8vIHBlcmZvcm0gdGhlIHdvcmsgb24gZXhpdCwgYWZ0ZXIgYWxsIGNoaWxkIGV4cHJlc3Npb25zIGhhdmUgYmVlblxuICAgIC8vIHByb2Nlc3NlZCBhbmQgbWVyZ2VkLlxuICAgIHJldHVybiBmdW5jdGlvbiBwb3N0VHJhbnNmb3JtRWxlbWVudCgpIHtcbiAgICAgICAgbm9kZSA9IGNvbnRleHQuY3VycmVudE5vZGU7XG4gICAgICAgIGlmICghKG5vZGUudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLyAmJlxuICAgICAgICAgICAgKG5vZGUudGFnVHlwZSA9PT0gMCAvKiBFbGVtZW50VHlwZXMuRUxFTUVOVCAqLyB8fFxuICAgICAgICAgICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMSAvKiBFbGVtZW50VHlwZXMuQ09NUE9ORU5UICovKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHRhZywgcHJvcHMgfSA9IG5vZGU7XG4gICAgICAgIGNvbnN0IGlzQ29tcG9uZW50ID0gbm9kZS50YWdUeXBlID09PSAxIC8qIEVsZW1lbnRUeXBlcy5DT01QT05FTlQgKi87XG4gICAgICAgIC8vIFRoZSBnb2FsIG9mIHRoZSB0cmFuc2Zvcm0gaXMgdG8gY3JlYXRlIGEgY29kZWdlbk5vZGUgaW1wbGVtZW50aW5nIHRoZVxuICAgICAgICAvLyBWTm9kZUNhbGwgaW50ZXJmYWNlLlxuICAgICAgICBsZXQgdm5vZGVUYWcgPSBpc0NvbXBvbmVudFxuICAgICAgICAgICAgPyByZXNvbHZlQ29tcG9uZW50VHlwZShub2RlLCBjb250ZXh0KVxuICAgICAgICAgICAgOiBgXCIke3RhZ31cImA7XG4gICAgICAgIGNvbnN0IGlzRHluYW1pY0NvbXBvbmVudCA9ICgwLCBzaGFyZWRfMS5pc09iamVjdCkodm5vZGVUYWcpICYmIHZub2RlVGFnLmNhbGxlZSA9PT0gUkVTT0xWRV9EWU5BTUlDX0NPTVBPTkVOVDtcbiAgICAgICAgbGV0IHZub2RlUHJvcHM7XG4gICAgICAgIGxldCB2bm9kZUNoaWxkcmVuO1xuICAgICAgICBsZXQgdm5vZGVQYXRjaEZsYWc7XG4gICAgICAgIGxldCBwYXRjaEZsYWcgPSAwO1xuICAgICAgICBsZXQgdm5vZGVEeW5hbWljUHJvcHM7XG4gICAgICAgIGxldCBkeW5hbWljUHJvcE5hbWVzO1xuICAgICAgICBsZXQgdm5vZGVEaXJlY3RpdmVzO1xuICAgICAgICBsZXQgc2hvdWxkVXNlQmxvY2sgPSBcbiAgICAgICAgLy8gZHluYW1pYyBjb21wb25lbnQgbWF5IHJlc29sdmUgdG8gcGxhaW4gZWxlbWVudHNcbiAgICAgICAgaXNEeW5hbWljQ29tcG9uZW50IHx8XG4gICAgICAgICAgICB2bm9kZVRhZyA9PT0gVEVMRVBPUlQgfHxcbiAgICAgICAgICAgIHZub2RlVGFnID09PSBTVVNQRU5TRSB8fFxuICAgICAgICAgICAgKCFpc0NvbXBvbmVudCAmJlxuICAgICAgICAgICAgICAgIC8vIDxzdmc+IGFuZCA8Zm9yZWlnbk9iamVjdD4gbXVzdCBiZSBmb3JjZWQgaW50byBibG9ja3Mgc28gdGhhdCBibG9ja1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZXMgaW5zaWRlIGdldCBwcm9wZXIgaXNTVkcgZmxhZyBhdCBydW50aW1lLiAoIzYzOSwgIzY0MylcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRlY2huaWNhbGx5IHdlYi1zcGVjaWZpYywgYnV0IHNwbGl0dGluZyB0aGUgbG9naWMgb3V0IG9mIGNvcmVcbiAgICAgICAgICAgICAgICAvLyBsZWFkcyB0byB0b28gbXVjaCB1bm5lY2Vzc2FyeSBjb21wbGV4aXR5LlxuICAgICAgICAgICAgICAgICh0YWcgPT09ICdzdmcnIHx8IHRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSk7XG4gICAgICAgIC8vIHByb3BzXG4gICAgICAgIGlmIChwcm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wc0J1aWxkUmVzdWx0ID0gYnVpbGRQcm9wcyhub2RlLCBjb250ZXh0LCB1bmRlZmluZWQsIGlzQ29tcG9uZW50LCBpc0R5bmFtaWNDb21wb25lbnQpO1xuICAgICAgICAgICAgdm5vZGVQcm9wcyA9IHByb3BzQnVpbGRSZXN1bHQucHJvcHM7XG4gICAgICAgICAgICBwYXRjaEZsYWcgPSBwcm9wc0J1aWxkUmVzdWx0LnBhdGNoRmxhZztcbiAgICAgICAgICAgIGR5bmFtaWNQcm9wTmFtZXMgPSBwcm9wc0J1aWxkUmVzdWx0LmR5bmFtaWNQcm9wTmFtZXM7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3RpdmVzID0gcHJvcHNCdWlsZFJlc3VsdC5kaXJlY3RpdmVzO1xuICAgICAgICAgICAgdm5vZGVEaXJlY3RpdmVzID1cbiAgICAgICAgICAgICAgICBkaXJlY3RpdmVzICYmIGRpcmVjdGl2ZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gY3JlYXRlQXJyYXlFeHByZXNzaW9uKGRpcmVjdGl2ZXMubWFwKGRpciA9PiBidWlsZERpcmVjdGl2ZUFyZ3MoZGlyLCBjb250ZXh0KSkpXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHByb3BzQnVpbGRSZXN1bHQuc2hvdWxkVXNlQmxvY2spIHtcbiAgICAgICAgICAgICAgICBzaG91bGRVc2VCbG9jayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hpbGRyZW5cbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHZub2RlVGFnID09PSBLRUVQX0FMSVZFKSB7XG4gICAgICAgICAgICAgICAgLy8gQWx0aG91Z2ggYSBidWlsdC1pbiBjb21wb25lbnQsIHdlIGNvbXBpbGUgS2VlcEFsaXZlIHdpdGggcmF3IGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiBzbG90IGZ1bmN0aW9ucyBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkIGluc2lkZSBUcmFuc2l0aW9uXG4gICAgICAgICAgICAgICAgLy8gb3Igb3RoZXIgVHJhbnNpdGlvbi13cmFwcGluZyBIT0NzLlxuICAgICAgICAgICAgICAgIC8vIFRvIGVuc3VyZSBjb3JyZWN0IHVwZGF0ZXMgd2l0aCBibG9jayBvcHRpbWl6YXRpb25zLCB3ZSBuZWVkIHRvOlxuICAgICAgICAgICAgICAgIC8vIDEuIEZvcmNlIGtlZXAtYWxpdmUgaW50byBhIGJsb2NrLiBUaGlzIGF2b2lkcyBpdHMgY2hpbGRyZW4gYmVpbmdcbiAgICAgICAgICAgICAgICAvLyAgICBjb2xsZWN0ZWQgYnkgYSBwYXJlbnQgYmxvY2suXG4gICAgICAgICAgICAgICAgc2hvdWxkVXNlQmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIDIuIEZvcmNlIGtlZXAtYWxpdmUgdG8gYWx3YXlzIGJlIHVwZGF0ZWQsIHNpbmNlIGl0IHVzZXMgcmF3IGNoaWxkcmVuLlxuICAgICAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAxMDI0IC8qIFBhdGNoRmxhZ3MuRFlOQU1JQ19TTE9UUyAqLztcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0NiAvKiBFcnJvckNvZGVzLlhfS0VFUF9BTElWRV9JTlZBTElEX0NISUxEUkVOICovLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbm9kZS5jaGlsZHJlblswXS5sb2Muc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG5vZGUuY2hpbGRyZW5bbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXS5sb2MuZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiAnJ1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkQnVpbGRBc1Nsb3RzID0gaXNDb21wb25lbnQgJiZcbiAgICAgICAgICAgICAgICAvLyBUZWxlcG9ydCBpcyBub3QgYSByZWFsIGNvbXBvbmVudCBhbmQgaGFzIGRlZGljYXRlZCBydW50aW1lIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgdm5vZGVUYWcgIT09IFRFTEVQT1JUICYmXG4gICAgICAgICAgICAgICAgLy8gZXhwbGFpbmVkIGFib3ZlLlxuICAgICAgICAgICAgICAgIHZub2RlVGFnICE9PSBLRUVQX0FMSVZFO1xuICAgICAgICAgICAgaWYgKHNob3VsZEJ1aWxkQXNTbG90cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2xvdHMsIGhhc0R5bmFtaWNTbG90cyB9ID0gYnVpbGRTbG90cyhub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB2bm9kZUNoaWxkcmVuID0gc2xvdHM7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0R5bmFtaWNTbG90cykge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaEZsYWcgfD0gMTAyNCAvKiBQYXRjaEZsYWdzLkRZTkFNSUNfU0xPVFMgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgdm5vZGVUYWcgIT09IFRFTEVQT1JUKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBjaGlsZC50eXBlO1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBkeW5hbWljIHRleHQgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBjb25zdCBoYXNEeW5hbWljVGV4dENoaWxkID0gdHlwZSA9PT0gNSAvKiBOb2RlVHlwZXMuSU5URVJQT0xBVElPTiAqLyB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlID09PSA4IC8qIE5vZGVUeXBlcy5DT01QT1VORF9FWFBSRVNTSU9OICovO1xuICAgICAgICAgICAgICAgIGlmIChoYXNEeW5hbWljVGV4dENoaWxkICYmXG4gICAgICAgICAgICAgICAgICAgIGdldENvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCkgPT09IDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDEgLyogUGF0Y2hGbGFncy5URVhUICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBwYXNzIGRpcmVjdGx5IGlmIHRoZSBvbmx5IGNoaWxkIGlzIGEgdGV4dCBub2RlXG4gICAgICAgICAgICAgICAgLy8gKHBsYWluIC8gaW50ZXJwb2xhdGlvbiAvIGV4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgaWYgKGhhc0R5bmFtaWNUZXh0Q2hpbGQgfHwgdHlwZSA9PT0gMiAvKiBOb2RlVHlwZXMuVEVYVCAqLykge1xuICAgICAgICAgICAgICAgICAgICB2bm9kZUNoaWxkcmVuID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2bm9kZUNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2bm9kZUNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBwYXRjaEZsYWcgJiBkeW5hbWljUHJvcE5hbWVzXG4gICAgICAgIGlmIChwYXRjaEZsYWcgIT09IDApIHtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hGbGFnIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGZsYWdzIChuZWdhdGl2ZSBhbmQgbXV0dWFsbHkgZXhjbHVzaXZlKVxuICAgICAgICAgICAgICAgICAgICB2bm9kZVBhdGNoRmxhZyA9IHBhdGNoRmxhZyArIGAgLyogJHtzaGFyZWRfMS5QYXRjaEZsYWdOYW1lc1twYXRjaEZsYWddfSAqL2A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBiaXR3aXNlIGZsYWdzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZsYWdOYW1lcyA9IE9iamVjdC5rZXlzKHNoYXJlZF8xLlBhdGNoRmxhZ05hbWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChOdW1iZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKG4gPT4gbiA+IDAgJiYgcGF0Y2hGbGFnICYgbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAobiA9PiBzaGFyZWRfMS5QYXRjaEZsYWdOYW1lc1tuXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKGAsIGApO1xuICAgICAgICAgICAgICAgICAgICB2bm9kZVBhdGNoRmxhZyA9IHBhdGNoRmxhZyArIGAgLyogJHtmbGFnTmFtZXN9ICovYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2bm9kZVBhdGNoRmxhZyA9IFN0cmluZyhwYXRjaEZsYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGR5bmFtaWNQcm9wTmFtZXMgJiYgZHluYW1pY1Byb3BOYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2bm9kZUR5bmFtaWNQcm9wcyA9IHN0cmluZ2lmeUR5bmFtaWNQcm9wTmFtZXMoZHluYW1pY1Byb3BOYW1lcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5jb2RlZ2VuTm9kZSA9IGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCB2bm9kZVRhZywgdm5vZGVQcm9wcywgdm5vZGVDaGlsZHJlbiwgdm5vZGVQYXRjaEZsYWcsIHZub2RlRHluYW1pY1Byb3BzLCB2bm9kZURpcmVjdGl2ZXMsICEhc2hvdWxkVXNlQmxvY2ssIGZhbHNlIC8qIGRpc2FibGVUcmFja2luZyAqLywgaXNDb21wb25lbnQsIG5vZGUubG9jKTtcbiAgICB9O1xufTtcbmV4cG9ydHMudHJhbnNmb3JtRWxlbWVudCA9IHRyYW5zZm9ybUVsZW1lbnQ7XG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50VHlwZShub2RlLCBjb250ZXh0LCBzc3IgPSBmYWxzZSkge1xuICAgIGxldCB7IHRhZyB9ID0gbm9kZTtcbiAgICAvLyAxLiBkeW5hbWljIGNvbXBvbmVudFxuICAgIGNvbnN0IGlzRXhwbGljaXREeW5hbWljID0gaXNDb21wb25lbnRUYWcodGFnKTtcbiAgICBjb25zdCBpc1Byb3AgPSBmaW5kUHJvcChub2RlLCAnaXMnKTtcbiAgICBpZiAoaXNQcm9wKSB7XG4gICAgICAgIGlmIChpc0V4cGxpY2l0RHluYW1pYyB8fFxuICAgICAgICAgICAgKGlzQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfSVNfT05fRUxFTUVOVCAqLywgY29udGV4dCkpKSB7XG4gICAgICAgICAgICBjb25zdCBleHAgPSBpc1Byb3AudHlwZSA9PT0gNiAvKiBOb2RlVHlwZXMuQVRUUklCVVRFICovXG4gICAgICAgICAgICAgICAgPyBpc1Byb3AudmFsdWUgJiYgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihpc1Byb3AudmFsdWUuY29udGVudCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICA6IGlzUHJvcC5leHA7XG4gICAgICAgICAgICBpZiAoZXhwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQpLCBbXG4gICAgICAgICAgICAgICAgICAgIGV4cFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUHJvcC50eXBlID09PSA2IC8qIE5vZGVUeXBlcy5BVFRSSUJVVEUgKi8gJiZcbiAgICAgICAgICAgIGlzUHJvcC52YWx1ZS5jb250ZW50LnN0YXJ0c1dpdGgoJ3Z1ZTonKSkge1xuICAgICAgICAgICAgLy8gPGJ1dHRvbiBpcz1cInZ1ZTp4eHhcIj5cbiAgICAgICAgICAgIC8vIGlmIG5vdCA8Y29tcG9uZW50Piwgb25seSBpcyB2YWx1ZSB0aGF0IHN0YXJ0cyB3aXRoIFwidnVlOlwiIHdpbGwgYmVcbiAgICAgICAgICAgIC8vIHRyZWF0ZWQgYXMgY29tcG9uZW50IGJ5IHRoZSBwYXJzZSBwaGFzZSBhbmQgcmVhY2ggaGVyZSwgdW5sZXNzIGl0J3NcbiAgICAgICAgICAgIC8vIGNvbXBhdCBtb2RlIHdoZXJlIGFsbCBpcyB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgY29tcG9uZW50c1xuICAgICAgICAgICAgdGFnID0gaXNQcm9wLnZhbHVlLmNvbnRlbnQuc2xpY2UoNCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gMS41IHYtaXMgKFRPRE86IERlcHJlY2F0ZSlcbiAgICBjb25zdCBpc0RpciA9ICFpc0V4cGxpY2l0RHluYW1pYyAmJiBmaW5kRGlyKG5vZGUsICdpcycpO1xuICAgIGlmIChpc0RpciAmJiBpc0Rpci5leHApIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQpLCBbXG4gICAgICAgICAgICBpc0Rpci5leHBcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8vIDIuIGJ1aWx0LWluIGNvbXBvbmVudHMgKFRlbGVwb3J0LCBUcmFuc2l0aW9uLCBLZWVwQWxpdmUsIFN1c3BlbnNlLi4uKVxuICAgIGNvbnN0IGJ1aWx0SW4gPSBpc0NvcmVDb21wb25lbnQodGFnKSB8fCBjb250ZXh0LmlzQnVpbHRJbkNvbXBvbmVudCh0YWcpO1xuICAgIGlmIChidWlsdEluKSB7XG4gICAgICAgIC8vIGJ1aWx0LWlucyBhcmUgc2ltcGx5IGZhbGx0aHJvdWdocyAvIGhhdmUgc3BlY2lhbCBoYW5kbGluZyBkdXJpbmcgc3NyXG4gICAgICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gaW1wb3J0IHRoZWlyIHJ1bnRpbWUgZXF1aXZhbGVudHNcbiAgICAgICAgaWYgKCFzc3IpXG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihidWlsdEluKTtcbiAgICAgICAgcmV0dXJuIGJ1aWx0SW47XG4gICAgfVxuICAgIC8vIDUuIHVzZXIgY29tcG9uZW50IChyZXNvbHZlKVxuICAgIGNvbnRleHQuaGVscGVyKFJFU09MVkVfQ09NUE9ORU5UKTtcbiAgICBjb250ZXh0LmNvbXBvbmVudHMuYWRkKHRhZyk7XG4gICAgcmV0dXJuIHRvVmFsaWRBc3NldElkKHRhZywgYGNvbXBvbmVudGApO1xufVxuZXhwb3J0cy5yZXNvbHZlQ29tcG9uZW50VHlwZSA9IHJlc29sdmVDb21wb25lbnRUeXBlO1xuZnVuY3Rpb24gYnVpbGRQcm9wcyhub2RlLCBjb250ZXh0LCBwcm9wcyA9IG5vZGUucHJvcHMsIGlzQ29tcG9uZW50LCBpc0R5bmFtaWNDb21wb25lbnQsIHNzciA9IGZhbHNlKSB7XG4gICAgY29uc3QgeyB0YWcsIGxvYzogZWxlbWVudExvYywgY2hpbGRyZW4gfSA9IG5vZGU7XG4gICAgbGV0IHByb3BlcnRpZXMgPSBbXTtcbiAgICBjb25zdCBtZXJnZUFyZ3MgPSBbXTtcbiAgICBjb25zdCBydW50aW1lRGlyZWN0aXZlcyA9IFtdO1xuICAgIGNvbnN0IGhhc0NoaWxkcmVuID0gY2hpbGRyZW4ubGVuZ3RoID4gMDtcbiAgICBsZXQgc2hvdWxkVXNlQmxvY2sgPSBmYWxzZTtcbiAgICAvLyBwYXRjaEZsYWcgYW5hbHlzaXNcbiAgICBsZXQgcGF0Y2hGbGFnID0gMDtcbiAgICBsZXQgaGFzUmVmID0gZmFsc2U7XG4gICAgbGV0IGhhc0NsYXNzQmluZGluZyA9IGZhbHNlO1xuICAgIGxldCBoYXNTdHlsZUJpbmRpbmcgPSBmYWxzZTtcbiAgICBsZXQgaGFzSHlkcmF0aW9uRXZlbnRCaW5kaW5nID0gZmFsc2U7XG4gICAgbGV0IGhhc0R5bmFtaWNLZXlzID0gZmFsc2U7XG4gICAgbGV0IGhhc1Zub2RlSG9vayA9IGZhbHNlO1xuICAgIGNvbnN0IGR5bmFtaWNQcm9wTmFtZXMgPSBbXTtcbiAgICBjb25zdCBwdXNoTWVyZ2VBcmcgPSAoYXJnKSA9PiB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbWVyZ2VBcmdzLnB1c2goY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihkZWR1cGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpLCBlbGVtZW50TG9jKSk7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZylcbiAgICAgICAgICAgIG1lcmdlQXJncy5wdXNoKGFyZyk7XG4gICAgfTtcbiAgICBjb25zdCBhbmFseXplUGF0Y2hGbGFnID0gKHsga2V5LCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgIGlmIChpc1N0YXRpY0V4cChrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0ga2V5LmNvbnRlbnQ7XG4gICAgICAgICAgICBjb25zdCBpc0V2ZW50SGFuZGxlciA9ICgwLCBzaGFyZWRfMS5pc09uKShuYW1lKTtcbiAgICAgICAgICAgIGlmIChpc0V2ZW50SGFuZGxlciAmJlxuICAgICAgICAgICAgICAgICghaXNDb21wb25lbnQgfHwgaXNEeW5hbWljQ29tcG9uZW50KSAmJlxuICAgICAgICAgICAgICAgIC8vIG9taXQgdGhlIGZsYWcgZm9yIGNsaWNrIGhhbmRsZXJzIGJlY2F1c2UgaHlkcmF0aW9uIGdpdmVzIGNsaWNrXG4gICAgICAgICAgICAgICAgLy8gZGVkaWNhdGVkIGZhc3QgcGF0aC5cbiAgICAgICAgICAgICAgICBuYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdvbmNsaWNrJyAmJlxuICAgICAgICAgICAgICAgIC8vIG9taXQgdi1tb2RlbCBoYW5kbGVyc1xuICAgICAgICAgICAgICAgIG5hbWUgIT09ICdvblVwZGF0ZTptb2RlbFZhbHVlJyAmJlxuICAgICAgICAgICAgICAgIC8vIG9taXQgb25Wbm9kZVhYWCBob29rc1xuICAgICAgICAgICAgICAgICEoMCwgc2hhcmVkXzEuaXNSZXNlcnZlZFByb3ApKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaGFzSHlkcmF0aW9uRXZlbnRCaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0V2ZW50SGFuZGxlciAmJiAoMCwgc2hhcmVkXzEuaXNSZXNlcnZlZFByb3ApKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaGFzVm5vZGVIb29rID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSAyMCAvKiBOb2RlVHlwZXMuSlNfQ0FDSEVfRVhQUkVTU0lPTiAqLyB8fFxuICAgICAgICAgICAgICAgICgodmFsdWUudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9PT0gOCAvKiBOb2RlVHlwZXMuQ09NUE9VTkRfRVhQUkVTU0lPTiAqLykgJiZcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29uc3RhbnRUeXBlKHZhbHVlLCBjb250ZXh0KSA+IDApKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBpZiB0aGUgcHJvcCBpcyBhIGNhY2hlZCBoYW5kbGVyIG9yIGhhcyBjb25zdGFudCB2YWx1ZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAncmVmJykge1xuICAgICAgICAgICAgICAgIGhhc1JlZiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgICAgaGFzQ2xhc3NCaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgICAgICBoYXNTdHlsZUJpbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSAhPT0gJ2tleScgJiYgIWR5bmFtaWNQcm9wTmFtZXMuaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljUHJvcE5hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0cmVhdCB0aGUgZHluYW1pYyBjbGFzcyBhbmQgc3R5bGUgYmluZGluZyBvZiB0aGUgY29tcG9uZW50IGFzIGR5bmFtaWMgcHJvcHNcbiAgICAgICAgICAgIGlmIChpc0NvbXBvbmVudCAmJlxuICAgICAgICAgICAgICAgIChuYW1lID09PSAnY2xhc3MnIHx8IG5hbWUgPT09ICdzdHlsZScpICYmXG4gICAgICAgICAgICAgICAgIWR5bmFtaWNQcm9wTmFtZXMuaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljUHJvcE5hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYXNEeW5hbWljS2V5cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gc3RhdGljIGF0dHJpYnV0ZVxuICAgICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XG4gICAgICAgIGlmIChwcm9wLnR5cGUgPT09IDYgLyogTm9kZVR5cGVzLkFUVFJJQlVURSAqLykge1xuICAgICAgICAgICAgY29uc3QgeyBsb2MsIG5hbWUsIHZhbHVlIH0gPSBwcm9wO1xuICAgICAgICAgICAgbGV0IGlzU3RhdGljID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAncmVmJykge1xuICAgICAgICAgICAgICAgIGhhc1JlZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuc2NvcGVzLnZGb3IgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCdyZWZfZm9yJywgdHJ1ZSksIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJ3RydWUnKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNraXAgaXMgb24gPGNvbXBvbmVudD4sIG9yIGlzPVwidnVlOnh4eFwiXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lzJyAmJlxuICAgICAgICAgICAgICAgIChpc0NvbXBvbmVudFRhZyh0YWcpIHx8XG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZSAmJiB2YWx1ZS5jb250ZW50LnN0YXJ0c1dpdGgoJ3Z1ZTonKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGlzQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfSVNfT05fRUxFTUVOVCAqLywgY29udGV4dCkpKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKGNyZWF0ZU9iamVjdFByb3BlcnR5KGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24obmFtZSwgdHJ1ZSwgZ2V0SW5uZXJSYW5nZShsb2MsIDAsIG5hbWUubGVuZ3RoKSksIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24odmFsdWUgPyB2YWx1ZS5jb250ZW50IDogJycsIGlzU3RhdGljLCB2YWx1ZSA/IHZhbHVlLmxvYyA6IGxvYykpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRpcmVjdGl2ZXNcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgYXJnLCBleHAsIGxvYyB9ID0gcHJvcDtcbiAgICAgICAgICAgIGNvbnN0IGlzVkJpbmQgPSBuYW1lID09PSAnYmluZCc7XG4gICAgICAgICAgICBjb25zdCBpc1ZPbiA9IG5hbWUgPT09ICdvbic7XG4gICAgICAgICAgICAvLyBza2lwIHYtc2xvdCAtIGl0IGlzIGhhbmRsZWQgYnkgaXRzIGRlZGljYXRlZCB0cmFuc2Zvcm0uXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0MCAvKiBFcnJvckNvZGVzLlhfVl9TTE9UX01JU1BMQUNFRCAqLywgbG9jKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2tpcCB2LW9uY2Uvdi1tZW1vIC0gdGhleSBhcmUgaGFuZGxlZCBieSBkZWRpY2F0ZWQgdHJhbnNmb3Jtcy5cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnb25jZScgfHwgbmFtZSA9PT0gJ21lbW8nKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBza2lwIHYtaXMgYW5kIDppcyBvbiA8Y29tcG9uZW50PlxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpcycgfHxcbiAgICAgICAgICAgICAgICAoaXNWQmluZCAmJlxuICAgICAgICAgICAgICAgICAgICBpc1N0YXRpY0FyZ09mKGFyZywgJ2lzJykgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlzQ29tcG9uZW50VGFnKHRhZykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChpc0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9JU19PTl9FTEVNRU5UXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX0lTX09OX0VMRU1FTlQgKi8sIGNvbnRleHQpKSkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBza2lwIHYtb24gaW4gU1NSIGNvbXBpbGF0aW9uXG4gICAgICAgICAgICBpZiAoaXNWT24gJiYgc3NyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyAjOTM4OiBlbGVtZW50cyB3aXRoIGR5bmFtaWMga2V5cyBzaG91bGQgYmUgZm9yY2VkIGludG8gYmxvY2tzXG4gICAgICAgICAgICAoaXNWQmluZCAmJiBpc1N0YXRpY0FyZ09mKGFyZywgJ2tleScpKSB8fFxuICAgICAgICAgICAgICAgIC8vIGlubGluZSBiZWZvcmUtdXBkYXRlIGhvb2tzIG5lZWQgdG8gZm9yY2UgYmxvY2sgc28gdGhhdCBpdCBpcyBpbnZva2VkXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgKGlzVk9uICYmIGhhc0NoaWxkcmVuICYmIGlzU3RhdGljQXJnT2YoYXJnLCAndnVlOmJlZm9yZS11cGRhdGUnKSkpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRVc2VCbG9jayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNWQmluZCAmJiBpc1N0YXRpY0FyZ09mKGFyZywgJ3JlZicpICYmIGNvbnRleHQuc2NvcGVzLnZGb3IgPiAwKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKGNyZWF0ZU9iamVjdFByb3BlcnR5KGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJ3JlZl9mb3InLCB0cnVlKSwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbigndHJ1ZScpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHYtYmluZCBhbmQgdi1vbiB3aXRoIG5vIGFyZ3VtZW50XG4gICAgICAgICAgICBpZiAoIWFyZyAmJiAoaXNWQmluZCB8fCBpc1ZPbikpIHtcbiAgICAgICAgICAgICAgICBoYXNEeW5hbWljS2V5cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGV4cCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWQmluZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZSB0byBtZXJnZSBlYXJseSBmb3IgY29tcGF0IGJ1aWxkIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoTWVyZ2VBcmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyLnggdi1iaW5kIG9iamVjdCBvcmRlciBjb21wYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc092ZXJyaWRhYmxlS2V5cyA9IG1lcmdlQXJncy5zb21lKGFyZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLnR5cGUgPT09IDE1IC8qIE5vZGVUeXBlcy5KU19PQkpFQ1RfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcucHJvcGVydGllcy5zb21lKCh7IGtleSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkudHlwZSAhPT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFrZXkuaXNTdGF0aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoa2V5LmNvbnRlbnQgIT09ICdjbGFzcycgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleS5jb250ZW50ICE9PSAnc3R5bGUnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKDAsIHNoYXJlZF8xLmlzT24pKGtleS5jb250ZW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkeW5hbWljIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPdmVycmlkYWJsZUtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVJcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfVl9CSU5EX09CSkVDVF9PUkRFUiAqLywgY29udGV4dCwgbG9jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfVl9CSU5EX09CSkVDVF9PUkRFUlwiIC8qIENvbXBpbGVyRGVwcmVjYXRpb25UeXBlcy5DT01QSUxFUl9WX0JJTkRfT0JKRUNUX09SREVSICovLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZUFyZ3MudW5zaGlmdChleHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZUFyZ3MucHVzaChleHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdi1vbj1cIm9ialwiIC0+IHRvSGFuZGxlcnMob2JqKVxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaE1lcmdlQXJnKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAxNCAvKiBOb2RlVHlwZXMuSlNfQ0FMTF9FWFBSRVNTSU9OICovLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsZWU6IGNvbnRleHQuaGVscGVyKFRPX0hBTkRMRVJTKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGlzQ29tcG9uZW50ID8gW2V4cF0gOiBbZXhwLCBgdHJ1ZWBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoaXNWQmluZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyAzNCAvKiBFcnJvckNvZGVzLlhfVl9CSU5EX05PX0VYUFJFU1NJT04gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIDogMzUgLyogRXJyb3JDb2Rlcy5YX1ZfT05fTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aXZlVHJhbnNmb3JtID0gY29udGV4dC5kaXJlY3RpdmVUcmFuc2Zvcm1zW25hbWVdO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZVRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIC8vIGhhcyBidWlsdC1pbiBkaXJlY3RpdmUgdHJhbnNmb3JtLlxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIG5lZWRSdW50aW1lIH0gPSBkaXJlY3RpdmVUcmFuc2Zvcm0ocHJvcCwgbm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgIXNzciAmJiBwcm9wcy5mb3JFYWNoKGFuYWx5emVQYXRjaEZsYWcpO1xuICAgICAgICAgICAgICAgIGlmIChpc1ZPbiAmJiBhcmcgJiYgIWlzU3RhdGljRXhwKGFyZykpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaE1lcmdlQXJnKGNyZWF0ZU9iamVjdEV4cHJlc3Npb24ocHJvcHMsIGVsZW1lbnRMb2MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaCguLi5wcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgICAgICAgICAgICAgICBydW50aW1lRGlyZWN0aXZlcy5wdXNoKHByb3ApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIHNoYXJlZF8xLmlzU3ltYm9sKShuZWVkUnVudGltZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZUltcG9ydE1hcC5zZXQocHJvcCwgbmVlZFJ1bnRpbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoISgwLCBzaGFyZWRfMS5pc0J1aWx0SW5EaXJlY3RpdmUpKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gYnVpbHQtaW4gdHJhbnNmb3JtLCB0aGlzIGlzIGEgdXNlciBjdXN0b20gZGlyZWN0aXZlLlxuICAgICAgICAgICAgICAgIHJ1bnRpbWVEaXJlY3RpdmVzLnB1c2gocHJvcCk7XG4gICAgICAgICAgICAgICAgLy8gY3VzdG9tIGRpcnMgbWF5IHVzZSBiZWZvcmVVcGRhdGUgc28gdGhleSBuZWVkIHRvIGZvcmNlIGJsb2Nrc1xuICAgICAgICAgICAgICAgIC8vIHRvIGVuc3VyZSBiZWZvcmUtdXBkYXRlIGdldHMgY2FsbGVkIGJlZm9yZSBjaGlsZHJlbiB1cGRhdGVcbiAgICAgICAgICAgICAgICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkVXNlQmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcHJvcHNFeHByZXNzaW9uID0gdW5kZWZpbmVkO1xuICAgIC8vIGhhcyB2LWJpbmQ9XCJvYmplY3RcIiBvciB2LW9uPVwib2JqZWN0XCIsIHdyYXAgd2l0aCBtZXJnZVByb3BzXG4gICAgaWYgKG1lcmdlQXJncy5sZW5ndGgpIHtcbiAgICAgICAgLy8gY2xvc2UgdXAgYW55IG5vdC15ZXQtbWVyZ2VkIHByb3BzXG4gICAgICAgIHB1c2hNZXJnZUFyZygpO1xuICAgICAgICBpZiAobWVyZ2VBcmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHByb3BzRXhwcmVzc2lvbiA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE1FUkdFX1BST1BTKSwgbWVyZ2VBcmdzLCBlbGVtZW50TG9jKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNpbmdsZSB2LWJpbmQgd2l0aCBub3RoaW5nIGVsc2UgLSBubyBuZWVkIGZvciBhIG1lcmdlUHJvcHMgY2FsbFxuICAgICAgICAgICAgcHJvcHNFeHByZXNzaW9uID0gbWVyZ2VBcmdzWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgIHByb3BzRXhwcmVzc2lvbiA9IGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oZGVkdXBlUHJvcGVydGllcyhwcm9wZXJ0aWVzKSwgZWxlbWVudExvYyk7XG4gICAgfVxuICAgIC8vIHBhdGNoRmxhZyBhbmFseXNpc1xuICAgIGlmIChoYXNEeW5hbWljS2V5cykge1xuICAgICAgICBwYXRjaEZsYWcgfD0gMTYgLyogUGF0Y2hGbGFncy5GVUxMX1BST1BTICovO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGhhc0NsYXNzQmluZGluZyAmJiAhaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAyIC8qIFBhdGNoRmxhZ3MuQ0xBU1MgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1N0eWxlQmluZGluZyAmJiAhaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHBhdGNoRmxhZyB8PSA0IC8qIFBhdGNoRmxhZ3MuU1RZTEUgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGR5bmFtaWNQcm9wTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gOCAvKiBQYXRjaEZsYWdzLlBST1BTICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNIeWRyYXRpb25FdmVudEJpbmRpbmcpIHtcbiAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAzMiAvKiBQYXRjaEZsYWdzLkhZRFJBVEVfRVZFTlRTICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghc2hvdWxkVXNlQmxvY2sgJiZcbiAgICAgICAgKHBhdGNoRmxhZyA9PT0gMCB8fCBwYXRjaEZsYWcgPT09IDMyIC8qIFBhdGNoRmxhZ3MuSFlEUkFURV9FVkVOVFMgKi8pICYmXG4gICAgICAgIChoYXNSZWYgfHwgaGFzVm5vZGVIb29rIHx8IHJ1bnRpbWVEaXJlY3RpdmVzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgIHBhdGNoRmxhZyB8PSA1MTIgLyogUGF0Y2hGbGFncy5ORUVEX1BBVENIICovO1xuICAgIH1cbiAgICAvLyBwcmUtbm9ybWFsaXplIHByb3BzLCBTU1IgaXMgc2tpcHBlZCBmb3Igbm93XG4gICAgaWYgKCFjb250ZXh0LmluU1NSICYmIHByb3BzRXhwcmVzc2lvbikge1xuICAgICAgICBzd2l0Y2ggKHByb3BzRXhwcmVzc2lvbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDE1IC8qIE5vZGVUeXBlcy5KU19PQkpFQ1RfRVhQUkVTU0lPTiAqLzpcbiAgICAgICAgICAgICAgICAvLyBtZWFucyB0aGF0IHRoZXJlIGlzIG5vIHYtYmluZCxcbiAgICAgICAgICAgICAgICAvLyBidXQgc3RpbGwgbmVlZCB0byBkZWFsIHdpdGggZHluYW1pYyBrZXkgYmluZGluZ1xuICAgICAgICAgICAgICAgIGxldCBjbGFzc0tleUluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlS2V5SW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICBsZXQgaGFzRHluYW1pY0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNFeHByZXNzaW9uLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNFeHByZXNzaW9uLnByb3BlcnRpZXNbaV0ua2V5O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdGF0aWNFeHAoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5jb250ZW50ID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NLZXlJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkuY29udGVudCA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlS2V5SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFrZXkuaXNIYW5kbGVyS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNEeW5hbWljS2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc1Byb3AgPSBwcm9wc0V4cHJlc3Npb24ucHJvcGVydGllc1tjbGFzc0tleUluZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZVByb3AgPSBwcm9wc0V4cHJlc3Npb24ucHJvcGVydGllc1tzdHlsZUtleUluZGV4XTtcbiAgICAgICAgICAgICAgICAvLyBubyBkeW5hbWljIGtleVxuICAgICAgICAgICAgICAgIGlmICghaGFzRHluYW1pY0tleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NQcm9wICYmICFpc1N0YXRpY0V4cChjbGFzc1Byb3AudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc1Byb3AudmFsdWUgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihOT1JNQUxJWkVfQ0xBU1MpLCBbY2xhc3NQcm9wLnZhbHVlXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlUHJvcCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN0YXRpYyBzdHlsZSBpcyBjb21waWxlZCBpbnRvIGFuIG9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHVzZSBgaGFzU3R5bGVCaW5kaW5nYCB0byBlbnN1cmUgdGhhdCBpdCBpcyBhIGR5bmFtaWMgc3R5bGUgYmluZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgKGhhc1N0eWxlQmluZGluZyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzdHlsZVByb3AudmFsdWUudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVQcm9wLnZhbHVlLmNvbnRlbnQudHJpbSgpWzBdID09PSBgW2ApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdi1iaW5kOnN0eWxlIGFuZCBzdHlsZSBib3RoIGV4aXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHYtYmluZDpzdHlsZSB3aXRoIHN0YXRpYyBsaXRlcmFsIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlUHJvcC52YWx1ZS50eXBlID09PSAxNyAvKiBOb2RlVHlwZXMuSlNfQVJSQVlfRVhQUkVTU0lPTiAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlUHJvcC52YWx1ZSA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE5PUk1BTElaRV9TVFlMRSksIFtzdHlsZVByb3AudmFsdWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZHluYW1pYyBrZXkgYmluZGluZywgd3JhcCB3aXRoIGBub3JtYWxpemVQcm9wc2BcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNFeHByZXNzaW9uID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoTk9STUFMSVpFX1BST1BTKSwgW3Byb3BzRXhwcmVzc2lvbl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTQgLyogTm9kZVR5cGVzLkpTX0NBTExfRVhQUkVTU0lPTiAqLzpcbiAgICAgICAgICAgICAgICAvLyBtZXJnZVByb3BzIGNhbGwsIGRvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gc2luZ2xlIHYtYmluZFxuICAgICAgICAgICAgICAgIHByb3BzRXhwcmVzc2lvbiA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE5PUk1BTElaRV9QUk9QUyksIFtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoR1VBUkRfUkVBQ1RJVkVfUFJPUFMpLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc0V4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczogcHJvcHNFeHByZXNzaW9uLFxuICAgICAgICBkaXJlY3RpdmVzOiBydW50aW1lRGlyZWN0aXZlcyxcbiAgICAgICAgcGF0Y2hGbGFnLFxuICAgICAgICBkeW5hbWljUHJvcE5hbWVzLFxuICAgICAgICBzaG91bGRVc2VCbG9ja1xuICAgIH07XG59XG5leHBvcnRzLmJ1aWxkUHJvcHMgPSBidWlsZFByb3BzO1xuLy8gRGVkdXBlIHByb3BzIGluIGFuIG9iamVjdCBsaXRlcmFsLlxuLy8gTGl0ZXJhbCBkdXBsaWNhdGVkIGF0dHJpYnV0ZXMgd291bGQgaGF2ZSBiZWVuIHdhcm5lZCBkdXJpbmcgdGhlIHBhcnNlIHBoYXNlLFxuLy8gaG93ZXZlciwgaXQncyBwb3NzaWJsZSB0byBlbmNvdW50ZXIgZHVwbGljYXRlZCBgb25YWFhgIGhhbmRsZXJzIHdpdGggZGlmZmVyZW50XG4vLyBtb2RpZmllcnMuIFdlIGFsc28gbmVlZCB0byBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgY2xhc3MgLyBzdHlsZSBhdHRyaWJ1dGVzLlxuLy8gLSBvblhYWCBoYW5kbGVycyAvIHN0eWxlOiBtZXJnZSBpbnRvIGFycmF5XG4vLyAtIGNsYXNzOiBtZXJnZSBpbnRvIHNpbmdsZSBleHByZXNzaW9uIHdpdGggY29uY2F0ZW5hdGlvblxuZnVuY3Rpb24gZGVkdXBlUHJvcGVydGllcyhwcm9wZXJ0aWVzKSB7XG4gICAgY29uc3Qga25vd25Qcm9wcyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkZWR1cGVkID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHByb3AgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAvLyBkeW5hbWljIGtleXMgYXJlIGFsd2F5cyBhbGxvd2VkXG4gICAgICAgIGlmIChwcm9wLmtleS50eXBlID09PSA4IC8qIE5vZGVUeXBlcy5DT01QT1VORF9FWFBSRVNTSU9OICovIHx8ICFwcm9wLmtleS5pc1N0YXRpYykge1xuICAgICAgICAgICAgZGVkdXBlZC5wdXNoKHByb3ApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IHByb3Aua2V5LmNvbnRlbnQ7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0ga25vd25Qcm9wcy5nZXQobmFtZSk7XG4gICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdzdHlsZScgfHwgbmFtZSA9PT0gJ2NsYXNzJyB8fCAoMCwgc2hhcmVkXzEuaXNPbikobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBtZXJnZUFzQXJyYXkoZXhpc3RpbmcsIHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdW5leHBlY3RlZCBkdXBsaWNhdGUsIHNob3VsZCBoYXZlIGVtaXR0ZWQgZXJyb3IgZHVyaW5nIHBhcnNlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBrbm93blByb3BzLnNldChuYW1lLCBwcm9wKTtcbiAgICAgICAgICAgIGRlZHVwZWQucHVzaChwcm9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVkdXBlZDtcbn1cbmZ1bmN0aW9uIG1lcmdlQXNBcnJheShleGlzdGluZywgaW5jb21pbmcpIHtcbiAgICBpZiAoZXhpc3RpbmcudmFsdWUudHlwZSA9PT0gMTcgLyogTm9kZVR5cGVzLkpTX0FSUkFZX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgZXhpc3RpbmcudmFsdWUuZWxlbWVudHMucHVzaChpbmNvbWluZy52YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBleGlzdGluZy52YWx1ZSA9IGNyZWF0ZUFycmF5RXhwcmVzc2lvbihbZXhpc3RpbmcudmFsdWUsIGluY29taW5nLnZhbHVlXSwgZXhpc3RpbmcubG9jKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZERpcmVjdGl2ZUFyZ3MoZGlyLCBjb250ZXh0KSB7XG4gICAgY29uc3QgZGlyQXJncyA9IFtdO1xuICAgIGNvbnN0IHJ1bnRpbWUgPSBkaXJlY3RpdmVJbXBvcnRNYXAuZ2V0KGRpcik7XG4gICAgaWYgKHJ1bnRpbWUpIHtcbiAgICAgICAgLy8gYnVpbHQtaW4gZGlyZWN0aXZlIHdpdGggcnVudGltZVxuICAgICAgICBkaXJBcmdzLnB1c2goY29udGV4dC5oZWxwZXJTdHJpbmcocnVudGltZSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gaW5qZWN0IHN0YXRlbWVudCBmb3IgcmVzb2x2aW5nIGRpcmVjdGl2ZVxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoUkVTT0xWRV9ESVJFQ1RJVkUpO1xuICAgICAgICAgICAgY29udGV4dC5kaXJlY3RpdmVzLmFkZChkaXIubmFtZSk7XG4gICAgICAgICAgICBkaXJBcmdzLnB1c2godG9WYWxpZEFzc2V0SWQoZGlyLm5hbWUsIGBkaXJlY3RpdmVgKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyBsb2MgfSA9IGRpcjtcbiAgICBpZiAoZGlyLmV4cClcbiAgICAgICAgZGlyQXJncy5wdXNoKGRpci5leHApO1xuICAgIGlmIChkaXIuYXJnKSB7XG4gICAgICAgIGlmICghZGlyLmV4cCkge1xuICAgICAgICAgICAgZGlyQXJncy5wdXNoKGB2b2lkIDBgKTtcbiAgICAgICAgfVxuICAgICAgICBkaXJBcmdzLnB1c2goZGlyLmFyZyk7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzKS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFkaXIuYXJnKSB7XG4gICAgICAgICAgICBpZiAoIWRpci5leHApIHtcbiAgICAgICAgICAgICAgICBkaXJBcmdzLnB1c2goYHZvaWQgMGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlyQXJncy5wdXNoKGB2b2lkIDBgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cnVlRXhwcmVzc2lvbiA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHRydWVgLCBmYWxzZSwgbG9jKTtcbiAgICAgICAgZGlyQXJncy5wdXNoKGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oZGlyLm1vZGlmaWVycy5tYXAobW9kaWZpZXIgPT4gY3JlYXRlT2JqZWN0UHJvcGVydHkobW9kaWZpZXIsIHRydWVFeHByZXNzaW9uKSksIGxvYykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQXJyYXlFeHByZXNzaW9uKGRpckFyZ3MsIGRpci5sb2MpO1xufVxuZXhwb3J0cy5idWlsZERpcmVjdGl2ZUFyZ3MgPSBidWlsZERpcmVjdGl2ZUFyZ3M7XG5mdW5jdGlvbiBzdHJpbmdpZnlEeW5hbWljUHJvcE5hbWVzKHByb3BzKSB7XG4gICAgbGV0IHByb3BzTmFtZXNTdHJpbmcgPSBgW2A7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBwcm9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcHJvcHNOYW1lc1N0cmluZyArPSBKU09OLnN0cmluZ2lmeShwcm9wc1tpXSk7XG4gICAgICAgIGlmIChpIDwgbCAtIDEpXG4gICAgICAgICAgICBwcm9wc05hbWVzU3RyaW5nICs9ICcsICc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wc05hbWVzU3RyaW5nICsgYF1gO1xufVxuZnVuY3Rpb24gaXNDb21wb25lbnRUYWcodGFnKSB7XG4gICAgcmV0dXJuIHRhZyA9PT0gJ2NvbXBvbmVudCcgfHwgdGFnID09PSAnQ29tcG9uZW50Jztcbn1cbihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgID8gT2JqZWN0LmZyZWV6ZSh7fSlcbiAgICA6IHt9O1xuKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXTtcbmNvbnN0IGNhY2hlU3RyaW5nRnVuY3Rpb24gPSAoZm4pID0+IHtcbiAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmV0dXJuICgoc3RyKSA9PiB7XG4gICAgICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XG4gICAgICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcbiAgICB9KTtcbn07XG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCAoXywgYykgPT4gKGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJykpO1xufSk7XG5jb25zdCB0cmFuc2Zvcm1TbG90T3V0bGV0ID0gKG5vZGUsIGNvbnRleHQpID0+IHtcbiAgICBpZiAoaXNTbG90T3V0bGV0KG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW4sIGxvYyB9ID0gbm9kZTtcbiAgICAgICAgY29uc3QgeyBzbG90TmFtZSwgc2xvdFByb3BzIH0gPSBwcm9jZXNzU2xvdE91dGxldChub2RlLCBjb250ZXh0KTtcbiAgICAgICAgY29uc3Qgc2xvdEFyZ3MgPSBbXG4gICAgICAgICAgICBjb250ZXh0LnByZWZpeElkZW50aWZpZXJzID8gYF9jdHguJHNsb3RzYCA6IGAkc2xvdHNgLFxuICAgICAgICAgICAgc2xvdE5hbWUsXG4gICAgICAgICAgICAne30nLFxuICAgICAgICAgICAgJ3VuZGVmaW5lZCcsXG4gICAgICAgICAgICAndHJ1ZSdcbiAgICAgICAgXTtcbiAgICAgICAgbGV0IGV4cGVjdGVkTGVuID0gMjtcbiAgICAgICAgaWYgKHNsb3RQcm9wcykge1xuICAgICAgICAgICAgc2xvdEFyZ3NbMl0gPSBzbG90UHJvcHM7XG4gICAgICAgICAgICBleHBlY3RlZExlbiA9IDM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgc2xvdEFyZ3NbM10gPSBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oW10sIGNoaWxkcmVuLCBmYWxzZSwgZmFsc2UsIGxvYyk7XG4gICAgICAgICAgICBleHBlY3RlZExlbiA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQuc2NvcGVJZCAmJiAhY29udGV4dC5zbG90dGVkKSB7XG4gICAgICAgICAgICBleHBlY3RlZExlbiA9IDU7XG4gICAgICAgIH1cbiAgICAgICAgc2xvdEFyZ3Muc3BsaWNlKGV4cGVjdGVkTGVuKTsgLy8gcmVtb3ZlIHVudXNlZCBhcmd1bWVudHNcbiAgICAgICAgbm9kZS5jb2RlZ2VuTm9kZSA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFTkRFUl9TTE9UKSwgc2xvdEFyZ3MsIGxvYyk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIHByb2Nlc3NTbG90T3V0bGV0KG5vZGUsIGNvbnRleHQpIHtcbiAgICBsZXQgc2xvdE5hbWUgPSBgXCJkZWZhdWx0XCJgO1xuICAgIGxldCBzbG90UHJvcHMgPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgbm9uTmFtZVByb3BzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xuICAgICAgICBpZiAocC50eXBlID09PSA2IC8qIE5vZGVUeXBlcy5BVFRSSUJVVEUgKi8pIHtcbiAgICAgICAgICAgIGlmIChwLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAubmFtZSA9PT0gJ25hbWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsb3ROYW1lID0gSlNPTi5zdHJpbmdpZnkocC52YWx1ZS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAubmFtZSA9IGNhbWVsaXplKHAubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIG5vbk5hbWVQcm9wcy5wdXNoKHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwLm5hbWUgPT09ICdiaW5kJyAmJiBpc1N0YXRpY0FyZ09mKHAuYXJnLCAnbmFtZScpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAuZXhwKVxuICAgICAgICAgICAgICAgICAgICBzbG90TmFtZSA9IHAuZXhwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHAubmFtZSA9PT0gJ2JpbmQnICYmIHAuYXJnICYmIGlzU3RhdGljRXhwKHAuYXJnKSkge1xuICAgICAgICAgICAgICAgICAgICBwLmFyZy5jb250ZW50ID0gY2FtZWxpemUocC5hcmcuY29udGVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vbk5hbWVQcm9wcy5wdXNoKHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChub25OYW1lUHJvcHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCBkaXJlY3RpdmVzIH0gPSBidWlsZFByb3BzKG5vZGUsIGNvbnRleHQsIG5vbk5hbWVQcm9wcywgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgc2xvdFByb3BzID0gcHJvcHM7XG4gICAgICAgIGlmIChkaXJlY3RpdmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzYgLyogRXJyb3JDb2Rlcy5YX1ZfU0xPVF9VTkVYUEVDVEVEX0RJUkVDVElWRV9PTl9TTE9UX09VVExFVCAqLywgZGlyZWN0aXZlc1swXS5sb2MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzbG90TmFtZSxcbiAgICAgICAgc2xvdFByb3BzXG4gICAgfTtcbn1cbmV4cG9ydHMucHJvY2Vzc1Nsb3RPdXRsZXQgPSBwcm9jZXNzU2xvdE91dGxldDtcbmNvbnN0IGZuRXhwUkUgPSAvXlxccyooW1xcdyRfXSt8KGFzeW5jXFxzKik/XFwoW14pXSo/XFwpKVxccyooOltePV0rKT89PnxeXFxzKihhc3luY1xccyspP2Z1bmN0aW9uKD86XFxzK1tcXHckXSspP1xccypcXCgvO1xuY29uc3QgdHJhbnNmb3JtT24gPSAoZGlyLCBub2RlLCBjb250ZXh0LCBhdWdtZW50b3IpID0+IHtcbiAgICBjb25zdCB7IGxvYywgbW9kaWZpZXJzLCBhcmcgfSA9IGRpcjtcbiAgICBpZiAoIWRpci5leHAgJiYgIW1vZGlmaWVycy5sZW5ndGgpIHtcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzUgLyogRXJyb3JDb2Rlcy5YX1ZfT05fTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XG4gICAgfVxuICAgIGxldCBldmVudE5hbWU7XG4gICAgaWYgKGFyZy50eXBlID09PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICBpZiAoYXJnLmlzU3RhdGljKSB7XG4gICAgICAgICAgICBsZXQgcmF3TmFtZSA9IGFyZy5jb250ZW50O1xuICAgICAgICAgICAgLy8gVE9ETyBkZXByZWNhdGUgQHZub2RlWFhYIHVzYWdlXG4gICAgICAgICAgICBpZiAocmF3TmFtZS5zdGFydHNXaXRoKCd2dWU6JykpIHtcbiAgICAgICAgICAgICAgICByYXdOYW1lID0gYHZub2RlLSR7cmF3TmFtZS5zbGljZSg0KX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXZlbnRTdHJpbmcgPSBub2RlLnRhZ1R5cGUgIT09IDAgLyogRWxlbWVudFR5cGVzLkVMRU1FTlQgKi8gfHxcbiAgICAgICAgICAgICAgICByYXdOYW1lLnN0YXJ0c1dpdGgoJ3Zub2RlJykgfHxcbiAgICAgICAgICAgICAgICAhL1tBLVpdLy50ZXN0KHJhd05hbWUpXG4gICAgICAgICAgICAgICAgPyAvLyBmb3Igbm9uLWVsZW1lbnQgYW5kIHZub2RlIGxpZmVjeWNsZSBldmVudCBsaXN0ZW5lcnMsIGF1dG8gY29udmVydFxuICAgICAgICAgICAgICAgICAgICAvLyBpdCB0byBjYW1lbENhc2UuIFNlZSBpc3N1ZSAjMjI0OVxuICAgICAgICAgICAgICAgICAgICAoMCwgc2hhcmVkXzEudG9IYW5kbGVyS2V5KSgoMCwgc2hhcmVkXzEuY2FtZWxpemUpKHJhd05hbWUpKVxuICAgICAgICAgICAgICAgIDogLy8gcHJlc2VydmUgY2FzZSBmb3IgcGxhaW4gZWxlbWVudCBsaXN0ZW5lcnMgdGhhdCBoYXZlIHVwcGVyY2FzZVxuICAgICAgICAgICAgICAgICAgICAvLyBsZXR0ZXJzLCBhcyB0aGVzZSBtYXkgYmUgY3VzdG9tIGVsZW1lbnRzJyBjdXN0b20gZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIGBvbjoke3Jhd05hbWV9YDtcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oZXZlbnRTdHJpbmcsIHRydWUsIGFyZy5sb2MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gIzIzODhcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbXG4gICAgICAgICAgICAgICAgYCR7Y29udGV4dC5oZWxwZXJTdHJpbmcoVE9fSEFORExFUl9LRVkpfShgLFxuICAgICAgICAgICAgICAgIGFyZyxcbiAgICAgICAgICAgICAgICBgKWBcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBhbHJlYWR5IGEgY29tcG91bmQgZXhwcmVzc2lvbi5cbiAgICAgICAgZXZlbnROYW1lID0gYXJnO1xuICAgICAgICBldmVudE5hbWUuY2hpbGRyZW4udW5zaGlmdChgJHtjb250ZXh0LmhlbHBlclN0cmluZyhUT19IQU5ETEVSX0tFWSl9KGApO1xuICAgICAgICBldmVudE5hbWUuY2hpbGRyZW4ucHVzaChgKWApO1xuICAgIH1cbiAgICAvLyBoYW5kbGVyIHByb2Nlc3NpbmdcbiAgICBsZXQgZXhwID0gZGlyLmV4cDtcbiAgICBpZiAoZXhwICYmICFleHAuY29udGVudC50cmltKCkpIHtcbiAgICAgICAgZXhwID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgc2hvdWxkQ2FjaGUgPSBjb250ZXh0LmNhY2hlSGFuZGxlcnMgJiYgIWV4cCAmJiAhY29udGV4dC5pblZPbmNlO1xuICAgIGlmIChleHApIHtcbiAgICAgICAgY29uc3QgaXNNZW1iZXJFeHAgPSBpc01lbWJlckV4cHJlc3Npb24oZXhwLmNvbnRlbnQpO1xuICAgICAgICBjb25zdCBpc0lubGluZVN0YXRlbWVudCA9ICEoaXNNZW1iZXJFeHAgfHwgZm5FeHBSRS50ZXN0KGV4cC5jb250ZW50KSk7XG4gICAgICAgIGNvbnN0IGhhc011bHRpcGxlU3RhdGVtZW50cyA9IGV4cC5jb250ZW50LmluY2x1ZGVzKGA7YCk7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSkge1xuICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihleHAsIGNvbnRleHQsIGZhbHNlLCBoYXNNdWx0aXBsZVN0YXRlbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0lubGluZVN0YXRlbWVudCB8fCAoc2hvdWxkQ2FjaGUgJiYgaXNNZW1iZXJFeHApKSB7XG4gICAgICAgICAgICAvLyB3cmFwIGlubGluZSBzdGF0ZW1lbnQgaW4gYSBmdW5jdGlvbiBleHByZXNzaW9uXG4gICAgICAgICAgICBleHAgPSBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW1xuICAgICAgICAgICAgICAgIGAke2lzSW5saW5lU3RhdGVtZW50XG4gICAgICAgICAgICAgICAgICAgID8gYCRldmVudGBcbiAgICAgICAgICAgICAgICAgICAgOiBgJHtgYH0oLi4uYXJncylgfSA9PiAke2hhc011bHRpcGxlU3RhdGVtZW50cyA/IGB7YCA6IGAoYH1gLFxuICAgICAgICAgICAgICAgIGV4cCxcbiAgICAgICAgICAgICAgICBoYXNNdWx0aXBsZVN0YXRlbWVudHMgPyBgfWAgOiBgKWBcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCByZXQgPSB7XG4gICAgICAgIHByb3BzOiBbXG4gICAgICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShldmVudE5hbWUsIGV4cCB8fCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGAoKSA9PiB7fWAsIGZhbHNlLCBsb2MpKVxuICAgICAgICBdXG4gICAgfTtcbiAgICAvLyBhcHBseSBleHRlbmRlZCBjb21waWxlciBhdWdtZW50b3JcbiAgICBpZiAoYXVnbWVudG9yKSB7XG4gICAgICAgIHJldCA9IGF1Z21lbnRvcihyZXQpO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkQ2FjaGUpIHtcbiAgICAgICAgLy8gY2FjaGUgaGFuZGxlcnMgc28gdGhhdCBpdCdzIGFsd2F5cyB0aGUgc2FtZSBoYW5kbGVyIGJlaW5nIHBhc3NlZCBkb3duLlxuICAgICAgICAvLyB0aGlzIGF2b2lkcyB1bm5lY2Vzc2FyeSByZS1yZW5kZXJzIHdoZW4gdXNlcnMgdXNlIGlubGluZSBoYW5kbGVycyBvblxuICAgICAgICAvLyBjb21wb25lbnRzLlxuICAgICAgICByZXQucHJvcHNbMF0udmFsdWUgPSBjb250ZXh0LmNhY2hlKHJldC5wcm9wc1swXS52YWx1ZSk7XG4gICAgfVxuICAgIC8vIG1hcmsgdGhlIGtleSBhcyBoYW5kbGVyIGZvciBwcm9wcyBub3JtYWxpemF0aW9uIGNoZWNrXG4gICAgcmV0LnByb3BzLmZvckVhY2gocCA9PiAocC5rZXkuaXNIYW5kbGVyS2V5ID0gdHJ1ZSkpO1xuICAgIHJldHVybiByZXQ7XG59O1xuZXhwb3J0cy50cmFuc2Zvcm1PbiA9IHRyYW5zZm9ybU9uO1xuLy8gdi1iaW5kIHdpdGhvdXQgYXJnIGlzIGhhbmRsZWQgZGlyZWN0bHkgaW4gLi90cmFuc2Zvcm1FbGVtZW50cy50cyBkdWUgdG8gaXQgYWZmZWN0aW5nXG4vLyBjb2RlZ2VuIGZvciB0aGUgZW50aXJlIHByb3BzIG9iamVjdC4gVGhpcyB0cmFuc2Zvcm0gaGVyZSBpcyBvbmx5IGZvciB2LWJpbmRcbi8vICp3aXRoKiBhcmdzLlxuY29uc3QgdHJhbnNmb3JtQmluZCA9IChkaXIsIF9ub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgY29uc3QgeyBleHAsIG1vZGlmaWVycywgbG9jIH0gPSBkaXI7XG4gICAgY29uc3QgYXJnID0gZGlyLmFyZztcbiAgICBpZiAoYXJnLnR5cGUgIT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgIGFyZy5jaGlsZHJlbi51bnNoaWZ0KGAoYCk7XG4gICAgICAgIGFyZy5jaGlsZHJlbi5wdXNoKGApIHx8IFwiXCJgKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWFyZy5pc1N0YXRpYykge1xuICAgICAgICBhcmcuY29udGVudCA9IGAke2FyZy5jb250ZW50fSB8fCBcIlwiYDtcbiAgICB9XG4gICAgLy8gLnN5bmMgaXMgcmVwbGFjZWQgYnkgdi1tb2RlbDphcmdcbiAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdjYW1lbCcpKSB7XG4gICAgICAgIGlmIChhcmcudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgICAgIGlmIChhcmcuaXNTdGF0aWMpIHtcbiAgICAgICAgICAgICAgICBhcmcuY29udGVudCA9ICgwLCBzaGFyZWRfMS5jYW1lbGl6ZSkoYXJnLmNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJnLmNvbnRlbnQgPSBgJHtjb250ZXh0LmhlbHBlclN0cmluZyhDQU1FTElaRSl9KCR7YXJnLmNvbnRlbnR9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhcmcuY2hpbGRyZW4udW5zaGlmdChgJHtjb250ZXh0LmhlbHBlclN0cmluZyhDQU1FTElaRSl9KGApO1xuICAgICAgICAgICAgYXJnLmNoaWxkcmVuLnB1c2goYClgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNvbnRleHQuaW5TU1IpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygncHJvcCcpKSB7XG4gICAgICAgICAgICBpbmplY3RQcmVmaXgoYXJnLCAnLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ2F0dHInKSkge1xuICAgICAgICAgICAgaW5qZWN0UHJlZml4KGFyZywgJ14nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWV4cCB8fFxuICAgICAgICAoZXhwLnR5cGUgPT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovICYmICFleHAuY29udGVudC50cmltKCkpKSB7XG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM0IC8qIEVycm9yQ29kZXMuWF9WX0JJTkRfTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9wczogW2NyZWF0ZU9iamVjdFByb3BlcnR5KGFyZywgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbignJywgdHJ1ZSwgbG9jKSldXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzOiBbY3JlYXRlT2JqZWN0UHJvcGVydHkoYXJnLCBleHApXVxuICAgIH07XG59O1xuZXhwb3J0cy50cmFuc2Zvcm1CaW5kID0gdHJhbnNmb3JtQmluZDtcbmNvbnN0IGluamVjdFByZWZpeCA9IChhcmcsIHByZWZpeCkgPT4ge1xuICAgIGlmIChhcmcudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgaWYgKGFyZy5pc1N0YXRpYykge1xuICAgICAgICAgICAgYXJnLmNvbnRlbnQgPSBwcmVmaXggKyBhcmcuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFyZy5jb250ZW50ID0gYFxcYCR7cHJlZml4fVxcJHske2FyZy5jb250ZW50fX1cXGBgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhcmcuY2hpbGRyZW4udW5zaGlmdChgJyR7cHJlZml4fScgKyAoYCk7XG4gICAgICAgIGFyZy5jaGlsZHJlbi5wdXNoKGApYCk7XG4gICAgfVxufTtcbi8vIE1lcmdlIGFkamFjZW50IHRleHQgbm9kZXMgYW5kIGV4cHJlc3Npb25zIGludG8gYSBzaW5nbGUgZXhwcmVzc2lvblxuLy8gZS5nLiA8ZGl2PmFiYyB7eyBkIH19IHt7IGUgfX08L2Rpdj4gc2hvdWxkIGhhdmUgYSBzaW5nbGUgZXhwcmVzc2lvbiBub2RlIGFzIGNoaWxkLlxuY29uc3QgdHJhbnNmb3JtVGV4dCA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMCAvKiBOb2RlVHlwZXMuUk9PVCAqLyB8fFxuICAgICAgICBub2RlLnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8gfHxcbiAgICAgICAgbm9kZS50eXBlID09PSAxMSAvKiBOb2RlVHlwZXMuRk9SICovIHx8XG4gICAgICAgIG5vZGUudHlwZSA9PT0gMTAgLyogTm9kZVR5cGVzLklGX0JSQU5DSCAqLykge1xuICAgICAgICAvLyBwZXJmb3JtIHRoZSB0cmFuc2Zvcm0gb24gbm9kZSBleGl0IHNvIHRoYXQgYWxsIGV4cHJlc3Npb25zIGhhdmUgYWxyZWFkeVxuICAgICAgICAvLyBiZWVuIHByb2Nlc3NlZC5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Q29udGFpbmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IGhhc1RleHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc1RleHQkMShjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzVGV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gY2hpbGRyZW5bal07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNUZXh0JDEobmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lciA9IGNoaWxkcmVuW2ldID0gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtjaGlsZF0sIGNoaWxkLmxvYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZSBpbnRvIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyLmNoaWxkcmVuLnB1c2goYCArIGAsIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXNUZXh0IHx8XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgd2l0aCBhIHNpbmdsZSB0ZXh0IGNoaWxkLCBsZWF2ZSBpdFxuICAgICAgICAgICAgICAgIC8vIGFzLWlzIHNpbmNlIHRoZSBydW50aW1lIGhhcyBkZWRpY2F0ZWQgZmFzdCBwYXRoIGZvciB0aGlzIGJ5IGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgLy8gc2V0dGluZyB0ZXh0Q29udGVudCBvZiB0aGUgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBmb3IgY29tcG9uZW50IHJvb3QgaXQncyBhbHdheXMgbm9ybWFsaXplZCBhbnl3YXkuXG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAobm9kZS50eXBlID09PSAwIC8qIE5vZGVUeXBlcy5ST09UICovIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAobm9kZS50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50YWdUeXBlID09PSAwIC8qIEVsZW1lbnRUeXBlcy5FTEVNRU5UICovICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIzM3NTZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXN0b20gZGlyZWN0aXZlcyBjYW4gcG90ZW50aWFsbHkgYWRkIERPTSBlbGVtZW50cyBhcmJpdHJhcmlseSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGF2b2lkIHNldHRpbmcgdGV4dENvbnRlbnQgb2YgdGhlIGVsZW1lbnQgYXQgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIGFjY2lkZW50YWxseSBvdmVyd3JpdGluZyB0aGUgRE9NIGVsZW1lbnRzIGFkZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnkgdGhlIHVzZXIgdGhyb3VnaCBjdXN0b20gZGlyZWN0aXZlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhbm9kZS5wcm9wcy5maW5kKHAgPT4gcC50eXBlID09PSA3IC8qIE5vZGVUeXBlcy5ESVJFQ1RJVkUgKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWNvbnRleHQuZGlyZWN0aXZlVHJhbnNmb3Jtc1twLm5hbWVdKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIGNvbXBhdCBtb2RlLCA8dGVtcGxhdGU+IHRhZ3Mgd2l0aCBubyBzcGVjaWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIHJlbmRlcmVkIGFzIGEgZnJhZ21lbnQgc28gaXRzIGNoaWxkcmVuIG11c3QgYmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0ZWQgaW50byB2bm9kZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIShub2RlLnRhZyA9PT0gJ3RlbXBsYXRlJykpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcmUtY29udmVydCB0ZXh0IG5vZGVzIGludG8gY3JlYXRlVGV4dFZOb2RlKHRleHQpIGNhbGxzIHRvIGF2b2lkXG4gICAgICAgICAgICAvLyBydW50aW1lIG5vcm1hbGl6YXRpb24uXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXh0JDEoY2hpbGQpIHx8IGNoaWxkLnR5cGUgPT09IDggLyogTm9kZVR5cGVzLkNPTVBPVU5EX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbEFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlVGV4dFZOb2RlIGRlZmF1bHRzIHRvIHNpbmdsZSB3aGl0ZXNwYWNlLCBzbyBpZiBpdCBpcyBhXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBzcGFjZSB0aGUgY29kZSBjb3VsZCBiZSBhbiBlbXB0eSBjYWxsIHRvIHNhdmUgYnl0ZXMuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSAyIC8qIE5vZGVUeXBlcy5URVhUICovIHx8IGNoaWxkLmNvbnRlbnQgIT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbEFyZ3MucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gbWFyayBkeW5hbWljIHRleHQgd2l0aCBmbGFnIHNvIGl0IGdldHMgcGF0Y2hlZCBpbnNpZGUgYSBibG9ja1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQuc3NyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpID09PSAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsQXJncy5wdXNoKDEgLyogUGF0Y2hGbGFncy5URVhUICovICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYCAvKiAke3NoYXJlZF8xLlBhdGNoRmxhZ05hbWVzWzEgLyogUGF0Y2hGbGFncy5URVhUICovXX0gKi9gIDogYGApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IDEyIC8qIE5vZGVUeXBlcy5URVhUX0NBTEwgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogY2hpbGQubG9jLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZWdlbk5vZGU6IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKENSRUFURV9URVhUKSwgY2FsbEFyZ3MpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn07XG5jb25zdCBzZWVuJDEgPSBuZXcgV2Vha1NldCgpO1xuY29uc3QgdHJhbnNmb3JtT25jZSA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLyAmJiBmaW5kRGlyKG5vZGUsICdvbmNlJywgdHJ1ZSkpIHtcbiAgICAgICAgaWYgKHNlZW4kMS5oYXMobm9kZSkgfHwgY29udGV4dC5pblZPbmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VlbiQxLmFkZChub2RlKTtcbiAgICAgICAgY29udGV4dC5pblZPbmNlID0gdHJ1ZTtcbiAgICAgICAgY29udGV4dC5oZWxwZXIoU0VUX0JMT0NLX1RSQUNLSU5HKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnRleHQuaW5WT25jZSA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgY3VyID0gY29udGV4dC5jdXJyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmIChjdXIuY29kZWdlbk5vZGUpIHtcbiAgICAgICAgICAgICAgICBjdXIuY29kZWdlbk5vZGUgPSBjb250ZXh0LmNhY2hlKGN1ci5jb2RlZ2VuTm9kZSwgdHJ1ZSAvKiBpc1ZOb2RlICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59O1xuY29uc3QgdHJhbnNmb3JtTW9kZWwgPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgY29uc3QgeyBleHAsIGFyZyB9ID0gZGlyO1xuICAgIGlmICghZXhwKSB7XG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQxIC8qIEVycm9yQ29kZXMuWF9WX01PREVMX05PX0VYUFJFU1NJT04gKi8sIGRpci5sb2MpKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRyYW5zZm9ybVByb3BzKCk7XG4gICAgfVxuICAgIGNvbnN0IHJhd0V4cCA9IGV4cC5sb2Muc291cmNlO1xuICAgIGNvbnN0IGV4cFN0cmluZyA9IGV4cC50eXBlID09PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLyA/IGV4cC5jb250ZW50IDogcmF3RXhwO1xuICAgIC8vIGltIFNGQyA8c2NyaXB0IHNldHVwPiBpbmxpbmUgbW9kZSwgdGhlIGV4cCBtYXkgaGF2ZSBiZWVuIHRyYW5zZm9ybWVkIGludG9cbiAgICAvLyBfdW5yZWYoZXhwKVxuICAgIGNvbnN0IGJpbmRpbmdUeXBlID0gY29udGV4dC5iaW5kaW5nTWV0YWRhdGFbcmF3RXhwXTtcbiAgICAvLyBjaGVjayBwcm9wc1xuICAgIGlmIChiaW5kaW5nVHlwZSA9PT0gXCJwcm9wc1wiIC8qIEJpbmRpbmdUeXBlcy5QUk9QUyAqLyB8fFxuICAgICAgICBiaW5kaW5nVHlwZSA9PT0gXCJwcm9wcy1hbGlhc2VkXCIgLyogQmluZGluZ1R5cGVzLlBST1BTX0FMSUFTRUQgKi8pIHtcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDQgLyogRXJyb3JDb2Rlcy5YX1ZfTU9ERUxfT05fUFJPUFMgKi8sIGV4cC5sb2MpKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRyYW5zZm9ybVByb3BzKCk7XG4gICAgfVxuICAgIGNvbnN0IG1heWJlUmVmID0gIXRydWU7XG4gICAgaWYgKCFleHBTdHJpbmcudHJpbSgpIHx8XG4gICAgICAgICghaXNNZW1iZXJFeHByZXNzaW9uKGV4cFN0cmluZykgJiYgIW1heWJlUmVmKSkge1xuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0MiAvKiBFcnJvckNvZGVzLlhfVl9NT0RFTF9NQUxGT1JNRURfRVhQUkVTU0lPTiAqLywgZXhwLmxvYykpO1xuICAgICAgICByZXR1cm4gY3JlYXRlVHJhbnNmb3JtUHJvcHMoKTtcbiAgICB9XG4gICAgY29uc3QgcHJvcE5hbWUgPSBhcmcgPyBhcmcgOiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCdtb2RlbFZhbHVlJywgdHJ1ZSk7XG4gICAgY29uc3QgZXZlbnROYW1lID0gYXJnXG4gICAgICAgID8gaXNTdGF0aWNFeHAoYXJnKVxuICAgICAgICAgICAgPyBgb25VcGRhdGU6JHsoMCwgc2hhcmVkXzEuY2FtZWxpemUpKGFyZy5jb250ZW50KX1gXG4gICAgICAgICAgICA6IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbJ1wib25VcGRhdGU6XCIgKyAnLCBhcmddKVxuICAgICAgICA6IGBvblVwZGF0ZTptb2RlbFZhbHVlYDtcbiAgICBsZXQgYXNzaWdubWVudEV4cDtcbiAgICBjb25zdCBldmVudEFyZyA9IGNvbnRleHQuaXNUUyA/IGAoJGV2ZW50OiBhbnkpYCA6IGAkZXZlbnRgO1xuICAgIHtcbiAgICAgICAgYXNzaWdubWVudEV4cCA9IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbXG4gICAgICAgICAgICBgJHtldmVudEFyZ30gPT4gKChgLFxuICAgICAgICAgICAgZXhwLFxuICAgICAgICAgICAgYCkgPSAkZXZlbnQpYFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY29uc3QgcHJvcHMgPSBbXG4gICAgICAgIC8vIG1vZGVsVmFsdWU6IGZvb1xuICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShwcm9wTmFtZSwgZGlyLmV4cCksXG4gICAgICAgIC8vIFwib25VcGRhdGU6bW9kZWxWYWx1ZVwiOiAkZXZlbnQgPT4gKGZvbyA9ICRldmVudClcbiAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoZXZlbnROYW1lLCBhc3NpZ25tZW50RXhwKVxuICAgIF07XG4gICAgLy8gbW9kZWxNb2RpZmllcnM6IHsgZm9vOiB0cnVlLCBcImJhci1iYXpcIjogdHJ1ZSB9XG4gICAgaWYgKGRpci5tb2RpZmllcnMubGVuZ3RoICYmIG5vZGUudGFnVHlwZSA9PT0gMSAvKiBFbGVtZW50VHlwZXMuQ09NUE9ORU5UICovKSB7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnNcbiAgICAgICAgICAgIC5tYXAobSA9PiAoaXNTaW1wbGVJZGVudGlmaWVyKG0pID8gbSA6IEpTT04uc3RyaW5naWZ5KG0pKSArIGA6IHRydWVgKVxuICAgICAgICAgICAgLmpvaW4oYCwgYCk7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVyc0tleSA9IGFyZ1xuICAgICAgICAgICAgPyBpc1N0YXRpY0V4cChhcmcpXG4gICAgICAgICAgICAgICAgPyBgJHthcmcuY29udGVudH1Nb2RpZmllcnNgXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW2FyZywgJyArIFwiTW9kaWZpZXJzXCInXSlcbiAgICAgICAgICAgIDogYG1vZGVsTW9kaWZpZXJzYDtcbiAgICAgICAgcHJvcHMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShtb2RpZmllcnNLZXksIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHsgJHttb2RpZmllcnN9IH1gLCBmYWxzZSwgZGlyLmxvYywgMiAvKiBDb25zdGFudFR5cGVzLkNBTl9IT0lTVCAqLykpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVRyYW5zZm9ybVByb3BzKHByb3BzKTtcbn07XG5leHBvcnRzLnRyYW5zZm9ybU1vZGVsID0gdHJhbnNmb3JtTW9kZWw7XG5mdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1Qcm9wcyhwcm9wcyA9IFtdKSB7XG4gICAgcmV0dXJuIHsgcHJvcHMgfTtcbn1cbmNvbnN0IHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5jb25zdCB0cmFuc2Zvcm1GaWx0ZXIgPSAobm9kZSwgY29udGV4dCkgPT4ge1xuICAgIGlmICghaXNDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfRklMVEVSXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX0ZJTFRFUlMgKi8sIGNvbnRleHQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gNSAvKiBOb2RlVHlwZXMuSU5URVJQT0xBVElPTiAqLykge1xuICAgICAgICAvLyBmaWx0ZXIgcmV3cml0ZSBpcyBhcHBsaWVkIGJlZm9yZSBleHByZXNzaW9uIHRyYW5zZm9ybSBzbyBvbmx5XG4gICAgICAgIC8vIHNpbXBsZSBleHByZXNzaW9ucyBhcmUgcG9zc2libGUgYXQgdGhpcyBzdGFnZVxuICAgICAgICByZXdyaXRlRmlsdGVyKG5vZGUuY29udGVudCwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8pIHtcbiAgICAgICAgbm9kZS5wcm9wcy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvcC50eXBlID09PSA3IC8qIE5vZGVUeXBlcy5ESVJFQ1RJVkUgKi8gJiZcbiAgICAgICAgICAgICAgICBwcm9wLm5hbWUgIT09ICdmb3InICYmXG4gICAgICAgICAgICAgICAgcHJvcC5leHApIHtcbiAgICAgICAgICAgICAgICByZXdyaXRlRmlsdGVyKHByb3AuZXhwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIHJld3JpdGVGaWx0ZXIobm9kZSwgY29udGV4dCkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgIHBhcnNlRmlsdGVyKG5vZGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICAgICAgICAgIHBhcnNlRmlsdGVyKGNoaWxkLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IDggLyogTm9kZVR5cGVzLkNPTVBPVU5EX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgICAgICAgICByZXdyaXRlRmlsdGVyKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gNSAvKiBOb2RlVHlwZXMuSU5URVJQT0xBVElPTiAqLykge1xuICAgICAgICAgICAgICAgIHJld3JpdGVGaWx0ZXIoY2hpbGQuY29udGVudCwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUZpbHRlcihub2RlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgZXhwID0gbm9kZS5jb250ZW50O1xuICAgIGxldCBpblNpbmdsZSA9IGZhbHNlO1xuICAgIGxldCBpbkRvdWJsZSA9IGZhbHNlO1xuICAgIGxldCBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG4gICAgbGV0IGluUmVnZXggPSBmYWxzZTtcbiAgICBsZXQgY3VybHkgPSAwO1xuICAgIGxldCBzcXVhcmUgPSAwO1xuICAgIGxldCBwYXJlbiA9IDA7XG4gICAgbGV0IGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gICAgbGV0IGMsIHByZXYsIGksIGV4cHJlc3Npb24sIGZpbHRlcnMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByZXYgPSBjO1xuICAgICAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1YylcbiAgICAgICAgICAgICAgICBpblNpbmdsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVjKVxuICAgICAgICAgICAgICAgIGluRG91YmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5UZW1wbGF0ZVN0cmluZykge1xuICAgICAgICAgICAgaWYgKGMgPT09IDB4NjAgJiYgcHJldiAhPT0gMHg1YylcbiAgICAgICAgICAgICAgICBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5SZWdleCkge1xuICAgICAgICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1YylcbiAgICAgICAgICAgICAgICBpblJlZ2V4ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gMHg3YyAmJiAvLyBwaXBlXG4gICAgICAgICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N2MgJiZcbiAgICAgICAgICAgIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3YyAmJlxuICAgICAgICAgICAgIWN1cmx5ICYmXG4gICAgICAgICAgICAhc3F1YXJlICYmXG4gICAgICAgICAgICAhcGFyZW4pIHtcbiAgICAgICAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDB4MjI6XG4gICAgICAgICAgICAgICAgICAgIGluRG91YmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIFwiXG4gICAgICAgICAgICAgICAgY2FzZSAweDI3OlxuICAgICAgICAgICAgICAgICAgICBpblNpbmdsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAnXG4gICAgICAgICAgICAgICAgY2FzZSAweDYwOlxuICAgICAgICAgICAgICAgICAgICBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGBcbiAgICAgICAgICAgICAgICBjYXNlIDB4Mjg6XG4gICAgICAgICAgICAgICAgICAgIHBhcmVuKys7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAoXG4gICAgICAgICAgICAgICAgY2FzZSAweDI5OlxuICAgICAgICAgICAgICAgICAgICBwYXJlbi0tO1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gKVxuICAgICAgICAgICAgICAgIGNhc2UgMHg1YjpcbiAgICAgICAgICAgICAgICAgICAgc3F1YXJlKys7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBbXG4gICAgICAgICAgICAgICAgY2FzZSAweDVkOlxuICAgICAgICAgICAgICAgICAgICBzcXVhcmUtLTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIF1cbiAgICAgICAgICAgICAgICBjYXNlIDB4N2I6XG4gICAgICAgICAgICAgICAgICAgIGN1cmx5Kys7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyB7XG4gICAgICAgICAgICAgICAgY2FzZSAweDdkOlxuICAgICAgICAgICAgICAgICAgICBjdXJseS0tO1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09IDB4MmYpIHtcbiAgICAgICAgICAgICAgICAvLyAvXG4gICAgICAgICAgICAgICAgbGV0IGogPSBpIC0gMTtcbiAgICAgICAgICAgICAgICBsZXQgcDtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuICAgICAgICAgICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICBwID0gZXhwLmNoYXJBdChqKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgIT09ICcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xuICAgICAgICAgICAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEZpbHRlcigpIHtcbiAgICAgICAgZmlsdGVycy5wdXNoKGV4cC5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKSk7XG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgIH1cbiAgICBpZiAoZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICB3YXJuRGVwcmVjYXRpb24oXCJDT01QSUxFUl9GSUxURVJcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfRklMVEVSUyAqLywgY29udGV4dCwgbm9kZS5sb2MpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5jb250ZW50ID0gZXhwcmVzc2lvbjtcbiAgICB9XG59XG5mdW5jdGlvbiB3cmFwRmlsdGVyKGV4cCwgZmlsdGVyLCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5oZWxwZXIoUkVTT0xWRV9GSUxURVIpO1xuICAgIGNvbnN0IGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICAgIGlmIChpIDwgMCkge1xuICAgICAgICBjb250ZXh0LmZpbHRlcnMuYWRkKGZpbHRlcik7XG4gICAgICAgIHJldHVybiBgJHt0b1ZhbGlkQXNzZXRJZChmaWx0ZXIsICdmaWx0ZXInKX0oJHtleHB9KWA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuICAgICAgICBjb25zdCBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgY29udGV4dC5maWx0ZXJzLmFkZChuYW1lKTtcbiAgICAgICAgcmV0dXJuIGAke3RvVmFsaWRBc3NldElkKG5hbWUsICdmaWx0ZXInKX0oJHtleHB9JHthcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJnc31gO1xuICAgIH1cbn1cbmNvbnN0IHNlZW4gPSBuZXcgV2Vha1NldCgpO1xuY29uc3QgdHJhbnNmb3JtTWVtbyA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLykge1xuICAgICAgICBjb25zdCBkaXIgPSBmaW5kRGlyKG5vZGUsICdtZW1vJyk7XG4gICAgICAgIGlmICghZGlyIHx8IHNlZW4uaGFzKG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5hZGQobm9kZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2RlZ2VuTm9kZSA9IG5vZGUuY29kZWdlbk5vZGUgfHxcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnROb2RlLmNvZGVnZW5Ob2RlO1xuICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlICYmIGNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzIC8qIE5vZGVUeXBlcy5WTk9ERV9DQUxMICovKSB7XG4gICAgICAgICAgICAgICAgLy8gbm9uLWNvbXBvbmVudCBzdWIgdHJlZSBzaG91bGQgYmUgdHVybmVkIGludG8gYSBibG9ja1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnRhZ1R5cGUgIT09IDEgLyogRWxlbWVudFR5cGVzLkNPTVBPTkVOVCAqLykge1xuICAgICAgICAgICAgICAgICAgICBtYWtlQmxvY2soY29kZWdlbk5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoV0lUSF9NRU1PKSwgW1xuICAgICAgICAgICAgICAgICAgICBkaXIuZXhwLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24odW5kZWZpbmVkLCBjb2RlZ2VuTm9kZSksXG4gICAgICAgICAgICAgICAgICAgIGBfY2FjaGVgLFxuICAgICAgICAgICAgICAgICAgICBTdHJpbmcoY29udGV4dC5jYWNoZWQrKylcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59O1xuZnVuY3Rpb24gZ2V0QmFzZVRyYW5zZm9ybVByZXNldChwcmVmaXhJZGVudGlmaWVycykge1xuICAgIHJldHVybiBbXG4gICAgICAgIFtcbiAgICAgICAgICAgIHRyYW5zZm9ybU9uY2UsXG4gICAgICAgICAgICB0cmFuc2Zvcm1JZixcbiAgICAgICAgICAgIHRyYW5zZm9ybU1lbW8sXG4gICAgICAgICAgICB0cmFuc2Zvcm1Gb3IsXG4gICAgICAgICAgICAuLi4oW3RyYW5zZm9ybUZpbHRlcl0pLFxuICAgICAgICAgICAgLi4uKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICAgICAgICAgID8gW3RyYW5zZm9ybUV4cHJlc3Npb25dXG4gICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgICAgICB0cmFuc2Zvcm1TbG90T3V0bGV0LFxuICAgICAgICAgICAgdHJhbnNmb3JtRWxlbWVudCxcbiAgICAgICAgICAgIHRyYWNrU2xvdFNjb3BlcyxcbiAgICAgICAgICAgIHRyYW5zZm9ybVRleHRcbiAgICAgICAgXSxcbiAgICAgICAge1xuICAgICAgICAgICAgb246IHRyYW5zZm9ybU9uLFxuICAgICAgICAgICAgYmluZDogdHJhbnNmb3JtQmluZCxcbiAgICAgICAgICAgIG1vZGVsOiB0cmFuc2Zvcm1Nb2RlbFxuICAgICAgICB9XG4gICAgXTtcbn1cbmV4cG9ydHMuZ2V0QmFzZVRyYW5zZm9ybVByZXNldCA9IGdldEJhc2VUcmFuc2Zvcm1QcmVzZXQ7XG4vLyB3ZSBuYW1lIGl0IGBiYXNlQ29tcGlsZWAgc28gdGhhdCBoaWdoZXIgb3JkZXIgY29tcGlsZXJzIGxpa2Vcbi8vIEB2dWUvY29tcGlsZXItZG9tIGNhbiBleHBvcnQgYGNvbXBpbGVgIHdoaWxlIHJlLWV4cG9ydGluZyBldmVyeXRoaW5nIGVsc2UuXG5mdW5jdGlvbiBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgb25FcnJvciA9IG9wdGlvbnMub25FcnJvciB8fCBkZWZhdWx0T25FcnJvcjtcbiAgICBjb25zdCBpc01vZHVsZU1vZGUgPSBvcHRpb25zLm1vZGUgPT09ICdtb2R1bGUnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucHJlZml4SWRlbnRpZmllcnMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0NyAvKiBFcnJvckNvZGVzLlhfUFJFRklYX0lEX05PVF9TVVBQT1JURUQgKi8pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc01vZHVsZU1vZGUpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0OCAvKiBFcnJvckNvZGVzLlhfTU9EVUxFX01PREVfTk9UX1NVUFBPUlRFRCAqLykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHByZWZpeElkZW50aWZpZXJzID0gIXRydWU7XG4gICAgaWYgKG9wdGlvbnMuY2FjaGVIYW5kbGVycykge1xuICAgICAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDkgLyogRXJyb3JDb2Rlcy5YX0NBQ0hFX0hBTkRMRVJfTk9UX1NVUFBPUlRFRCAqLykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zY29wZUlkICYmICFpc01vZHVsZU1vZGUpIHtcbiAgICAgICAgb25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDUwIC8qIEVycm9yQ29kZXMuWF9TQ09QRV9JRF9OT1RfU1VQUE9SVEVEICovKSk7XG4gICAgfVxuICAgIGNvbnN0IGFzdCA9ICgwLCBzaGFyZWRfMS5pc1N0cmluZykodGVtcGxhdGUpID8gYmFzZVBhcnNlKHRlbXBsYXRlLCBvcHRpb25zKSA6IHRlbXBsYXRlO1xuICAgIGNvbnN0IFtub2RlVHJhbnNmb3JtcywgZGlyZWN0aXZlVHJhbnNmb3Jtc10gPSBnZXRCYXNlVHJhbnNmb3JtUHJlc2V0KCk7XG4gICAgdHJhbnNmb3JtKGFzdCwgKDAsIHNoYXJlZF8xLmV4dGVuZCkoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgcHJlZml4SWRlbnRpZmllcnMsXG4gICAgICAgIG5vZGVUcmFuc2Zvcm1zOiBbXG4gICAgICAgICAgICAuLi5ub2RlVHJhbnNmb3JtcyxcbiAgICAgICAgICAgIC4uLihvcHRpb25zLm5vZGVUcmFuc2Zvcm1zIHx8IFtdKSAvLyB1c2VyIHRyYW5zZm9ybXNcbiAgICAgICAgXSxcbiAgICAgICAgZGlyZWN0aXZlVHJhbnNmb3JtczogKDAsIHNoYXJlZF8xLmV4dGVuZCkoe30sIGRpcmVjdGl2ZVRyYW5zZm9ybXMsIG9wdGlvbnMuZGlyZWN0aXZlVHJhbnNmb3JtcyB8fCB7fSAvLyB1c2VyIHRyYW5zZm9ybXNcbiAgICAgICAgKVxuICAgIH0pKTtcbiAgICByZXR1cm4gZ2VuZXJhdGUoYXN0LCAoMCwgc2hhcmVkXzEuZXh0ZW5kKSh7fSwgb3B0aW9ucywge1xuICAgICAgICBwcmVmaXhJZGVudGlmaWVyc1xuICAgIH0pKTtcbn1cbmV4cG9ydHMuYmFzZUNvbXBpbGUgPSBiYXNlQ29tcGlsZTtcbmNvbnN0IG5vb3BEaXJlY3RpdmVUcmFuc2Zvcm0gPSAoKSA9PiAoeyBwcm9wczogW10gfSk7XG5leHBvcnRzLm5vb3BEaXJlY3RpdmVUcmFuc2Zvcm0gPSBub29wRGlyZWN0aXZlVHJhbnNmb3JtO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js\n");

/***/ }),

/***/ "./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.transformStyle = exports.parserOptions = exports.parse = exports.createDOMCompilerError = exports.compile = exports.V_SHOW = exports.V_ON_WITH_MODIFIERS = exports.V_ON_WITH_KEYS = exports.V_MODEL_TEXT = exports.V_MODEL_SELECT = exports.V_MODEL_RADIO = exports.V_MODEL_DYNAMIC = exports.V_MODEL_CHECKBOX = exports.TRANSITION_GROUP = exports.TRANSITION = exports.DOMNodeTransforms = exports.DOMDirectiveTransforms = void 0;\nconst compiler_core_1 = __webpack_require__(/*! @vue/compiler-core */ \"./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js\");\n__exportStar(__webpack_require__(/*! @vue/compiler-core */ \"./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js\"), exports);\nconst shared_1 = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/shared/dist/shared.esm-bundler.js\");\nconst V_MODEL_RADIO = Symbol( true ? `vModelRadio` : 0);\nexports.V_MODEL_RADIO = V_MODEL_RADIO;\nconst V_MODEL_CHECKBOX = Symbol( true ? `vModelCheckbox` : 0);\nexports.V_MODEL_CHECKBOX = V_MODEL_CHECKBOX;\nconst V_MODEL_TEXT = Symbol( true ? `vModelText` : 0);\nexports.V_MODEL_TEXT = V_MODEL_TEXT;\nconst V_MODEL_SELECT = Symbol( true ? `vModelSelect` : 0);\nexports.V_MODEL_SELECT = V_MODEL_SELECT;\nconst V_MODEL_DYNAMIC = Symbol( true ? `vModelDynamic` : 0);\nexports.V_MODEL_DYNAMIC = V_MODEL_DYNAMIC;\nconst V_ON_WITH_MODIFIERS = Symbol( true ? `vOnModifiersGuard` : 0);\nexports.V_ON_WITH_MODIFIERS = V_ON_WITH_MODIFIERS;\nconst V_ON_WITH_KEYS = Symbol( true ? `vOnKeysGuard` : 0);\nexports.V_ON_WITH_KEYS = V_ON_WITH_KEYS;\nconst V_SHOW = Symbol( true ? `vShow` : 0);\nexports.V_SHOW = V_SHOW;\nconst TRANSITION = Symbol( true ? `Transition` : 0);\nexports.TRANSITION = TRANSITION;\nconst TRANSITION_GROUP = Symbol( true ? `TransitionGroup` : 0);\nexports.TRANSITION_GROUP = TRANSITION_GROUP;\n(0, compiler_core_1.registerRuntimeHelpers)({\n  [V_MODEL_RADIO]: `vModelRadio`,\n  [V_MODEL_CHECKBOX]: `vModelCheckbox`,\n  [V_MODEL_TEXT]: `vModelText`,\n  [V_MODEL_SELECT]: `vModelSelect`,\n  [V_MODEL_DYNAMIC]: `vModelDynamic`,\n  [V_ON_WITH_MODIFIERS]: `withModifiers`,\n  [V_ON_WITH_KEYS]: `withKeys`,\n  [V_SHOW]: `vShow`,\n  [TRANSITION]: `Transition`,\n  [TRANSITION_GROUP]: `TransitionGroup`\n});\n/* eslint-disable no-restricted-globals */\nlet decoder;\nfunction decodeHtmlBrowser(raw) {\n  let asAttr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (!decoder) {\n    decoder = document.createElement('div');\n  }\n  if (asAttr) {\n    decoder.innerHTML = `<div foo=\"${raw.replace(/\"/g, '&quot;')}\">`;\n    return decoder.children[0].getAttribute('foo');\n  } else {\n    decoder.innerHTML = raw;\n    return decoder.textContent;\n  }\n}\nconst isRawTextContainer = /*#__PURE__*/(0, shared_1.makeMap)('style,iframe,script,noscript', true);\nconst parserOptions = {\n  isVoidTag: shared_1.isVoidTag,\n  isNativeTag: tag => (0, shared_1.isHTMLTag)(tag) || (0, shared_1.isSVGTag)(tag),\n  isPreTag: tag => tag === 'pre',\n  decodeEntities: decodeHtmlBrowser,\n  isBuiltInComponent: tag => {\n    if ((0, compiler_core_1.isBuiltInType)(tag, `Transition`)) {\n      return TRANSITION;\n    } else if ((0, compiler_core_1.isBuiltInType)(tag, `TransitionGroup`)) {\n      return TRANSITION_GROUP;\n    }\n  },\n  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\n  getNamespace(tag, parent) {\n    let ns = parent ? parent.ns : 0 /* DOMNamespaces.HTML */;\n    if (parent && ns === 2 /* DOMNamespaces.MATH_ML */) {\n      if (parent.tag === 'annotation-xml') {\n        if (tag === 'svg') {\n          return 1 /* DOMNamespaces.SVG */;\n        }\n\n        if (parent.props.some(a => a.type === 6 /* NodeTypes.ATTRIBUTE */ && a.name === 'encoding' && a.value != null && (a.value.content === 'text/html' || a.value.content === 'application/xhtml+xml'))) {\n          ns = 0 /* DOMNamespaces.HTML */;\n        }\n      } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== 'mglyph' && tag !== 'malignmark') {\n        ns = 0 /* DOMNamespaces.HTML */;\n      }\n    } else if (parent && ns === 1 /* DOMNamespaces.SVG */) {\n      if (parent.tag === 'foreignObject' || parent.tag === 'desc' || parent.tag === 'title') {\n        ns = 0 /* DOMNamespaces.HTML */;\n      }\n    }\n\n    if (ns === 0 /* DOMNamespaces.HTML */) {\n      if (tag === 'svg') {\n        return 1 /* DOMNamespaces.SVG */;\n      }\n\n      if (tag === 'math') {\n        return 2 /* DOMNamespaces.MATH_ML */;\n      }\n    }\n\n    return ns;\n  },\n  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments\n  getTextMode(_ref) {\n    let {\n      tag,\n      ns\n    } = _ref;\n    if (ns === 0 /* DOMNamespaces.HTML */) {\n      if (tag === 'textarea' || tag === 'title') {\n        return 1 /* TextModes.RCDATA */;\n      }\n\n      if (isRawTextContainer(tag)) {\n        return 2 /* TextModes.RAWTEXT */;\n      }\n    }\n\n    return 0 /* TextModes.DATA */;\n  }\n};\n\nexports.parserOptions = parserOptions;\n// Parse inline CSS strings for static style attributes into an object.\n// This is a NodeTransform since it works on the static `style` attribute and\n// converts it into a dynamic equivalent:\n// style=\"color: red\" -> :style='{ \"color\": \"red\" }'\n// It is then processed by `transformElement` and included in the generated\n// props.\nconst transformStyle = node => {\n  if (node.type === 1 /* NodeTypes.ELEMENT */) {\n    node.props.forEach((p, i) => {\n      if (p.type === 6 /* NodeTypes.ATTRIBUTE */ && p.name === 'style' && p.value) {\n        // replace p with an expression node\n        node.props[i] = {\n          type: 7 /* NodeTypes.DIRECTIVE */,\n          name: `bind`,\n          arg: (0, compiler_core_1.createSimpleExpression)(`style`, true, p.loc),\n          exp: parseInlineCSS(p.value.content, p.loc),\n          modifiers: [],\n          loc: p.loc\n        };\n      }\n    });\n  }\n};\nexports.transformStyle = transformStyle;\nconst parseInlineCSS = (cssText, loc) => {\n  const normalized = (0, shared_1.parseStringStyle)(cssText);\n  return (0, compiler_core_1.createSimpleExpression)(JSON.stringify(normalized), false, loc, 3 /* ConstantTypes.CAN_STRINGIFY */);\n};\n\nfunction createDOMCompilerError(code, loc) {\n  return (0, compiler_core_1.createCompilerError)(code, loc,  true ? DOMErrorMessages : 0);\n}\nexports.createDOMCompilerError = createDOMCompilerError;\nconst DOMErrorMessages = {\n  [51 /* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,\n  [52 /* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,\n  [53 /* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,\n  [54 /* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,\n  [55 /* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,\n  [56 /* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,\n  [57 /* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,\n  [58 /* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,\n  [59 /* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,\n  [60 /* DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,\n  [61 /* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`\n};\nconst transformVHtml = (dir, node, context) => {\n  const {\n    exp,\n    loc\n  } = dir;\n  if (!exp) {\n    context.onError(createDOMCompilerError(51 /* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */, loc));\n  }\n  if (node.children.length) {\n    context.onError(createDOMCompilerError(52 /* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */, loc));\n    node.children.length = 0;\n  }\n  return {\n    props: [(0, compiler_core_1.createObjectProperty)((0, compiler_core_1.createSimpleExpression)(`innerHTML`, true, loc), exp || (0, compiler_core_1.createSimpleExpression)('', true))]\n  };\n};\nconst transformVText = (dir, node, context) => {\n  const {\n    exp,\n    loc\n  } = dir;\n  if (!exp) {\n    context.onError(createDOMCompilerError(53 /* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */, loc));\n  }\n  if (node.children.length) {\n    context.onError(createDOMCompilerError(54 /* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */, loc));\n    node.children.length = 0;\n  }\n  return {\n    props: [(0, compiler_core_1.createObjectProperty)((0, compiler_core_1.createSimpleExpression)(`textContent`, true), exp ? (0, compiler_core_1.getConstantType)(exp, context) > 0 ? exp : (0, compiler_core_1.createCallExpression)(context.helperString(compiler_core_1.TO_DISPLAY_STRING), [exp], loc) : (0, compiler_core_1.createSimpleExpression)('', true))]\n  };\n};\nconst transformModel = (dir, node, context) => {\n  const baseResult = (0, compiler_core_1.transformModel)(dir, node, context);\n  // base transform has errors OR component v-model (only need props)\n  if (!baseResult.props.length || node.tagType === 1 /* ElementTypes.COMPONENT */) {\n    return baseResult;\n  }\n  if (dir.arg) {\n    context.onError(createDOMCompilerError(56 /* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));\n  }\n  function checkDuplicatedValue() {\n    const value = (0, compiler_core_1.findProp)(node, 'value');\n    if (value) {\n      context.onError(createDOMCompilerError(58 /* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */, value.loc));\n    }\n  }\n  const {\n    tag\n  } = node;\n  const isCustomElement = context.isCustomElement(tag);\n  if (tag === 'input' || tag === 'textarea' || tag === 'select' || isCustomElement) {\n    let directiveToUse = V_MODEL_TEXT;\n    let isInvalidType = false;\n    if (tag === 'input' || isCustomElement) {\n      const type = (0, compiler_core_1.findProp)(node, `type`);\n      if (type) {\n        if (type.type === 7 /* NodeTypes.DIRECTIVE */) {\n          // :type=\"foo\"\n          directiveToUse = V_MODEL_DYNAMIC;\n        } else if (type.value) {\n          switch (type.value.content) {\n            case 'radio':\n              directiveToUse = V_MODEL_RADIO;\n              break;\n            case 'checkbox':\n              directiveToUse = V_MODEL_CHECKBOX;\n              break;\n            case 'file':\n              isInvalidType = true;\n              context.onError(createDOMCompilerError(57 /* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));\n              break;\n            default:\n              // text type\n               true && checkDuplicatedValue();\n              break;\n          }\n        }\n      } else if ((0, compiler_core_1.hasDynamicKeyVBind)(node)) {\n        // element has bindings with dynamic keys, which can possibly contain\n        // \"type\".\n        directiveToUse = V_MODEL_DYNAMIC;\n      } else {\n        // text type\n         true && checkDuplicatedValue();\n      }\n    } else if (tag === 'select') {\n      directiveToUse = V_MODEL_SELECT;\n    } else {\n      // textarea\n       true && checkDuplicatedValue();\n    }\n    // inject runtime directive\n    // by returning the helper symbol via needRuntime\n    // the import will replaced a resolveDirective call.\n    if (!isInvalidType) {\n      baseResult.needRuntime = context.helper(directiveToUse);\n    }\n  } else {\n    context.onError(createDOMCompilerError(55 /* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));\n  }\n  // native vmodel doesn't need the `modelValue` props since they are also\n  // passed to the runtime as `binding.value`. removing it reduces code size.\n  baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ && p.key.content === 'modelValue'));\n  return baseResult;\n};\nconst isEventOptionModifier = /*#__PURE__*/(0, shared_1.makeMap)(`passive,once,capture`);\nconst isNonKeyModifier = /*#__PURE__*/(0, shared_1.makeMap)(\n// event propagation management\n`stop,prevent,self,` +\n// system modifiers + exact\n`ctrl,shift,alt,meta,exact,` +\n// mouse\n`middle`);\n// left & right could be mouse or key modifiers based on event type\nconst maybeKeyModifier = /*#__PURE__*/(0, shared_1.makeMap)('left,right');\nconst isKeyboardEvent = /*#__PURE__*/(0, shared_1.makeMap)(`onkeyup,onkeydown,onkeypress`, true);\nconst resolveModifiers = (key, modifiers, context, loc) => {\n  const keyModifiers = [];\n  const nonKeyModifiers = [];\n  const eventOptionModifiers = [];\n  for (let i = 0; i < modifiers.length; i++) {\n    const modifier = modifiers[i];\n    if (modifier === 'native' && (0, compiler_core_1.checkCompatEnabled)(\"COMPILER_V_ON_NATIVE\" /* CompilerDeprecationTypes.COMPILER_V_ON_NATIVE */, context, loc)) {\n      eventOptionModifiers.push(modifier);\n    } else if (isEventOptionModifier(modifier)) {\n      // eventOptionModifiers: modifiers for addEventListener() options,\n      // e.g. .passive & .capture\n      eventOptionModifiers.push(modifier);\n    } else {\n      // runtimeModifiers: modifiers that needs runtime guards\n      if (maybeKeyModifier(modifier)) {\n        if ((0, compiler_core_1.isStaticExp)(key)) {\n          if (isKeyboardEvent(key.content)) {\n            keyModifiers.push(modifier);\n          } else {\n            nonKeyModifiers.push(modifier);\n          }\n        } else {\n          keyModifiers.push(modifier);\n          nonKeyModifiers.push(modifier);\n        }\n      } else {\n        if (isNonKeyModifier(modifier)) {\n          nonKeyModifiers.push(modifier);\n        } else {\n          keyModifiers.push(modifier);\n        }\n      }\n    }\n  }\n  return {\n    keyModifiers,\n    nonKeyModifiers,\n    eventOptionModifiers\n  };\n};\nconst transformClick = (key, event) => {\n  const isStaticClick = (0, compiler_core_1.isStaticExp)(key) && key.content.toLowerCase() === 'onclick';\n  return isStaticClick ? (0, compiler_core_1.createSimpleExpression)(event, true) : key.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */ ? (0, compiler_core_1.createCompoundExpression)([`(`, key, `) === \"onClick\" ? \"${event}\" : (`, key, `)`]) : key;\n};\nconst transformOn = (dir, node, context) => {\n  return (0, compiler_core_1.transformOn)(dir, node, context, baseResult => {\n    const {\n      modifiers\n    } = dir;\n    if (!modifiers.length) return baseResult;\n    let {\n      key,\n      value: handlerExp\n    } = baseResult.props[0];\n    const {\n      keyModifiers,\n      nonKeyModifiers,\n      eventOptionModifiers\n    } = resolveModifiers(key, modifiers, context, dir.loc);\n    // normalize click.right and click.middle since they don't actually fire\n    if (nonKeyModifiers.includes('right')) {\n      key = transformClick(key, `onContextmenu`);\n    }\n    if (nonKeyModifiers.includes('middle')) {\n      key = transformClick(key, `onMouseup`);\n    }\n    if (nonKeyModifiers.length) {\n      handlerExp = (0, compiler_core_1.createCallExpression)(context.helper(V_ON_WITH_MODIFIERS), [handlerExp, JSON.stringify(nonKeyModifiers)]);\n    }\n    if (keyModifiers.length && (\n    // if event name is dynamic, always wrap with keys guard\n    !(0, compiler_core_1.isStaticExp)(key) || isKeyboardEvent(key.content))) {\n      handlerExp = (0, compiler_core_1.createCallExpression)(context.helper(V_ON_WITH_KEYS), [handlerExp, JSON.stringify(keyModifiers)]);\n    }\n    if (eventOptionModifiers.length) {\n      const modifierPostfix = eventOptionModifiers.map(shared_1.capitalize).join('');\n      key = (0, compiler_core_1.isStaticExp)(key) ? (0, compiler_core_1.createSimpleExpression)(`${key.content}${modifierPostfix}`, true) : (0, compiler_core_1.createCompoundExpression)([`(`, key, `) + \"${modifierPostfix}\"`]);\n    }\n    return {\n      props: [(0, compiler_core_1.createObjectProperty)(key, handlerExp)]\n    };\n  });\n};\nconst transformShow = (dir, node, context) => {\n  const {\n    exp,\n    loc\n  } = dir;\n  if (!exp) {\n    context.onError(createDOMCompilerError(59 /* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */, loc));\n  }\n  return {\n    props: [],\n    needRuntime: context.helper(V_SHOW)\n  };\n};\nconst transformTransition = (node, context) => {\n  if (node.type === 1 /* NodeTypes.ELEMENT */ && node.tagType === 1 /* ElementTypes.COMPONENT */) {\n    const component = context.isBuiltInComponent(node.tag);\n    if (component === TRANSITION) {\n      return () => {\n        if (!node.children.length) {\n          return;\n        }\n        // warn multiple transition children\n        if (hasMultipleChildren(node)) {\n          context.onError(createDOMCompilerError(60 /* DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN */, {\n            start: node.children[0].loc.start,\n            end: node.children[node.children.length - 1].loc.end,\n            source: ''\n          }));\n        }\n        // check if it's s single child w/ v-show\n        // if yes, inject \"persisted: true\" to the transition props\n        const child = node.children[0];\n        if (child.type === 1 /* NodeTypes.ELEMENT */) {\n          for (const p of child.props) {\n            if (p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'show') {\n              node.props.push({\n                type: 6 /* NodeTypes.ATTRIBUTE */,\n                name: 'persisted',\n                value: undefined,\n                loc: node.loc\n              });\n            }\n          }\n        }\n      };\n    }\n  }\n};\nfunction hasMultipleChildren(node) {\n  // #1352 filter out potential comment nodes.\n  const children = node.children = node.children.filter(c => c.type !== 3 /* NodeTypes.COMMENT */ && !(c.type === 2 /* NodeTypes.TEXT */ && !c.content.trim()));\n  const child = children[0];\n  return children.length !== 1 || child.type === 11 /* NodeTypes.FOR */ || child.type === 9 /* NodeTypes.IF */ && child.branches.some(hasMultipleChildren);\n}\nconst ignoreSideEffectTags = (node, context) => {\n  if (node.type === 1 /* NodeTypes.ELEMENT */ && node.tagType === 0 /* ElementTypes.ELEMENT */ && (node.tag === 'script' || node.tag === 'style')) {\n    context.onError(createDOMCompilerError(61 /* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */, node.loc));\n    context.removeNode();\n  }\n};\nconst DOMNodeTransforms = [transformStyle, ...( true ? [transformTransition] : 0)];\nexports.DOMNodeTransforms = DOMNodeTransforms;\nconst DOMDirectiveTransforms = {\n  cloak: compiler_core_1.noopDirectiveTransform,\n  html: transformVHtml,\n  text: transformVText,\n  model: transformModel,\n  on: transformOn,\n  show: transformShow\n};\nexports.DOMDirectiveTransforms = DOMDirectiveTransforms;\nfunction compile(template) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return (0, compiler_core_1.baseCompile)(template, (0, shared_1.extend)({}, parserOptions, options, {\n    nodeTransforms: [\n    // ignore <script> and <tag>\n    // this is not put inside DOMNodeTransforms because that list is used\n    // by compiler-ssr to generate vnode fallback branches\n    ignoreSideEffectTags, ...DOMNodeTransforms, ...(options.nodeTransforms || [])],\n    directiveTransforms: (0, shared_1.extend)({}, DOMDirectiveTransforms, options.directiveTransforms || {}),\n    transformHoist: null\n  }));\n}\nexports.compile = compile;\nfunction parse(template) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return (0, compiler_core_1.baseParse)(template, (0, shared_1.extend)({}, parserOptions, options));\n}\nexports.parse = parse;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS9jb21waWxlci1kb20vZGlzdC9jb21waWxlci1kb20uZXNtLWJ1bmRsZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFiLy4vbm9kZV9tb2R1bGVzL0B2dWUvY29tcGlsZXItZG9tL2Rpc3QvY29tcGlsZXItZG9tLmVzbS1idW5kbGVyLmpzP2VlNTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudHJhbnNmb3JtU3R5bGUgPSBleHBvcnRzLnBhcnNlck9wdGlvbnMgPSBleHBvcnRzLnBhcnNlID0gZXhwb3J0cy5jcmVhdGVET01Db21waWxlckVycm9yID0gZXhwb3J0cy5jb21waWxlID0gZXhwb3J0cy5WX1NIT1cgPSBleHBvcnRzLlZfT05fV0lUSF9NT0RJRklFUlMgPSBleHBvcnRzLlZfT05fV0lUSF9LRVlTID0gZXhwb3J0cy5WX01PREVMX1RFWFQgPSBleHBvcnRzLlZfTU9ERUxfU0VMRUNUID0gZXhwb3J0cy5WX01PREVMX1JBRElPID0gZXhwb3J0cy5WX01PREVMX0RZTkFNSUMgPSBleHBvcnRzLlZfTU9ERUxfQ0hFQ0tCT1ggPSBleHBvcnRzLlRSQU5TSVRJT05fR1JPVVAgPSBleHBvcnRzLlRSQU5TSVRJT04gPSBleHBvcnRzLkRPTU5vZGVUcmFuc2Zvcm1zID0gZXhwb3J0cy5ET01EaXJlY3RpdmVUcmFuc2Zvcm1zID0gdm9pZCAwO1xuY29uc3QgY29tcGlsZXJfY29yZV8xID0gcmVxdWlyZShcIkB2dWUvY29tcGlsZXItY29yZVwiKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiQHZ1ZS9jb21waWxlci1jb3JlXCIpLCBleHBvcnRzKTtcbmNvbnN0IHNoYXJlZF8xID0gcmVxdWlyZShcIkB2dWUvc2hhcmVkXCIpO1xuY29uc3QgVl9NT0RFTF9SQURJTyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsUmFkaW9gIDogYGApO1xuZXhwb3J0cy5WX01PREVMX1JBRElPID0gVl9NT0RFTF9SQURJTztcbmNvbnN0IFZfTU9ERUxfQ0hFQ0tCT1ggPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZNb2RlbENoZWNrYm94YCA6IGBgKTtcbmV4cG9ydHMuVl9NT0RFTF9DSEVDS0JPWCA9IFZfTU9ERUxfQ0hFQ0tCT1g7XG5jb25zdCBWX01PREVMX1RFWFQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZNb2RlbFRleHRgIDogYGApO1xuZXhwb3J0cy5WX01PREVMX1RFWFQgPSBWX01PREVMX1RFWFQ7XG5jb25zdCBWX01PREVMX1NFTEVDVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsU2VsZWN0YCA6IGBgKTtcbmV4cG9ydHMuVl9NT0RFTF9TRUxFQ1QgPSBWX01PREVMX1NFTEVDVDtcbmNvbnN0IFZfTU9ERUxfRFlOQU1JQyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsRHluYW1pY2AgOiBgYCk7XG5leHBvcnRzLlZfTU9ERUxfRFlOQU1JQyA9IFZfTU9ERUxfRFlOQU1JQztcbmNvbnN0IFZfT05fV0lUSF9NT0RJRklFUlMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZPbk1vZGlmaWVyc0d1YXJkYCA6IGBgKTtcbmV4cG9ydHMuVl9PTl9XSVRIX01PRElGSUVSUyA9IFZfT05fV0lUSF9NT0RJRklFUlM7XG5jb25zdCBWX09OX1dJVEhfS0VZUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk9uS2V5c0d1YXJkYCA6IGBgKTtcbmV4cG9ydHMuVl9PTl9XSVRIX0tFWVMgPSBWX09OX1dJVEhfS0VZUztcbmNvbnN0IFZfU0hPVyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdlNob3dgIDogYGApO1xuZXhwb3J0cy5WX1NIT1cgPSBWX1NIT1c7XG5jb25zdCBUUkFOU0lUSU9OID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBUcmFuc2l0aW9uYCA6IGBgKTtcbmV4cG9ydHMuVFJBTlNJVElPTiA9IFRSQU5TSVRJT047XG5jb25zdCBUUkFOU0lUSU9OX0dST1VQID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBUcmFuc2l0aW9uR3JvdXBgIDogYGApO1xuZXhwb3J0cy5UUkFOU0lUSU9OX0dST1VQID0gVFJBTlNJVElPTl9HUk9VUDtcbigwLCBjb21waWxlcl9jb3JlXzEucmVnaXN0ZXJSdW50aW1lSGVscGVycykoe1xuICAgIFtWX01PREVMX1JBRElPXTogYHZNb2RlbFJhZGlvYCxcbiAgICBbVl9NT0RFTF9DSEVDS0JPWF06IGB2TW9kZWxDaGVja2JveGAsXG4gICAgW1ZfTU9ERUxfVEVYVF06IGB2TW9kZWxUZXh0YCxcbiAgICBbVl9NT0RFTF9TRUxFQ1RdOiBgdk1vZGVsU2VsZWN0YCxcbiAgICBbVl9NT0RFTF9EWU5BTUlDXTogYHZNb2RlbER5bmFtaWNgLFxuICAgIFtWX09OX1dJVEhfTU9ESUZJRVJTXTogYHdpdGhNb2RpZmllcnNgLFxuICAgIFtWX09OX1dJVEhfS0VZU106IGB3aXRoS2V5c2AsXG4gICAgW1ZfU0hPV106IGB2U2hvd2AsXG4gICAgW1RSQU5TSVRJT05dOiBgVHJhbnNpdGlvbmAsXG4gICAgW1RSQU5TSVRJT05fR1JPVVBdOiBgVHJhbnNpdGlvbkdyb3VwYFxufSk7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cbmxldCBkZWNvZGVyO1xuZnVuY3Rpb24gZGVjb2RlSHRtbEJyb3dzZXIocmF3LCBhc0F0dHIgPSBmYWxzZSkge1xuICAgIGlmICghZGVjb2Rlcikge1xuICAgICAgICBkZWNvZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgfVxuICAgIGlmIChhc0F0dHIpIHtcbiAgICAgICAgZGVjb2Rlci5pbm5lckhUTUwgPSBgPGRpdiBmb289XCIke3Jhdy5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyl9XCI+YDtcbiAgICAgICAgcmV0dXJuIGRlY29kZXIuY2hpbGRyZW5bMF0uZ2V0QXR0cmlidXRlKCdmb28nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlY29kZXIuaW5uZXJIVE1MID0gcmF3O1xuICAgICAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudDtcbiAgICB9XG59XG5jb25zdCBpc1Jhd1RleHRDb250YWluZXIgPSAvKiNfX1BVUkVfXyovICgwLCBzaGFyZWRfMS5tYWtlTWFwKSgnc3R5bGUsaWZyYW1lLHNjcmlwdCxub3NjcmlwdCcsIHRydWUpO1xuY29uc3QgcGFyc2VyT3B0aW9ucyA9IHtcbiAgICBpc1ZvaWRUYWc6IHNoYXJlZF8xLmlzVm9pZFRhZyxcbiAgICBpc05hdGl2ZVRhZzogdGFnID0+ICgwLCBzaGFyZWRfMS5pc0hUTUxUYWcpKHRhZykgfHwgKDAsIHNoYXJlZF8xLmlzU1ZHVGFnKSh0YWcpLFxuICAgIGlzUHJlVGFnOiB0YWcgPT4gdGFnID09PSAncHJlJyxcbiAgICBkZWNvZGVFbnRpdGllczogZGVjb2RlSHRtbEJyb3dzZXIsXG4gICAgaXNCdWlsdEluQ29tcG9uZW50OiAodGFnKSA9PiB7XG4gICAgICAgIGlmICgoMCwgY29tcGlsZXJfY29yZV8xLmlzQnVpbHRJblR5cGUpKHRhZywgYFRyYW5zaXRpb25gKSkge1xuICAgICAgICAgICAgcmV0dXJuIFRSQU5TSVRJT047XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIGNvbXBpbGVyX2NvcmVfMS5pc0J1aWx0SW5UeXBlKSh0YWcsIGBUcmFuc2l0aW9uR3JvdXBgKSkge1xuICAgICAgICAgICAgcmV0dXJuIFRSQU5TSVRJT05fR1JPVVA7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCN0cmVlLWNvbnN0cnVjdGlvbi1kaXNwYXRjaGVyXG4gICAgZ2V0TmFtZXNwYWNlKHRhZywgcGFyZW50KSB7XG4gICAgICAgIGxldCBucyA9IHBhcmVudCA/IHBhcmVudC5ucyA6IDAgLyogRE9NTmFtZXNwYWNlcy5IVE1MICovO1xuICAgICAgICBpZiAocGFyZW50ICYmIG5zID09PSAyIC8qIERPTU5hbWVzcGFjZXMuTUFUSF9NTCAqLykge1xuICAgICAgICAgICAgaWYgKHBhcmVudC50YWcgPT09ICdhbm5vdGF0aW9uLXhtbCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFnID09PSAnc3ZnJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBET01OYW1lc3BhY2VzLlNWRyAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5wcm9wcy5zb21lKGEgPT4gYS50eXBlID09PSA2IC8qIE5vZGVUeXBlcy5BVFRSSUJVVEUgKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgYS5uYW1lID09PSAnZW5jb2RpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgIGEudmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAoYS52YWx1ZS5jb250ZW50ID09PSAndGV4dC9odG1sJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgYS52YWx1ZS5jb250ZW50ID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5zID0gMCAvKiBET01OYW1lc3BhY2VzLkhUTUwgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoL15tKD86W2lvbnNdfHRleHQpJC8udGVzdChwYXJlbnQudGFnKSAmJlxuICAgICAgICAgICAgICAgIHRhZyAhPT0gJ21nbHlwaCcgJiZcbiAgICAgICAgICAgICAgICB0YWcgIT09ICdtYWxpZ25tYXJrJykge1xuICAgICAgICAgICAgICAgIG5zID0gMCAvKiBET01OYW1lc3BhY2VzLkhUTUwgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyZW50ICYmIG5zID09PSAxIC8qIERPTU5hbWVzcGFjZXMuU1ZHICovKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50LnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgcGFyZW50LnRhZyA9PT0gJ2Rlc2MnIHx8XG4gICAgICAgICAgICAgICAgcGFyZW50LnRhZyA9PT0gJ3RpdGxlJykge1xuICAgICAgICAgICAgICAgIG5zID0gMCAvKiBET01OYW1lc3BhY2VzLkhUTUwgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5zID09PSAwIC8qIERPTU5hbWVzcGFjZXMuSFRNTCAqLykge1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBET01OYW1lc3BhY2VzLlNWRyAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIERPTU5hbWVzcGFjZXMuTUFUSF9NTCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnM7XG4gICAgfSxcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjcGFyc2luZy1odG1sLWZyYWdtZW50c1xuICAgIGdldFRleHRNb2RlKHsgdGFnLCBucyB9KSB7XG4gICAgICAgIGlmIChucyA9PT0gMCAvKiBET01OYW1lc3BhY2VzLkhUTUwgKi8pIHtcbiAgICAgICAgICAgIGlmICh0YWcgPT09ICd0ZXh0YXJlYScgfHwgdGFnID09PSAndGl0bGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogVGV4dE1vZGVzLlJDREFUQSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1Jhd1RleHRDb250YWluZXIodGFnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIFRleHRNb2Rlcy5SQVdURVhUICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIFRleHRNb2Rlcy5EQVRBICovO1xuICAgIH1cbn07XG5leHBvcnRzLnBhcnNlck9wdGlvbnMgPSBwYXJzZXJPcHRpb25zO1xuLy8gUGFyc2UgaW5saW5lIENTUyBzdHJpbmdzIGZvciBzdGF0aWMgc3R5bGUgYXR0cmlidXRlcyBpbnRvIGFuIG9iamVjdC5cbi8vIFRoaXMgaXMgYSBOb2RlVHJhbnNmb3JtIHNpbmNlIGl0IHdvcmtzIG9uIHRoZSBzdGF0aWMgYHN0eWxlYCBhdHRyaWJ1dGUgYW5kXG4vLyBjb252ZXJ0cyBpdCBpbnRvIGEgZHluYW1pYyBlcXVpdmFsZW50OlxuLy8gc3R5bGU9XCJjb2xvcjogcmVkXCIgLT4gOnN0eWxlPSd7IFwiY29sb3JcIjogXCJyZWRcIiB9J1xuLy8gSXQgaXMgdGhlbiBwcm9jZXNzZWQgYnkgYHRyYW5zZm9ybUVsZW1lbnRgIGFuZCBpbmNsdWRlZCBpbiB0aGUgZ2VuZXJhdGVkXG4vLyBwcm9wcy5cbmNvbnN0IHRyYW5zZm9ybVN0eWxlID0gbm9kZSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLykge1xuICAgICAgICBub2RlLnByb3BzLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgICAgICAgIGlmIChwLnR5cGUgPT09IDYgLyogTm9kZVR5cGVzLkFUVFJJQlVURSAqLyAmJiBwLm5hbWUgPT09ICdzdHlsZScgJiYgcC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgcCB3aXRoIGFuIGV4cHJlc3Npb24gbm9kZVxuICAgICAgICAgICAgICAgIG5vZGUucHJvcHNbaV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IDcgLyogTm9kZVR5cGVzLkRJUkVDVElWRSAqLyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogYGJpbmRgLFxuICAgICAgICAgICAgICAgICAgICBhcmc6ICgwLCBjb21waWxlcl9jb3JlXzEuY3JlYXRlU2ltcGxlRXhwcmVzc2lvbikoYHN0eWxlYCwgdHJ1ZSwgcC5sb2MpLFxuICAgICAgICAgICAgICAgICAgICBleHA6IHBhcnNlSW5saW5lQ1NTKHAudmFsdWUuY29udGVudCwgcC5sb2MpLFxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllcnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBsb2M6IHAubG9jXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmV4cG9ydHMudHJhbnNmb3JtU3R5bGUgPSB0cmFuc2Zvcm1TdHlsZTtcbmNvbnN0IHBhcnNlSW5saW5lQ1NTID0gKGNzc1RleHQsIGxvYykgPT4ge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSAoMCwgc2hhcmVkXzEucGFyc2VTdHJpbmdTdHlsZSkoY3NzVGV4dCk7XG4gICAgcmV0dXJuICgwLCBjb21waWxlcl9jb3JlXzEuY3JlYXRlU2ltcGxlRXhwcmVzc2lvbikoSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZCksIGZhbHNlLCBsb2MsIDMgLyogQ29uc3RhbnRUeXBlcy5DQU5fU1RSSU5HSUZZICovKTtcbn07XG5mdW5jdGlvbiBjcmVhdGVET01Db21waWxlckVycm9yKGNvZGUsIGxvYykge1xuICAgIHJldHVybiAoMCwgY29tcGlsZXJfY29yZV8xLmNyZWF0ZUNvbXBpbGVyRXJyb3IpKGNvZGUsIGxvYywgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICF0cnVlID8gRE9NRXJyb3JNZXNzYWdlcyA6IHVuZGVmaW5lZCk7XG59XG5leHBvcnRzLmNyZWF0ZURPTUNvbXBpbGVyRXJyb3IgPSBjcmVhdGVET01Db21waWxlckVycm9yO1xuY29uc3QgRE9NRXJyb3JNZXNzYWdlcyA9IHtcbiAgICBbNTEgLyogRE9NRXJyb3JDb2Rlcy5YX1ZfSFRNTF9OT19FWFBSRVNTSU9OICovXTogYHYtaHRtbCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcbiAgICBbNTIgLyogRE9NRXJyb3JDb2Rlcy5YX1ZfSFRNTF9XSVRIX0NISUxEUkVOICovXTogYHYtaHRtbCB3aWxsIG92ZXJyaWRlIGVsZW1lbnQgY2hpbGRyZW4uYCxcbiAgICBbNTMgLyogRE9NRXJyb3JDb2Rlcy5YX1ZfVEVYVF9OT19FWFBSRVNTSU9OICovXTogYHYtdGV4dCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcbiAgICBbNTQgLyogRE9NRXJyb3JDb2Rlcy5YX1ZfVEVYVF9XSVRIX0NISUxEUkVOICovXTogYHYtdGV4dCB3aWxsIG92ZXJyaWRlIGVsZW1lbnQgY2hpbGRyZW4uYCxcbiAgICBbNTUgLyogRE9NRXJyb3JDb2Rlcy5YX1ZfTU9ERUxfT05fSU5WQUxJRF9FTEVNRU5UICovXTogYHYtbW9kZWwgY2FuIG9ubHkgYmUgdXNlZCBvbiA8aW5wdXQ+LCA8dGV4dGFyZWE+IGFuZCA8c2VsZWN0PiBlbGVtZW50cy5gLFxuICAgIFs1NiAvKiBET01FcnJvckNvZGVzLlhfVl9NT0RFTF9BUkdfT05fRUxFTUVOVCAqL106IGB2LW1vZGVsIGFyZ3VtZW50IGlzIG5vdCBzdXBwb3J0ZWQgb24gcGxhaW4gZWxlbWVudHMuYCxcbiAgICBbNTcgLyogRE9NRXJyb3JDb2Rlcy5YX1ZfTU9ERUxfT05fRklMRV9JTlBVVF9FTEVNRU5UICovXTogYHYtbW9kZWwgY2Fubm90IGJlIHVzZWQgb24gZmlsZSBpbnB1dHMgc2luY2UgdGhleSBhcmUgcmVhZC1vbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLmAsXG4gICAgWzU4IC8qIERPTUVycm9yQ29kZXMuWF9WX01PREVMX1VOTkVDRVNTQVJZX1ZBTFVFICovXTogYFVubmVjZXNzYXJ5IHZhbHVlIGJpbmRpbmcgdXNlZCBhbG9uZ3NpZGUgdi1tb2RlbC4gSXQgd2lsbCBpbnRlcmZlcmUgd2l0aCB2LW1vZGVsJ3MgYmVoYXZpb3IuYCxcbiAgICBbNTkgLyogRE9NRXJyb3JDb2Rlcy5YX1ZfU0hPV19OT19FWFBSRVNTSU9OICovXTogYHYtc2hvdyBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcbiAgICBbNjAgLyogRE9NRXJyb3JDb2Rlcy5YX1RSQU5TSVRJT05fSU5WQUxJRF9DSElMRFJFTiAqL106IGA8VHJhbnNpdGlvbj4gZXhwZWN0cyBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50IG9yIGNvbXBvbmVudC5gLFxuICAgIFs2MSAvKiBET01FcnJvckNvZGVzLlhfSUdOT1JFRF9TSURFX0VGRkVDVF9UQUcgKi9dOiBgVGFncyB3aXRoIHNpZGUgZWZmZWN0ICg8c2NyaXB0PiBhbmQgPHN0eWxlPikgYXJlIGlnbm9yZWQgaW4gY2xpZW50IGNvbXBvbmVudCB0ZW1wbGF0ZXMuYFxufTtcbmNvbnN0IHRyYW5zZm9ybVZIdG1sID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xuICAgIGNvbnN0IHsgZXhwLCBsb2MgfSA9IGRpcjtcbiAgICBpZiAoIWV4cCkge1xuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1MSAvKiBET01FcnJvckNvZGVzLlhfVl9IVE1MX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTIgLyogRE9NRXJyb3JDb2Rlcy5YX1ZfSFRNTF9XSVRIX0NISUxEUkVOICovLCBsb2MpKTtcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczogW1xuICAgICAgICAgICAgKDAsIGNvbXBpbGVyX2NvcmVfMS5jcmVhdGVPYmplY3RQcm9wZXJ0eSkoKDAsIGNvbXBpbGVyX2NvcmVfMS5jcmVhdGVTaW1wbGVFeHByZXNzaW9uKShgaW5uZXJIVE1MYCwgdHJ1ZSwgbG9jKSwgZXhwIHx8ICgwLCBjb21waWxlcl9jb3JlXzEuY3JlYXRlU2ltcGxlRXhwcmVzc2lvbikoJycsIHRydWUpKVxuICAgICAgICBdXG4gICAgfTtcbn07XG5jb25zdCB0cmFuc2Zvcm1WVGV4dCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcbiAgICBjb25zdCB7IGV4cCwgbG9jIH0gPSBkaXI7XG4gICAgaWYgKCFleHApIHtcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTMgLyogRE9NRXJyb3JDb2Rlcy5YX1ZfVEVYVF9OT19FWFBSRVNTSU9OICovLCBsb2MpKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDU0IC8qIERPTUVycm9yQ29kZXMuWF9WX1RFWFRfV0lUSF9DSElMRFJFTiAqLywgbG9jKSk7XG4gICAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IFtcbiAgICAgICAgICAgICgwLCBjb21waWxlcl9jb3JlXzEuY3JlYXRlT2JqZWN0UHJvcGVydHkpKCgwLCBjb21waWxlcl9jb3JlXzEuY3JlYXRlU2ltcGxlRXhwcmVzc2lvbikoYHRleHRDb250ZW50YCwgdHJ1ZSksIGV4cFxuICAgICAgICAgICAgICAgID8gKDAsIGNvbXBpbGVyX2NvcmVfMS5nZXRDb25zdGFudFR5cGUpKGV4cCwgY29udGV4dCkgPiAwXG4gICAgICAgICAgICAgICAgICAgID8gZXhwXG4gICAgICAgICAgICAgICAgICAgIDogKDAsIGNvbXBpbGVyX2NvcmVfMS5jcmVhdGVDYWxsRXhwcmVzc2lvbikoY29udGV4dC5oZWxwZXJTdHJpbmcoY29tcGlsZXJfY29yZV8xLlRPX0RJU1BMQVlfU1RSSU5HKSwgW2V4cF0sIGxvYylcbiAgICAgICAgICAgICAgICA6ICgwLCBjb21waWxlcl9jb3JlXzEuY3JlYXRlU2ltcGxlRXhwcmVzc2lvbikoJycsIHRydWUpKVxuICAgICAgICBdXG4gICAgfTtcbn07XG5jb25zdCB0cmFuc2Zvcm1Nb2RlbCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcbiAgICBjb25zdCBiYXNlUmVzdWx0ID0gKDAsIGNvbXBpbGVyX2NvcmVfMS50cmFuc2Zvcm1Nb2RlbCkoZGlyLCBub2RlLCBjb250ZXh0KTtcbiAgICAvLyBiYXNlIHRyYW5zZm9ybSBoYXMgZXJyb3JzIE9SIGNvbXBvbmVudCB2LW1vZGVsIChvbmx5IG5lZWQgcHJvcHMpXG4gICAgaWYgKCFiYXNlUmVzdWx0LnByb3BzLmxlbmd0aCB8fCBub2RlLnRhZ1R5cGUgPT09IDEgLyogRWxlbWVudFR5cGVzLkNPTVBPTkVOVCAqLykge1xuICAgICAgICByZXR1cm4gYmFzZVJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGRpci5hcmcpIHtcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTYgLyogRE9NRXJyb3JDb2Rlcy5YX1ZfTU9ERUxfQVJHX09OX0VMRU1FTlQgKi8sIGRpci5hcmcubG9jKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrRHVwbGljYXRlZFZhbHVlKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9ICgwLCBjb21waWxlcl9jb3JlXzEuZmluZFByb3ApKG5vZGUsICd2YWx1ZScpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDU4IC8qIERPTUVycm9yQ29kZXMuWF9WX01PREVMX1VOTkVDRVNTQVJZX1ZBTFVFICovLCB2YWx1ZS5sb2MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IHRhZyB9ID0gbm9kZTtcbiAgICBjb25zdCBpc0N1c3RvbUVsZW1lbnQgPSBjb250ZXh0LmlzQ3VzdG9tRWxlbWVudCh0YWcpO1xuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgfHxcbiAgICAgICAgdGFnID09PSAndGV4dGFyZWEnIHx8XG4gICAgICAgIHRhZyA9PT0gJ3NlbGVjdCcgfHxcbiAgICAgICAgaXNDdXN0b21FbGVtZW50KSB7XG4gICAgICAgIGxldCBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfVEVYVDtcbiAgICAgICAgbGV0IGlzSW52YWxpZFR5cGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCBpc0N1c3RvbUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSAoMCwgY29tcGlsZXJfY29yZV8xLmZpbmRQcm9wKShub2RlLCBgdHlwZWApO1xuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS50eXBlID09PSA3IC8qIE5vZGVUeXBlcy5ESVJFQ1RJVkUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gOnR5cGU9XCJmb29cIlxuICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfRFlOQU1JQztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUudmFsdWUuY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmFkaW8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9SQURJTztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfQ0hFQ0tCT1g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmaWxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ludmFsaWRUeXBlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1NyAvKiBET01FcnJvckNvZGVzLlhfVl9NT0RFTF9PTl9GSUxFX0lOUFVUX0VMRU1FTlQgKi8sIGRpci5sb2MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGV4dCB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoZWNrRHVwbGljYXRlZFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoMCwgY29tcGlsZXJfY29yZV8xLmhhc0R5bmFtaWNLZXlWQmluZCkobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGhhcyBiaW5kaW5ncyB3aXRoIGR5bmFtaWMga2V5cywgd2hpY2ggY2FuIHBvc3NpYmx5IGNvbnRhaW5cbiAgICAgICAgICAgICAgICAvLyBcInR5cGVcIi5cbiAgICAgICAgICAgICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfRFlOQU1JQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRleHQgdHlwZVxuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9TRUxFQ1Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0ZXh0YXJlYVxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoZWNrRHVwbGljYXRlZFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5qZWN0IHJ1bnRpbWUgZGlyZWN0aXZlXG4gICAgICAgIC8vIGJ5IHJldHVybmluZyB0aGUgaGVscGVyIHN5bWJvbCB2aWEgbmVlZFJ1bnRpbWVcbiAgICAgICAgLy8gdGhlIGltcG9ydCB3aWxsIHJlcGxhY2VkIGEgcmVzb2x2ZURpcmVjdGl2ZSBjYWxsLlxuICAgICAgICBpZiAoIWlzSW52YWxpZFR5cGUpIHtcbiAgICAgICAgICAgIGJhc2VSZXN1bHQubmVlZFJ1bnRpbWUgPSBjb250ZXh0LmhlbHBlcihkaXJlY3RpdmVUb1VzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDU1IC8qIERPTUVycm9yQ29kZXMuWF9WX01PREVMX09OX0lOVkFMSURfRUxFTUVOVCAqLywgZGlyLmxvYykpO1xuICAgIH1cbiAgICAvLyBuYXRpdmUgdm1vZGVsIGRvZXNuJ3QgbmVlZCB0aGUgYG1vZGVsVmFsdWVgIHByb3BzIHNpbmNlIHRoZXkgYXJlIGFsc29cbiAgICAvLyBwYXNzZWQgdG8gdGhlIHJ1bnRpbWUgYXMgYGJpbmRpbmcudmFsdWVgLiByZW1vdmluZyBpdCByZWR1Y2VzIGNvZGUgc2l6ZS5cbiAgICBiYXNlUmVzdWx0LnByb3BzID0gYmFzZVJlc3VsdC5wcm9wcy5maWx0ZXIocCA9PiAhKHAua2V5LnR5cGUgPT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovICYmXG4gICAgICAgIHAua2V5LmNvbnRlbnQgPT09ICdtb2RlbFZhbHVlJykpO1xuICAgIHJldHVybiBiYXNlUmVzdWx0O1xufTtcbmNvbnN0IGlzRXZlbnRPcHRpb25Nb2RpZmllciA9IC8qI19fUFVSRV9fKi8gKDAsIHNoYXJlZF8xLm1ha2VNYXApKGBwYXNzaXZlLG9uY2UsY2FwdHVyZWApO1xuY29uc3QgaXNOb25LZXlNb2RpZmllciA9IC8qI19fUFVSRV9fKi8gKDAsIHNoYXJlZF8xLm1ha2VNYXApKFxuLy8gZXZlbnQgcHJvcGFnYXRpb24gbWFuYWdlbWVudFxuYHN0b3AscHJldmVudCxzZWxmLGAgK1xuICAgIC8vIHN5c3RlbSBtb2RpZmllcnMgKyBleGFjdFxuICAgIGBjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0LGAgK1xuICAgIC8vIG1vdXNlXG4gICAgYG1pZGRsZWApO1xuLy8gbGVmdCAmIHJpZ2h0IGNvdWxkIGJlIG1vdXNlIG9yIGtleSBtb2RpZmllcnMgYmFzZWQgb24gZXZlbnQgdHlwZVxuY29uc3QgbWF5YmVLZXlNb2RpZmllciA9IC8qI19fUFVSRV9fKi8gKDAsIHNoYXJlZF8xLm1ha2VNYXApKCdsZWZ0LHJpZ2h0Jyk7XG5jb25zdCBpc0tleWJvYXJkRXZlbnQgPSAvKiNfX1BVUkVfXyovICgwLCBzaGFyZWRfMS5tYWtlTWFwKShgb25rZXl1cCxvbmtleWRvd24sb25rZXlwcmVzc2AsIHRydWUpO1xuY29uc3QgcmVzb2x2ZU1vZGlmaWVycyA9IChrZXksIG1vZGlmaWVycywgY29udGV4dCwgbG9jKSA9PiB7XG4gICAgY29uc3Qga2V5TW9kaWZpZXJzID0gW107XG4gICAgY29uc3Qgbm9uS2V5TW9kaWZpZXJzID0gW107XG4gICAgY29uc3QgZXZlbnRPcHRpb25Nb2RpZmllcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBtb2RpZmllciA9IG1vZGlmaWVyc1tpXTtcbiAgICAgICAgaWYgKG1vZGlmaWVyID09PSAnbmF0aXZlJyAmJlxuICAgICAgICAgICAgKDAsIGNvbXBpbGVyX2NvcmVfMS5jaGVja0NvbXBhdEVuYWJsZWQpKFwiQ09NUElMRVJfVl9PTl9OQVRJVkVcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfVl9PTl9OQVRJVkUgKi8sIGNvbnRleHQsIGxvYykpIHtcbiAgICAgICAgICAgIGV2ZW50T3B0aW9uTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRXZlbnRPcHRpb25Nb2RpZmllcihtb2RpZmllcikpIHtcbiAgICAgICAgICAgIC8vIGV2ZW50T3B0aW9uTW9kaWZpZXJzOiBtb2RpZmllcnMgZm9yIGFkZEV2ZW50TGlzdGVuZXIoKSBvcHRpb25zLFxuICAgICAgICAgICAgLy8gZS5nLiAucGFzc2l2ZSAmIC5jYXB0dXJlXG4gICAgICAgICAgICBldmVudE9wdGlvbk1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJ1bnRpbWVNb2RpZmllcnM6IG1vZGlmaWVycyB0aGF0IG5lZWRzIHJ1bnRpbWUgZ3VhcmRzXG4gICAgICAgICAgICBpZiAobWF5YmVLZXlNb2RpZmllcihtb2RpZmllcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGNvbXBpbGVyX2NvcmVfMS5pc1N0YXRpY0V4cCkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNLZXlib2FyZEV2ZW50KGtleS5jb250ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9uS2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBrZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgICAgICAgICAgICAgICAgIG5vbktleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOb25LZXlNb2RpZmllcihtb2RpZmllcikpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uS2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAga2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBrZXlNb2RpZmllcnMsXG4gICAgICAgIG5vbktleU1vZGlmaWVycyxcbiAgICAgICAgZXZlbnRPcHRpb25Nb2RpZmllcnNcbiAgICB9O1xufTtcbmNvbnN0IHRyYW5zZm9ybUNsaWNrID0gKGtleSwgZXZlbnQpID0+IHtcbiAgICBjb25zdCBpc1N0YXRpY0NsaWNrID0gKDAsIGNvbXBpbGVyX2NvcmVfMS5pc1N0YXRpY0V4cCkoa2V5KSAmJiBrZXkuY29udGVudC50b0xvd2VyQ2FzZSgpID09PSAnb25jbGljayc7XG4gICAgcmV0dXJuIGlzU3RhdGljQ2xpY2tcbiAgICAgICAgPyAoMCwgY29tcGlsZXJfY29yZV8xLmNyZWF0ZVNpbXBsZUV4cHJlc3Npb24pKGV2ZW50LCB0cnVlKVxuICAgICAgICA6IGtleS50eXBlICE9PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqL1xuICAgICAgICAgICAgPyAoMCwgY29tcGlsZXJfY29yZV8xLmNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbikoW1xuICAgICAgICAgICAgICAgIGAoYCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgYCkgPT09IFwib25DbGlja1wiID8gXCIke2V2ZW50fVwiIDogKGAsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGApYFxuICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIDoga2V5O1xufTtcbmNvbnN0IHRyYW5zZm9ybU9uID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xuICAgIHJldHVybiAoMCwgY29tcGlsZXJfY29yZV8xLnRyYW5zZm9ybU9uKShkaXIsIG5vZGUsIGNvbnRleHQsIGJhc2VSZXN1bHQgPT4ge1xuICAgICAgICBjb25zdCB7IG1vZGlmaWVycyB9ID0gZGlyO1xuICAgICAgICBpZiAoIW1vZGlmaWVycy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gYmFzZVJlc3VsdDtcbiAgICAgICAgbGV0IHsga2V5LCB2YWx1ZTogaGFuZGxlckV4cCB9ID0gYmFzZVJlc3VsdC5wcm9wc1swXTtcbiAgICAgICAgY29uc3QgeyBrZXlNb2RpZmllcnMsIG5vbktleU1vZGlmaWVycywgZXZlbnRPcHRpb25Nb2RpZmllcnMgfSA9IHJlc29sdmVNb2RpZmllcnMoa2V5LCBtb2RpZmllcnMsIGNvbnRleHQsIGRpci5sb2MpO1xuICAgICAgICAvLyBub3JtYWxpemUgY2xpY2sucmlnaHQgYW5kIGNsaWNrLm1pZGRsZSBzaW5jZSB0aGV5IGRvbid0IGFjdHVhbGx5IGZpcmVcbiAgICAgICAgaWYgKG5vbktleU1vZGlmaWVycy5pbmNsdWRlcygncmlnaHQnKSkge1xuICAgICAgICAgICAga2V5ID0gdHJhbnNmb3JtQ2xpY2soa2V5LCBgb25Db250ZXh0bWVudWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub25LZXlNb2RpZmllcnMuaW5jbHVkZXMoJ21pZGRsZScpKSB7XG4gICAgICAgICAgICBrZXkgPSB0cmFuc2Zvcm1DbGljayhrZXksIGBvbk1vdXNldXBgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uS2V5TW9kaWZpZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgaGFuZGxlckV4cCA9ICgwLCBjb21waWxlcl9jb3JlXzEuY3JlYXRlQ2FsbEV4cHJlc3Npb24pKGNvbnRleHQuaGVscGVyKFZfT05fV0lUSF9NT0RJRklFUlMpLCBbXG4gICAgICAgICAgICAgICAgaGFuZGxlckV4cCxcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShub25LZXlNb2RpZmllcnMpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5TW9kaWZpZXJzLmxlbmd0aCAmJlxuICAgICAgICAgICAgLy8gaWYgZXZlbnQgbmFtZSBpcyBkeW5hbWljLCBhbHdheXMgd3JhcCB3aXRoIGtleXMgZ3VhcmRcbiAgICAgICAgICAgICghKDAsIGNvbXBpbGVyX2NvcmVfMS5pc1N0YXRpY0V4cCkoa2V5KSB8fCBpc0tleWJvYXJkRXZlbnQoa2V5LmNvbnRlbnQpKSkge1xuICAgICAgICAgICAgaGFuZGxlckV4cCA9ICgwLCBjb21waWxlcl9jb3JlXzEuY3JlYXRlQ2FsbEV4cHJlc3Npb24pKGNvbnRleHQuaGVscGVyKFZfT05fV0lUSF9LRVlTKSwgW1xuICAgICAgICAgICAgICAgIGhhbmRsZXJFeHAsXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoa2V5TW9kaWZpZXJzKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50T3B0aW9uTW9kaWZpZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgbW9kaWZpZXJQb3N0Zml4ID0gZXZlbnRPcHRpb25Nb2RpZmllcnMubWFwKHNoYXJlZF8xLmNhcGl0YWxpemUpLmpvaW4oJycpO1xuICAgICAgICAgICAga2V5ID0gKDAsIGNvbXBpbGVyX2NvcmVfMS5pc1N0YXRpY0V4cCkoa2V5KVxuICAgICAgICAgICAgICAgID8gKDAsIGNvbXBpbGVyX2NvcmVfMS5jcmVhdGVTaW1wbGVFeHByZXNzaW9uKShgJHtrZXkuY29udGVudH0ke21vZGlmaWVyUG9zdGZpeH1gLCB0cnVlKVxuICAgICAgICAgICAgICAgIDogKDAsIGNvbXBpbGVyX2NvcmVfMS5jcmVhdGVDb21wb3VuZEV4cHJlc3Npb24pKFtgKGAsIGtleSwgYCkgKyBcIiR7bW9kaWZpZXJQb3N0Zml4fVwiYF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9wczogWygwLCBjb21waWxlcl9jb3JlXzEuY3JlYXRlT2JqZWN0UHJvcGVydHkpKGtleSwgaGFuZGxlckV4cCldXG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuY29uc3QgdHJhbnNmb3JtU2hvdyA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcbiAgICBjb25zdCB7IGV4cCwgbG9jIH0gPSBkaXI7XG4gICAgaWYgKCFleHApIHtcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTkgLyogRE9NRXJyb3JDb2Rlcy5YX1ZfU0hPV19OT19FWFBSRVNTSU9OICovLCBsb2MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IFtdLFxuICAgICAgICBuZWVkUnVudGltZTogY29udGV4dC5oZWxwZXIoVl9TSE9XKVxuICAgIH07XG59O1xuY29uc3QgdHJhbnNmb3JtVHJhbnNpdGlvbiA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLyAmJlxuICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDEgLyogRWxlbWVudFR5cGVzLkNPTVBPTkVOVCAqLykge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBjb250ZXh0LmlzQnVpbHRJbkNvbXBvbmVudChub2RlLnRhZyk7XG4gICAgICAgIGlmIChjb21wb25lbnQgPT09IFRSQU5TSVRJT04pIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHdhcm4gbXVsdGlwbGUgdHJhbnNpdGlvbiBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGlmIChoYXNNdWx0aXBsZUNoaWxkcmVuKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDYwIC8qIERPTUVycm9yQ29kZXMuWF9UUkFOU0lUSU9OX0lOVkFMSURfQ0hJTERSRU4gKi8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBub2RlLmNoaWxkcmVuWzBdLmxvYy5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbm9kZS5jaGlsZHJlbltub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxvYy5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICcnXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgaXQncyBzIHNpbmdsZSBjaGlsZCB3LyB2LXNob3dcbiAgICAgICAgICAgICAgICAvLyBpZiB5ZXMsIGluamVjdCBcInBlcnNpc3RlZDogdHJ1ZVwiIHRvIHRoZSB0cmFuc2l0aW9uIHByb3BzXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiBjaGlsZC5wcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gNyAvKiBOb2RlVHlwZXMuRElSRUNUSVZFICovICYmIHAubmFtZSA9PT0gJ3Nob3cnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wcm9wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogNiAvKiBOb2RlVHlwZXMuQVRUUklCVVRFICovLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncGVyc2lzdGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiBub2RlLmxvY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5mdW5jdGlvbiBoYXNNdWx0aXBsZUNoaWxkcmVuKG5vZGUpIHtcbiAgICAvLyAjMTM1MiBmaWx0ZXIgb3V0IHBvdGVudGlhbCBjb21tZW50IG5vZGVzLlxuICAgIGNvbnN0IGNoaWxkcmVuID0gKG5vZGUuY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLmZpbHRlcihjID0+IGMudHlwZSAhPT0gMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLyAmJlxuICAgICAgICAhKGMudHlwZSA9PT0gMiAvKiBOb2RlVHlwZXMuVEVYVCAqLyAmJiAhYy5jb250ZW50LnRyaW0oKSkpKTtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuICAgIHJldHVybiAoY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgIGNoaWxkLnR5cGUgPT09IDExIC8qIE5vZGVUeXBlcy5GT1IgKi8gfHxcbiAgICAgICAgKGNoaWxkLnR5cGUgPT09IDkgLyogTm9kZVR5cGVzLklGICovICYmIGNoaWxkLmJyYW5jaGVzLnNvbWUoaGFzTXVsdGlwbGVDaGlsZHJlbikpKTtcbn1cbmNvbnN0IGlnbm9yZVNpZGVFZmZlY3RUYWdzID0gKG5vZGUsIGNvbnRleHQpID0+IHtcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovICYmXG4gICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMCAvKiBFbGVtZW50VHlwZXMuRUxFTUVOVCAqLyAmJlxuICAgICAgICAobm9kZS50YWcgPT09ICdzY3JpcHQnIHx8IG5vZGUudGFnID09PSAnc3R5bGUnKSkge1xuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig2MSAvKiBET01FcnJvckNvZGVzLlhfSUdOT1JFRF9TSURFX0VGRkVDVF9UQUcgKi8sIG5vZGUubG9jKSk7XG4gICAgICAgIGNvbnRleHQucmVtb3ZlTm9kZSgpO1xuICAgIH1cbn07XG5jb25zdCBET01Ob2RlVHJhbnNmb3JtcyA9IFtcbiAgICB0cmFuc2Zvcm1TdHlsZSxcbiAgICAuLi4oKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gW3RyYW5zZm9ybVRyYW5zaXRpb25dIDogW10pXG5dO1xuZXhwb3J0cy5ET01Ob2RlVHJhbnNmb3JtcyA9IERPTU5vZGVUcmFuc2Zvcm1zO1xuY29uc3QgRE9NRGlyZWN0aXZlVHJhbnNmb3JtcyA9IHtcbiAgICBjbG9hazogY29tcGlsZXJfY29yZV8xLm5vb3BEaXJlY3RpdmVUcmFuc2Zvcm0sXG4gICAgaHRtbDogdHJhbnNmb3JtVkh0bWwsXG4gICAgdGV4dDogdHJhbnNmb3JtVlRleHQsXG4gICAgbW9kZWw6IHRyYW5zZm9ybU1vZGVsLFxuICAgIG9uOiB0cmFuc2Zvcm1PbixcbiAgICBzaG93OiB0cmFuc2Zvcm1TaG93XG59O1xuZXhwb3J0cy5ET01EaXJlY3RpdmVUcmFuc2Zvcm1zID0gRE9NRGlyZWN0aXZlVHJhbnNmb3JtcztcbmZ1bmN0aW9uIGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiAoMCwgY29tcGlsZXJfY29yZV8xLmJhc2VDb21waWxlKSh0ZW1wbGF0ZSwgKDAsIHNoYXJlZF8xLmV4dGVuZCkoe30sIHBhcnNlck9wdGlvbnMsIG9wdGlvbnMsIHtcbiAgICAgICAgbm9kZVRyYW5zZm9ybXM6IFtcbiAgICAgICAgICAgIC8vIGlnbm9yZSA8c2NyaXB0PiBhbmQgPHRhZz5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHB1dCBpbnNpZGUgRE9NTm9kZVRyYW5zZm9ybXMgYmVjYXVzZSB0aGF0IGxpc3QgaXMgdXNlZFxuICAgICAgICAgICAgLy8gYnkgY29tcGlsZXItc3NyIHRvIGdlbmVyYXRlIHZub2RlIGZhbGxiYWNrIGJyYW5jaGVzXG4gICAgICAgICAgICBpZ25vcmVTaWRlRWZmZWN0VGFncyxcbiAgICAgICAgICAgIC4uLkRPTU5vZGVUcmFuc2Zvcm1zLFxuICAgICAgICAgICAgLi4uKG9wdGlvbnMubm9kZVRyYW5zZm9ybXMgfHwgW10pXG4gICAgICAgIF0sXG4gICAgICAgIGRpcmVjdGl2ZVRyYW5zZm9ybXM6ICgwLCBzaGFyZWRfMS5leHRlbmQpKHt9LCBET01EaXJlY3RpdmVUcmFuc2Zvcm1zLCBvcHRpb25zLmRpcmVjdGl2ZVRyYW5zZm9ybXMgfHwge30pLFxuICAgICAgICB0cmFuc2Zvcm1Ib2lzdDogbnVsbFxuICAgIH0pKTtcbn1cbmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGU7XG5mdW5jdGlvbiBwYXJzZSh0ZW1wbGF0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuICgwLCBjb21waWxlcl9jb3JlXzEuYmFzZVBhcnNlKSh0ZW1wbGF0ZSwgKDAsIHNoYXJlZF8xLmV4dGVuZCkoe30sIHBhcnNlck9wdGlvbnMsIG9wdGlvbnMpKTtcbn1cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js\n");

/***/ }),

/***/ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.unref = exports.triggerRef = exports.trigger = exports.track = exports.toRefs = exports.toRef = exports.toRaw = exports.stop = exports.shallowRef = exports.shallowReadonly = exports.shallowReactive = exports.resetTracking = exports.ref = exports.readonly = exports.reactive = exports.proxyRefs = exports.pauseTracking = exports.onScopeDispose = exports.markRaw = exports.isShallow = exports.isRef = exports.isReadonly = exports.isReactive = exports.isProxy = exports.getCurrentScope = exports.enableTracking = exports.effectScope = exports.effect = exports.deferredComputed = exports.customRef = exports.computed = exports.ReactiveEffect = exports.ITERATE_KEY = exports.EffectScope = void 0;\nconst shared_1 = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/shared/dist/shared.esm-bundler.js\");\nfunction warn(msg) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\nlet activeEffectScope;\nclass EffectScope {\n  constructor() {\n    let detached = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (true) {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    activeEffectScope = this;\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    activeEffectScope = this.parent;\n  }\n  stop(fromParent) {\n    if (this._active) {\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n      }\n      // nested scope, dereference from parent to avoid memory leaks\n      if (!this.detached && this.parent && !fromParent) {\n        // optimized O(1) removal\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = undefined;\n      this._active = false;\n    }\n  }\n}\nexports.EffectScope = EffectScope;\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nexports.effectScope = effectScope;\nfunction recordEffectScope(effect) {\n  let scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : activeEffectScope;\n  if (scope && scope.active) {\n    scope.effects.push(effect);\n  }\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nexports.getCurrentScope = getCurrentScope;\nfunction onScopeDispose(fn) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (true) {\n    warn(`onScopeDispose() is called when there is no active effect scope` + ` to be associated with.`);\n  }\n}\nexports.onScopeDispose = onScopeDispose;\nconst createDep = effects => {\n  const dep = new Set(effects);\n  dep.w = 0;\n  dep.n = 0;\n  return dep;\n};\nconst wasTracked = dep => (dep.w & trackOpBit) > 0;\nconst newTracked = dep => (dep.n & trackOpBit) > 0;\nconst initDepMarkers = _ref => {\n  let {\n    deps\n  } = _ref;\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].w |= trackOpBit; // set was tracked\n    }\n  }\n};\n\nconst finalizeDepMarkers = effect => {\n  const {\n    deps\n  } = effect;\n  if (deps.length) {\n    let ptr = 0;\n    for (let i = 0; i < deps.length; i++) {\n      const dep = deps[i];\n      if (wasTracked(dep) && !newTracked(dep)) {\n        dep.delete(effect);\n      } else {\n        deps[ptr++] = dep;\n      }\n      // clear bits\n      dep.w &= ~trackOpBit;\n      dep.n &= ~trackOpBit;\n    }\n    deps.length = ptr;\n  }\n};\nconst targetMap = new WeakMap();\n// The number of effects currently being tracked recursively.\nlet effectTrackDepth = 0;\nlet trackOpBit = 1;\n/**\n * The bitwise track markers support at most 30 levels of recursion.\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\n * When recursion depth is greater, fall back to using a full cleanup.\n */\nconst maxMarkerBits = 30;\nlet activeEffect;\nconst ITERATE_KEY = Symbol( true ? 'iterate' : 0);\nexports.ITERATE_KEY = ITERATE_KEY;\nconst MAP_KEY_ITERATE_KEY = Symbol( true ? 'Map key iterate' : 0);\nclass ReactiveEffect {\n  constructor(fn) {\n    let scheduler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let scope = arguments.length > 2 ? arguments[2] : undefined;\n    this.fn = fn;\n    this.scheduler = scheduler;\n    this.active = true;\n    this.deps = [];\n    this.parent = undefined;\n    recordEffectScope(this, scope);\n  }\n  run() {\n    if (!this.active) {\n      return this.fn();\n    }\n    let parent = activeEffect;\n    let lastShouldTrack = shouldTrack;\n    while (parent) {\n      if (parent === this) {\n        return;\n      }\n      parent = parent.parent;\n    }\n    try {\n      this.parent = activeEffect;\n      activeEffect = this;\n      shouldTrack = true;\n      trackOpBit = 1 << ++effectTrackDepth;\n      if (effectTrackDepth <= maxMarkerBits) {\n        initDepMarkers(this);\n      } else {\n        cleanupEffect(this);\n      }\n      return this.fn();\n    } finally {\n      if (effectTrackDepth <= maxMarkerBits) {\n        finalizeDepMarkers(this);\n      }\n      trackOpBit = 1 << --effectTrackDepth;\n      activeEffect = this.parent;\n      shouldTrack = lastShouldTrack;\n      this.parent = undefined;\n      if (this.deferStop) {\n        this.stop();\n      }\n    }\n  }\n  stop() {\n    // stopped while running itself - defer the cleanup\n    if (activeEffect === this) {\n      this.deferStop = true;\n    } else if (this.active) {\n      cleanupEffect(this);\n      if (this.onStop) {\n        this.onStop();\n      }\n      this.active = false;\n    }\n  }\n}\nexports.ReactiveEffect = ReactiveEffect;\nfunction cleanupEffect(effect) {\n  const {\n    deps\n  } = effect;\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect);\n    }\n    deps.length = 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect) {\n    fn = fn.effect.fn;\n  }\n  const _effect = new ReactiveEffect(fn);\n  if (options) {\n    (0, shared_1.extend)(_effect, options);\n    if (options.scope) recordEffectScope(_effect, options.scope);\n  }\n  if (!options || !options.lazy) {\n    _effect.run();\n  }\n  const runner = _effect.run.bind(_effect);\n  runner.effect = _effect;\n  return runner;\n}\nexports.effect = effect;\nfunction stop(runner) {\n  runner.effect.stop();\n}\nexports.stop = stop;\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nexports.pauseTracking = pauseTracking;\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nexports.enableTracking = enableTracking;\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === undefined ? true : last;\n}\nexports.resetTracking = resetTracking;\nfunction track(target, type, key) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = createDep());\n    }\n    const eventInfo =  true ? {\n      effect: activeEffect,\n      target,\n      type,\n      key\n    } : 0;\n    trackEffects(dep, eventInfo);\n  }\n}\nexports.track = track;\nfunction trackEffects(dep, debuggerEventExtraInfo) {\n  let shouldTrack = false;\n  if (effectTrackDepth <= maxMarkerBits) {\n    if (!newTracked(dep)) {\n      dep.n |= trackOpBit; // set newly tracked\n      shouldTrack = !wasTracked(dep);\n    }\n  } else {\n    // Full cleanup mode.\n    shouldTrack = !dep.has(activeEffect);\n  }\n  if (shouldTrack) {\n    dep.add(activeEffect);\n    activeEffect.deps.push(dep);\n    if ( true && activeEffect.onTrack) {\n      activeEffect.onTrack(Object.assign({\n        effect: activeEffect\n      }, debuggerEventExtraInfo));\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    // never been tracked\n    return;\n  }\n  let deps = [];\n  if (type === \"clear\" /* TriggerOpTypes.CLEAR */) {\n    // collection being cleared\n    // trigger all effects for target\n    deps = [...depsMap.values()];\n  } else if (key === 'length' && (0, shared_1.isArray)(target)) {\n    const newLength = Number(newValue);\n    depsMap.forEach((dep, key) => {\n      if (key === 'length' || key >= newLength) {\n        deps.push(dep);\n      }\n    });\n  } else {\n    // schedule runs for SET | ADD | DELETE\n    if (key !== void 0) {\n      deps.push(depsMap.get(key));\n    }\n    // also run for iteration key on ADD | DELETE | Map.SET\n    switch (type) {\n      case \"add\" /* TriggerOpTypes.ADD */:\n        if (!(0, shared_1.isArray)(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if ((0, shared_1.isMap)(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if ((0, shared_1.isIntegerKey)(key)) {\n          // new index added to array -> length changes\n          deps.push(depsMap.get('length'));\n        }\n        break;\n      case \"delete\" /* TriggerOpTypes.DELETE */:\n        if (!(0, shared_1.isArray)(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if ((0, shared_1.isMap)(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n        break;\n      case \"set\" /* TriggerOpTypes.SET */:\n        if ((0, shared_1.isMap)(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n        }\n        break;\n    }\n  }\n  const eventInfo =  true ? {\n    target,\n    type,\n    key,\n    newValue,\n    oldValue,\n    oldTarget\n  } : 0;\n  if (deps.length === 1) {\n    if (deps[0]) {\n      if (true) {\n        triggerEffects(deps[0], eventInfo);\n      } else {}\n    }\n  } else {\n    const effects = [];\n    for (const dep of deps) {\n      if (dep) {\n        effects.push(...dep);\n      }\n    }\n    if (true) {\n      triggerEffects(createDep(effects), eventInfo);\n    } else {}\n  }\n}\nexports.trigger = trigger;\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n  // spread into array for stabilization\n  const effects = (0, shared_1.isArray)(dep) ? dep : [...dep];\n  for (const effect of effects) {\n    if (effect.computed) {\n      triggerEffect(effect, debuggerEventExtraInfo);\n    }\n  }\n  for (const effect of effects) {\n    if (!effect.computed) {\n      triggerEffect(effect, debuggerEventExtraInfo);\n    }\n  }\n}\nfunction triggerEffect(effect, debuggerEventExtraInfo) {\n  if (effect !== activeEffect || effect.allowRecurse) {\n    if ( true && effect.onTrigger) {\n      effect.onTrigger((0, shared_1.extend)({\n        effect\n      }, debuggerEventExtraInfo));\n    }\n    if (effect.scheduler) {\n      effect.scheduler();\n    } else {\n      effect.run();\n    }\n  }\n}\nfunction getDepFromReactive(object, key) {\n  var _a;\n  return (_a = targetMap.get(object)) === null || _a === void 0 ? void 0 : _a.get(key);\n}\nconst isNonTrackableKeys = /*#__PURE__*/(0, shared_1.makeMap)(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set( /*#__PURE__*/\nObject.getOwnPropertyNames(Symbol)\n// ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'\n// but accessing them on Symbol leads to TypeError because Symbol is a strict mode\n// function\n.filter(key => key !== 'arguments' && key !== 'caller').map(key => Symbol[key]).filter(shared_1.isSymbol));\nconst get$1 = /*#__PURE__*/createGetter();\nconst shallowGet = /*#__PURE__*/createGetter(false, true);\nconst readonlyGet = /*#__PURE__*/createGetter(true);\nconst shallowReadonlyGet = /*#__PURE__*/createGetter(true, true);\nconst arrayInstrumentations = /*#__PURE__*/createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n  const instrumentations = {};\n  ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\n    instrumentations[key] = function () {\n      const arr = toRaw(this);\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, \"get\" /* TrackOpTypes.GET */, i + '');\n      }\n      // we run the method using the original args first (which may be reactive)\n      for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      const res = arr[key](...args);\n      if (res === -1 || res === false) {\n        // if that didn't work, run it again using raw values.\n        return arr[key](...args.map(toRaw));\n      } else {\n        return res;\n      }\n    };\n  });\n  ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\n    instrumentations[key] = function () {\n      pauseTracking();\n      for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      const res = toRaw(this)[key].apply(this, args);\n      resetTracking();\n      return res;\n    };\n  });\n  return instrumentations;\n}\nfunction hasOwnProperty(key) {\n  const obj = toRaw(this);\n  track(obj, \"has\" /* TrackOpTypes.HAS */, key);\n  return obj.hasOwnProperty(key);\n}\nfunction createGetter() {\n  let isReadonly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  let shallow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return function get(target, key, receiver) {\n    if (key === \"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */) {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */) {\n      return isReadonly;\n    } else if (key === \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */) {\n      return shallow;\n    } else if (key === \"__v_raw\" /* ReactiveFlags.RAW */ && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\n      return target;\n    }\n    const targetIsArray = (0, shared_1.isArray)(target);\n    if (!isReadonly) {\n      if (targetIsArray && (0, shared_1.hasOwn)(arrayInstrumentations, key)) {\n        return Reflect.get(arrayInstrumentations, key, receiver);\n      }\n      if (key === 'hasOwnProperty') {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(target, key, receiver);\n    if ((0, shared_1.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly) {\n      track(target, \"get\" /* TrackOpTypes.GET */, key);\n    }\n    if (shallow) {\n      return res;\n    }\n    if (isRef(res)) {\n      // ref unwrapping - skip unwrap for Array + integer key.\n      return targetIsArray && (0, shared_1.isIntegerKey)(key) ? res : res.value;\n    }\n    if ((0, shared_1.isObject)(res)) {\n      // Convert returned value into a proxy as well. we do the isObject check\n      // here to avoid invalid value warning. Also need to lazy access readonly\n      // and reactive here to avoid circular dependency.\n      return isReadonly ? readonly(res) : reactive(res);\n    }\n    return res;\n  };\n}\nconst set$1 = /*#__PURE__*/createSetter();\nconst shallowSet = /*#__PURE__*/createSetter(true);\nfunction createSetter() {\n  let shallow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return function set(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\n      return false;\n    }\n    if (!shallow) {\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!(0, shared_1.isArray)(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      }\n    }\n    const hadKey = (0, shared_1.isArray)(target) && (0, shared_1.isIntegerKey)(key) ? Number(key) < target.length : (0, shared_1.hasOwn)(target, key);\n    const result = Reflect.set(target, key, value, receiver);\n    // don't trigger if target is something up in the prototype chain of original\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\" /* TriggerOpTypes.ADD */, key, value);\n      } else if ((0, shared_1.hasChanged)(value, oldValue)) {\n        trigger(target, \"set\" /* TriggerOpTypes.SET */, key, value, oldValue);\n      }\n    }\n    return result;\n  };\n}\nfunction deleteProperty(target, key) {\n  const hadKey = (0, shared_1.hasOwn)(target, key);\n  const oldValue = target[key];\n  const result = Reflect.deleteProperty(target, key);\n  if (result && hadKey) {\n    trigger(target, \"delete\" /* TriggerOpTypes.DELETE */, key, undefined, oldValue);\n  }\n  return result;\n}\nfunction has$1(target, key) {\n  const result = Reflect.has(target, key);\n  if (!(0, shared_1.isSymbol)(key) || !builtInSymbols.has(key)) {\n    track(target, \"has\" /* TrackOpTypes.HAS */, key);\n  }\n  return result;\n}\nfunction ownKeys(target) {\n  track(target, \"iterate\" /* TrackOpTypes.ITERATE */, (0, shared_1.isArray)(target) ? 'length' : ITERATE_KEY);\n  return Reflect.ownKeys(target);\n}\nconst mutableHandlers = {\n  get: get$1,\n  set: set$1,\n  deleteProperty,\n  has: has$1,\n  ownKeys\n};\nconst readonlyHandlers = {\n  get: readonlyGet,\n  set(target, key) {\n    if (true) {\n      warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n    return true;\n  },\n  deleteProperty(target, key) {\n    if (true) {\n      warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n    return true;\n  }\n};\nconst shallowReactiveHandlers = /*#__PURE__*/(0, shared_1.extend)({}, mutableHandlers, {\n  get: shallowGet,\n  set: shallowSet\n});\n// Props handlers are special in the sense that it should not unwrap top-level\n// refs (in order to allow refs to be explicitly passed down), but should\n// retain the reactivity of the normal readonly object.\nconst shallowReadonlyHandlers = /*#__PURE__*/(0, shared_1.extend)({}, readonlyHandlers, {\n  get: shallowReadonlyGet\n});\nconst toShallow = value => value;\nconst getProto = v => Reflect.getPrototypeOf(v);\nfunction get(target, key) {\n  let isReadonly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let isShallow = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  // #1772: readonly(reactive(Map)) should return readonly + reactive version\n  // of the value\n  target = target[\"__v_raw\" /* ReactiveFlags.RAW */];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, \"get\" /* TrackOpTypes.GET */, key);\n    }\n    track(rawTarget, \"get\" /* TrackOpTypes.GET */, rawKey);\n  }\n  const {\n    has\n  } = getProto(rawTarget);\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n  if (has.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    // #3602 readonly(reactive(Map))\n    // ensure that the nested reactive `Map` can do tracking for itself\n    target.get(key);\n  }\n}\nfunction has(key) {\n  let isReadonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const target = this[\"__v_raw\" /* ReactiveFlags.RAW */];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, \"has\" /* TrackOpTypes.HAS */, key);\n    }\n    track(rawTarget, \"has\" /* TrackOpTypes.HAS */, rawKey);\n  }\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\nfunction size(target) {\n  let isReadonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  target = target[\"__v_raw\" /* ReactiveFlags.RAW */];\n  !isReadonly && track(toRaw(target), \"iterate\" /* TrackOpTypes.ITERATE */, ITERATE_KEY);\n  return Reflect.get(target, 'size', target);\n}\nfunction add(value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const proto = getProto(target);\n  const hadKey = proto.has.call(target, value);\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, \"add\" /* TriggerOpTypes.ADD */, value, value);\n  }\n  return this;\n}\nfunction set(key, value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const {\n    has,\n    get\n  } = getProto(target);\n  let hadKey = has.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has.call(target, key);\n  } else if (true) {\n    checkIdentityKeys(target, has, key);\n  }\n  const oldValue = get.call(target, key);\n  target.set(key, value);\n  if (!hadKey) {\n    trigger(target, \"add\" /* TriggerOpTypes.ADD */, key, value);\n  } else if ((0, shared_1.hasChanged)(value, oldValue)) {\n    trigger(target, \"set\" /* TriggerOpTypes.SET */, key, value, oldValue);\n  }\n  return this;\n}\nfunction deleteEntry(key) {\n  const target = toRaw(this);\n  const {\n    has,\n    get\n  } = getProto(target);\n  let hadKey = has.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has.call(target, key);\n  } else if (true) {\n    checkIdentityKeys(target, has, key);\n  }\n  const oldValue = get ? get.call(target, key) : undefined;\n  // forward the operation before queueing reactions\n  const result = target.delete(key);\n  if (hadKey) {\n    trigger(target, \"delete\" /* TriggerOpTypes.DELETE */, key, undefined, oldValue);\n  }\n  return result;\n}\nfunction clear() {\n  const target = toRaw(this);\n  const hadItems = target.size !== 0;\n  const oldTarget =  true ? (0, shared_1.isMap)(target) ? new Map(target) : new Set(target) : 0;\n  // forward the operation before queueing reactions\n  const result = target.clear();\n  if (hadItems) {\n    trigger(target, \"clear\" /* TriggerOpTypes.CLEAR */, undefined, undefined, oldTarget);\n  }\n  return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    const observed = this;\n    const target = observed[\"__v_raw\" /* ReactiveFlags.RAW */];\n    const rawTarget = toRaw(target);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\" /* TrackOpTypes.ITERATE */, ITERATE_KEY);\n    return target.forEach((value, key) => {\n      // important: make sure the callback is\n      // 1. invoked with the reactive map as `this` and 3rd arg\n      // 2. the value received should be a corresponding reactive/readonly.\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function () {\n    const target = this[\"__v_raw\" /* ReactiveFlags.RAW */];\n    const rawTarget = toRaw(target);\n    const targetIsMap = (0, shared_1.isMap)(rawTarget);\n    const isPair = method === 'entries' || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === 'keys' && targetIsMap;\n    const innerIterator = target[method](...arguments);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\" /* TrackOpTypes.ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n    // return a wrapped iterator which returns observed versions of the\n    // values emitted from the real iterator\n    return {\n      // iterator protocol\n      next() {\n        const {\n          value,\n          done\n        } = innerIterator.next();\n        return done ? {\n          value,\n          done\n        } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function () {\n    if (true) {\n      const key = (arguments.length <= 0 ? undefined : arguments[0]) ? `on key \"${arguments.length <= 0 ? undefined : arguments[0]}\" ` : ``;\n      console.warn(`${(0, shared_1.capitalize)(type)} operation ${key}failed: target is readonly.`, toRaw(this));\n    }\n    return type === \"delete\" /* TriggerOpTypes.DELETE */ ? false : this;\n  };\n}\nfunction createInstrumentations() {\n  const mutableInstrumentations = {\n    get(key) {\n      return get(this, key);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  const shallowInstrumentations = {\n    get(key) {\n      return get(this, key, false, true);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  const readonlyInstrumentations = {\n    get(key) {\n      return get(this, key, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\" /* TriggerOpTypes.ADD */),\n    set: createReadonlyMethod(\"set\" /* TriggerOpTypes.SET */),\n    delete: createReadonlyMethod(\"delete\" /* TriggerOpTypes.DELETE */),\n    clear: createReadonlyMethod(\"clear\" /* TriggerOpTypes.CLEAR */),\n    forEach: createForEach(true, false)\n  };\n  const shallowReadonlyInstrumentations = {\n    get(key) {\n      return get(this, key, true, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\" /* TriggerOpTypes.ADD */),\n    set: createReadonlyMethod(\"set\" /* TriggerOpTypes.SET */),\n    delete: createReadonlyMethod(\"delete\" /* TriggerOpTypes.DELETE */),\n    clear: createReadonlyMethod(\"clear\" /* TriggerOpTypes.CLEAR */),\n    forEach: createForEach(true, true)\n  };\n  const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\n  iteratorMethods.forEach(method => {\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\n    shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\n  });\n  return [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations];\n}\nconst [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/createInstrumentations();\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */) {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */) {\n      return isReadonly;\n    } else if (key === \"__v_raw\" /* ReactiveFlags.RAW */) {\n      return target;\n    }\n    return Reflect.get((0, shared_1.hasOwn)(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has.call(target, rawKey)) {\n    const type = (0, shared_1.toRawType)(target);\n    console.warn(`Reactive ${type} contains both the raw and reactive ` + `versions of the same object${type === `Map` ? ` as keys` : ``}, ` + `which can lead to inconsistencies. ` + `Avoid differentiating between the raw and reactive versions ` + `of an object and only use the reactive version if possible.`);\n  }\n}\nconst reactiveMap = new WeakMap();\nconst shallowReactiveMap = new WeakMap();\nconst readonlyMap = new WeakMap();\nconst shallowReadonlyMap = new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case 'Object':\n    case 'Array':\n      return 1 /* TargetType.COMMON */;\n    case 'Map':\n    case 'Set':\n    case 'WeakMap':\n    case 'WeakSet':\n      return 2 /* TargetType.COLLECTION */;\n    default:\n      return 0 /* TargetType.INVALID */;\n  }\n}\n\nfunction getTargetType(value) {\n  return value[\"__v_skip\" /* ReactiveFlags.SKIP */] || !Object.isExtensible(value) ? 0 /* TargetType.INVALID */ : targetTypeMap((0, shared_1.toRawType)(value));\n}\nfunction reactive(target) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\nexports.reactive = reactive;\n/**\n * Return a shallowly-reactive copy of the original object, where only the root\n * level properties are reactive. It also does not auto-unwrap refs (even at the\n * root level).\n */\nfunction shallowReactive(target) {\n  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n}\nexports.shallowReactive = shallowReactive;\n/**\n * Creates a readonly copy of the original object. Note the returned copy is not\n * made reactive, but `readonly` can be called on an already reactive object.\n */\nfunction readonly(target) {\n  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\nexports.readonly = readonly;\n/**\n * Returns a reactive-copy of the original object, where only the root level\n * properties are readonly, and does NOT unwrap refs nor recursively convert\n * returned properties.\n * This is used for creating the props proxy object for stateful components.\n */\nfunction shallowReadonly(target) {\n  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n}\nexports.shallowReadonly = shallowReadonly;\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n  if (!(0, shared_1.isObject)(target)) {\n    if (true) {\n      console.warn(`value cannot be made reactive: ${String(target)}`);\n    }\n    return target;\n  }\n  // target is already a Proxy, return it.\n  // exception: calling readonly() on a reactive object\n  if (target[\"__v_raw\" /* ReactiveFlags.RAW */] && !(isReadonly && target[\"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */])) {\n    return target;\n  }\n  // target already has corresponding Proxy\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  // only specific value types can be observed.\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* TargetType.INVALID */) {\n    return target;\n  }\n  const proxy = new Proxy(target, targetType === 2 /* TargetType.COLLECTION */ ? collectionHandlers : baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\" /* ReactiveFlags.RAW */]);\n  }\n\n  return !!(value && value[\"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */]);\n}\n\nexports.isReactive = isReactive;\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */]);\n}\n\nexports.isReadonly = isReadonly;\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */]);\n}\n\nexports.isShallow = isShallow;\nfunction isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\nexports.isProxy = isProxy;\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\" /* ReactiveFlags.RAW */];\n  return raw ? toRaw(raw) : observed;\n}\nexports.toRaw = toRaw;\nfunction markRaw(value) {\n  (0, shared_1.def)(value, \"__v_skip\" /* ReactiveFlags.SKIP */, true);\n  return value;\n}\nexports.markRaw = markRaw;\nconst toReactive = value => (0, shared_1.isObject)(value) ? reactive(value) : value;\nconst toReadonly = value => (0, shared_1.isObject)(value) ? readonly(value) : value;\nfunction trackRefValue(ref) {\n  if (shouldTrack && activeEffect) {\n    ref = toRaw(ref);\n    if (true) {\n      trackEffects(ref.dep || (ref.dep = createDep()), {\n        target: ref,\n        type: \"get\" /* TrackOpTypes.GET */,\n        key: 'value'\n      });\n    } else {}\n  }\n}\nfunction triggerRefValue(ref, newVal) {\n  ref = toRaw(ref);\n  const dep = ref.dep;\n  if (dep) {\n    if (true) {\n      triggerEffects(dep, {\n        target: ref,\n        type: \"set\" /* TriggerOpTypes.SET */,\n        key: 'value',\n        newValue: newVal\n      });\n    } else {}\n  }\n}\nfunction isRef(r) {\n  return !!(r && r.__v_isRef === true);\n}\nexports.isRef = isRef;\nfunction ref(value) {\n  return createRef(value, false);\n}\nexports.ref = ref;\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nexports.shallowRef = shallowRef;\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, __v_isShallow) {\n    this.__v_isShallow = __v_isShallow;\n    this.dep = undefined;\n    this.__v_isRef = true;\n    this._rawValue = __v_isShallow ? value : toRaw(value);\n    this._value = __v_isShallow ? value : toReactive(value);\n  }\n  get value() {\n    trackRefValue(this);\n    return this._value;\n  }\n  set value(newVal) {\n    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n    newVal = useDirectValue ? newVal : toRaw(newVal);\n    if ((0, shared_1.hasChanged)(newVal, this._rawValue)) {\n      this._rawValue = newVal;\n      this._value = useDirectValue ? newVal : toReactive(newVal);\n      triggerRefValue(this, newVal);\n    }\n  }\n}\nfunction triggerRef(ref) {\n  triggerRefValue(ref,  true ? ref.value : 0);\n}\nexports.triggerRef = triggerRef;\nfunction unref(ref) {\n  return isRef(ref) ? ref.value : ref;\n}\nexports.unref = unref;\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nexports.proxyRefs = proxyRefs;\nclass CustomRefImpl {\n  constructor(factory) {\n    this.dep = undefined;\n    this.__v_isRef = true;\n    const {\n      get,\n      set\n    } = factory(() => trackRefValue(this), () => triggerRefValue(this));\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nexports.customRef = customRef;\nfunction toRefs(object) {\n  if ( true && !isProxy(object)) {\n    console.warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n  const ret = (0, shared_1.isArray)(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = toRef(object, key);\n  }\n  return ret;\n}\nexports.toRefs = toRefs;\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this.__v_isRef = true;\n  }\n  get value() {\n    const val = this._object[this._key];\n    return val === undefined ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(toRaw(this._object), this._key);\n  }\n}\nfunction toRef(object, key, defaultValue) {\n  const val = object[key];\n  return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);\n}\nexports.toRef = toRef;\nvar _a$1;\nclass ComputedRefImpl {\n  constructor(getter, _setter, isReadonly, isSSR) {\n    this._setter = _setter;\n    this.dep = undefined;\n    this.__v_isRef = true;\n    this[_a$1] = false;\n    this._dirty = true;\n    this.effect = new ReactiveEffect(getter, () => {\n      if (!this._dirty) {\n        this._dirty = true;\n        triggerRefValue(this);\n      }\n    });\n    this.effect.computed = this;\n    this.effect.active = this._cacheable = !isSSR;\n    this[\"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */] = isReadonly;\n  }\n  get value() {\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n    const self = toRaw(this);\n    trackRefValue(self);\n    if (self._dirty || !self._cacheable) {\n      self._dirty = false;\n      self._value = self.effect.run();\n    }\n    return self._value;\n  }\n  set value(newValue) {\n    this._setter(newValue);\n  }\n}\n_a$1 = \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */;\nfunction computed(getterOrOptions, debugOptions) {\n  let isSSR = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let getter;\n  let setter;\n  const onlyGetter = (0, shared_1.isFunction)(getterOrOptions);\n  if (onlyGetter) {\n    getter = getterOrOptions;\n    setter =  true ? () => {\n      console.warn('Write operation failed: computed value is readonly');\n    } : 0;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n  if ( true && debugOptions && !isSSR) {\n    cRef.effect.onTrack = debugOptions.onTrack;\n    cRef.effect.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\nexports.computed = computed;\nvar _a;\nconst tick = /*#__PURE__*/Promise.resolve();\nconst queue = [];\nlet queued = false;\nconst scheduler = fn => {\n  queue.push(fn);\n  if (!queued) {\n    queued = true;\n    tick.then(flush);\n  }\n};\nconst flush = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n  queue.length = 0;\n  queued = false;\n};\nclass DeferredComputedRefImpl {\n  constructor(getter) {\n    this.dep = undefined;\n    this._dirty = true;\n    this.__v_isRef = true;\n    this[_a] = true;\n    let compareTarget;\n    let hasCompareTarget = false;\n    let scheduled = false;\n    this.effect = new ReactiveEffect(getter, computedTrigger => {\n      if (this.dep) {\n        if (computedTrigger) {\n          compareTarget = this._value;\n          hasCompareTarget = true;\n        } else if (!scheduled) {\n          const valueToCompare = hasCompareTarget ? compareTarget : this._value;\n          scheduled = true;\n          hasCompareTarget = false;\n          scheduler(() => {\n            if (this.effect.active && this._get() !== valueToCompare) {\n              triggerRefValue(this);\n            }\n            scheduled = false;\n          });\n        }\n        // chained upstream computeds are notified synchronously to ensure\n        // value invalidation in case of sync access; normal effects are\n        // deferred to be triggered in scheduler.\n        for (const e of this.dep) {\n          if (e.computed instanceof DeferredComputedRefImpl) {\n            e.scheduler(true /* computedTrigger */);\n          }\n        }\n      }\n\n      this._dirty = true;\n    });\n    this.effect.computed = this;\n  }\n  _get() {\n    if (this._dirty) {\n      this._dirty = false;\n      return this._value = this.effect.run();\n    }\n    return this._value;\n  }\n  get value() {\n    trackRefValue(this);\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n    return toRaw(this)._get();\n  }\n}\n_a = \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */;\nfunction deferredComputed(getter) {\n  return new DeferredComputedRefImpl(getter);\n}\nexports.deferredComputed = deferredComputed;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L2Rpc3QvcmVhY3Rpdml0eS5lc20tYnVuZGxlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUxBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQURBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7O0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhYi8uL25vZGVfbW9kdWxlcy9AdnVlL3JlYWN0aXZpdHkvZGlzdC9yZWFjdGl2aXR5LmVzbS1idW5kbGVyLmpzP2ExZTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVucmVmID0gZXhwb3J0cy50cmlnZ2VyUmVmID0gZXhwb3J0cy50cmlnZ2VyID0gZXhwb3J0cy50cmFjayA9IGV4cG9ydHMudG9SZWZzID0gZXhwb3J0cy50b1JlZiA9IGV4cG9ydHMudG9SYXcgPSBleHBvcnRzLnN0b3AgPSBleHBvcnRzLnNoYWxsb3dSZWYgPSBleHBvcnRzLnNoYWxsb3dSZWFkb25seSA9IGV4cG9ydHMuc2hhbGxvd1JlYWN0aXZlID0gZXhwb3J0cy5yZXNldFRyYWNraW5nID0gZXhwb3J0cy5yZWYgPSBleHBvcnRzLnJlYWRvbmx5ID0gZXhwb3J0cy5yZWFjdGl2ZSA9IGV4cG9ydHMucHJveHlSZWZzID0gZXhwb3J0cy5wYXVzZVRyYWNraW5nID0gZXhwb3J0cy5vblNjb3BlRGlzcG9zZSA9IGV4cG9ydHMubWFya1JhdyA9IGV4cG9ydHMuaXNTaGFsbG93ID0gZXhwb3J0cy5pc1JlZiA9IGV4cG9ydHMuaXNSZWFkb25seSA9IGV4cG9ydHMuaXNSZWFjdGl2ZSA9IGV4cG9ydHMuaXNQcm94eSA9IGV4cG9ydHMuZ2V0Q3VycmVudFNjb3BlID0gZXhwb3J0cy5lbmFibGVUcmFja2luZyA9IGV4cG9ydHMuZWZmZWN0U2NvcGUgPSBleHBvcnRzLmVmZmVjdCA9IGV4cG9ydHMuZGVmZXJyZWRDb21wdXRlZCA9IGV4cG9ydHMuY3VzdG9tUmVmID0gZXhwb3J0cy5jb21wdXRlZCA9IGV4cG9ydHMuUmVhY3RpdmVFZmZlY3QgPSBleHBvcnRzLklURVJBVEVfS0VZID0gZXhwb3J0cy5FZmZlY3RTY29wZSA9IHZvaWQgMDtcbmNvbnN0IHNoYXJlZF8xID0gcmVxdWlyZShcIkB2dWUvc2hhcmVkXCIpO1xuZnVuY3Rpb24gd2Fybihtc2csIC4uLmFyZ3MpIHtcbiAgICBjb25zb2xlLndhcm4oYFtWdWUgd2Fybl0gJHttc2d9YCwgLi4uYXJncyk7XG59XG5sZXQgYWN0aXZlRWZmZWN0U2NvcGU7XG5jbGFzcyBFZmZlY3RTY29wZSB7XG4gICAgY29uc3RydWN0b3IoZGV0YWNoZWQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmRldGFjaGVkID0gZGV0YWNoZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWZmZWN0cyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsZWFudXBzID0gW107XG4gICAgICAgIHRoaXMucGFyZW50ID0gYWN0aXZlRWZmZWN0U2NvcGU7XG4gICAgICAgIGlmICghZGV0YWNoZWQgJiYgYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPVxuICAgICAgICAgICAgICAgIChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgfHwgKGFjdGl2ZUVmZmVjdFNjb3BlLnNjb3BlcyA9IFtdKSkucHVzaCh0aGlzKSAtIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9XG4gICAgcnVuKGZuKSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRFZmZlY3RTY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IGN1cnJlbnRFZmZlY3RTY29wZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIHdhcm4oYGNhbm5vdCBydW4gYW4gaW5hY3RpdmUgZWZmZWN0IHNjb3BlLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIG5vbi1kZXRhY2hlZCBzY29wZXNcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBvbigpIHtcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgb2ZmKCkge1xuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXMucGFyZW50O1xuICAgIH1cbiAgICBzdG9wKGZyb21QYXJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgICAgICAgbGV0IGksIGw7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZmZlY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZWZmZWN0c1tpXS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jbGVhbnVwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXBzW2ldKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zY29wZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5zY29wZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NvcGVzW2ldLnN0b3AodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbmVzdGVkIHNjb3BlLCBkZXJlZmVyZW5jZSBmcm9tIHBhcmVudCB0byBhdm9pZCBtZW1vcnkgbGVha3NcbiAgICAgICAgICAgIGlmICghdGhpcy5kZXRhY2hlZCAmJiB0aGlzLnBhcmVudCAmJiAhZnJvbVBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIG9wdGltaXplZCBPKDEpIHJlbW92YWxcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy5wYXJlbnQuc2NvcGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0ICYmIGxhc3QgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuc2NvcGVzW3RoaXMuaW5kZXhdID0gbGFzdDtcbiAgICAgICAgICAgICAgICAgICAgbGFzdC5pbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRWZmZWN0U2NvcGUgPSBFZmZlY3RTY29wZTtcbmZ1bmN0aW9uIGVmZmVjdFNjb3BlKGRldGFjaGVkKSB7XG4gICAgcmV0dXJuIG5ldyBFZmZlY3RTY29wZShkZXRhY2hlZCk7XG59XG5leHBvcnRzLmVmZmVjdFNjb3BlID0gZWZmZWN0U2NvcGU7XG5mdW5jdGlvbiByZWNvcmRFZmZlY3RTY29wZShlZmZlY3QsIHNjb3BlID0gYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgICBpZiAoc2NvcGUgJiYgc2NvcGUuYWN0aXZlKSB7XG4gICAgICAgIHNjb3BlLmVmZmVjdHMucHVzaChlZmZlY3QpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRTY29wZSgpIHtcbiAgICByZXR1cm4gYWN0aXZlRWZmZWN0U2NvcGU7XG59XG5leHBvcnRzLmdldEN1cnJlbnRTY29wZSA9IGdldEN1cnJlbnRTY29wZTtcbmZ1bmN0aW9uIG9uU2NvcGVEaXNwb3NlKGZuKSB7XG4gICAgaWYgKGFjdGl2ZUVmZmVjdFNjb3BlKSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlLmNsZWFudXBzLnB1c2goZm4pO1xuICAgIH1cbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgd2Fybihgb25TY29wZURpc3Bvc2UoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgZWZmZWN0IHNjb3BlYCArXG4gICAgICAgICAgICBgIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5gKTtcbiAgICB9XG59XG5leHBvcnRzLm9uU2NvcGVEaXNwb3NlID0gb25TY29wZURpc3Bvc2U7XG5jb25zdCBjcmVhdGVEZXAgPSAoZWZmZWN0cykgPT4ge1xuICAgIGNvbnN0IGRlcCA9IG5ldyBTZXQoZWZmZWN0cyk7XG4gICAgZGVwLncgPSAwO1xuICAgIGRlcC5uID0gMDtcbiAgICByZXR1cm4gZGVwO1xufTtcbmNvbnN0IHdhc1RyYWNrZWQgPSAoZGVwKSA9PiAoZGVwLncgJiB0cmFja09wQml0KSA+IDA7XG5jb25zdCBuZXdUcmFja2VkID0gKGRlcCkgPT4gKGRlcC5uICYgdHJhY2tPcEJpdCkgPiAwO1xuY29uc3QgaW5pdERlcE1hcmtlcnMgPSAoeyBkZXBzIH0pID0+IHtcbiAgICBpZiAoZGVwcy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkZXBzW2ldLncgfD0gdHJhY2tPcEJpdDsgLy8gc2V0IHdhcyB0cmFja2VkXG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgZmluYWxpemVEZXBNYXJrZXJzID0gKGVmZmVjdCkgPT4ge1xuICAgIGNvbnN0IHsgZGVwcyB9ID0gZWZmZWN0O1xuICAgIGlmIChkZXBzLmxlbmd0aCkge1xuICAgICAgICBsZXQgcHRyID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkZXAgPSBkZXBzW2ldO1xuICAgICAgICAgICAgaWYgKHdhc1RyYWNrZWQoZGVwKSAmJiAhbmV3VHJhY2tlZChkZXApKSB7XG4gICAgICAgICAgICAgICAgZGVwLmRlbGV0ZShlZmZlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVwc1twdHIrK10gPSBkZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjbGVhciBiaXRzXG4gICAgICAgICAgICBkZXAudyAmPSB+dHJhY2tPcEJpdDtcbiAgICAgICAgICAgIGRlcC5uICY9IH50cmFja09wQml0O1xuICAgICAgICB9XG4gICAgICAgIGRlcHMubGVuZ3RoID0gcHRyO1xuICAgIH1cbn07XG5jb25zdCB0YXJnZXRNYXAgPSBuZXcgV2Vha01hcCgpO1xuLy8gVGhlIG51bWJlciBvZiBlZmZlY3RzIGN1cnJlbnRseSBiZWluZyB0cmFja2VkIHJlY3Vyc2l2ZWx5LlxubGV0IGVmZmVjdFRyYWNrRGVwdGggPSAwO1xubGV0IHRyYWNrT3BCaXQgPSAxO1xuLyoqXG4gKiBUaGUgYml0d2lzZSB0cmFjayBtYXJrZXJzIHN1cHBvcnQgYXQgbW9zdCAzMCBsZXZlbHMgb2YgcmVjdXJzaW9uLlxuICogVGhpcyB2YWx1ZSBpcyBjaG9zZW4gdG8gZW5hYmxlIG1vZGVybiBKUyBlbmdpbmVzIHRvIHVzZSBhIFNNSSBvbiBhbGwgcGxhdGZvcm1zLlxuICogV2hlbiByZWN1cnNpb24gZGVwdGggaXMgZ3JlYXRlciwgZmFsbCBiYWNrIHRvIHVzaW5nIGEgZnVsbCBjbGVhbnVwLlxuICovXG5jb25zdCBtYXhNYXJrZXJCaXRzID0gMzA7XG5sZXQgYWN0aXZlRWZmZWN0O1xuY29uc3QgSVRFUkFURV9LRVkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ2l0ZXJhdGUnIDogJycpO1xuZXhwb3J0cy5JVEVSQVRFX0tFWSA9IElURVJBVEVfS0VZO1xuY29uc3QgTUFQX0tFWV9JVEVSQVRFX0tFWSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnTWFwIGtleSBpdGVyYXRlJyA6ICcnKTtcbmNsYXNzIFJlYWN0aXZlRWZmZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihmbiwgc2NoZWR1bGVyID0gbnVsbCwgc2NvcGUpIHtcbiAgICAgICAgdGhpcy5mbiA9IGZuO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlcHMgPSBbXTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJlY29yZEVmZmVjdFNjb3BlKHRoaXMsIHNjb3BlKTtcbiAgICB9XG4gICAgcnVuKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbigpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJlbnQgPSBhY3RpdmVFZmZlY3Q7XG4gICAgICAgIGxldCBsYXN0U2hvdWxkVHJhY2sgPSBzaG91bGRUcmFjaztcbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gYWN0aXZlRWZmZWN0O1xuICAgICAgICAgICAgYWN0aXZlRWZmZWN0ID0gdGhpcztcbiAgICAgICAgICAgIHNob3VsZFRyYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyYWNrT3BCaXQgPSAxIDw8ICsrZWZmZWN0VHJhY2tEZXB0aDtcbiAgICAgICAgICAgIGlmIChlZmZlY3RUcmFja0RlcHRoIDw9IG1heE1hcmtlckJpdHMpIHtcbiAgICAgICAgICAgICAgICBpbml0RGVwTWFya2Vycyh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbigpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGVmZmVjdFRyYWNrRGVwdGggPD0gbWF4TWFya2VyQml0cykge1xuICAgICAgICAgICAgICAgIGZpbmFsaXplRGVwTWFya2Vycyh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNrT3BCaXQgPSAxIDw8IC0tZWZmZWN0VHJhY2tEZXB0aDtcbiAgICAgICAgICAgIGFjdGl2ZUVmZmVjdCA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgc2hvdWxkVHJhY2sgPSBsYXN0U2hvdWxkVHJhY2s7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZmVyU3RvcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIC8vIHN0b3BwZWQgd2hpbGUgcnVubmluZyBpdHNlbGYgLSBkZWZlciB0aGUgY2xlYW51cFxuICAgICAgICBpZiAoYWN0aXZlRWZmZWN0ID09PSB0aGlzKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmVyU3RvcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5vblN0b3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uU3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUmVhY3RpdmVFZmZlY3QgPSBSZWFjdGl2ZUVmZmVjdDtcbmZ1bmN0aW9uIGNsZWFudXBFZmZlY3QoZWZmZWN0KSB7XG4gICAgY29uc3QgeyBkZXBzIH0gPSBlZmZlY3Q7XG4gICAgaWYgKGRlcHMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVwc1tpXS5kZWxldGUoZWZmZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBkZXBzLmxlbmd0aCA9IDA7XG4gICAgfVxufVxuZnVuY3Rpb24gZWZmZWN0KGZuLCBvcHRpb25zKSB7XG4gICAgaWYgKGZuLmVmZmVjdCkge1xuICAgICAgICBmbiA9IGZuLmVmZmVjdC5mbjtcbiAgICB9XG4gICAgY29uc3QgX2VmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChmbik7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgKDAsIHNoYXJlZF8xLmV4dGVuZCkoX2VmZmVjdCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLnNjb3BlKVxuICAgICAgICAgICAgcmVjb3JkRWZmZWN0U2NvcGUoX2VmZmVjdCwgb3B0aW9ucy5zY29wZSk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5sYXp5KSB7XG4gICAgICAgIF9lZmZlY3QucnVuKCk7XG4gICAgfVxuICAgIGNvbnN0IHJ1bm5lciA9IF9lZmZlY3QucnVuLmJpbmQoX2VmZmVjdCk7XG4gICAgcnVubmVyLmVmZmVjdCA9IF9lZmZlY3Q7XG4gICAgcmV0dXJuIHJ1bm5lcjtcbn1cbmV4cG9ydHMuZWZmZWN0ID0gZWZmZWN0O1xuZnVuY3Rpb24gc3RvcChydW5uZXIpIHtcbiAgICBydW5uZXIuZWZmZWN0LnN0b3AoKTtcbn1cbmV4cG9ydHMuc3RvcCA9IHN0b3A7XG5sZXQgc2hvdWxkVHJhY2sgPSB0cnVlO1xuY29uc3QgdHJhY2tTdGFjayA9IFtdO1xuZnVuY3Rpb24gcGF1c2VUcmFja2luZygpIHtcbiAgICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xuICAgIHNob3VsZFRyYWNrID0gZmFsc2U7XG59XG5leHBvcnRzLnBhdXNlVHJhY2tpbmcgPSBwYXVzZVRyYWNraW5nO1xuZnVuY3Rpb24gZW5hYmxlVHJhY2tpbmcoKSB7XG4gICAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcbiAgICBzaG91bGRUcmFjayA9IHRydWU7XG59XG5leHBvcnRzLmVuYWJsZVRyYWNraW5nID0gZW5hYmxlVHJhY2tpbmc7XG5mdW5jdGlvbiByZXNldFRyYWNraW5nKCkge1xuICAgIGNvbnN0IGxhc3QgPSB0cmFja1N0YWNrLnBvcCgpO1xuICAgIHNob3VsZFRyYWNrID0gbGFzdCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGxhc3Q7XG59XG5leHBvcnRzLnJlc2V0VHJhY2tpbmcgPSByZXNldFRyYWNraW5nO1xuZnVuY3Rpb24gdHJhY2sodGFyZ2V0LCB0eXBlLCBrZXkpIHtcbiAgICBpZiAoc2hvdWxkVHJhY2sgJiYgYWN0aXZlRWZmZWN0KSB7XG4gICAgICAgIGxldCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICAgICAgICBpZiAoIWRlcHNNYXApIHtcbiAgICAgICAgICAgIHRhcmdldE1hcC5zZXQodGFyZ2V0LCAoZGVwc01hcCA9IG5ldyBNYXAoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZXAgPSBkZXBzTWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWRlcCkge1xuICAgICAgICAgICAgZGVwc01hcC5zZXQoa2V5LCAoZGVwID0gY3JlYXRlRGVwKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudEluZm8gPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgICAgID8geyBlZmZlY3Q6IGFjdGl2ZUVmZmVjdCwgdGFyZ2V0LCB0eXBlLCBrZXkgfVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRyYWNrRWZmZWN0cyhkZXAsIGV2ZW50SW5mbyk7XG4gICAgfVxufVxuZXhwb3J0cy50cmFjayA9IHRyYWNrO1xuZnVuY3Rpb24gdHJhY2tFZmZlY3RzKGRlcCwgZGVidWdnZXJFdmVudEV4dHJhSW5mbykge1xuICAgIGxldCBzaG91bGRUcmFjayA9IGZhbHNlO1xuICAgIGlmIChlZmZlY3RUcmFja0RlcHRoIDw9IG1heE1hcmtlckJpdHMpIHtcbiAgICAgICAgaWYgKCFuZXdUcmFja2VkKGRlcCkpIHtcbiAgICAgICAgICAgIGRlcC5uIHw9IHRyYWNrT3BCaXQ7IC8vIHNldCBuZXdseSB0cmFja2VkXG4gICAgICAgICAgICBzaG91bGRUcmFjayA9ICF3YXNUcmFja2VkKGRlcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEZ1bGwgY2xlYW51cCBtb2RlLlxuICAgICAgICBzaG91bGRUcmFjayA9ICFkZXAuaGFzKGFjdGl2ZUVmZmVjdCk7XG4gICAgfVxuICAgIGlmIChzaG91bGRUcmFjaykge1xuICAgICAgICBkZXAuYWRkKGFjdGl2ZUVmZmVjdCk7XG4gICAgICAgIGFjdGl2ZUVmZmVjdC5kZXBzLnB1c2goZGVwKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBhY3RpdmVFZmZlY3Qub25UcmFjaykge1xuICAgICAgICAgICAgYWN0aXZlRWZmZWN0Lm9uVHJhY2soT2JqZWN0LmFzc2lnbih7IGVmZmVjdDogYWN0aXZlRWZmZWN0IH0sIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXIodGFyZ2V0LCB0eXBlLCBrZXksIG5ld1ZhbHVlLCBvbGRWYWx1ZSwgb2xkVGFyZ2V0KSB7XG4gICAgY29uc3QgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcbiAgICBpZiAoIWRlcHNNYXApIHtcbiAgICAgICAgLy8gbmV2ZXIgYmVlbiB0cmFja2VkXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGRlcHMgPSBbXTtcbiAgICBpZiAodHlwZSA9PT0gXCJjbGVhclwiIC8qIFRyaWdnZXJPcFR5cGVzLkNMRUFSICovKSB7XG4gICAgICAgIC8vIGNvbGxlY3Rpb24gYmVpbmcgY2xlYXJlZFxuICAgICAgICAvLyB0cmlnZ2VyIGFsbCBlZmZlY3RzIGZvciB0YXJnZXRcbiAgICAgICAgZGVwcyA9IFsuLi5kZXBzTWFwLnZhbHVlcygpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2V5ID09PSAnbGVuZ3RoJyAmJiAoMCwgc2hhcmVkXzEuaXNBcnJheSkodGFyZ2V0KSkge1xuICAgICAgICBjb25zdCBuZXdMZW5ndGggPSBOdW1iZXIobmV3VmFsdWUpO1xuICAgICAgICBkZXBzTWFwLmZvckVhY2goKGRlcCwga2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnbGVuZ3RoJyB8fCBrZXkgPj0gbmV3TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gc2NoZWR1bGUgcnVucyBmb3IgU0VUIHwgQUREIHwgREVMRVRFXG4gICAgICAgIGlmIChrZXkgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KGtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFsc28gcnVuIGZvciBpdGVyYXRpb24ga2V5IG9uIEFERCB8IERFTEVURSB8IE1hcC5TRVRcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYWRkXCIgLyogVHJpZ2dlck9wVHlwZXMuQUREICovOlxuICAgICAgICAgICAgICAgIGlmICghKDAsIHNoYXJlZF8xLmlzQXJyYXkpKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgc2hhcmVkXzEuaXNNYXApKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKDAsIHNoYXJlZF8xLmlzSW50ZWdlcktleSkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBuZXcgaW5kZXggYWRkZWQgdG8gYXJyYXkgLT4gbGVuZ3RoIGNoYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KCdsZW5ndGgnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVwiIC8qIFRyaWdnZXJPcFR5cGVzLkRFTEVURSAqLzpcbiAgICAgICAgICAgICAgICBpZiAoISgwLCBzaGFyZWRfMS5pc0FycmF5KSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIHNoYXJlZF8xLmlzTWFwKSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNldFwiIC8qIFRyaWdnZXJPcFR5cGVzLlNFVCAqLzpcbiAgICAgICAgICAgICAgICBpZiAoKDAsIHNoYXJlZF8xLmlzTWFwKSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBldmVudEluZm8gPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgPyB7IHRhcmdldCwgdHlwZSwga2V5LCBuZXdWYWx1ZSwgb2xkVmFsdWUsIG9sZFRhcmdldCB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGlmIChkZXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAoZGVwc1swXSkge1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFZmZlY3RzKGRlcHNbMF0sIGV2ZW50SW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRWZmZWN0cyhkZXBzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgZWZmZWN0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBzKSB7XG4gICAgICAgICAgICBpZiAoZGVwKSB7XG4gICAgICAgICAgICAgICAgZWZmZWN0cy5wdXNoKC4uLmRlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdHMoY3JlYXRlRGVwKGVmZmVjdHMpLCBldmVudEluZm8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdHMoY3JlYXRlRGVwKGVmZmVjdHMpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudHJpZ2dlciA9IHRyaWdnZXI7XG5mdW5jdGlvbiB0cmlnZ2VyRWZmZWN0cyhkZXAsIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pIHtcbiAgICAvLyBzcHJlYWQgaW50byBhcnJheSBmb3Igc3RhYmlsaXphdGlvblxuICAgIGNvbnN0IGVmZmVjdHMgPSAoMCwgc2hhcmVkXzEuaXNBcnJheSkoZGVwKSA/IGRlcCA6IFsuLi5kZXBdO1xuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgaWYgKGVmZmVjdC5jb21wdXRlZCkge1xuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdChlZmZlY3QsIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgaWYgKCFlZmZlY3QuY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIHRyaWdnZXJFZmZlY3QoZWZmZWN0LCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJFZmZlY3QoZWZmZWN0LCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSB7XG4gICAgaWYgKGVmZmVjdCAhPT0gYWN0aXZlRWZmZWN0IHx8IGVmZmVjdC5hbGxvd1JlY3Vyc2UpIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBlZmZlY3Qub25UcmlnZ2VyKSB7XG4gICAgICAgICAgICBlZmZlY3Qub25UcmlnZ2VyKCgwLCBzaGFyZWRfMS5leHRlbmQpKHsgZWZmZWN0IH0sIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWZmZWN0LnNjaGVkdWxlcikge1xuICAgICAgICAgICAgZWZmZWN0LnNjaGVkdWxlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWZmZWN0LnJ1bigpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RGVwRnJvbVJlYWN0aXZlKG9iamVjdCwga2V5KSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0YXJnZXRNYXAuZ2V0KG9iamVjdCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoa2V5KTtcbn1cbmNvbnN0IGlzTm9uVHJhY2thYmxlS2V5cyA9IC8qI19fUFVSRV9fKi8gKDAsIHNoYXJlZF8xLm1ha2VNYXApKGBfX3Byb3RvX18sX192X2lzUmVmLF9faXNWdWVgKTtcbmNvbnN0IGJ1aWx0SW5TeW1ib2xzID0gbmV3IFNldChcbi8qI19fUFVSRV9fKi9cbk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFN5bWJvbClcbiAgICAvLyBpb3MxMC54IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFN5bWJvbCkgY2FuIGVudW1lcmF0ZSAnYXJndW1lbnRzJyBhbmQgJ2NhbGxlcidcbiAgICAvLyBidXQgYWNjZXNzaW5nIHRoZW0gb24gU3ltYm9sIGxlYWRzIHRvIFR5cGVFcnJvciBiZWNhdXNlIFN5bWJvbCBpcyBhIHN0cmljdCBtb2RlXG4gICAgLy8gZnVuY3Rpb25cbiAgICAuZmlsdGVyKGtleSA9PiBrZXkgIT09ICdhcmd1bWVudHMnICYmIGtleSAhPT0gJ2NhbGxlcicpXG4gICAgLm1hcChrZXkgPT4gU3ltYm9sW2tleV0pXG4gICAgLmZpbHRlcihzaGFyZWRfMS5pc1N5bWJvbCkpO1xuY29uc3QgZ2V0JDEgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcigpO1xuY29uc3Qgc2hhbGxvd0dldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKGZhbHNlLCB0cnVlKTtcbmNvbnN0IHJlYWRvbmx5R2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIodHJ1ZSk7XG5jb25zdCBzaGFsbG93UmVhZG9ubHlHZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcih0cnVlLCB0cnVlKTtcbmNvbnN0IGFycmF5SW5zdHJ1bWVudGF0aW9ucyA9IC8qI19fUFVSRV9fKi8gY3JlYXRlQXJyYXlJbnN0cnVtZW50YXRpb25zKCk7XG5mdW5jdGlvbiBjcmVhdGVBcnJheUluc3RydW1lbnRhdGlvbnMoKSB7XG4gICAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IHt9O1xuICAgIFsnaW5jbHVkZXMnLCAnaW5kZXhPZicsICdsYXN0SW5kZXhPZiddLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaW5zdHJ1bWVudGF0aW9uc1trZXldID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IHRvUmF3KHRoaXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHRyYWNrKGFyciwgXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLCBpICsgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2UgcnVuIHRoZSBtZXRob2QgdXNpbmcgdGhlIG9yaWdpbmFsIGFyZ3MgZmlyc3QgKHdoaWNoIG1heSBiZSByZWFjdGl2ZSlcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGFycltrZXldKC4uLmFyZ3MpO1xuICAgICAgICAgICAgaWYgKHJlcyA9PT0gLTEgfHwgcmVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoYXQgZGlkbid0IHdvcmssIHJ1biBpdCBhZ2FpbiB1c2luZyByYXcgdmFsdWVzLlxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJba2V5XSguLi5hcmdzLm1hcCh0b1JhdykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBbJ3B1c2gnLCAncG9wJywgJ3NoaWZ0JywgJ3Vuc2hpZnQnLCAnc3BsaWNlJ10uZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gdG9SYXcodGhpcylba2V5XS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbnM7XG59XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShrZXkpIHtcbiAgICBjb25zdCBvYmogPSB0b1Jhdyh0aGlzKTtcbiAgICB0cmFjayhvYmosIFwiaGFzXCIgLyogVHJhY2tPcFR5cGVzLkhBUyAqLywga2V5KTtcbiAgICByZXR1cm4gb2JqLmhhc093blByb3BlcnR5KGtleSk7XG59XG5mdW5jdGlvbiBjcmVhdGVHZXR0ZXIoaXNSZWFkb25seSA9IGZhbHNlLCBzaGFsbG93ID0gZmFsc2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikge1xuICAgICAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIgLyogUmVhY3RpdmVGbGFncy5JU19SRUFDVElWRSAqLykge1xuICAgICAgICAgICAgcmV0dXJuICFpc1JlYWRvbmx5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBRE9OTFkgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNTaGFsbG93XCIgLyogUmVhY3RpdmVGbGFncy5JU19TSEFMTE9XICovKSB7XG4gICAgICAgICAgICByZXR1cm4gc2hhbGxvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiIC8qIFJlYWN0aXZlRmxhZ3MuUkFXICovICYmXG4gICAgICAgICAgICByZWNlaXZlciA9PT1cbiAgICAgICAgICAgICAgICAoaXNSZWFkb25seVxuICAgICAgICAgICAgICAgICAgICA/IHNoYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2hhbGxvd1JlYWRvbmx5TWFwXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlYWRvbmx5TWFwXG4gICAgICAgICAgICAgICAgICAgIDogc2hhbGxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBzaGFsbG93UmVhY3RpdmVNYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVhY3RpdmVNYXApLmdldCh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldElzQXJyYXkgPSAoMCwgc2hhcmVkXzEuaXNBcnJheSkodGFyZ2V0KTtcbiAgICAgICAgaWYgKCFpc1JlYWRvbmx5KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0SXNBcnJheSAmJiAoMCwgc2hhcmVkXzEuaGFzT3duKShhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoYXJyYXlJbnN0cnVtZW50YXRpb25zLCBrZXksIHJlY2VpdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdoYXNPd25Qcm9wZXJ0eScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcbiAgICAgICAgaWYgKCgwLCBzaGFyZWRfMS5pc1N5bWJvbCkoa2V5KSA/IGJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpIDogaXNOb25UcmFja2FibGVLZXlzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1JlYWRvbmx5KSB7XG4gICAgICAgICAgICB0cmFjayh0YXJnZXQsIFwiZ2V0XCIgLyogVHJhY2tPcFR5cGVzLkdFVCAqLywga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhbGxvdykge1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSZWYocmVzKSkge1xuICAgICAgICAgICAgLy8gcmVmIHVud3JhcHBpbmcgLSBza2lwIHVud3JhcCBmb3IgQXJyYXkgKyBpbnRlZ2VyIGtleS5cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRJc0FycmF5ICYmICgwLCBzaGFyZWRfMS5pc0ludGVnZXJLZXkpKGtleSkgPyByZXMgOiByZXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBzaGFyZWRfMS5pc09iamVjdCkocmVzKSkge1xuICAgICAgICAgICAgLy8gQ29udmVydCByZXR1cm5lZCB2YWx1ZSBpbnRvIGEgcHJveHkgYXMgd2VsbC4gd2UgZG8gdGhlIGlzT2JqZWN0IGNoZWNrXG4gICAgICAgICAgICAvLyBoZXJlIHRvIGF2b2lkIGludmFsaWQgdmFsdWUgd2FybmluZy4gQWxzbyBuZWVkIHRvIGxhenkgYWNjZXNzIHJlYWRvbmx5XG4gICAgICAgICAgICAvLyBhbmQgcmVhY3RpdmUgaGVyZSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgICAgICAgcmV0dXJuIGlzUmVhZG9ubHkgPyByZWFkb25seShyZXMpIDogcmVhY3RpdmUocmVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG59XG5jb25zdCBzZXQkMSA9IC8qI19fUFVSRV9fKi8gY3JlYXRlU2V0dGVyKCk7XG5jb25zdCBzaGFsbG93U2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVTZXR0ZXIodHJ1ZSk7XG5mdW5jdGlvbiBjcmVhdGVTZXR0ZXIoc2hhbGxvdyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICAgIGxldCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgICAgICBpZiAoaXNSZWFkb25seShvbGRWYWx1ZSkgJiYgaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNoYWxsb3cpIHtcbiAgICAgICAgICAgIGlmICghaXNTaGFsbG93KHZhbHVlKSAmJiAhaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IHRvUmF3KG9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKDAsIHNoYXJlZF8xLmlzQXJyYXkpKHRhcmdldCkgJiYgaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhZEtleSA9ICgwLCBzaGFyZWRfMS5pc0FycmF5KSh0YXJnZXQpICYmICgwLCBzaGFyZWRfMS5pc0ludGVnZXJLZXkpKGtleSlcbiAgICAgICAgICAgID8gTnVtYmVyKGtleSkgPCB0YXJnZXQubGVuZ3RoXG4gICAgICAgICAgICA6ICgwLCBzaGFyZWRfMS5oYXNPd24pKHRhcmdldCwga2V5KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XG4gICAgICAgIC8vIGRvbid0IHRyaWdnZXIgaWYgdGFyZ2V0IGlzIHNvbWV0aGluZyB1cCBpbiB0aGUgcHJvdG90eXBlIGNoYWluIG9mIG9yaWdpbmFsXG4gICAgICAgIGlmICh0YXJnZXQgPT09IHRvUmF3KHJlY2VpdmVyKSkge1xuICAgICAgICAgICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5BREQgKi8sIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKDAsIHNoYXJlZF8xLmhhc0NoYW5nZWQpKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8sIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5mdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICAgIGNvbnN0IGhhZEtleSA9ICgwLCBzaGFyZWRfMS5oYXNPd24pKHRhcmdldCwga2V5KTtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpO1xuICAgIGlmIChyZXN1bHQgJiYgaGFkS2V5KSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiIC8qIFRyaWdnZXJPcFR5cGVzLkRFTEVURSAqLywga2V5LCB1bmRlZmluZWQsIG9sZFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGhhcyQxKHRhcmdldCwga2V5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5oYXModGFyZ2V0LCBrZXkpO1xuICAgIGlmICghKDAsIHNoYXJlZF8xLmlzU3ltYm9sKShrZXkpIHx8ICFidWlsdEluU3ltYm9scy5oYXMoa2V5KSkge1xuICAgICAgICB0cmFjayh0YXJnZXQsIFwiaGFzXCIgLyogVHJhY2tPcFR5cGVzLkhBUyAqLywga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG93bktleXModGFyZ2V0KSB7XG4gICAgdHJhY2sodGFyZ2V0LCBcIml0ZXJhdGVcIiAvKiBUcmFja09wVHlwZXMuSVRFUkFURSAqLywgKDAsIHNoYXJlZF8xLmlzQXJyYXkpKHRhcmdldCkgPyAnbGVuZ3RoJyA6IElURVJBVEVfS0VZKTtcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG59XG5jb25zdCBtdXRhYmxlSGFuZGxlcnMgPSB7XG4gICAgZ2V0OiBnZXQkMSxcbiAgICBzZXQ6IHNldCQxLFxuICAgIGRlbGV0ZVByb3BlcnR5LFxuICAgIGhhczogaGFzJDEsXG4gICAgb3duS2V5c1xufTtcbmNvbnN0IHJlYWRvbmx5SGFuZGxlcnMgPSB7XG4gICAgZ2V0OiByZWFkb25seUdldCxcbiAgICBzZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgd2FybihgU2V0IG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICB3YXJuKGBEZWxldGUgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuY29uc3Qgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMgPSAvKiNfX1BVUkVfXyovICgwLCBzaGFyZWRfMS5leHRlbmQpKHt9LCBtdXRhYmxlSGFuZGxlcnMsIHtcbiAgICBnZXQ6IHNoYWxsb3dHZXQsXG4gICAgc2V0OiBzaGFsbG93U2V0XG59KTtcbi8vIFByb3BzIGhhbmRsZXJzIGFyZSBzcGVjaWFsIGluIHRoZSBzZW5zZSB0aGF0IGl0IHNob3VsZCBub3QgdW53cmFwIHRvcC1sZXZlbFxuLy8gcmVmcyAoaW4gb3JkZXIgdG8gYWxsb3cgcmVmcyB0byBiZSBleHBsaWNpdGx5IHBhc3NlZCBkb3duKSwgYnV0IHNob3VsZFxuLy8gcmV0YWluIHRoZSByZWFjdGl2aXR5IG9mIHRoZSBub3JtYWwgcmVhZG9ubHkgb2JqZWN0LlxuY29uc3Qgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMgPSAvKiNfX1BVUkVfXyovICgwLCBzaGFyZWRfMS5leHRlbmQpKHt9LCByZWFkb25seUhhbmRsZXJzLCB7XG4gICAgZ2V0OiBzaGFsbG93UmVhZG9ubHlHZXRcbn0pO1xuY29uc3QgdG9TaGFsbG93ID0gKHZhbHVlKSA9PiB2YWx1ZTtcbmNvbnN0IGdldFByb3RvID0gKHYpID0+IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yodik7XG5mdW5jdGlvbiBnZXQodGFyZ2V0LCBrZXksIGlzUmVhZG9ubHkgPSBmYWxzZSwgaXNTaGFsbG93ID0gZmFsc2UpIHtcbiAgICAvLyAjMTc3MjogcmVhZG9ubHkocmVhY3RpdmUoTWFwKSkgc2hvdWxkIHJldHVybiByZWFkb25seSArIHJlYWN0aXZlIHZlcnNpb25cbiAgICAvLyBvZiB0aGUgdmFsdWVcbiAgICB0YXJnZXQgPSB0YXJnZXRbXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi9dO1xuICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcbiAgICBpZiAoIWlzUmVhZG9ubHkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gcmF3S2V5KSB7XG4gICAgICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIgLyogVHJhY2tPcFR5cGVzLkdFVCAqLywga2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIgLyogVHJhY2tPcFR5cGVzLkdFVCAqLywgcmF3S2V5KTtcbiAgICB9XG4gICAgY29uc3QgeyBoYXMgfSA9IGdldFByb3RvKHJhd1RhcmdldCk7XG4gICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICBpZiAoaGFzLmNhbGwocmF3VGFyZ2V0LCBrZXkpKSB7XG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQoa2V5KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhcy5jYWxsKHJhd1RhcmdldCwgcmF3S2V5KSkge1xuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KHJhd0tleSkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0YXJnZXQgIT09IHJhd1RhcmdldCkge1xuICAgICAgICAvLyAjMzYwMiByZWFkb25seShyZWFjdGl2ZShNYXApKVxuICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgbmVzdGVkIHJlYWN0aXZlIGBNYXBgIGNhbiBkbyB0cmFja2luZyBmb3IgaXRzZWxmXG4gICAgICAgIHRhcmdldC5nZXQoa2V5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXMoa2V5LCBpc1JlYWRvbmx5ID0gZmFsc2UpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiIC8qIFJlYWN0aXZlRmxhZ3MuUkFXICovXTtcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XG4gICAgaWYgKCFpc1JlYWRvbmx5KSB7XG4gICAgICAgIGlmIChrZXkgIT09IHJhd0tleSkge1xuICAgICAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiIC8qIFRyYWNrT3BUeXBlcy5IQVMgKi8sIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiIC8qIFRyYWNrT3BUeXBlcy5IQVMgKi8sIHJhd0tleSk7XG4gICAgfVxuICAgIHJldHVybiBrZXkgPT09IHJhd0tleVxuICAgICAgICA/IHRhcmdldC5oYXMoa2V5KVxuICAgICAgICA6IHRhcmdldC5oYXMoa2V5KSB8fCB0YXJnZXQuaGFzKHJhd0tleSk7XG59XG5mdW5jdGlvbiBzaXplKHRhcmdldCwgaXNSZWFkb25seSA9IGZhbHNlKSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiIC8qIFJlYWN0aXZlRmxhZ3MuUkFXICovXTtcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayh0b1Jhdyh0YXJnZXQpLCBcIml0ZXJhdGVcIiAvKiBUcmFja09wVHlwZXMuSVRFUkFURSAqLywgSVRFUkFURV9LRVkpO1xuICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsICdzaXplJywgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICAgIGNvbnN0IHByb3RvID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgICBjb25zdCBoYWRLZXkgPSBwcm90by5oYXMuY2FsbCh0YXJnZXQsIHZhbHVlKTtcbiAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICB0YXJnZXQuYWRkKHZhbHVlKTtcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIgLyogVHJpZ2dlck9wVHlwZXMuQUREICovLCB2YWx1ZSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gICAgY29uc3QgeyBoYXMsIGdldCB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgICBsZXQgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xuICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgIGtleSA9IHRvUmF3KGtleSk7XG4gICAgICAgIGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpO1xuICAgIH1cbiAgICBjb25zdCBvbGRWYWx1ZSA9IGdldC5jYWxsKHRhcmdldCwga2V5KTtcbiAgICB0YXJnZXQuc2V0KGtleSwgdmFsdWUpO1xuICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiIC8qIFRyaWdnZXJPcFR5cGVzLkFERCAqLywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBzaGFyZWRfMS5oYXNDaGFuZ2VkKSh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiIC8qIFRyaWdnZXJPcFR5cGVzLlNFVCAqLywga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIGRlbGV0ZUVudHJ5KGtleSkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICAgIGNvbnN0IHsgaGFzLCBnZXQgfSA9IGdldFByb3RvKHRhcmdldCk7XG4gICAgbGV0IGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICBrZXkgPSB0b1JhdyhrZXkpO1xuICAgICAgICBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhcywga2V5KTtcbiAgICB9XG4gICAgY29uc3Qgb2xkVmFsdWUgPSBnZXQgPyBnZXQuY2FsbCh0YXJnZXQsIGtleSkgOiB1bmRlZmluZWQ7XG4gICAgLy8gZm9yd2FyZCB0aGUgb3BlcmF0aW9uIGJlZm9yZSBxdWV1ZWluZyByZWFjdGlvbnNcbiAgICBjb25zdCByZXN1bHQgPSB0YXJnZXQuZGVsZXRlKGtleSk7XG4gICAgaWYgKGhhZEtleSkge1xuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiAvKiBUcmlnZ2VyT3BUeXBlcy5ERUxFVEUgKi8sIGtleSwgdW5kZWZpbmVkLCBvbGRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjbGVhcigpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgICBjb25zdCBoYWRJdGVtcyA9IHRhcmdldC5zaXplICE9PSAwO1xuICAgIGNvbnN0IG9sZFRhcmdldCA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICA/ICgwLCBzaGFyZWRfMS5pc01hcCkodGFyZ2V0KVxuICAgICAgICAgICAgPyBuZXcgTWFwKHRhcmdldClcbiAgICAgICAgICAgIDogbmV3IFNldCh0YXJnZXQpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIC8vIGZvcndhcmQgdGhlIG9wZXJhdGlvbiBiZWZvcmUgcXVldWVpbmcgcmVhY3Rpb25zXG4gICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmNsZWFyKCk7XG4gICAgaWYgKGhhZEl0ZW1zKSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImNsZWFyXCIgLyogVHJpZ2dlck9wVHlwZXMuQ0xFQVIgKi8sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvbGRUYXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlRm9yRWFjaChpc1JlYWRvbmx5LCBpc1NoYWxsb3cpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICBjb25zdCBvYnNlcnZlZCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG9ic2VydmVkW1wiX192X3Jhd1wiIC8qIFJlYWN0aXZlRmxhZ3MuUkFXICovXTtcbiAgICAgICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcbiAgICAgICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICAgICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiAvKiBUcmFja09wVHlwZXMuSVRFUkFURSAqLywgSVRFUkFURV9LRVkpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0LmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIC8vIGltcG9ydGFudDogbWFrZSBzdXJlIHRoZSBjYWxsYmFjayBpc1xuICAgICAgICAgICAgLy8gMS4gaW52b2tlZCB3aXRoIHRoZSByZWFjdGl2ZSBtYXAgYXMgYHRoaXNgIGFuZCAzcmQgYXJnXG4gICAgICAgICAgICAvLyAyLiB0aGUgdmFsdWUgcmVjZWl2ZWQgc2hvdWxkIGJlIGEgY29ycmVzcG9uZGluZyByZWFjdGl2ZS9yZWFkb25seS5cbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHdyYXAodmFsdWUpLCB3cmFwKGtleSksIG9ic2VydmVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgaXNSZWFkb25seSwgaXNTaGFsbG93KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi9dO1xuICAgICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgICAgICBjb25zdCB0YXJnZXRJc01hcCA9ICgwLCBzaGFyZWRfMS5pc01hcCkocmF3VGFyZ2V0KTtcbiAgICAgICAgY29uc3QgaXNQYWlyID0gbWV0aG9kID09PSAnZW50cmllcycgfHwgKG1ldGhvZCA9PT0gU3ltYm9sLml0ZXJhdG9yICYmIHRhcmdldElzTWFwKTtcbiAgICAgICAgY29uc3QgaXNLZXlPbmx5ID0gbWV0aG9kID09PSAna2V5cycgJiYgdGFyZ2V0SXNNYXA7XG4gICAgICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0YXJnZXRbbWV0aG9kXSguLi5hcmdzKTtcbiAgICAgICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICAgICAgIWlzUmVhZG9ubHkgJiZcbiAgICAgICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIgLyogVHJhY2tPcFR5cGVzLklURVJBVEUgKi8sIGlzS2V5T25seSA/IE1BUF9LRVlfSVRFUkFURV9LRVkgOiBJVEVSQVRFX0tFWSk7XG4gICAgICAgIC8vIHJldHVybiBhIHdyYXBwZWQgaXRlcmF0b3Igd2hpY2ggcmV0dXJucyBvYnNlcnZlZCB2ZXJzaW9ucyBvZiB0aGVcbiAgICAgICAgLy8gdmFsdWVzIGVtaXR0ZWQgZnJvbSB0aGUgcmVhbCBpdGVyYXRvclxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gaXRlcmF0b3IgcHJvdG9jb2xcbiAgICAgICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgPyB7IHZhbHVlLCBkb25lIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXNQYWlyID8gW3dyYXAodmFsdWVbMF0pLCB3cmFwKHZhbHVlWzFdKV0gOiB3cmFwKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBpdGVyYWJsZSBwcm90b2NvbFxuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlYWRvbmx5TWV0aG9kKHR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYXJnc1swXSA/IGBvbiBrZXkgXCIke2FyZ3NbMF19XCIgYCA6IGBgO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGAkeygwLCBzaGFyZWRfMS5jYXBpdGFsaXplKSh0eXBlKX0gb3BlcmF0aW9uICR7a2V5fWZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRvUmF3KHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZSA9PT0gXCJkZWxldGVcIiAvKiBUcmlnZ2VyT3BUeXBlcy5ERUxFVEUgKi8gPyBmYWxzZSA6IHRoaXM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbnMoKSB7XG4gICAgY29uc3QgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMgPSB7XG4gICAgICAgIGdldChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywga2V5KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZSh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzLFxuICAgICAgICBhZGQsXG4gICAgICAgIHNldCxcbiAgICAgICAgZGVsZXRlOiBkZWxldGVFbnRyeSxcbiAgICAgICAgY2xlYXIsXG4gICAgICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2goZmFsc2UsIGZhbHNlKVxuICAgIH07XG4gICAgY29uc3Qgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMgPSB7XG4gICAgICAgIGdldChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywga2V5LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBzaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNpemUodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhcyxcbiAgICAgICAgYWRkLFxuICAgICAgICBzZXQsXG4gICAgICAgIGRlbGV0ZTogZGVsZXRlRW50cnksXG4gICAgICAgIGNsZWFyLFxuICAgICAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCB0cnVlKVxuICAgIH07XG4gICAgY29uc3QgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zID0ge1xuICAgICAgICBnZXQoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBzaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhcyhrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXMuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiYWRkXCIgLyogVHJpZ2dlck9wVHlwZXMuQUREICovKSxcbiAgICAgICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiIC8qIFRyaWdnZXJPcFR5cGVzLlNFVCAqLyksXG4gICAgICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiAvKiBUcmlnZ2VyT3BUeXBlcy5ERUxFVEUgKi8pLFxuICAgICAgICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJjbGVhclwiIC8qIFRyaWdnZXJPcFR5cGVzLkNMRUFSICovKSxcbiAgICAgICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCBmYWxzZSlcbiAgICB9O1xuICAgIGNvbnN0IHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnMgPSB7XG4gICAgICAgIGdldChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywga2V5LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHNpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhcy5jYWxsKHRoaXMsIGtleSwgdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJhZGRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5BREQgKi8pLFxuICAgICAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIgLyogVHJpZ2dlck9wVHlwZXMuU0VUICovKSxcbiAgICAgICAgZGVsZXRlOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImRlbGV0ZVwiIC8qIFRyaWdnZXJPcFR5cGVzLkRFTEVURSAqLyksXG4gICAgICAgIGNsZWFyOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImNsZWFyXCIgLyogVHJpZ2dlck9wVHlwZXMuQ0xFQVIgKi8pLFxuICAgICAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKHRydWUsIHRydWUpXG4gICAgfTtcbiAgICBjb25zdCBpdGVyYXRvck1ldGhvZHMgPSBbJ2tleXMnLCAndmFsdWVzJywgJ2VudHJpZXMnLCBTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGl0ZXJhdG9yTWV0aG9kcy5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gICAgICAgIG11dGFibGVJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCB0cnVlLCB0cnVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucyxcbiAgICAgICAgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zLFxuICAgICAgICBzaGFsbG93SW5zdHJ1bWVudGF0aW9ucyxcbiAgICAgICAgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1xuICAgIF07XG59XG5jb25zdCBbbXV0YWJsZUluc3RydW1lbnRhdGlvbnMsIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucywgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMsIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNdID0gLyogI19fUFVSRV9fKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9ucygpO1xuZnVuY3Rpb24gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGlzUmVhZG9ubHksIHNoYWxsb3cpIHtcbiAgICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0gc2hhbGxvd1xuICAgICAgICA/IGlzUmVhZG9ubHlcbiAgICAgICAgICAgID8gc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1xuICAgICAgICAgICAgOiBzaGFsbG93SW5zdHJ1bWVudGF0aW9uc1xuICAgICAgICA6IGlzUmVhZG9ubHlcbiAgICAgICAgICAgID8gcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXG4gICAgICAgICAgICA6IG11dGFibGVJbnN0cnVtZW50YXRpb25zO1xuICAgIHJldHVybiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1JFQUNUSVZFICovKSB7XG4gICAgICAgICAgICByZXR1cm4gIWlzUmVhZG9ubHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWRvbmx5XCIgLyogUmVhY3RpdmVGbGFncy5JU19SRUFET05MWSAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGlzUmVhZG9ubHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIiAvKiBSZWFjdGl2ZUZsYWdzLlJBVyAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoKDAsIHNoYXJlZF8xLmhhc093bikoaW5zdHJ1bWVudGF0aW9ucywga2V5KSAmJiBrZXkgaW4gdGFyZ2V0XG4gICAgICAgICAgICA/IGluc3RydW1lbnRhdGlvbnNcbiAgICAgICAgICAgIDogdGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcbiAgICB9O1xufVxuY29uc3QgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgICBnZXQ6IC8qI19fUFVSRV9fKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCBmYWxzZSlcbn07XG5jb25zdCBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICAgIGdldDogLyojX19QVVJFX18qLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIHRydWUpXG59O1xuY29uc3QgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gICAgZ2V0OiAvKiNfX1BVUkVfXyovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcih0cnVlLCBmYWxzZSlcbn07XG5jb25zdCBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gICAgZ2V0OiAvKiNfX1BVUkVfXyovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcih0cnVlLCB0cnVlKVxufTtcbmZ1bmN0aW9uIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpIHtcbiAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICAgIGlmIChyYXdLZXkgIT09IGtleSAmJiBoYXMuY2FsbCh0YXJnZXQsIHJhd0tleSkpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9ICgwLCBzaGFyZWRfMS50b1Jhd1R5cGUpKHRhcmdldCk7XG4gICAgICAgIGNvbnNvbGUud2FybihgUmVhY3RpdmUgJHt0eXBlfSBjb250YWlucyBib3RoIHRoZSByYXcgYW5kIHJlYWN0aXZlIGAgK1xuICAgICAgICAgICAgYHZlcnNpb25zIG9mIHRoZSBzYW1lIG9iamVjdCR7dHlwZSA9PT0gYE1hcGAgPyBgIGFzIGtleXNgIDogYGB9LCBgICtcbiAgICAgICAgICAgIGB3aGljaCBjYW4gbGVhZCB0byBpbmNvbnNpc3RlbmNpZXMuIGAgK1xuICAgICAgICAgICAgYEF2b2lkIGRpZmZlcmVudGlhdGluZyBiZXR3ZWVuIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIGAgK1xuICAgICAgICAgICAgYG9mIGFuIG9iamVjdCBhbmQgb25seSB1c2UgdGhlIHJlYWN0aXZlIHZlcnNpb24gaWYgcG9zc2libGUuYCk7XG4gICAgfVxufVxuY29uc3QgcmVhY3RpdmVNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3Qgc2hhbGxvd1JlYWN0aXZlTWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJlYWRvbmx5TWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB0YXJnZXRUeXBlTWFwKHJhd1R5cGUpIHtcbiAgICBzd2l0Y2ggKHJhd1R5cGUpIHtcbiAgICAgICAgY2FzZSAnT2JqZWN0JzpcbiAgICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICAgICAgcmV0dXJuIDEgLyogVGFyZ2V0VHlwZS5DT01NT04gKi87XG4gICAgICAgIGNhc2UgJ01hcCc6XG4gICAgICAgIGNhc2UgJ1NldCc6XG4gICAgICAgIGNhc2UgJ1dlYWtNYXAnOlxuICAgICAgICBjYXNlICdXZWFrU2V0JzpcbiAgICAgICAgICAgIHJldHVybiAyIC8qIFRhcmdldFR5cGUuQ09MTEVDVElPTiAqLztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAwIC8qIFRhcmdldFR5cGUuSU5WQUxJRCAqLztcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRUeXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlW1wiX192X3NraXBcIiAvKiBSZWFjdGl2ZUZsYWdzLlNLSVAgKi9dIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKVxuICAgICAgICA/IDAgLyogVGFyZ2V0VHlwZS5JTlZBTElEICovXG4gICAgICAgIDogdGFyZ2V0VHlwZU1hcCgoMCwgc2hhcmVkXzEudG9SYXdUeXBlKSh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gcmVhY3RpdmUodGFyZ2V0KSB7XG4gICAgLy8gaWYgdHJ5aW5nIHRvIG9ic2VydmUgYSByZWFkb25seSBwcm94eSwgcmV0dXJuIHRoZSByZWFkb25seSB2ZXJzaW9uLlxuICAgIGlmIChpc1JlYWRvbmx5KHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgZmFsc2UsIG11dGFibGVIYW5kbGVycywgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycywgcmVhY3RpdmVNYXApO1xufVxuZXhwb3J0cy5yZWFjdGl2ZSA9IHJlYWN0aXZlO1xuLyoqXG4gKiBSZXR1cm4gYSBzaGFsbG93bHktcmVhY3RpdmUgY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LCB3aGVyZSBvbmx5IHRoZSByb290XG4gKiBsZXZlbCBwcm9wZXJ0aWVzIGFyZSByZWFjdGl2ZS4gSXQgYWxzbyBkb2VzIG5vdCBhdXRvLXVud3JhcCByZWZzIChldmVuIGF0IHRoZVxuICogcm9vdCBsZXZlbCkuXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dSZWFjdGl2ZSh0YXJnZXQpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBmYWxzZSwgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMsIHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMsIHNoYWxsb3dSZWFjdGl2ZU1hcCk7XG59XG5leHBvcnRzLnNoYWxsb3dSZWFjdGl2ZSA9IHNoYWxsb3dSZWFjdGl2ZTtcbi8qKlxuICogQ3JlYXRlcyBhIHJlYWRvbmx5IGNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdC4gTm90ZSB0aGUgcmV0dXJuZWQgY29weSBpcyBub3RcbiAqIG1hZGUgcmVhY3RpdmUsIGJ1dCBgcmVhZG9ubHlgIGNhbiBiZSBjYWxsZWQgb24gYW4gYWxyZWFkeSByZWFjdGl2ZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlYWRvbmx5KHRhcmdldCkge1xuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIHRydWUsIHJlYWRvbmx5SGFuZGxlcnMsIHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzLCByZWFkb25seU1hcCk7XG59XG5leHBvcnRzLnJlYWRvbmx5ID0gcmVhZG9ubHk7XG4vKipcbiAqIFJldHVybnMgYSByZWFjdGl2ZS1jb3B5IG9mIHRoZSBvcmlnaW5hbCBvYmplY3QsIHdoZXJlIG9ubHkgdGhlIHJvb3QgbGV2ZWxcbiAqIHByb3BlcnRpZXMgYXJlIHJlYWRvbmx5LCBhbmQgZG9lcyBOT1QgdW53cmFwIHJlZnMgbm9yIHJlY3Vyc2l2ZWx5IGNvbnZlcnRcbiAqIHJldHVybmVkIHByb3BlcnRpZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGNyZWF0aW5nIHRoZSBwcm9wcyBwcm94eSBvYmplY3QgZm9yIHN0YXRlZnVsIGNvbXBvbmVudHMuXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dSZWFkb25seSh0YXJnZXQpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCB0cnVlLCBzaGFsbG93UmVhZG9ubHlIYW5kbGVycywgc2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzLCBzaGFsbG93UmVhZG9ubHlNYXApO1xufVxuZXhwb3J0cy5zaGFsbG93UmVhZG9ubHkgPSBzaGFsbG93UmVhZG9ubHk7XG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGlzUmVhZG9ubHksIGJhc2VIYW5kbGVycywgY29sbGVjdGlvbkhhbmRsZXJzLCBwcm94eU1hcCkge1xuICAgIGlmICghKDAsIHNoYXJlZF8xLmlzT2JqZWN0KSh0YXJnZXQpKSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdmFsdWUgY2Fubm90IGJlIG1hZGUgcmVhY3RpdmU6ICR7U3RyaW5nKHRhcmdldCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgLy8gdGFyZ2V0IGlzIGFscmVhZHkgYSBQcm94eSwgcmV0dXJuIGl0LlxuICAgIC8vIGV4Y2VwdGlvbjogY2FsbGluZyByZWFkb25seSgpIG9uIGEgcmVhY3RpdmUgb2JqZWN0XG4gICAgaWYgKHRhcmdldFtcIl9fdl9yYXdcIiAvKiBSZWFjdGl2ZUZsYWdzLlJBVyAqL10gJiZcbiAgICAgICAgIShpc1JlYWRvbmx5ICYmIHRhcmdldFtcIl9fdl9pc1JlYWN0aXZlXCIgLyogUmVhY3RpdmVGbGFncy5JU19SRUFDVElWRSAqL10pKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIC8vIHRhcmdldCBhbHJlYWR5IGhhcyBjb3JyZXNwb25kaW5nIFByb3h5XG4gICAgY29uc3QgZXhpc3RpbmdQcm94eSA9IHByb3h5TWFwLmdldCh0YXJnZXQpO1xuICAgIGlmIChleGlzdGluZ1Byb3h5KSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xuICAgIH1cbiAgICAvLyBvbmx5IHNwZWNpZmljIHZhbHVlIHR5cGVzIGNhbiBiZSBvYnNlcnZlZC5cbiAgICBjb25zdCB0YXJnZXRUeXBlID0gZ2V0VGFyZ2V0VHlwZSh0YXJnZXQpO1xuICAgIGlmICh0YXJnZXRUeXBlID09PSAwIC8qIFRhcmdldFR5cGUuSU5WQUxJRCAqLykge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh0YXJnZXQsIHRhcmdldFR5cGUgPT09IDIgLyogVGFyZ2V0VHlwZS5DT0xMRUNUSU9OICovID8gY29sbGVjdGlvbkhhbmRsZXJzIDogYmFzZUhhbmRsZXJzKTtcbiAgICBwcm94eU1hcC5zZXQodGFyZ2V0LCBwcm94eSk7XG4gICAgcmV0dXJuIHByb3h5O1xufVxuZnVuY3Rpb24gaXNSZWFjdGl2ZSh2YWx1ZSkge1xuICAgIGlmIChpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZVtcIl9fdl9yYXdcIiAvKiBSZWFjdGl2ZUZsYWdzLlJBVyAqL10pO1xuICAgIH1cbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFjdGl2ZVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBQ1RJVkUgKi9dKTtcbn1cbmV4cG9ydHMuaXNSZWFjdGl2ZSA9IGlzUmVhY3RpdmU7XG5mdW5jdGlvbiBpc1JlYWRvbmx5KHZhbHVlKSB7XG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhZG9ubHlcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1JFQURPTkxZICovXSk7XG59XG5leHBvcnRzLmlzUmVhZG9ubHkgPSBpc1JlYWRvbmx5O1xuZnVuY3Rpb24gaXNTaGFsbG93KHZhbHVlKSB7XG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzU2hhbGxvd1wiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfU0hBTExPVyAqL10pO1xufVxuZXhwb3J0cy5pc1NoYWxsb3cgPSBpc1NoYWxsb3c7XG5mdW5jdGlvbiBpc1Byb3h5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWUpIHx8IGlzUmVhZG9ubHkodmFsdWUpO1xufVxuZXhwb3J0cy5pc1Byb3h5ID0gaXNQcm94eTtcbmZ1bmN0aW9uIHRvUmF3KG9ic2VydmVkKSB7XG4gICAgY29uc3QgcmF3ID0gb2JzZXJ2ZWQgJiYgb2JzZXJ2ZWRbXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi9dO1xuICAgIHJldHVybiByYXcgPyB0b1JhdyhyYXcpIDogb2JzZXJ2ZWQ7XG59XG5leHBvcnRzLnRvUmF3ID0gdG9SYXc7XG5mdW5jdGlvbiBtYXJrUmF3KHZhbHVlKSB7XG4gICAgKDAsIHNoYXJlZF8xLmRlZikodmFsdWUsIFwiX192X3NraXBcIiAvKiBSZWFjdGl2ZUZsYWdzLlNLSVAgKi8sIHRydWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydHMubWFya1JhdyA9IG1hcmtSYXc7XG5jb25zdCB0b1JlYWN0aXZlID0gKHZhbHVlKSA9PiAoMCwgc2hhcmVkXzEuaXNPYmplY3QpKHZhbHVlKSA/IHJlYWN0aXZlKHZhbHVlKSA6IHZhbHVlO1xuY29uc3QgdG9SZWFkb25seSA9ICh2YWx1ZSkgPT4gKDAsIHNoYXJlZF8xLmlzT2JqZWN0KSh2YWx1ZSkgPyByZWFkb25seSh2YWx1ZSkgOiB2YWx1ZTtcbmZ1bmN0aW9uIHRyYWNrUmVmVmFsdWUocmVmKSB7XG4gICAgaWYgKHNob3VsZFRyYWNrICYmIGFjdGl2ZUVmZmVjdCkge1xuICAgICAgICByZWYgPSB0b1JhdyhyZWYpO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICB0cmFja0VmZmVjdHMocmVmLmRlcCB8fCAocmVmLmRlcCA9IGNyZWF0ZURlcCgpKSwge1xuICAgICAgICAgICAgICAgIHRhcmdldDogcmVmLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZ2V0XCIgLyogVHJhY2tPcFR5cGVzLkdFVCAqLyxcbiAgICAgICAgICAgICAgICBrZXk6ICd2YWx1ZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJhY2tFZmZlY3RzKHJlZi5kZXAgfHwgKHJlZi5kZXAgPSBjcmVhdGVEZXAoKSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlclJlZlZhbHVlKHJlZiwgbmV3VmFsKSB7XG4gICAgcmVmID0gdG9SYXcocmVmKTtcbiAgICBjb25zdCBkZXAgPSByZWYuZGVwO1xuICAgIGlmIChkZXApIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdHMoZGVwLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiByZWYsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8sXG4gICAgICAgICAgICAgICAga2V5OiAndmFsdWUnLFxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdHMoZGVwKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzUmVmKHIpIHtcbiAgICByZXR1cm4gISEociAmJiByLl9fdl9pc1JlZiA9PT0gdHJ1ZSk7XG59XG5leHBvcnRzLmlzUmVmID0gaXNSZWY7XG5mdW5jdGlvbiByZWYodmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCBmYWxzZSk7XG59XG5leHBvcnRzLnJlZiA9IHJlZjtcbmZ1bmN0aW9uIHNoYWxsb3dSZWYodmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCB0cnVlKTtcbn1cbmV4cG9ydHMuc2hhbGxvd1JlZiA9IHNoYWxsb3dSZWY7XG5mdW5jdGlvbiBjcmVhdGVSZWYocmF3VmFsdWUsIHNoYWxsb3cpIHtcbiAgICBpZiAoaXNSZWYocmF3VmFsdWUpKSB7XG4gICAgICAgIHJldHVybiByYXdWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWZJbXBsKHJhd1ZhbHVlLCBzaGFsbG93KTtcbn1cbmNsYXNzIFJlZkltcGwge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBfX3ZfaXNTaGFsbG93KSB7XG4gICAgICAgIHRoaXMuX192X2lzU2hhbGxvdyA9IF9fdl9pc1NoYWxsb3c7XG4gICAgICAgIHRoaXMuZGVwID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XG4gICAgICAgIHRoaXMuX3Jhd1ZhbHVlID0gX192X2lzU2hhbGxvdyA/IHZhbHVlIDogdG9SYXcodmFsdWUpO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IF9fdl9pc1NoYWxsb3cgPyB2YWx1ZSA6IHRvUmVhY3RpdmUodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHRyYWNrUmVmVmFsdWUodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgICAgICBjb25zdCB1c2VEaXJlY3RWYWx1ZSA9IHRoaXMuX192X2lzU2hhbGxvdyB8fCBpc1NoYWxsb3cobmV3VmFsKSB8fCBpc1JlYWRvbmx5KG5ld1ZhbCk7XG4gICAgICAgIG5ld1ZhbCA9IHVzZURpcmVjdFZhbHVlID8gbmV3VmFsIDogdG9SYXcobmV3VmFsKTtcbiAgICAgICAgaWYgKCgwLCBzaGFyZWRfMS5oYXNDaGFuZ2VkKShuZXdWYWwsIHRoaXMuX3Jhd1ZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fcmF3VmFsdWUgPSBuZXdWYWw7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHVzZURpcmVjdFZhbHVlID8gbmV3VmFsIDogdG9SZWFjdGl2ZShuZXdWYWwpO1xuICAgICAgICAgICAgdHJpZ2dlclJlZlZhbHVlKHRoaXMsIG5ld1ZhbCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyUmVmKHJlZikge1xuICAgIHRyaWdnZXJSZWZWYWx1ZShyZWYsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHJlZi52YWx1ZSA6IHZvaWQgMCk7XG59XG5leHBvcnRzLnRyaWdnZXJSZWYgPSB0cmlnZ2VyUmVmO1xuZnVuY3Rpb24gdW5yZWYocmVmKSB7XG4gICAgcmV0dXJuIGlzUmVmKHJlZikgPyByZWYudmFsdWUgOiByZWY7XG59XG5leHBvcnRzLnVucmVmID0gdW5yZWY7XG5jb25zdCBzaGFsbG93VW53cmFwSGFuZGxlcnMgPSB7XG4gICAgZ2V0OiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB1bnJlZihSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpKSxcbiAgICBzZXQ6ICh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmIChpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xuICAgICAgICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmZ1bmN0aW9uIHByb3h5UmVmcyhvYmplY3RXaXRoUmVmcykge1xuICAgIHJldHVybiBpc1JlYWN0aXZlKG9iamVjdFdpdGhSZWZzKVxuICAgICAgICA/IG9iamVjdFdpdGhSZWZzXG4gICAgICAgIDogbmV3IFByb3h5KG9iamVjdFdpdGhSZWZzLCBzaGFsbG93VW53cmFwSGFuZGxlcnMpO1xufVxuZXhwb3J0cy5wcm94eVJlZnMgPSBwcm94eVJlZnM7XG5jbGFzcyBDdXN0b21SZWZJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuZGVwID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgZ2V0LCBzZXQgfSA9IGZhY3RvcnkoKCkgPT4gdHJhY2tSZWZWYWx1ZSh0aGlzKSwgKCkgPT4gdHJpZ2dlclJlZlZhbHVlKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fZ2V0ID0gZ2V0O1xuICAgICAgICB0aGlzLl9zZXQgPSBzZXQ7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldCgpO1xuICAgIH1cbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgICAgIHRoaXMuX3NldChuZXdWYWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGN1c3RvbVJlZihmYWN0b3J5KSB7XG4gICAgcmV0dXJuIG5ldyBDdXN0b21SZWZJbXBsKGZhY3RvcnkpO1xufVxuZXhwb3J0cy5jdXN0b21SZWYgPSBjdXN0b21SZWY7XG5mdW5jdGlvbiB0b1JlZnMob2JqZWN0KSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNQcm94eShvYmplY3QpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgdG9SZWZzKCkgZXhwZWN0cyBhIHJlYWN0aXZlIG9iamVjdCBidXQgcmVjZWl2ZWQgYSBwbGFpbiBvbmUuYCk7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9ICgwLCBzaGFyZWRfMS5pc0FycmF5KShvYmplY3QpID8gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpIDoge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIHJldFtrZXldID0gdG9SZWYob2JqZWN0LCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuZXhwb3J0cy50b1JlZnMgPSB0b1JlZnM7XG5jbGFzcyBPYmplY3RSZWZJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihfb2JqZWN0LCBfa2V5LCBfZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHRoaXMuX29iamVjdCA9IF9vYmplY3Q7XG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRWYWx1ZSA9IF9kZWZhdWx0VmFsdWU7XG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICBjb25zdCB2YWwgPSB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkID8gdGhpcy5fZGVmYXVsdFZhbHVlIDogdmFsO1xuICAgIH1cbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgICAgIHRoaXMuX29iamVjdFt0aGlzLl9rZXldID0gbmV3VmFsO1xuICAgIH1cbiAgICBnZXQgZGVwKCkge1xuICAgICAgICByZXR1cm4gZ2V0RGVwRnJvbVJlYWN0aXZlKHRvUmF3KHRoaXMuX29iamVjdCksIHRoaXMuX2tleSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9SZWYob2JqZWN0LCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHZhbCA9IG9iamVjdFtrZXldO1xuICAgIHJldHVybiBpc1JlZih2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogbmV3IE9iamVjdFJlZkltcGwob2JqZWN0LCBrZXksIGRlZmF1bHRWYWx1ZSk7XG59XG5leHBvcnRzLnRvUmVmID0gdG9SZWY7XG52YXIgX2EkMTtcbmNsYXNzIENvbXB1dGVkUmVmSW1wbCB7XG4gICAgY29uc3RydWN0b3IoZ2V0dGVyLCBfc2V0dGVyLCBpc1JlYWRvbmx5LCBpc1NTUikge1xuICAgICAgICB0aGlzLl9zZXR0ZXIgPSBfc2V0dGVyO1xuICAgICAgICB0aGlzLmRlcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgICAgICB0aGlzW19hJDFdID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZ2V0dGVyLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RpcnR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJSZWZWYWx1ZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWZmZWN0LmNvbXB1dGVkID0gdGhpcztcbiAgICAgICAgdGhpcy5lZmZlY3QuYWN0aXZlID0gdGhpcy5fY2FjaGVhYmxlID0gIWlzU1NSO1xuICAgICAgICB0aGlzW1wiX192X2lzUmVhZG9ubHlcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1JFQURPTkxZICovXSA9IGlzUmVhZG9ubHk7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgLy8gdGhlIGNvbXB1dGVkIHJlZiBtYXkgZ2V0IHdyYXBwZWQgYnkgb3RoZXIgcHJveGllcyBlLmcuIHJlYWRvbmx5KCkgIzMzNzZcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRvUmF3KHRoaXMpO1xuICAgICAgICB0cmFja1JlZlZhbHVlKHNlbGYpO1xuICAgICAgICBpZiAoc2VsZi5fZGlydHkgfHwgIXNlbGYuX2NhY2hlYWJsZSkge1xuICAgICAgICAgICAgc2VsZi5fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGYuX3ZhbHVlID0gc2VsZi5lZmZlY3QucnVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuX3ZhbHVlO1xuICAgIH1cbiAgICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc2V0dGVyKG5ld1ZhbHVlKTtcbiAgICB9XG59XG5fYSQxID0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBRE9OTFkgKi87XG5mdW5jdGlvbiBjb21wdXRlZChnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucywgaXNTU1IgPSBmYWxzZSkge1xuICAgIGxldCBnZXR0ZXI7XG4gICAgbGV0IHNldHRlcjtcbiAgICBjb25zdCBvbmx5R2V0dGVyID0gKDAsIHNoYXJlZF8xLmlzRnVuY3Rpb24pKGdldHRlck9yT3B0aW9ucyk7XG4gICAgaWYgKG9ubHlHZXR0ZXIpIHtcbiAgICAgICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zO1xuICAgICAgICBzZXR0ZXIgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgICAgID8gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgdmFsdWUgaXMgcmVhZG9ubHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogc2hhcmVkXzEuTk9PUDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucy5nZXQ7XG4gICAgICAgIHNldHRlciA9IGdldHRlck9yT3B0aW9ucy5zZXQ7XG4gICAgfVxuICAgIGNvbnN0IGNSZWYgPSBuZXcgQ29tcHV0ZWRSZWZJbXBsKGdldHRlciwgc2V0dGVyLCBvbmx5R2V0dGVyIHx8ICFzZXR0ZXIsIGlzU1NSKTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGRlYnVnT3B0aW9ucyAmJiAhaXNTU1IpIHtcbiAgICAgICAgY1JlZi5lZmZlY3Qub25UcmFjayA9IGRlYnVnT3B0aW9ucy5vblRyYWNrO1xuICAgICAgICBjUmVmLmVmZmVjdC5vblRyaWdnZXIgPSBkZWJ1Z09wdGlvbnMub25UcmlnZ2VyO1xuICAgIH1cbiAgICByZXR1cm4gY1JlZjtcbn1cbmV4cG9ydHMuY29tcHV0ZWQgPSBjb21wdXRlZDtcbnZhciBfYTtcbmNvbnN0IHRpY2sgPSAvKiNfX1BVUkVfXyovIFByb21pc2UucmVzb2x2ZSgpO1xuY29uc3QgcXVldWUgPSBbXTtcbmxldCBxdWV1ZWQgPSBmYWxzZTtcbmNvbnN0IHNjaGVkdWxlciA9IChmbikgPT4ge1xuICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgIGlmICghcXVldWVkKSB7XG4gICAgICAgIHF1ZXVlZCA9IHRydWU7XG4gICAgICAgIHRpY2sudGhlbihmbHVzaCk7XG4gICAgfVxufTtcbmNvbnN0IGZsdXNoID0gKCkgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcXVldWVbaV0oKTtcbiAgICB9XG4gICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICBxdWV1ZWQgPSBmYWxzZTtcbn07XG5jbGFzcyBEZWZlcnJlZENvbXB1dGVkUmVmSW1wbCB7XG4gICAgY29uc3RydWN0b3IoZ2V0dGVyKSB7XG4gICAgICAgIHRoaXMuZGVwID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgICAgICAgdGhpc1tfYV0gPSB0cnVlO1xuICAgICAgICBsZXQgY29tcGFyZVRhcmdldDtcbiAgICAgICAgbGV0IGhhc0NvbXBhcmVUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChnZXR0ZXIsIChjb21wdXRlZFRyaWdnZXIpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlcCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wdXRlZFRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFyZVRhcmdldCA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBoYXNDb21wYXJlVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZVRvQ29tcGFyZSA9IGhhc0NvbXBhcmVUYXJnZXQgPyBjb21wYXJlVGFyZ2V0IDogdGhpcy5fdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhhc0NvbXBhcmVUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVmZmVjdC5hY3RpdmUgJiYgdGhpcy5fZ2V0KCkgIT09IHZhbHVlVG9Db21wYXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlclJlZlZhbHVlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjaGFpbmVkIHVwc3RyZWFtIGNvbXB1dGVkcyBhcmUgbm90aWZpZWQgc3luY2hyb25vdXNseSB0byBlbnN1cmVcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZSBpbnZhbGlkYXRpb24gaW4gY2FzZSBvZiBzeW5jIGFjY2Vzczsgbm9ybWFsIGVmZmVjdHMgYXJlXG4gICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQgdG8gYmUgdHJpZ2dlcmVkIGluIHNjaGVkdWxlci5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5kZXApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuY29tcHV0ZWQgaW5zdGFuY2VvZiBEZWZlcnJlZENvbXB1dGVkUmVmSW1wbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zY2hlZHVsZXIodHJ1ZSAvKiBjb21wdXRlZFRyaWdnZXIgKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lZmZlY3QuY29tcHV0ZWQgPSB0aGlzO1xuICAgIH1cbiAgICBfZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5fZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX3ZhbHVlID0gdGhpcy5lZmZlY3QucnVuKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICB0cmFja1JlZlZhbHVlKHRoaXMpO1xuICAgICAgICAvLyB0aGUgY29tcHV0ZWQgcmVmIG1heSBnZXQgd3JhcHBlZCBieSBvdGhlciBwcm94aWVzIGUuZy4gcmVhZG9ubHkoKSAjMzM3NlxuICAgICAgICByZXR1cm4gdG9SYXcodGhpcykuX2dldCgpO1xuICAgIH1cbn1cbl9hID0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBRE9OTFkgKi87XG5mdW5jdGlvbiBkZWZlcnJlZENvbXB1dGVkKGdldHRlcikge1xuICAgIHJldHVybiBuZXcgRGVmZXJyZWRDb21wdXRlZFJlZkltcGwoZ2V0dGVyKTtcbn1cbmV4cG9ydHMuZGVmZXJyZWRDb21wdXRlZCA9IGRlZmVycmVkQ29tcHV0ZWQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\n");

/***/ }),

/***/ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.createElementBlock = exports.createCommentVNode = exports.createBlock = exports.computed = exports.compatUtils = exports.cloneVNode = exports.callWithErrorHandling = exports.callWithAsyncErrorHandling = exports.assertNumber = exports.Text = exports.Teleport = exports.Suspense = exports.Static = exports.KeepAlive = exports.Fragment = exports.Comment = exports.BaseTransition = exports.toHandlerKey = exports.toDisplayString = exports.normalizeStyle = exports.normalizeProps = exports.normalizeClass = exports.capitalize = exports.camelize = exports.unref = exports.triggerRef = exports.toRefs = exports.toRef = exports.toRaw = exports.stop = exports.shallowRef = exports.shallowReadonly = exports.shallowReactive = exports.ref = exports.readonly = exports.reactive = exports.proxyRefs = exports.onScopeDispose = exports.markRaw = exports.isShallow = exports.isRef = exports.isReadonly = exports.isReactive = exports.isProxy = exports.getCurrentScope = exports.effectScope = exports.effect = exports.customRef = exports.ReactiveEffect = exports.EffectScope = void 0;\nexports.resolveDynamicComponent = exports.resolveDirective = exports.resolveComponent = exports.renderSlot = exports.renderList = exports.registerRuntimeCompiler = exports.queuePostFlushCb = exports.pushScopeId = exports.provide = exports.popScopeId = exports.openBlock = exports.onUpdated = exports.onUnmounted = exports.onServerPrefetch = exports.onRenderTriggered = exports.onRenderTracked = exports.onMounted = exports.onErrorCaptured = exports.onDeactivated = exports.onBeforeUpdate = exports.onBeforeUnmount = exports.onBeforeMount = exports.onActivated = exports.nextTick = exports.mergeProps = exports.mergeDefaults = exports.isVNode = exports.isRuntimeOnly = exports.isMemoSame = exports.inject = exports.initCustomFormatter = exports.handleError = exports.h = exports.guardReactiveProps = exports.getTransitionRawChildren = exports.getCurrentInstance = exports.devtools = exports.defineProps = exports.defineExpose = exports.defineEmits = exports.defineComponent = exports.defineAsyncComponent = exports.createVNode = exports.createTextVNode = exports.createStaticVNode = exports.createSlots = exports.createRenderer = exports.createPropsRestProxy = exports.createHydrationRenderer = exports.createElementVNode = void 0;\nexports.withScopeId = exports.withMemo = exports.withDirectives = exports.withDefaults = exports.withCtx = exports.withAsyncContext = exports.watchSyncEffect = exports.watchPostEffect = exports.watchEffect = exports.watch = exports.warn = exports.version = exports.useTransitionState = exports.useSlots = exports.useSSRContext = exports.useAttrs = exports.transformVNodeArgs = exports.toHandlers = exports.ssrUtils = exports.ssrContextKey = exports.setTransitionHooks = exports.setDevtoolsHook = exports.setBlockTracking = exports.resolveTransitionHooks = exports.resolveFilter = void 0;\nconst reactivity_1 = __webpack_require__(/*! @vue/reactivity */ \"./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\");\nvar reactivity_2 = __webpack_require__(/*! @vue/reactivity */ \"./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\");\nObject.defineProperty(exports, \"EffectScope\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.EffectScope;\n  }\n}));\nObject.defineProperty(exports, \"ReactiveEffect\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.ReactiveEffect;\n  }\n}));\nObject.defineProperty(exports, \"customRef\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.customRef;\n  }\n}));\nObject.defineProperty(exports, \"effect\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.effect;\n  }\n}));\nObject.defineProperty(exports, \"effectScope\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.effectScope;\n  }\n}));\nObject.defineProperty(exports, \"getCurrentScope\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.getCurrentScope;\n  }\n}));\nObject.defineProperty(exports, \"isProxy\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.isProxy;\n  }\n}));\nObject.defineProperty(exports, \"isReactive\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.isReactive;\n  }\n}));\nObject.defineProperty(exports, \"isReadonly\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.isReadonly;\n  }\n}));\nObject.defineProperty(exports, \"isRef\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.isRef;\n  }\n}));\nObject.defineProperty(exports, \"isShallow\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.isShallow;\n  }\n}));\nObject.defineProperty(exports, \"markRaw\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.markRaw;\n  }\n}));\nObject.defineProperty(exports, \"onScopeDispose\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.onScopeDispose;\n  }\n}));\nObject.defineProperty(exports, \"proxyRefs\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.proxyRefs;\n  }\n}));\nObject.defineProperty(exports, \"reactive\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.reactive;\n  }\n}));\nObject.defineProperty(exports, \"readonly\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.readonly;\n  }\n}));\nObject.defineProperty(exports, \"ref\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.ref;\n  }\n}));\nObject.defineProperty(exports, \"shallowReactive\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.shallowReactive;\n  }\n}));\nObject.defineProperty(exports, \"shallowReadonly\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.shallowReadonly;\n  }\n}));\nObject.defineProperty(exports, \"shallowRef\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.shallowRef;\n  }\n}));\nObject.defineProperty(exports, \"stop\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.stop;\n  }\n}));\nObject.defineProperty(exports, \"toRaw\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.toRaw;\n  }\n}));\nObject.defineProperty(exports, \"toRef\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.toRef;\n  }\n}));\nObject.defineProperty(exports, \"toRefs\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.toRefs;\n  }\n}));\nObject.defineProperty(exports, \"triggerRef\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.triggerRef;\n  }\n}));\nObject.defineProperty(exports, \"unref\", ({\n  enumerable: true,\n  get: function () {\n    return reactivity_2.unref;\n  }\n}));\nconst shared_1 = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/shared/dist/shared.esm-bundler.js\");\nvar shared_2 = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/shared/dist/shared.esm-bundler.js\");\nObject.defineProperty(exports, \"camelize\", ({\n  enumerable: true,\n  get: function () {\n    return shared_2.camelize;\n  }\n}));\nObject.defineProperty(exports, \"capitalize\", ({\n  enumerable: true,\n  get: function () {\n    return shared_2.capitalize;\n  }\n}));\nObject.defineProperty(exports, \"normalizeClass\", ({\n  enumerable: true,\n  get: function () {\n    return shared_2.normalizeClass;\n  }\n}));\nObject.defineProperty(exports, \"normalizeProps\", ({\n  enumerable: true,\n  get: function () {\n    return shared_2.normalizeProps;\n  }\n}));\nObject.defineProperty(exports, \"normalizeStyle\", ({\n  enumerable: true,\n  get: function () {\n    return shared_2.normalizeStyle;\n  }\n}));\nObject.defineProperty(exports, \"toDisplayString\", ({\n  enumerable: true,\n  get: function () {\n    return shared_2.toDisplayString;\n  }\n}));\nObject.defineProperty(exports, \"toHandlerKey\", ({\n  enumerable: true,\n  get: function () {\n    return shared_2.toHandlerKey;\n  }\n}));\nconst stack = [];\nfunction pushWarningContext(vnode) {\n  stack.push(vnode);\n}\nfunction popWarningContext() {\n  stack.pop();\n}\nfunction warn(msg) {\n  if (false) {}\n  // avoid props formatting or warn handler tracking deps that might be mutated\n  // during patch, leading to infinite recursion.\n  (0, reactivity_1.pauseTracking)();\n  const instance = stack.length ? stack[stack.length - 1].component : null;\n  const appWarnHandler = instance && instance.appContext.config.warnHandler;\n  const trace = getComponentTrace();\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n  if (appWarnHandler) {\n    callWithErrorHandling(appWarnHandler, instance, 11 /* ErrorCodes.APP_WARN_HANDLER */, [msg + args.join(''), instance && instance.proxy, trace.map(_ref => {\n      let {\n        vnode\n      } = _ref;\n      return `at <${formatComponentName(instance, vnode.type)}>`;\n    }).join('\\n'), trace]);\n  } else {\n    const warnArgs = [`[Vue warn]: ${msg}`, ...args];\n    /* istanbul ignore if */\n    if (trace.length &&\n    // avoid spamming console during tests\n    !false) {\n      warnArgs.push(`\\n`, ...formatTrace(trace));\n    }\n    console.warn(...warnArgs);\n  }\n  (0, reactivity_1.resetTracking)();\n}\nexports.warn = warn;\nfunction getComponentTrace() {\n  let currentVNode = stack[stack.length - 1];\n  if (!currentVNode) {\n    return [];\n  }\n  // we can't just use the stack because it will be incomplete during updates\n  // that did not start from the root. Re-construct the parent chain using\n  // instance parent pointers.\n  const normalizedStack = [];\n  while (currentVNode) {\n    const last = normalizedStack[0];\n    if (last && last.vnode === currentVNode) {\n      last.recurseCount++;\n    } else {\n      normalizedStack.push({\n        vnode: currentVNode,\n        recurseCount: 0\n      });\n    }\n    const parentInstance = currentVNode.component && currentVNode.component.parent;\n    currentVNode = parentInstance && parentInstance.vnode;\n  }\n  return normalizedStack;\n}\n/* istanbul ignore next */\nfunction formatTrace(trace) {\n  const logs = [];\n  trace.forEach((entry, i) => {\n    logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\n  });\n  return logs;\n}\nfunction formatTraceEntry(_ref2) {\n  let {\n    vnode,\n    recurseCount\n  } = _ref2;\n  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\n  const isRoot = vnode.component ? vnode.component.parent == null : false;\n  const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\n  const close = `>` + postfix;\n  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];\n}\n/* istanbul ignore next */\nfunction formatProps(props) {\n  const res = [];\n  const keys = Object.keys(props);\n  keys.slice(0, 3).forEach(key => {\n    res.push(...formatProp(key, props[key]));\n  });\n  if (keys.length > 3) {\n    res.push(` ...`);\n  }\n  return res;\n}\n/* istanbul ignore next */\nfunction formatProp(key, value, raw) {\n  if ((0, shared_1.isString)(value)) {\n    value = JSON.stringify(value);\n    return raw ? value : [`${key}=${value}`];\n  } else if (typeof value === 'number' || typeof value === 'boolean' || value == null) {\n    return raw ? value : [`${key}=${value}`];\n  } else if ((0, reactivity_1.isRef)(value)) {\n    value = formatProp(key, (0, reactivity_1.toRaw)(value.value), true);\n    return raw ? value : [`${key}=Ref<`, value, `>`];\n  } else if ((0, shared_1.isFunction)(value)) {\n    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\n  } else {\n    value = (0, reactivity_1.toRaw)(value);\n    return raw ? value : [`${key}=`, value];\n  }\n}\n/**\n * @internal\n */\nfunction assertNumber(val, type) {\n  if (false) {}\n  if (val === undefined) {\n    return;\n  } else if (typeof val !== 'number') {\n    warn(`${type} is not a valid number - ` + `got ${JSON.stringify(val)}.`);\n  } else if (isNaN(val)) {\n    warn(`${type} is NaN - ` + 'the duration expression might be incorrect.');\n  }\n}\nexports.assertNumber = assertNumber;\nconst ErrorTypeStrings = {\n  [\"sp\" /* LifecycleHooks.SERVER_PREFETCH */]: 'serverPrefetch hook',\n  [\"bc\" /* LifecycleHooks.BEFORE_CREATE */]: 'beforeCreate hook',\n  [\"c\" /* LifecycleHooks.CREATED */]: 'created hook',\n  [\"bm\" /* LifecycleHooks.BEFORE_MOUNT */]: 'beforeMount hook',\n  [\"m\" /* LifecycleHooks.MOUNTED */]: 'mounted hook',\n  [\"bu\" /* LifecycleHooks.BEFORE_UPDATE */]: 'beforeUpdate hook',\n  [\"u\" /* LifecycleHooks.UPDATED */]: 'updated',\n  [\"bum\" /* LifecycleHooks.BEFORE_UNMOUNT */]: 'beforeUnmount hook',\n  [\"um\" /* LifecycleHooks.UNMOUNTED */]: 'unmounted hook',\n  [\"a\" /* LifecycleHooks.ACTIVATED */]: 'activated hook',\n  [\"da\" /* LifecycleHooks.DEACTIVATED */]: 'deactivated hook',\n  [\"ec\" /* LifecycleHooks.ERROR_CAPTURED */]: 'errorCaptured hook',\n  [\"rtc\" /* LifecycleHooks.RENDER_TRACKED */]: 'renderTracked hook',\n  [\"rtg\" /* LifecycleHooks.RENDER_TRIGGERED */]: 'renderTriggered hook',\n  [0 /* ErrorCodes.SETUP_FUNCTION */]: 'setup function',\n  [1 /* ErrorCodes.RENDER_FUNCTION */]: 'render function',\n  [2 /* ErrorCodes.WATCH_GETTER */]: 'watcher getter',\n  [3 /* ErrorCodes.WATCH_CALLBACK */]: 'watcher callback',\n  [4 /* ErrorCodes.WATCH_CLEANUP */]: 'watcher cleanup function',\n  [5 /* ErrorCodes.NATIVE_EVENT_HANDLER */]: 'native event handler',\n  [6 /* ErrorCodes.COMPONENT_EVENT_HANDLER */]: 'component event handler',\n  [7 /* ErrorCodes.VNODE_HOOK */]: 'vnode hook',\n  [8 /* ErrorCodes.DIRECTIVE_HOOK */]: 'directive hook',\n  [9 /* ErrorCodes.TRANSITION_HOOK */]: 'transition hook',\n  [10 /* ErrorCodes.APP_ERROR_HANDLER */]: 'app errorHandler',\n  [11 /* ErrorCodes.APP_WARN_HANDLER */]: 'app warnHandler',\n  [12 /* ErrorCodes.FUNCTION_REF */]: 'ref function',\n  [13 /* ErrorCodes.ASYNC_COMPONENT_LOADER */]: 'async component loader',\n  [14 /* ErrorCodes.SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' + 'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'\n};\nfunction callWithErrorHandling(fn, instance, type, args) {\n  let res;\n  try {\n    res = args ? fn(...args) : fn();\n  } catch (err) {\n    handleError(err, instance, type);\n  }\n  return res;\n}\nexports.callWithErrorHandling = callWithErrorHandling;\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\n  if ((0, shared_1.isFunction)(fn)) {\n    const res = callWithErrorHandling(fn, instance, type, args);\n    if (res && (0, shared_1.isPromise)(res)) {\n      res.catch(err => {\n        handleError(err, instance, type);\n      });\n    }\n    return res;\n  }\n  const values = [];\n  for (let i = 0; i < fn.length; i++) {\n    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\n  }\n  return values;\n}\nexports.callWithAsyncErrorHandling = callWithAsyncErrorHandling;\nfunction handleError(err, instance, type) {\n  let throwInDev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  const contextVNode = instance ? instance.vnode : null;\n  if (instance) {\n    let cur = instance.parent;\n    // the exposed instance is the render proxy to keep it consistent with 2.x\n    const exposedInstance = instance.proxy;\n    // in production the hook receives only the error code\n    const errorInfo =  true ? ErrorTypeStrings[type] : 0;\n    while (cur) {\n      const errorCapturedHooks = cur.ec;\n      if (errorCapturedHooks) {\n        for (let i = 0; i < errorCapturedHooks.length; i++) {\n          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\n            return;\n          }\n        }\n      }\n      cur = cur.parent;\n    }\n    // app-level handling\n    const appErrorHandler = instance.appContext.config.errorHandler;\n    if (appErrorHandler) {\n      callWithErrorHandling(appErrorHandler, null, 10 /* ErrorCodes.APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\n      return;\n    }\n  }\n  logError(err, type, contextVNode, throwInDev);\n}\nexports.handleError = handleError;\nfunction logError(err, type, contextVNode) {\n  let throwInDev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  if (true) {\n    const info = ErrorTypeStrings[type];\n    if (contextVNode) {\n      pushWarningContext(contextVNode);\n    }\n    warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\n    if (contextVNode) {\n      popWarningContext();\n    }\n    // crash in dev by default so it's more noticeable\n    if (throwInDev) {\n      throw err;\n    } else {\n      console.error(err);\n    }\n  } else {}\n}\nlet isFlushing = false;\nlet isFlushPending = false;\nconst queue = [];\nlet flushIndex = 0;\nconst pendingPostFlushCbs = [];\nlet activePostFlushCbs = null;\nlet postFlushIndex = 0;\nconst resolvedPromise = /*#__PURE__*/Promise.resolve();\nlet currentFlushPromise = null;\nconst RECURSION_LIMIT = 100;\nfunction nextTick(fn) {\n  const p = currentFlushPromise || resolvedPromise;\n  return fn ? p.then(this ? fn.bind(this) : fn) : p;\n}\nexports.nextTick = nextTick;\n// #2768\n// Use binary-search to find a suitable position in the queue,\n// so that the queue maintains the increasing order of job's id,\n// which can prevent the job from being skipped and also can avoid repeated patching.\nfunction findInsertionIndex(id) {\n  // the start index should be `flushIndex + 1`\n  let start = flushIndex + 1;\n  let end = queue.length;\n  while (start < end) {\n    const middle = start + end >>> 1;\n    const middleJobId = getId(queue[middle]);\n    middleJobId < id ? start = middle + 1 : end = middle;\n  }\n  return start;\n}\nfunction queueJob(job) {\n  // the dedupe search uses the startIndex argument of Array.includes()\n  // by default the search index includes the current job that is being run\n  // so it cannot recursively trigger itself again.\n  // if the job is a watch() callback, the search will start with a +1 index to\n  // allow it recursively trigger itself - it is the user's responsibility to\n  // ensure it doesn't end up in an infinite loop.\n  if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {\n    if (job.id == null) {\n      queue.push(job);\n    } else {\n      queue.splice(findInsertionIndex(job.id), 0, job);\n    }\n    queueFlush();\n  }\n}\nfunction queueFlush() {\n  if (!isFlushing && !isFlushPending) {\n    isFlushPending = true;\n    currentFlushPromise = resolvedPromise.then(flushJobs);\n  }\n}\nfunction invalidateJob(job) {\n  const i = queue.indexOf(job);\n  if (i > flushIndex) {\n    queue.splice(i, 1);\n  }\n}\nfunction queuePostFlushCb(cb) {\n  if (!(0, shared_1.isArray)(cb)) {\n    if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {\n      pendingPostFlushCbs.push(cb);\n    }\n  } else {\n    // if cb is an array, it is a component lifecycle hook which can only be\n    // triggered by a job, which is already deduped in the main queue, so\n    // we can skip duplicate check here to improve perf\n    pendingPostFlushCbs.push(...cb);\n  }\n  queueFlush();\n}\nexports.queuePostFlushCb = queuePostFlushCb;\nfunction flushPreFlushCbs(seen) {\n  let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : isFlushing ? flushIndex + 1 : 0;\n  if (true) {\n    seen = seen || new Map();\n  }\n  for (; i < queue.length; i++) {\n    const cb = queue[i];\n    if (cb && cb.pre) {\n      if ( true && checkRecursiveUpdates(seen, cb)) {\n        continue;\n      }\n      queue.splice(i, 1);\n      i--;\n      cb();\n    }\n  }\n}\nfunction flushPostFlushCbs(seen) {\n  if (pendingPostFlushCbs.length) {\n    const deduped = [...new Set(pendingPostFlushCbs)];\n    pendingPostFlushCbs.length = 0;\n    // #1947 already has active queue, nested flushPostFlushCbs call\n    if (activePostFlushCbs) {\n      activePostFlushCbs.push(...deduped);\n      return;\n    }\n    activePostFlushCbs = deduped;\n    if (true) {\n      seen = seen || new Map();\n    }\n    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\n    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\n      if ( true && checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {\n        continue;\n      }\n      activePostFlushCbs[postFlushIndex]();\n    }\n    activePostFlushCbs = null;\n    postFlushIndex = 0;\n  }\n}\nconst getId = job => job.id == null ? Infinity : job.id;\nconst comparator = (a, b) => {\n  const diff = getId(a) - getId(b);\n  if (diff === 0) {\n    if (a.pre && !b.pre) return -1;\n    if (b.pre && !a.pre) return 1;\n  }\n  return diff;\n};\nfunction flushJobs(seen) {\n  isFlushPending = false;\n  isFlushing = true;\n  if (true) {\n    seen = seen || new Map();\n  }\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child so its render effect will have smaller\n  //    priority number)\n  // 2. If a component is unmounted during a parent component's update,\n  //    its update can be skipped.\n  queue.sort(comparator);\n  // conditional usage of checkRecursiveUpdate must be determined out of\n  // try ... catch block since Rollup by default de-optimizes treeshaking\n  // inside try-catch. This can leave all warning code unshaked. Although\n  // they would get eventually shaken by a minifier like terser, some minifiers\n  // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)\n  const check =  true ? job => checkRecursiveUpdates(seen, job) : 0;\n  try {\n    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\n      const job = queue[flushIndex];\n      if (job && job.active !== false) {\n        if ( true && check(job)) {\n          continue;\n        }\n        // console.log(`running:`, job.id)\n        callWithErrorHandling(job, null, 14 /* ErrorCodes.SCHEDULER */);\n      }\n    }\n  } finally {\n    flushIndex = 0;\n    queue.length = 0;\n    flushPostFlushCbs(seen);\n    isFlushing = false;\n    currentFlushPromise = null;\n    // some postFlushCb queued jobs!\n    // keep flushing until it drains.\n    if (queue.length || pendingPostFlushCbs.length) {\n      flushJobs(seen);\n    }\n  }\n}\nfunction checkRecursiveUpdates(seen, fn) {\n  if (!seen.has(fn)) {\n    seen.set(fn, 1);\n  } else {\n    const count = seen.get(fn);\n    if (count > RECURSION_LIMIT) {\n      const instance = fn.ownerInstance;\n      const componentName = instance && getComponentName(instance.type);\n      warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. ` + `This means you have a reactive effect that is mutating its own ` + `dependencies and thus recursively triggering itself. Possible sources ` + `include component template, render function, updated hook or ` + `watcher source function.`);\n      return true;\n    } else {\n      seen.set(fn, count + 1);\n    }\n  }\n}\n/* eslint-disable no-restricted-globals */\nlet isHmrUpdating = false;\nconst hmrDirtyComponents = new Set();\n// Expose the HMR runtime on the global object\n// This makes it entirely tree-shakable without polluting the exports and makes\n// it easier to be used in toolings like vue-loader\n// Note: for a component to be eligible for HMR it also needs the __hmrId option\n// to be set so that its instances can be registered / removed.\nif (true) {\n  (0, shared_1.getGlobalThis)().__VUE_HMR_RUNTIME__ = {\n    createRecord: tryWrap(createRecord),\n    rerender: tryWrap(rerender),\n    reload: tryWrap(reload)\n  };\n}\nconst map = new Map();\nfunction registerHMR(instance) {\n  const id = instance.type.__hmrId;\n  let record = map.get(id);\n  if (!record) {\n    createRecord(id, instance.type);\n    record = map.get(id);\n  }\n  record.instances.add(instance);\n}\nfunction unregisterHMR(instance) {\n  map.get(instance.type.__hmrId).instances.delete(instance);\n}\nfunction createRecord(id, initialDef) {\n  if (map.has(id)) {\n    return false;\n  }\n  map.set(id, {\n    initialDef: normalizeClassComponent(initialDef),\n    instances: new Set()\n  });\n  return true;\n}\nfunction normalizeClassComponent(component) {\n  return isClassComponent(component) ? component.__vccOpts : component;\n}\nfunction rerender(id, newRender) {\n  const record = map.get(id);\n  if (!record) {\n    return;\n  }\n  // update initial record (for not-yet-rendered component)\n  record.initialDef.render = newRender;\n  [...record.instances].forEach(instance => {\n    if (newRender) {\n      instance.render = newRender;\n      normalizeClassComponent(instance.type).render = newRender;\n    }\n    instance.renderCache = [];\n    // this flag forces child components with slot content to update\n    isHmrUpdating = true;\n    instance.update();\n    isHmrUpdating = false;\n  });\n}\nfunction reload(id, newComp) {\n  const record = map.get(id);\n  if (!record) return;\n  newComp = normalizeClassComponent(newComp);\n  // update initial def (for not-yet-rendered components)\n  updateComponentDef(record.initialDef, newComp);\n  // create a snapshot which avoids the set being mutated during updates\n  const instances = [...record.instances];\n  for (const instance of instances) {\n    const oldComp = normalizeClassComponent(instance.type);\n    if (!hmrDirtyComponents.has(oldComp)) {\n      // 1. Update existing comp definition to match new one\n      if (oldComp !== record.initialDef) {\n        updateComponentDef(oldComp, newComp);\n      }\n      // 2. mark definition dirty. This forces the renderer to replace the\n      // component on patch.\n      hmrDirtyComponents.add(oldComp);\n    }\n    // 3. invalidate options resolution cache\n    instance.appContext.optionsCache.delete(instance.type);\n    // 4. actually update\n    if (instance.ceReload) {\n      // custom element\n      hmrDirtyComponents.add(oldComp);\n      instance.ceReload(newComp.styles);\n      hmrDirtyComponents.delete(oldComp);\n    } else if (instance.parent) {\n      // 4. Force the parent instance to re-render. This will cause all updated\n      // components to be unmounted and re-mounted. Queue the update so that we\n      // don't end up forcing the same parent to re-render multiple times.\n      queueJob(instance.parent.update);\n    } else if (instance.appContext.reload) {\n      // root instance mounted via createApp() has a reload method\n      instance.appContext.reload();\n    } else if (typeof window !== 'undefined') {\n      // root instance inside tree created via raw render(). Force reload.\n      window.location.reload();\n    } else {\n      console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');\n    }\n  }\n  // 5. make sure to cleanup dirty hmr components after update\n  queuePostFlushCb(() => {\n    for (const instance of instances) {\n      hmrDirtyComponents.delete(normalizeClassComponent(instance.type));\n    }\n  });\n}\nfunction updateComponentDef(oldComp, newComp) {\n  (0, shared_1.extend)(oldComp, newComp);\n  for (const key in oldComp) {\n    if (key !== '__file' && !(key in newComp)) {\n      delete oldComp[key];\n    }\n  }\n}\nfunction tryWrap(fn) {\n  return (id, arg) => {\n    try {\n      return fn(id, arg);\n    } catch (e) {\n      console.error(e);\n      console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` + `Full reload required.`);\n    }\n  };\n}\nlet devtools;\nexports.devtools = devtools;\nlet buffer = [];\nlet devtoolsNotInstalled = false;\nfunction emit$1(event) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n  if (devtools) {\n    devtools.emit(event, ...args);\n  } else if (!devtoolsNotInstalled) {\n    buffer.push({\n      event,\n      args\n    });\n  }\n}\nfunction setDevtoolsHook(hook, target) {\n  var _a, _b;\n  exports.devtools = devtools = hook;\n  if (devtools) {\n    devtools.enabled = true;\n    buffer.forEach(_ref3 => {\n      let {\n        event,\n        args\n      } = _ref3;\n      return devtools.emit(event, ...args);\n    });\n    buffer = [];\n  } else if (\n  // handle late devtools injection - only do this if we are in an actual\n  // browser environment to avoid the timer handle stalling test runner exit\n  // (#4815)\n  typeof window !== 'undefined' &&\n  // some envs mock window but not fully\n  window.HTMLElement &&\n  // also exclude jsdom\n  !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes('jsdom'))) {\n    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];\n    replay.push(newHook => {\n      setDevtoolsHook(newHook, target);\n    });\n    // clear buffer after 3s - the user probably doesn't have devtools installed\n    // at all, and keeping the buffer will cause memory leaks (#4738)\n    setTimeout(() => {\n      if (!devtools) {\n        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;\n        devtoolsNotInstalled = true;\n        buffer = [];\n      }\n    }, 3000);\n  } else {\n    // non-browser env, assume not installed\n    devtoolsNotInstalled = true;\n    buffer = [];\n  }\n}\nexports.setDevtoolsHook = setDevtoolsHook;\nfunction devtoolsInitApp(app, version) {\n  emit$1(\"app:init\" /* DevtoolsHooks.APP_INIT */, app, version, {\n    Fragment,\n    Text,\n    Comment,\n    Static\n  });\n}\nfunction devtoolsUnmountApp(app) {\n  emit$1(\"app:unmount\" /* DevtoolsHooks.APP_UNMOUNT */, app);\n}\nconst devtoolsComponentAdded = /*#__PURE__*/createDevtoolsComponentHook(\"component:added\" /* DevtoolsHooks.COMPONENT_ADDED */);\nconst devtoolsComponentUpdated = /*#__PURE__*/createDevtoolsComponentHook(\"component:updated\" /* DevtoolsHooks.COMPONENT_UPDATED */);\nconst _devtoolsComponentRemoved = /*#__PURE__*/createDevtoolsComponentHook(\"component:removed\" /* DevtoolsHooks.COMPONENT_REMOVED */);\nconst devtoolsComponentRemoved = component => {\n  if (devtools && typeof devtools.cleanupBuffer === 'function' &&\n  // remove the component if it wasn't buffered\n  !devtools.cleanupBuffer(component)) {\n    _devtoolsComponentRemoved(component);\n  }\n};\nfunction createDevtoolsComponentHook(hook) {\n  return component => {\n    emit$1(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);\n  };\n}\nconst devtoolsPerfStart = /*#__PURE__*/createDevtoolsPerformanceHook(\"perf:start\" /* DevtoolsHooks.PERFORMANCE_START */);\nconst devtoolsPerfEnd = /*#__PURE__*/createDevtoolsPerformanceHook(\"perf:end\" /* DevtoolsHooks.PERFORMANCE_END */);\nfunction createDevtoolsPerformanceHook(hook) {\n  return (component, type, time) => {\n    emit$1(hook, component.appContext.app, component.uid, component, type, time);\n  };\n}\nfunction devtoolsComponentEmit(component, event, params) {\n  emit$1(\"component:emit\" /* DevtoolsHooks.COMPONENT_EMIT */, component.appContext.app, component, event, params);\n}\nfunction emit(instance, event) {\n  if (instance.isUnmounted) return;\n  const props = instance.vnode.props || shared_1.EMPTY_OBJ;\n  for (var _len3 = arguments.length, rawArgs = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n    rawArgs[_key3 - 2] = arguments[_key3];\n  }\n  if (true) {\n    const {\n      emitsOptions,\n      propsOptions: [propsOptions]\n    } = instance;\n    if (emitsOptions) {\n      if (!(event in emitsOptions) && !false) {\n        if (!propsOptions || !((0, shared_1.toHandlerKey)(event) in propsOptions)) {\n          warn(`Component emitted event \"${event}\" but it is neither declared in ` + `the emits option nor as an \"${(0, shared_1.toHandlerKey)(event)}\" prop.`);\n        }\n      } else {\n        const validator = emitsOptions[event];\n        if ((0, shared_1.isFunction)(validator)) {\n          const isValid = validator(...rawArgs);\n          if (!isValid) {\n            warn(`Invalid event arguments: event validation failed for event \"${event}\".`);\n          }\n        }\n      }\n    }\n  }\n  let args = rawArgs;\n  const isModelListener = event.startsWith('update:');\n  // for v-model update:xxx events, apply modifiers on args\n  const modelArg = isModelListener && event.slice(7);\n  if (modelArg && modelArg in props) {\n    const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;\n    const {\n      number,\n      trim\n    } = props[modifiersKey] || shared_1.EMPTY_OBJ;\n    if (trim) {\n      args = rawArgs.map(a => (0, shared_1.isString)(a) ? a.trim() : a);\n    }\n    if (number) {\n      args = rawArgs.map(shared_1.looseToNumber);\n    }\n  }\n  if (true) {\n    devtoolsComponentEmit(instance, event, args);\n  }\n  if (true) {\n    const lowerCaseEvent = event.toLowerCase();\n    if (lowerCaseEvent !== event && props[(0, shared_1.toHandlerKey)(lowerCaseEvent)]) {\n      warn(`Event \"${lowerCaseEvent}\" is emitted in component ` + `${formatComponentName(instance, instance.type)} but the handler is registered for \"${event}\". ` + `Note that HTML attributes are case-insensitive and you cannot use ` + `v-on to listen to camelCase events when using in-DOM templates. ` + `You should probably use \"${(0, shared_1.hyphenate)(event)}\" instead of \"${event}\".`);\n    }\n  }\n  let handlerName;\n  let handler = props[handlerName = (0, shared_1.toHandlerKey)(event)] ||\n  // also try camelCase event handler (#2249)\n  props[handlerName = (0, shared_1.toHandlerKey)((0, shared_1.camelize)(event))];\n  // for v-model update:xxx events, also trigger kebab-case equivalent\n  // for props passed via kebab-case\n  if (!handler && isModelListener) {\n    handler = props[handlerName = (0, shared_1.toHandlerKey)((0, shared_1.hyphenate)(event))];\n  }\n  if (handler) {\n    callWithAsyncErrorHandling(handler, instance, 6 /* ErrorCodes.COMPONENT_EVENT_HANDLER */, args);\n  }\n  const onceHandler = props[handlerName + `Once`];\n  if (onceHandler) {\n    if (!instance.emitted) {\n      instance.emitted = {};\n    } else if (instance.emitted[handlerName]) {\n      return;\n    }\n    instance.emitted[handlerName] = true;\n    callWithAsyncErrorHandling(onceHandler, instance, 6 /* ErrorCodes.COMPONENT_EVENT_HANDLER */, args);\n  }\n}\nfunction normalizeEmitsOptions(comp, appContext) {\n  let asMixin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const cache = appContext.emitsCache;\n  const cached = cache.get(comp);\n  if (cached !== undefined) {\n    return cached;\n  }\n  const raw = comp.emits;\n  let normalized = {};\n  // apply mixin/extends props\n  let hasExtends = false;\n  if (__VUE_OPTIONS_API__ && !(0, shared_1.isFunction)(comp)) {\n    const extendEmits = raw => {\n      const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);\n      if (normalizedFromExtend) {\n        hasExtends = true;\n        (0, shared_1.extend)(normalized, normalizedFromExtend);\n      }\n    };\n    if (!asMixin && appContext.mixins.length) {\n      appContext.mixins.forEach(extendEmits);\n    }\n    if (comp.extends) {\n      extendEmits(comp.extends);\n    }\n    if (comp.mixins) {\n      comp.mixins.forEach(extendEmits);\n    }\n  }\n  if (!raw && !hasExtends) {\n    if ((0, shared_1.isObject)(comp)) {\n      cache.set(comp, null);\n    }\n    return null;\n  }\n  if ((0, shared_1.isArray)(raw)) {\n    raw.forEach(key => normalized[key] = null);\n  } else {\n    (0, shared_1.extend)(normalized, raw);\n  }\n  if ((0, shared_1.isObject)(comp)) {\n    cache.set(comp, normalized);\n  }\n  return normalized;\n}\n// Check if an incoming prop key is a declared emit event listener.\n// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are\n// both considered matched listeners.\nfunction isEmitListener(options, key) {\n  if (!options || !(0, shared_1.isOn)(key)) {\n    return false;\n  }\n  key = key.slice(2).replace(/Once$/, '');\n  return (0, shared_1.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) || (0, shared_1.hasOwn)(options, (0, shared_1.hyphenate)(key)) || (0, shared_1.hasOwn)(options, key);\n}\n/**\n * mark the current rendering instance for asset resolution (e.g.\n * resolveComponent, resolveDirective) during render\n */\nlet currentRenderingInstance = null;\nlet currentScopeId = null;\n/**\n * Note: rendering calls maybe nested. The function returns the parent rendering\n * instance if present, which should be restored after the render is done:\n *\n * ```js\n * const prev = setCurrentRenderingInstance(i)\n * // ...render\n * setCurrentRenderingInstance(prev)\n * ```\n */\nfunction setCurrentRenderingInstance(instance) {\n  const prev = currentRenderingInstance;\n  currentRenderingInstance = instance;\n  currentScopeId = instance && instance.type.__scopeId || null;\n  return prev;\n}\n/**\n * Set scope id when creating hoisted vnodes.\n * @private compiler helper\n */\nfunction pushScopeId(id) {\n  currentScopeId = id;\n}\nexports.pushScopeId = pushScopeId;\n/**\n * Technically we no longer need this after 3.0.8 but we need to keep the same\n * API for backwards compat w/ code generated by compilers.\n * @private\n */\nfunction popScopeId() {\n  currentScopeId = null;\n}\nexports.popScopeId = popScopeId;\n/**\n * Only for backwards compat\n * @private\n */\nconst withScopeId = _id => withCtx;\nexports.withScopeId = withScopeId;\n/**\n * Wrap a slot function to memoize current rendering instance\n * @private compiler helper\n */\nfunction withCtx(fn) {\n  let ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentRenderingInstance;\n  let isNonScopedSlot // false only\n  = arguments.length > 2 ? arguments[2] : undefined;\n  if (!ctx) return fn;\n  // already normalized\n  if (fn._n) {\n    return fn;\n  }\n  const renderFnWithContext = function () {\n    // If a user calls a compiled slot inside a template expression (#1745), it\n    // can mess up block tracking, so by default we disable block tracking and\n    // force bail out when invoking a compiled slot (indicated by the ._d flag).\n    // This isn't necessary if rendering a compiled `<slot>`, so we flip the\n    // ._d flag off when invoking the wrapped fn inside `renderSlot`.\n    if (renderFnWithContext._d) {\n      setBlockTracking(-1);\n    }\n    const prevInstance = setCurrentRenderingInstance(ctx);\n    let res;\n    try {\n      res = fn(...arguments);\n    } finally {\n      setCurrentRenderingInstance(prevInstance);\n      if (renderFnWithContext._d) {\n        setBlockTracking(1);\n      }\n    }\n    if (true) {\n      devtoolsComponentUpdated(ctx);\n    }\n    return res;\n  };\n  // mark normalized to avoid duplicated wrapping\n  renderFnWithContext._n = true;\n  // mark this as compiled by default\n  // this is used in vnode.ts -> normalizeChildren() to set the slot\n  // rendering flag.\n  renderFnWithContext._c = true;\n  // disable block tracking by default\n  renderFnWithContext._d = true;\n  return renderFnWithContext;\n}\nexports.withCtx = withCtx;\n/**\n * dev only flag to track whether $attrs was used during render.\n * If $attrs was used during render then the warning for failed attrs\n * fallthrough can be suppressed.\n */\nlet accessedAttrs = false;\nfunction markAttrsAccessed() {\n  accessedAttrs = true;\n}\nfunction renderComponentRoot(instance) {\n  const {\n    type: Component,\n    vnode,\n    proxy,\n    withProxy,\n    props,\n    propsOptions: [propsOptions],\n    slots,\n    attrs,\n    emit,\n    render,\n    renderCache,\n    data,\n    setupState,\n    ctx,\n    inheritAttrs\n  } = instance;\n  let result;\n  let fallthroughAttrs;\n  const prev = setCurrentRenderingInstance(instance);\n  if (true) {\n    accessedAttrs = false;\n  }\n  try {\n    if (vnode.shapeFlag & 4 /* ShapeFlags.STATEFUL_COMPONENT */) {\n      // withProxy is a proxy with a different `has` trap only for\n      // runtime-compiled render functions using `with` block.\n      const proxyToUse = withProxy || proxy;\n      result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));\n      fallthroughAttrs = attrs;\n    } else {\n      // functional\n      const render = Component;\n      // in dev, mark attrs accessed if optional props (attrs === props)\n      if ( true && attrs === props) {\n        markAttrsAccessed();\n      }\n      result = normalizeVNode(render.length > 1 ? render(props,  true ? {\n        get attrs() {\n          markAttrsAccessed();\n          return attrs;\n        },\n        slots,\n        emit\n      } : 0) : render(props, null /* we know it doesn't need it */));\n      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);\n    }\n  } catch (err) {\n    blockStack.length = 0;\n    handleError(err, instance, 1 /* ErrorCodes.RENDER_FUNCTION */);\n    result = createVNode(Comment);\n  }\n  // attr merging\n  // in dev mode, comments are preserved, and it's possible for a template\n  // to have comments along side the root element which makes it a fragment\n  let root = result;\n  let setRoot = undefined;\n  if ( true && result.patchFlag > 0 && result.patchFlag & 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */) {\n    [root, setRoot] = getChildRoot(result);\n  }\n  if (fallthroughAttrs && inheritAttrs !== false) {\n    const keys = Object.keys(fallthroughAttrs);\n    const {\n      shapeFlag\n    } = root;\n    if (keys.length) {\n      if (shapeFlag & (1 /* ShapeFlags.ELEMENT */ | 6 /* ShapeFlags.COMPONENT */)) {\n        if (propsOptions && keys.some(shared_1.isModelListener)) {\n          // If a v-model listener (onUpdate:xxx) has a corresponding declared\n          // prop, it indicates this component expects to handle v-model and\n          // it should not fallthrough.\n          // related: #1543, #1643, #1989\n          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);\n        }\n        root = cloneVNode(root, fallthroughAttrs);\n      } else if ( true && !accessedAttrs && root.type !== Comment) {\n        const allAttrs = Object.keys(attrs);\n        const eventAttrs = [];\n        const extraAttrs = [];\n        for (let i = 0, l = allAttrs.length; i < l; i++) {\n          const key = allAttrs[i];\n          if ((0, shared_1.isOn)(key)) {\n            // ignore v-model handlers when they fail to fallthrough\n            if (!(0, shared_1.isModelListener)(key)) {\n              // remove `on`, lowercase first letter to reflect event casing\n              // accurately\n              eventAttrs.push(key[2].toLowerCase() + key.slice(3));\n            }\n          } else {\n            extraAttrs.push(key);\n          }\n        }\n        if (extraAttrs.length) {\n          warn(`Extraneous non-props attributes (` + `${extraAttrs.join(', ')}) ` + `were passed to component but could not be automatically inherited ` + `because component renders fragment or text root nodes.`);\n        }\n        if (eventAttrs.length) {\n          warn(`Extraneous non-emits event listeners (` + `${eventAttrs.join(', ')}) ` + `were passed to component but could not be automatically inherited ` + `because component renders fragment or text root nodes. ` + `If the listener is intended to be a component custom event listener only, ` + `declare it using the \"emits\" option.`);\n        }\n      }\n    }\n  }\n  // inherit directives\n  if (vnode.dirs) {\n    if ( true && !isElementRoot(root)) {\n      warn(`Runtime directive used on component with non-element root node. ` + `The directives will not function as intended.`);\n    }\n    // clone before mutating since the root may be a hoisted vnode\n    root = cloneVNode(root);\n    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;\n  }\n  // inherit transition data\n  if (vnode.transition) {\n    if ( true && !isElementRoot(root)) {\n      warn(`Component inside <Transition> renders non-element root node ` + `that cannot be animated.`);\n    }\n    root.transition = vnode.transition;\n  }\n  if ( true && setRoot) {\n    setRoot(root);\n  } else {\n    result = root;\n  }\n  setCurrentRenderingInstance(prev);\n  return result;\n}\n/**\n * dev only\n * In dev mode, template root level comments are rendered, which turns the\n * template into a fragment root, but we need to locate the single element\n * root for attrs and scope id processing.\n */\nconst getChildRoot = vnode => {\n  const rawChildren = vnode.children;\n  const dynamicChildren = vnode.dynamicChildren;\n  const childRoot = filterSingleRoot(rawChildren);\n  if (!childRoot) {\n    return [vnode, undefined];\n  }\n  const index = rawChildren.indexOf(childRoot);\n  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;\n  const setRoot = updatedRoot => {\n    rawChildren[index] = updatedRoot;\n    if (dynamicChildren) {\n      if (dynamicIndex > -1) {\n        dynamicChildren[dynamicIndex] = updatedRoot;\n      } else if (updatedRoot.patchFlag > 0) {\n        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];\n      }\n    }\n  };\n  return [normalizeVNode(childRoot), setRoot];\n};\nfunction filterSingleRoot(children) {\n  let singleRoot;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (isVNode(child)) {\n      // ignore user comment\n      if (child.type !== Comment || child.children === 'v-if') {\n        if (singleRoot) {\n          // has more than 1 non-comment child, return now\n          return;\n        } else {\n          singleRoot = child;\n        }\n      }\n    } else {\n      return;\n    }\n  }\n  return singleRoot;\n}\nconst getFunctionalFallthrough = attrs => {\n  let res;\n  for (const key in attrs) {\n    if (key === 'class' || key === 'style' || (0, shared_1.isOn)(key)) {\n      (res || (res = {}))[key] = attrs[key];\n    }\n  }\n  return res;\n};\nconst filterModelListeners = (attrs, props) => {\n  const res = {};\n  for (const key in attrs) {\n    if (!(0, shared_1.isModelListener)(key) || !(key.slice(9) in props)) {\n      res[key] = attrs[key];\n    }\n  }\n  return res;\n};\nconst isElementRoot = vnode => {\n  return vnode.shapeFlag & (6 /* ShapeFlags.COMPONENT */ | 1 /* ShapeFlags.ELEMENT */) || vnode.type === Comment // potential v-if branch switch\n  ;\n};\n\nfunction shouldUpdateComponent(prevVNode, nextVNode, optimized) {\n  const {\n    props: prevProps,\n    children: prevChildren,\n    component\n  } = prevVNode;\n  const {\n    props: nextProps,\n    children: nextChildren,\n    patchFlag\n  } = nextVNode;\n  const emits = component.emitsOptions;\n  // Parent component's render function was hot-updated. Since this may have\n  // caused the child component's slots content to have changed, we need to\n  // force the child to update as well.\n  if ( true && (prevChildren || nextChildren) && isHmrUpdating) {\n    return true;\n  }\n  // force child update for runtime directive or transition on component vnode.\n  if (nextVNode.dirs || nextVNode.transition) {\n    return true;\n  }\n  if (optimized && patchFlag >= 0) {\n    if (patchFlag & 1024 /* PatchFlags.DYNAMIC_SLOTS */) {\n      // slot content that references values that might have changed,\n      // e.g. in a v-for\n      return true;\n    }\n    if (patchFlag & 16 /* PatchFlags.FULL_PROPS */) {\n      if (!prevProps) {\n        return !!nextProps;\n      }\n      // presence of this flag indicates props are always non-null\n      return hasPropsChanged(prevProps, nextProps, emits);\n    } else if (patchFlag & 8 /* PatchFlags.PROPS */) {\n      const dynamicProps = nextVNode.dynamicProps;\n      for (let i = 0; i < dynamicProps.length; i++) {\n        const key = dynamicProps[i];\n        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {\n          return true;\n        }\n      }\n    }\n  } else {\n    // this path is only taken by manually written render functions\n    // so presence of any children leads to a forced update\n    if (prevChildren || nextChildren) {\n      if (!nextChildren || !nextChildren.$stable) {\n        return true;\n      }\n    }\n    if (prevProps === nextProps) {\n      return false;\n    }\n    if (!prevProps) {\n      return !!nextProps;\n    }\n    if (!nextProps) {\n      return true;\n    }\n    return hasPropsChanged(prevProps, nextProps, emits);\n  }\n  return false;\n}\nfunction hasPropsChanged(prevProps, nextProps, emitsOptions) {\n  const nextKeys = Object.keys(nextProps);\n  if (nextKeys.length !== Object.keys(prevProps).length) {\n    return true;\n  }\n  for (let i = 0; i < nextKeys.length; i++) {\n    const key = nextKeys[i];\n    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction updateHOCHostEl(_ref4, el // HostNode\n) {\n  let {\n    vnode,\n    parent\n  } = _ref4;\n  while (parent && parent.subTree === vnode) {\n    (vnode = parent.vnode).el = el;\n    parent = parent.parent;\n  }\n}\nconst isSuspense = type => type.__isSuspense;\n// Suspense exposes a component-like API, and is treated like a component\n// in the compiler, but internally it's a special built-in type that hooks\n// directly into the renderer.\nconst SuspenseImpl = {\n  name: 'Suspense',\n  // In order to make Suspense tree-shakable, we need to avoid importing it\n  // directly in the renderer. The renderer checks for the __isSuspense flag\n  // on a vnode's type and calls the `process` method, passing in renderer\n  // internals.\n  __isSuspense: true,\n  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized,\n  // platform-specific impl passed from renderer\n  rendererInternals) {\n    if (n1 == null) {\n      mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);\n    } else {\n      patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);\n    }\n  },\n  hydrate: hydrateSuspense,\n  create: createSuspenseBoundary,\n  normalize: normalizeSuspenseChildren\n};\n// Force-casted public typing for h and TSX props inference\nconst Suspense = SuspenseImpl;\nexports.Suspense = Suspense;\nfunction triggerEvent(vnode, name) {\n  const eventListener = vnode.props && vnode.props[name];\n  if ((0, shared_1.isFunction)(eventListener)) {\n    eventListener();\n  }\n}\nfunction mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {\n  const {\n    p: patch,\n    o: {\n      createElement\n    }\n  } = rendererInternals;\n  const hiddenContainer = createElement('div');\n  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals);\n  // start mounting the content subtree in an off-dom container\n  patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);\n  // now check if we have encountered any async deps\n  if (suspense.deps > 0) {\n    // has async\n    // invoke @fallback event\n    triggerEvent(vnode, 'onPending');\n    triggerEvent(vnode, 'onFallback');\n    // mount the fallback tree\n    patch(null, vnode.ssFallback, container, anchor, parentComponent, null,\n    // fallback tree will not have suspense context\n    isSVG, slotScopeIds);\n    setActiveBranch(suspense, vnode.ssFallback);\n  } else {\n    // Suspense has no async deps. Just resolve.\n    suspense.resolve();\n  }\n}\nfunction patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, _ref5) {\n  let {\n    p: patch,\n    um: unmount,\n    o: {\n      createElement\n    }\n  } = _ref5;\n  const suspense = n2.suspense = n1.suspense;\n  suspense.vnode = n2;\n  n2.el = n1.el;\n  const newBranch = n2.ssContent;\n  const newFallback = n2.ssFallback;\n  const {\n    activeBranch,\n    pendingBranch,\n    isInFallback,\n    isHydrating\n  } = suspense;\n  if (pendingBranch) {\n    suspense.pendingBranch = newBranch;\n    if (isSameVNodeType(newBranch, pendingBranch)) {\n      // same root type but content may have changed.\n      patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n      if (suspense.deps <= 0) {\n        suspense.resolve();\n      } else if (isInFallback) {\n        patch(activeBranch, newFallback, container, anchor, parentComponent, null,\n        // fallback tree will not have suspense context\n        isSVG, slotScopeIds, optimized);\n        setActiveBranch(suspense, newFallback);\n      }\n    } else {\n      // toggled before pending tree is resolved\n      suspense.pendingId++;\n      if (isHydrating) {\n        // if toggled before hydration is finished, the current DOM tree is\n        // no longer valid. set it as the active branch so it will be unmounted\n        // when resolved\n        suspense.isHydrating = false;\n        suspense.activeBranch = pendingBranch;\n      } else {\n        unmount(pendingBranch, parentComponent, suspense);\n      }\n      // increment pending ID. this is used to invalidate async callbacks\n      // reset suspense state\n      suspense.deps = 0;\n      // discard effects from pending branch\n      suspense.effects.length = 0;\n      // discard previous container\n      suspense.hiddenContainer = createElement('div');\n      if (isInFallback) {\n        // already in fallback state\n        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n        if (suspense.deps <= 0) {\n          suspense.resolve();\n        } else {\n          patch(activeBranch, newFallback, container, anchor, parentComponent, null,\n          // fallback tree will not have suspense context\n          isSVG, slotScopeIds, optimized);\n          setActiveBranch(suspense, newFallback);\n        }\n      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n        // toggled \"back\" to current active branch\n        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n        // force resolve\n        suspense.resolve(true);\n      } else {\n        // switched to a 3rd branch\n        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n        if (suspense.deps <= 0) {\n          suspense.resolve();\n        }\n      }\n    }\n  } else {\n    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n      // root did not change, just normal patch\n      patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n      setActiveBranch(suspense, newBranch);\n    } else {\n      // root node toggled\n      // invoke @pending event\n      triggerEvent(n2, 'onPending');\n      // mount pending branch in off-dom container\n      suspense.pendingBranch = newBranch;\n      suspense.pendingId++;\n      patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n      if (suspense.deps <= 0) {\n        // incoming branch has no async deps, resolve now.\n        suspense.resolve();\n      } else {\n        const {\n          timeout,\n          pendingId\n        } = suspense;\n        if (timeout > 0) {\n          setTimeout(() => {\n            if (suspense.pendingId === pendingId) {\n              suspense.fallback(newFallback);\n            }\n          }, timeout);\n        } else if (timeout === 0) {\n          suspense.fallback(newFallback);\n        }\n      }\n    }\n  }\n}\nlet hasWarned = false;\nfunction createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals) {\n  let isHydrating = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : false;\n  /* istanbul ignore if */\n  if ( true && !hasWarned) {\n    hasWarned = true;\n    // @ts-ignore `console.info` cannot be null error\n    console[console.info ? 'info' : 'log'](`<Suspense> is an experimental feature and its API will likely change.`);\n  }\n  const {\n    p: patch,\n    m: move,\n    um: unmount,\n    n: next,\n    o: {\n      parentNode,\n      remove\n    }\n  } = rendererInternals;\n  const timeout = vnode.props ? (0, shared_1.toNumber)(vnode.props.timeout) : undefined;\n  if (true) {\n    assertNumber(timeout, `Suspense timeout`);\n  }\n  const suspense = {\n    vnode,\n    parent,\n    parentComponent,\n    isSVG,\n    container,\n    hiddenContainer,\n    anchor,\n    deps: 0,\n    pendingId: 0,\n    timeout: typeof timeout === 'number' ? timeout : -1,\n    activeBranch: null,\n    pendingBranch: null,\n    isInFallback: true,\n    isHydrating,\n    isUnmounted: false,\n    effects: [],\n    resolve() {\n      let resume = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (true) {\n        if (!resume && !suspense.pendingBranch) {\n          throw new Error(`suspense.resolve() is called without a pending branch.`);\n        }\n        if (suspense.isUnmounted) {\n          throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);\n        }\n      }\n      const {\n        vnode,\n        activeBranch,\n        pendingBranch,\n        pendingId,\n        effects,\n        parentComponent,\n        container\n      } = suspense;\n      if (suspense.isHydrating) {\n        suspense.isHydrating = false;\n      } else if (!resume) {\n        const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === 'out-in';\n        if (delayEnter) {\n          activeBranch.transition.afterLeave = () => {\n            if (pendingId === suspense.pendingId) {\n              move(pendingBranch, container, anchor, 0 /* MoveType.ENTER */);\n            }\n          };\n        }\n        // this is initial anchor on mount\n        let {\n          anchor\n        } = suspense;\n        // unmount current active tree\n        if (activeBranch) {\n          // if the fallback tree was mounted, it may have been moved\n          // as part of a parent suspense. get the latest anchor for insertion\n          anchor = next(activeBranch);\n          unmount(activeBranch, parentComponent, suspense, true);\n        }\n        if (!delayEnter) {\n          // move content from off-dom container to actual container\n          move(pendingBranch, container, anchor, 0 /* MoveType.ENTER */);\n        }\n      }\n\n      setActiveBranch(suspense, pendingBranch);\n      suspense.pendingBranch = null;\n      suspense.isInFallback = false;\n      // flush buffered effects\n      // check if there is a pending parent suspense\n      let parent = suspense.parent;\n      let hasUnresolvedAncestor = false;\n      while (parent) {\n        if (parent.pendingBranch) {\n          // found a pending parent suspense, merge buffered post jobs\n          // into that parent\n          parent.effects.push(...effects);\n          hasUnresolvedAncestor = true;\n          break;\n        }\n        parent = parent.parent;\n      }\n      // no pending parent suspense, flush all jobs\n      if (!hasUnresolvedAncestor) {\n        queuePostFlushCb(effects);\n      }\n      suspense.effects = [];\n      // invoke @resolve event\n      triggerEvent(vnode, 'onResolve');\n    },\n    fallback(fallbackVNode) {\n      if (!suspense.pendingBranch) {\n        return;\n      }\n      const {\n        vnode,\n        activeBranch,\n        parentComponent,\n        container,\n        isSVG\n      } = suspense;\n      // invoke @fallback event\n      triggerEvent(vnode, 'onFallback');\n      const anchor = next(activeBranch);\n      const mountFallback = () => {\n        if (!suspense.isInFallback) {\n          return;\n        }\n        // mount the fallback tree\n        patch(null, fallbackVNode, container, anchor, parentComponent, null,\n        // fallback tree will not have suspense context\n        isSVG, slotScopeIds, optimized);\n        setActiveBranch(suspense, fallbackVNode);\n      };\n      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';\n      if (delayEnter) {\n        activeBranch.transition.afterLeave = mountFallback;\n      }\n      suspense.isInFallback = true;\n      // unmount current active branch\n      unmount(activeBranch, parentComponent, null,\n      // no suspense so unmount hooks fire now\n      true // shouldRemove\n      );\n\n      if (!delayEnter) {\n        mountFallback();\n      }\n    },\n    move(container, anchor, type) {\n      suspense.activeBranch && move(suspense.activeBranch, container, anchor, type);\n      suspense.container = container;\n    },\n    next() {\n      return suspense.activeBranch && next(suspense.activeBranch);\n    },\n    registerDep(instance, setupRenderEffect) {\n      const isInPendingSuspense = !!suspense.pendingBranch;\n      if (isInPendingSuspense) {\n        suspense.deps++;\n      }\n      const hydratedEl = instance.vnode.el;\n      instance.asyncDep.catch(err => {\n        handleError(err, instance, 0 /* ErrorCodes.SETUP_FUNCTION */);\n      }).then(asyncSetupResult => {\n        // retry when the setup() promise resolves.\n        // component may have been unmounted before resolve.\n        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {\n          return;\n        }\n        // retry from this component\n        instance.asyncResolved = true;\n        const {\n          vnode\n        } = instance;\n        if (true) {\n          pushWarningContext(vnode);\n        }\n        handleSetupResult(instance, asyncSetupResult, false);\n        if (hydratedEl) {\n          // vnode may have been replaced if an update happened before the\n          // async dep is resolved.\n          vnode.el = hydratedEl;\n        }\n        const placeholder = !hydratedEl && instance.subTree.el;\n        setupRenderEffect(instance, vnode,\n        // component may have been moved before resolve.\n        // if this is not a hydration, instance.subTree will be the comment\n        // placeholder.\n        parentNode(hydratedEl || instance.subTree.el),\n        // anchor will not be used if this is hydration, so only need to\n        // consider the comment placeholder case.\n        hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);\n        if (placeholder) {\n          remove(placeholder);\n        }\n        updateHOCHostEl(instance, vnode.el);\n        if (true) {\n          popWarningContext();\n        }\n        // only decrease deps count if suspense is not already resolved\n        if (isInPendingSuspense && --suspense.deps === 0) {\n          suspense.resolve();\n        }\n      });\n    },\n    unmount(parentSuspense, doRemove) {\n      suspense.isUnmounted = true;\n      if (suspense.activeBranch) {\n        unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);\n      }\n      if (suspense.pendingBranch) {\n        unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);\n      }\n    }\n  };\n  return suspense;\n}\nfunction hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {\n  /* eslint-disable no-restricted-globals */\n  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true /* hydrating */);\n  // there are two possible scenarios for server-rendered suspense:\n  // - success: ssr content should be fully resolved\n  // - failure: ssr content should be the fallback branch.\n  // however, on the client we don't really know if it has failed or not\n  // attempt to hydrate the DOM assuming it has succeeded, but we still\n  // need to construct a suspense boundary first\n  const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);\n  if (suspense.deps === 0) {\n    suspense.resolve();\n  }\n  return result;\n  /* eslint-enable no-restricted-globals */\n}\n\nfunction normalizeSuspenseChildren(vnode) {\n  const {\n    shapeFlag,\n    children\n  } = vnode;\n  const isSlotChildren = shapeFlag & 32 /* ShapeFlags.SLOTS_CHILDREN */;\n  vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);\n  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);\n}\nfunction normalizeSuspenseSlot(s) {\n  let block;\n  if ((0, shared_1.isFunction)(s)) {\n    const trackBlock = isBlockTreeEnabled && s._c;\n    if (trackBlock) {\n      // disableTracking: false\n      // allow block tracking for compiled slots\n      // (see ./componentRenderContext.ts)\n      s._d = false;\n      openBlock();\n    }\n    s = s();\n    if (trackBlock) {\n      s._d = true;\n      block = currentBlock;\n      closeBlock();\n    }\n  }\n  if ((0, shared_1.isArray)(s)) {\n    const singleChild = filterSingleRoot(s);\n    if ( true && !singleChild) {\n      warn(`<Suspense> slots expect a single root node.`);\n    }\n    s = singleChild;\n  }\n  s = normalizeVNode(s);\n  if (block && !s.dynamicChildren) {\n    s.dynamicChildren = block.filter(c => c !== s);\n  }\n  return s;\n}\nfunction queueEffectWithSuspense(fn, suspense) {\n  if (suspense && suspense.pendingBranch) {\n    if ((0, shared_1.isArray)(fn)) {\n      suspense.effects.push(...fn);\n    } else {\n      suspense.effects.push(fn);\n    }\n  } else {\n    queuePostFlushCb(fn);\n  }\n}\nfunction setActiveBranch(suspense, branch) {\n  suspense.activeBranch = branch;\n  const {\n    vnode,\n    parentComponent\n  } = suspense;\n  const el = vnode.el = branch.el;\n  // in case suspense is the root node of a component,\n  // recursively update the HOC el\n  if (parentComponent && parentComponent.subTree === vnode) {\n    parentComponent.vnode.el = el;\n    updateHOCHostEl(parentComponent, el);\n  }\n}\nfunction provide(key, value) {\n  if (!currentInstance) {\n    if (true) {\n      warn(`provide() can only be used inside setup().`);\n    }\n  } else {\n    let provides = currentInstance.provides;\n    // by default an instance inherits its parent's provides object\n    // but when it needs to provide values of its own, it creates its\n    // own provides object using parent provides object as prototype.\n    // this way in `inject` we can simply look up injections from direct\n    // parent and let the prototype chain do the work.\n    const parentProvides = currentInstance.parent && currentInstance.parent.provides;\n    if (parentProvides === provides) {\n      provides = currentInstance.provides = Object.create(parentProvides);\n    }\n    // TS doesn't allow symbol as index type\n    provides[key] = value;\n  }\n}\nexports.provide = provide;\nfunction inject(key, defaultValue) {\n  let treatDefaultAsFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // fallback to `currentRenderingInstance` so that this can be called in\n  // a functional component\n  const instance = currentInstance || currentRenderingInstance;\n  if (instance) {\n    // #2400\n    // to support `app.use` plugins,\n    // fallback to appContext's `provides` if the instance is at root\n    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;\n    if (provides && key in provides) {\n      // TS doesn't allow symbol as index type\n      return provides[key];\n    } else if (arguments.length > 1) {\n      return treatDefaultAsFactory && (0, shared_1.isFunction)(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;\n    } else if (true) {\n      warn(`injection \"${String(key)}\" not found.`);\n    }\n  } else if (true) {\n    warn(`inject() can only be used inside setup() or functional components.`);\n  }\n}\nexports.inject = inject;\n// Simple effect.\nfunction watchEffect(effect, options) {\n  return doWatch(effect, null, options);\n}\nexports.watchEffect = watchEffect;\nfunction watchPostEffect(effect, options) {\n  return doWatch(effect, null,  true ? Object.assign(Object.assign({}, options), {\n    flush: 'post'\n  }) : 0);\n}\nexports.watchPostEffect = watchPostEffect;\nfunction watchSyncEffect(effect, options) {\n  return doWatch(effect, null,  true ? Object.assign(Object.assign({}, options), {\n    flush: 'sync'\n  }) : 0);\n}\nexports.watchSyncEffect = watchSyncEffect;\n// initial value for watchers to trigger on undefined initial values\nconst INITIAL_WATCHER_VALUE = {};\n// implementation\nfunction watch(source, cb, options) {\n  if ( true && !(0, shared_1.isFunction)(cb)) {\n    warn(`\\`watch(fn, options?)\\` signature has been moved to a separate API. ` + `Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only ` + `supports \\`watch(source, cb, options?) signature.`);\n  }\n  return doWatch(source, cb, options);\n}\nexports.watch = watch;\nfunction doWatch(source, cb) {\n  let {\n    immediate,\n    deep,\n    flush,\n    onTrack,\n    onTrigger\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : shared_1.EMPTY_OBJ;\n  if ( true && !cb) {\n    if (immediate !== undefined) {\n      warn(`watch() \"immediate\" option is only respected when using the ` + `watch(source, callback, options?) signature.`);\n    }\n    if (deep !== undefined) {\n      warn(`watch() \"deep\" option is only respected when using the ` + `watch(source, callback, options?) signature.`);\n    }\n  }\n  const warnInvalidSource = s => {\n    warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` + `a reactive object, or an array of these types.`);\n  };\n  const instance = (0, reactivity_1.getCurrentScope)() === (currentInstance === null || currentInstance === void 0 ? void 0 : currentInstance.scope) ? currentInstance : null;\n  // const instance = currentInstance\n  let getter;\n  let forceTrigger = false;\n  let isMultiSource = false;\n  if ((0, reactivity_1.isRef)(source)) {\n    getter = () => source.value;\n    forceTrigger = (0, reactivity_1.isShallow)(source);\n  } else if ((0, reactivity_1.isReactive)(source)) {\n    getter = () => source;\n    deep = true;\n  } else if ((0, shared_1.isArray)(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some(s => (0, reactivity_1.isReactive)(s) || (0, reactivity_1.isShallow)(s));\n    getter = () => source.map(s => {\n      if ((0, reactivity_1.isRef)(s)) {\n        return s.value;\n      } else if ((0, reactivity_1.isReactive)(s)) {\n        return traverse(s);\n      } else if ((0, shared_1.isFunction)(s)) {\n        return callWithErrorHandling(s, instance, 2 /* ErrorCodes.WATCH_GETTER */);\n      } else {\n         true && warnInvalidSource(s);\n      }\n    });\n  } else if ((0, shared_1.isFunction)(source)) {\n    if (cb) {\n      // getter with cb\n      getter = () => callWithErrorHandling(source, instance, 2 /* ErrorCodes.WATCH_GETTER */);\n    } else {\n      // no cb -> simple effect\n      getter = () => {\n        if (instance && instance.isUnmounted) {\n          return;\n        }\n        if (cleanup) {\n          cleanup();\n        }\n        return callWithAsyncErrorHandling(source, instance, 3 /* ErrorCodes.WATCH_CALLBACK */, [onCleanup]);\n      };\n    }\n  } else {\n    getter = shared_1.NOOP;\n     true && warnInvalidSource(source);\n  }\n  if (cb && deep) {\n    const baseGetter = getter;\n    getter = () => traverse(baseGetter());\n  }\n  let cleanup;\n  let onCleanup = fn => {\n    cleanup = effect.onStop = () => {\n      callWithErrorHandling(fn, instance, 4 /* ErrorCodes.WATCH_CLEANUP */);\n    };\n  };\n  // in SSR there is no need to setup an actual effect, and it should be noop\n  // unless it's eager or sync flush\n  let ssrCleanup;\n  if (isInSSRComponentSetup) {\n    // we will also not call the invalidate callback (+ runner is not set up)\n    onCleanup = shared_1.NOOP;\n    if (!cb) {\n      getter();\n    } else if (immediate) {\n      callWithAsyncErrorHandling(cb, instance, 3 /* ErrorCodes.WATCH_CALLBACK */, [getter(), isMultiSource ? [] : undefined, onCleanup]);\n    }\n    if (flush === 'sync') {\n      const ctx = useSSRContext();\n      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);\n    } else {\n      return shared_1.NOOP;\n    }\n  }\n  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n  const job = () => {\n    if (!effect.active) {\n      return;\n    }\n    if (cb) {\n      // watch(source, cb)\n      const newValue = effect.run();\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => (0, shared_1.hasChanged)(v, oldValue[i])) : (0, shared_1.hasChanged)(newValue, oldValue)) || false) {\n        // cleanup before running cb again\n        if (cleanup) {\n          cleanup();\n        }\n        callWithAsyncErrorHandling(cb, instance, 3 /* ErrorCodes.WATCH_CALLBACK */, [newValue,\n        // pass undefined as the old value when it's changed for the first time\n        oldValue === INITIAL_WATCHER_VALUE ? undefined : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue, onCleanup]);\n        oldValue = newValue;\n      }\n    } else {\n      // watchEffect\n      effect.run();\n    }\n  };\n  // important: mark the job as a watcher callback so that scheduler knows\n  // it is allowed to self-trigger (#1727)\n  job.allowRecurse = !!cb;\n  let scheduler;\n  if (flush === 'sync') {\n    scheduler = job; // the scheduler function gets called directly\n  } else if (flush === 'post') {\n    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\n  } else {\n    // default: 'pre'\n    job.pre = true;\n    if (instance) job.id = instance.uid;\n    scheduler = () => queueJob(job);\n  }\n  const effect = new reactivity_1.ReactiveEffect(getter, scheduler);\n  if (true) {\n    effect.onTrack = onTrack;\n    effect.onTrigger = onTrigger;\n  }\n  // initial run\n  if (cb) {\n    if (immediate) {\n      job();\n    } else {\n      oldValue = effect.run();\n    }\n  } else if (flush === 'post') {\n    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);\n  } else {\n    effect.run();\n  }\n  const unwatch = () => {\n    effect.stop();\n    if (instance && instance.scope) {\n      (0, shared_1.remove)(instance.scope.effects, effect);\n    }\n  };\n  if (ssrCleanup) ssrCleanup.push(unwatch);\n  return unwatch;\n}\n// this.$watch\nfunction instanceWatch(source, value, options) {\n  const publicThis = this.proxy;\n  const getter = (0, shared_1.isString)(source) ? source.includes('.') ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);\n  let cb;\n  if ((0, shared_1.isFunction)(value)) {\n    cb = value;\n  } else {\n    cb = value.handler;\n    options = value;\n  }\n  const cur = currentInstance;\n  setCurrentInstance(this);\n  const res = doWatch(getter, cb.bind(publicThis), options);\n  if (cur) {\n    setCurrentInstance(cur);\n  } else {\n    unsetCurrentInstance();\n  }\n  return res;\n}\nfunction createPathGetter(ctx, path) {\n  const segments = path.split('.');\n  return () => {\n    let cur = ctx;\n    for (let i = 0; i < segments.length && cur; i++) {\n      cur = cur[segments[i]];\n    }\n    return cur;\n  };\n}\nfunction traverse(value, seen) {\n  if (!(0, shared_1.isObject)(value) || value[\"__v_skip\" /* ReactiveFlags.SKIP */]) {\n    return value;\n  }\n  seen = seen || new Set();\n  if (seen.has(value)) {\n    return value;\n  }\n  seen.add(value);\n  if ((0, reactivity_1.isRef)(value)) {\n    traverse(value.value, seen);\n  } else if ((0, shared_1.isArray)(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], seen);\n    }\n  } else if ((0, shared_1.isSet)(value) || (0, shared_1.isMap)(value)) {\n    value.forEach(v => {\n      traverse(v, seen);\n    });\n  } else if ((0, shared_1.isPlainObject)(value)) {\n    for (const key in value) {\n      traverse(value[key], seen);\n    }\n  }\n  return value;\n}\nfunction useTransitionState() {\n  const state = {\n    isMounted: false,\n    isLeaving: false,\n    isUnmounting: false,\n    leavingVNodes: new Map()\n  };\n  onMounted(() => {\n    state.isMounted = true;\n  });\n  onBeforeUnmount(() => {\n    state.isUnmounting = true;\n  });\n  return state;\n}\nexports.useTransitionState = useTransitionState;\nconst TransitionHookValidator = [Function, Array];\nconst BaseTransitionImpl = {\n  name: `BaseTransition`,\n  props: {\n    mode: String,\n    appear: Boolean,\n    persisted: Boolean,\n    // enter\n    onBeforeEnter: TransitionHookValidator,\n    onEnter: TransitionHookValidator,\n    onAfterEnter: TransitionHookValidator,\n    onEnterCancelled: TransitionHookValidator,\n    // leave\n    onBeforeLeave: TransitionHookValidator,\n    onLeave: TransitionHookValidator,\n    onAfterLeave: TransitionHookValidator,\n    onLeaveCancelled: TransitionHookValidator,\n    // appear\n    onBeforeAppear: TransitionHookValidator,\n    onAppear: TransitionHookValidator,\n    onAfterAppear: TransitionHookValidator,\n    onAppearCancelled: TransitionHookValidator\n  },\n  setup(props, _ref6) {\n    let {\n      slots\n    } = _ref6;\n    const instance = getCurrentInstance();\n    const state = useTransitionState();\n    let prevTransitionKey;\n    return () => {\n      const children = slots.default && getTransitionRawChildren(slots.default(), true);\n      if (!children || !children.length) {\n        return;\n      }\n      let child = children[0];\n      if (children.length > 1) {\n        let hasFound = false;\n        // locate first non-comment child\n        for (const c of children) {\n          if (c.type !== Comment) {\n            if ( true && hasFound) {\n              // warn more than one non-comment child\n              warn('<transition> can only be used on a single element or component. ' + 'Use <transition-group> for lists.');\n              break;\n            }\n            child = c;\n            hasFound = true;\n            if (false) {}\n          }\n        }\n      }\n      // there's no need to track reactivity for these props so use the raw\n      // props for a bit better perf\n      const rawProps = (0, reactivity_1.toRaw)(props);\n      const {\n        mode\n      } = rawProps;\n      // check mode\n      if ( true && mode && mode !== 'in-out' && mode !== 'out-in' && mode !== 'default') {\n        warn(`invalid <transition> mode: ${mode}`);\n      }\n      if (state.isLeaving) {\n        return emptyPlaceholder(child);\n      }\n      // in the case of <transition><keep-alive/></transition>, we need to\n      // compare the type of the kept-alive children.\n      const innerChild = getKeepAliveChild(child);\n      if (!innerChild) {\n        return emptyPlaceholder(child);\n      }\n      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);\n      setTransitionHooks(innerChild, enterHooks);\n      const oldChild = instance.subTree;\n      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);\n      let transitionKeyChanged = false;\n      const {\n        getTransitionKey\n      } = innerChild.type;\n      if (getTransitionKey) {\n        const key = getTransitionKey();\n        if (prevTransitionKey === undefined) {\n          prevTransitionKey = key;\n        } else if (key !== prevTransitionKey) {\n          prevTransitionKey = key;\n          transitionKeyChanged = true;\n        }\n      }\n      // handle mode\n      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {\n        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);\n        // update old tree's hooks in case of dynamic transition\n        setTransitionHooks(oldInnerChild, leavingHooks);\n        // switching between different views\n        if (mode === 'out-in') {\n          state.isLeaving = true;\n          // return placeholder node and queue update when leave finishes\n          leavingHooks.afterLeave = () => {\n            state.isLeaving = false;\n            // #6835\n            // it also needs to be updated when active is undefined\n            if (instance.update.active !== false) {\n              instance.update();\n            }\n          };\n          return emptyPlaceholder(child);\n        } else if (mode === 'in-out' && innerChild.type !== Comment) {\n          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {\n            const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);\n            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;\n            // early removal callback\n            el._leaveCb = () => {\n              earlyRemove();\n              el._leaveCb = undefined;\n              delete enterHooks.delayedLeave;\n            };\n            enterHooks.delayedLeave = delayedLeave;\n          };\n        }\n      }\n      return child;\n    };\n  }\n};\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\nconst BaseTransition = BaseTransitionImpl;\nexports.BaseTransition = BaseTransition;\nfunction getLeavingNodesForType(state, vnode) {\n  const {\n    leavingVNodes\n  } = state;\n  let leavingVNodesCache = leavingVNodes.get(vnode.type);\n  if (!leavingVNodesCache) {\n    leavingVNodesCache = Object.create(null);\n    leavingVNodes.set(vnode.type, leavingVNodesCache);\n  }\n  return leavingVNodesCache;\n}\n// The transition hooks are attached to the vnode as vnode.transition\n// and will be called at appropriate timing in the renderer.\nfunction resolveTransitionHooks(vnode, props, state, instance) {\n  const {\n    appear,\n    mode,\n    persisted = false,\n    onBeforeEnter,\n    onEnter,\n    onAfterEnter,\n    onEnterCancelled,\n    onBeforeLeave,\n    onLeave,\n    onAfterLeave,\n    onLeaveCancelled,\n    onBeforeAppear,\n    onAppear,\n    onAfterAppear,\n    onAppearCancelled\n  } = props;\n  const key = String(vnode.key);\n  const leavingVNodesCache = getLeavingNodesForType(state, vnode);\n  const callHook = (hook, args) => {\n    hook && callWithAsyncErrorHandling(hook, instance, 9 /* ErrorCodes.TRANSITION_HOOK */, args);\n  };\n  const callAsyncHook = (hook, args) => {\n    const done = args[1];\n    callHook(hook, args);\n    if ((0, shared_1.isArray)(hook)) {\n      if (hook.every(hook => hook.length <= 1)) done();\n    } else if (hook.length <= 1) {\n      done();\n    }\n  };\n  const hooks = {\n    mode,\n    persisted,\n    beforeEnter(el) {\n      let hook = onBeforeEnter;\n      if (!state.isMounted) {\n        if (appear) {\n          hook = onBeforeAppear || onBeforeEnter;\n        } else {\n          return;\n        }\n      }\n      // for same element (v-show)\n      if (el._leaveCb) {\n        el._leaveCb(true /* cancelled */);\n      }\n      // for toggled element with same key (v-if)\n      const leavingVNode = leavingVNodesCache[key];\n      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {\n        // force early removal (not cancelled)\n        leavingVNode.el._leaveCb();\n      }\n      callHook(hook, [el]);\n    },\n    enter(el) {\n      let hook = onEnter;\n      let afterHook = onAfterEnter;\n      let cancelHook = onEnterCancelled;\n      if (!state.isMounted) {\n        if (appear) {\n          hook = onAppear || onEnter;\n          afterHook = onAfterAppear || onAfterEnter;\n          cancelHook = onAppearCancelled || onEnterCancelled;\n        } else {\n          return;\n        }\n      }\n      let called = false;\n      const done = el._enterCb = cancelled => {\n        if (called) return;\n        called = true;\n        if (cancelled) {\n          callHook(cancelHook, [el]);\n        } else {\n          callHook(afterHook, [el]);\n        }\n        if (hooks.delayedLeave) {\n          hooks.delayedLeave();\n        }\n        el._enterCb = undefined;\n      };\n      if (hook) {\n        callAsyncHook(hook, [el, done]);\n      } else {\n        done();\n      }\n    },\n    leave(el, remove) {\n      const key = String(vnode.key);\n      if (el._enterCb) {\n        el._enterCb(true /* cancelled */);\n      }\n\n      if (state.isUnmounting) {\n        return remove();\n      }\n      callHook(onBeforeLeave, [el]);\n      let called = false;\n      const done = el._leaveCb = cancelled => {\n        if (called) return;\n        called = true;\n        remove();\n        if (cancelled) {\n          callHook(onLeaveCancelled, [el]);\n        } else {\n          callHook(onAfterLeave, [el]);\n        }\n        el._leaveCb = undefined;\n        if (leavingVNodesCache[key] === vnode) {\n          delete leavingVNodesCache[key];\n        }\n      };\n      leavingVNodesCache[key] = vnode;\n      if (onLeave) {\n        callAsyncHook(onLeave, [el, done]);\n      } else {\n        done();\n      }\n    },\n    clone(vnode) {\n      return resolveTransitionHooks(vnode, props, state, instance);\n    }\n  };\n  return hooks;\n}\nexports.resolveTransitionHooks = resolveTransitionHooks;\n// the placeholder really only handles one special case: KeepAlive\n// in the case of a KeepAlive in a leave phase we need to return a KeepAlive\n// placeholder with empty content to avoid the KeepAlive instance from being\n// unmounted.\nfunction emptyPlaceholder(vnode) {\n  if (isKeepAlive(vnode)) {\n    vnode = cloneVNode(vnode);\n    vnode.children = null;\n    return vnode;\n  }\n}\nfunction getKeepAliveChild(vnode) {\n  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : undefined : vnode;\n}\nfunction setTransitionHooks(vnode, hooks) {\n  if (vnode.shapeFlag & 6 /* ShapeFlags.COMPONENT */ && vnode.component) {\n    setTransitionHooks(vnode.component.subTree, hooks);\n  } else if (vnode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n    vnode.ssContent.transition = hooks.clone(vnode.ssContent);\n    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);\n  } else {\n    vnode.transition = hooks;\n  }\n}\nexports.setTransitionHooks = setTransitionHooks;\nfunction getTransitionRawChildren(children) {\n  let keepComment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let parentKey = arguments.length > 2 ? arguments[2] : undefined;\n  let ret = [];\n  let keyedFragmentCount = 0;\n  for (let i = 0; i < children.length; i++) {\n    let child = children[i];\n    // #5360 inherit parent key in case of <template v-for>\n    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);\n    // handle fragment children case, e.g. v-for\n    if (child.type === Fragment) {\n      if (child.patchFlag & 128 /* PatchFlags.KEYED_FRAGMENT */) keyedFragmentCount++;\n      ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));\n    }\n    // comment placeholders should be skipped, e.g. v-if\n    else if (keepComment || child.type !== Comment) {\n      ret.push(key != null ? cloneVNode(child, {\n        key\n      }) : child);\n    }\n  }\n  // #1126 if a transition children list contains multiple sub fragments, these\n  // fragments will be merged into a flat children array. Since each v-for\n  // fragment may contain different static bindings inside, we need to de-op\n  // these children to force full diffs to ensure correct behavior.\n  if (keyedFragmentCount > 1) {\n    for (let i = 0; i < ret.length; i++) {\n      ret[i].patchFlag = -2 /* PatchFlags.BAIL */;\n    }\n  }\n\n  return ret;\n}\nexports.getTransitionRawChildren = getTransitionRawChildren;\n// implementation, close to no-op\nfunction defineComponent(options) {\n  return (0, shared_1.isFunction)(options) ? {\n    setup: options,\n    name: options.name\n  } : options;\n}\nexports.defineComponent = defineComponent;\nconst isAsyncWrapper = i => !!i.type.__asyncLoader;\nfunction defineAsyncComponent(source) {\n  if ((0, shared_1.isFunction)(source)) {\n    source = {\n      loader: source\n    };\n  }\n  const {\n    loader,\n    loadingComponent,\n    errorComponent,\n    delay = 200,\n    timeout,\n    // undefined = never times out\n    suspensible = true,\n    onError: userOnError\n  } = source;\n  let pendingRequest = null;\n  let resolvedComp;\n  let retries = 0;\n  const retry = () => {\n    retries++;\n    pendingRequest = null;\n    return load();\n  };\n  const load = () => {\n    let thisRequest;\n    return pendingRequest || (thisRequest = pendingRequest = loader().catch(err => {\n      err = err instanceof Error ? err : new Error(String(err));\n      if (userOnError) {\n        return new Promise((resolve, reject) => {\n          const userRetry = () => resolve(retry());\n          const userFail = () => reject(err);\n          userOnError(err, userRetry, userFail, retries + 1);\n        });\n      } else {\n        throw err;\n      }\n    }).then(comp => {\n      if (thisRequest !== pendingRequest && pendingRequest) {\n        return pendingRequest;\n      }\n      if ( true && !comp) {\n        warn(`Async component loader resolved to undefined. ` + `If you are using retry(), make sure to return its return value.`);\n      }\n      // interop module default\n      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {\n        comp = comp.default;\n      }\n      if ( true && comp && !(0, shared_1.isObject)(comp) && !(0, shared_1.isFunction)(comp)) {\n        throw new Error(`Invalid async component load result: ${comp}`);\n      }\n      resolvedComp = comp;\n      return comp;\n    }));\n  };\n  return defineComponent({\n    name: 'AsyncComponentWrapper',\n    __asyncLoader: load,\n    get __asyncResolved() {\n      return resolvedComp;\n    },\n    setup() {\n      const instance = currentInstance;\n      // already resolved\n      if (resolvedComp) {\n        return () => createInnerComp(resolvedComp, instance);\n      }\n      const onError = err => {\n        pendingRequest = null;\n        handleError(err, instance, 13 /* ErrorCodes.ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);\n      };\n      // suspense-controlled or SSR.\n      if (suspensible && instance.suspense || isInSSRComponentSetup) {\n        return load().then(comp => {\n          return () => createInnerComp(comp, instance);\n        }).catch(err => {\n          onError(err);\n          return () => errorComponent ? createVNode(errorComponent, {\n            error: err\n          }) : null;\n        });\n      }\n      const loaded = (0, reactivity_1.ref)(false);\n      const error = (0, reactivity_1.ref)();\n      const delayed = (0, reactivity_1.ref)(!!delay);\n      if (delay) {\n        setTimeout(() => {\n          delayed.value = false;\n        }, delay);\n      }\n      if (timeout != null) {\n        setTimeout(() => {\n          if (!loaded.value && !error.value) {\n            const err = new Error(`Async component timed out after ${timeout}ms.`);\n            onError(err);\n            error.value = err;\n          }\n        }, timeout);\n      }\n      load().then(() => {\n        loaded.value = true;\n        if (instance.parent && isKeepAlive(instance.parent.vnode)) {\n          // parent is keep-alive, force update so the loaded component's\n          // name is taken into account\n          queueJob(instance.parent.update);\n        }\n      }).catch(err => {\n        onError(err);\n        error.value = err;\n      });\n      return () => {\n        if (loaded.value && resolvedComp) {\n          return createInnerComp(resolvedComp, instance);\n        } else if (error.value && errorComponent) {\n          return createVNode(errorComponent, {\n            error: error.value\n          });\n        } else if (loadingComponent && !delayed.value) {\n          return createVNode(loadingComponent);\n        }\n      };\n    }\n  });\n}\nexports.defineAsyncComponent = defineAsyncComponent;\nfunction createInnerComp(comp, parent) {\n  const {\n    ref,\n    props,\n    children,\n    ce\n  } = parent.vnode;\n  const vnode = createVNode(comp, props, children);\n  // ensure inner component inherits the async wrapper's ref owner\n  vnode.ref = ref;\n  // pass the custom element callback on to the inner comp\n  // and remove it from the async wrapper\n  vnode.ce = ce;\n  delete parent.vnode.ce;\n  return vnode;\n}\nconst isKeepAlive = vnode => vnode.type.__isKeepAlive;\nconst KeepAliveImpl = {\n  name: `KeepAlive`,\n  // Marker for special handling inside the renderer. We are not using a ===\n  // check directly on KeepAlive in the renderer, because importing it directly\n  // would prevent it from being tree-shaken.\n  __isKeepAlive: true,\n  props: {\n    include: [String, RegExp, Array],\n    exclude: [String, RegExp, Array],\n    max: [String, Number]\n  },\n  setup(props, _ref7) {\n    let {\n      slots\n    } = _ref7;\n    const instance = getCurrentInstance();\n    // KeepAlive communicates with the instantiated renderer via the\n    // ctx where the renderer passes in its internals,\n    // and the KeepAlive instance exposes activate/deactivate implementations.\n    // The whole point of this is to avoid importing KeepAlive directly in the\n    // renderer to facilitate tree-shaking.\n    const sharedContext = instance.ctx;\n    // if the internal renderer is not registered, it indicates that this is server-side rendering,\n    // for KeepAlive, we just need to render its children\n    if (!sharedContext.renderer) {\n      return () => {\n        const children = slots.default && slots.default();\n        return children && children.length === 1 ? children[0] : children;\n      };\n    }\n    const cache = new Map();\n    const keys = new Set();\n    let current = null;\n    if (true) {\n      instance.__v_cache = cache;\n    }\n    const parentSuspense = instance.suspense;\n    const {\n      renderer: {\n        p: patch,\n        m: move,\n        um: _unmount,\n        o: {\n          createElement\n        }\n      }\n    } = sharedContext;\n    const storageContainer = createElement('div');\n    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {\n      const instance = vnode.component;\n      move(vnode, container, anchor, 0 /* MoveType.ENTER */, parentSuspense);\n      // in case props have changed\n      patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);\n      queuePostRenderEffect(() => {\n        instance.isDeactivated = false;\n        if (instance.a) {\n          (0, shared_1.invokeArrayFns)(instance.a);\n        }\n        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance.parent, vnode);\n        }\n      }, parentSuspense);\n      if (true) {\n        // Update components tree\n        devtoolsComponentAdded(instance);\n      }\n    };\n    sharedContext.deactivate = vnode => {\n      const instance = vnode.component;\n      move(vnode, storageContainer, null, 1 /* MoveType.LEAVE */, parentSuspense);\n      queuePostRenderEffect(() => {\n        if (instance.da) {\n          (0, shared_1.invokeArrayFns)(instance.da);\n        }\n        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance.parent, vnode);\n        }\n        instance.isDeactivated = true;\n      }, parentSuspense);\n      if (true) {\n        // Update components tree\n        devtoolsComponentAdded(instance);\n      }\n    };\n    function unmount(vnode) {\n      // reset the shapeFlag so it can be properly unmounted\n      resetShapeFlag(vnode);\n      _unmount(vnode, instance, parentSuspense, true);\n    }\n    function pruneCache(filter) {\n      cache.forEach((vnode, key) => {\n        const name = getComponentName(vnode.type);\n        if (name && (!filter || !filter(name))) {\n          pruneCacheEntry(key);\n        }\n      });\n    }\n    function pruneCacheEntry(key) {\n      const cached = cache.get(key);\n      if (!current || !isSameVNodeType(cached, current)) {\n        unmount(cached);\n      } else if (current) {\n        // current active instance should no longer be kept-alive.\n        // we can't unmount it now but it might be later, so reset its flag now.\n        resetShapeFlag(current);\n      }\n      cache.delete(key);\n      keys.delete(key);\n    }\n    // prune cache on include/exclude prop change\n    watch(() => [props.include, props.exclude], _ref8 => {\n      let [include, exclude] = _ref8;\n      include && pruneCache(name => matches(include, name));\n      exclude && pruneCache(name => !matches(exclude, name));\n    },\n    // prune post-render after `current` has been updated\n    {\n      flush: 'post',\n      deep: true\n    });\n    // cache sub tree after render\n    let pendingCacheKey = null;\n    const cacheSubtree = () => {\n      // fix #1621, the pendingCacheKey could be 0\n      if (pendingCacheKey != null) {\n        cache.set(pendingCacheKey, getInnerChild(instance.subTree));\n      }\n    };\n    onMounted(cacheSubtree);\n    onUpdated(cacheSubtree);\n    onBeforeUnmount(() => {\n      cache.forEach(cached => {\n        const {\n          subTree,\n          suspense\n        } = instance;\n        const vnode = getInnerChild(subTree);\n        if (cached.type === vnode.type && cached.key === vnode.key) {\n          // current instance will be unmounted as part of keep-alive's unmount\n          resetShapeFlag(vnode);\n          // but invoke its deactivated hook here\n          const da = vnode.component.da;\n          da && queuePostRenderEffect(da, suspense);\n          return;\n        }\n        unmount(cached);\n      });\n    });\n    return () => {\n      pendingCacheKey = null;\n      if (!slots.default) {\n        return null;\n      }\n      const children = slots.default();\n      const rawVNode = children[0];\n      if (children.length > 1) {\n        if (true) {\n          warn(`KeepAlive should contain exactly one component child.`);\n        }\n        current = null;\n        return children;\n      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4 /* ShapeFlags.STATEFUL_COMPONENT */) && !(rawVNode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */)) {\n        current = null;\n        return rawVNode;\n      }\n      let vnode = getInnerChild(rawVNode);\n      const comp = vnode.type;\n      // for async components, name check should be based in its loaded\n      // inner component if available\n      const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);\n      const {\n        include,\n        exclude,\n        max\n      } = props;\n      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {\n        current = vnode;\n        return rawVNode;\n      }\n      const key = vnode.key == null ? comp : vnode.key;\n      const cachedVNode = cache.get(key);\n      // clone vnode if it's reused because we are going to mutate it\n      if (vnode.el) {\n        vnode = cloneVNode(vnode);\n        if (rawVNode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n          rawVNode.ssContent = vnode;\n        }\n      }\n      // #1513 it's possible for the returned vnode to be cloned due to attr\n      // fallthrough or scopeId, so the vnode here may not be the final vnode\n      // that is mounted. Instead of caching it directly, we store the pending\n      // key and cache `instance.subTree` (the normalized vnode) in\n      // beforeMount/beforeUpdate hooks.\n      pendingCacheKey = key;\n      if (cachedVNode) {\n        // copy over mounted state\n        vnode.el = cachedVNode.el;\n        vnode.component = cachedVNode.component;\n        if (vnode.transition) {\n          // recursively update transition hooks on subTree\n          setTransitionHooks(vnode, vnode.transition);\n        }\n        // avoid vnode being mounted as fresh\n        vnode.shapeFlag |= 512 /* ShapeFlags.COMPONENT_KEPT_ALIVE */;\n        // make this key the freshest\n        keys.delete(key);\n        keys.add(key);\n      } else {\n        keys.add(key);\n        // prune oldest entry\n        if (max && keys.size > parseInt(max, 10)) {\n          pruneCacheEntry(keys.values().next().value);\n        }\n      }\n      // avoid vnode being unmounted\n      vnode.shapeFlag |= 256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */;\n      current = vnode;\n      return isSuspense(rawVNode.type) ? rawVNode : vnode;\n    };\n  }\n};\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\nconst KeepAlive = KeepAliveImpl;\nexports.KeepAlive = KeepAlive;\nfunction matches(pattern, name) {\n  if ((0, shared_1.isArray)(pattern)) {\n    return pattern.some(p => matches(p, name));\n  } else if ((0, shared_1.isString)(pattern)) {\n    return pattern.split(',').includes(name);\n  } else if ((0, shared_1.isRegExp)(pattern)) {\n    return pattern.test(name);\n  }\n  /* istanbul ignore next */\n  return false;\n}\nfunction onActivated(hook, target) {\n  registerKeepAliveHook(hook, \"a\" /* LifecycleHooks.ACTIVATED */, target);\n}\nexports.onActivated = onActivated;\nfunction onDeactivated(hook, target) {\n  registerKeepAliveHook(hook, \"da\" /* LifecycleHooks.DEACTIVATED */, target);\n}\nexports.onDeactivated = onDeactivated;\nfunction registerKeepAliveHook(hook, type) {\n  let target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : currentInstance;\n  // cache the deactivate branch check wrapper for injected hooks so the same\n  // hook can be properly deduped by the scheduler. \"__wdc\" stands for \"with\n  // deactivation check\".\n  const wrappedHook = hook.__wdc || (hook.__wdc = () => {\n    // only fire the hook if the target instance is NOT in a deactivated branch.\n    let current = target;\n    while (current) {\n      if (current.isDeactivated) {\n        return;\n      }\n      current = current.parent;\n    }\n    return hook();\n  });\n  injectHook(type, wrappedHook, target);\n  // In addition to registering it on the target instance, we walk up the parent\n  // chain and register it on all ancestor instances that are keep-alive roots.\n  // This avoids the need to walk the entire component tree when invoking these\n  // hooks, and more importantly, avoids the need to track child components in\n  // arrays.\n  if (target) {\n    let current = target.parent;\n    while (current && current.parent) {\n      if (isKeepAlive(current.parent.vnode)) {\n        injectToKeepAliveRoot(wrappedHook, type, target, current);\n      }\n      current = current.parent;\n    }\n  }\n}\nfunction injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {\n  // injectHook wraps the original for error handling, so make sure to remove\n  // the wrapped version.\n  const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);\n  onUnmounted(() => {\n    (0, shared_1.remove)(keepAliveRoot[type], injected);\n  }, target);\n}\nfunction resetShapeFlag(vnode) {\n  // bitwise operations to remove keep alive flags\n  vnode.shapeFlag &= ~256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */;\n  vnode.shapeFlag &= ~512 /* ShapeFlags.COMPONENT_KEPT_ALIVE */;\n}\n\nfunction getInnerChild(vnode) {\n  return vnode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */ ? vnode.ssContent : vnode;\n}\nfunction injectHook(type, hook) {\n  let target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : currentInstance;\n  let prepend = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (target) {\n    const hooks = target[type] || (target[type] = []);\n    // cache the error handling wrapper for injected hooks so the same hook\n    // can be properly deduped by the scheduler. \"__weh\" stands for \"with error\n    // handling\".\n    const wrappedHook = hook.__weh || (hook.__weh = function () {\n      if (target.isUnmounted) {\n        return;\n      }\n      // disable tracking inside all lifecycle hooks\n      // since they can potentially be called inside effects.\n      (0, reactivity_1.pauseTracking)();\n      // Set currentInstance during hook invocation.\n      // This assumes the hook does not synchronously trigger other hooks, which\n      // can only be false when the user does something really funky.\n      setCurrentInstance(target);\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      const res = callWithAsyncErrorHandling(hook, target, type, args);\n      unsetCurrentInstance();\n      (0, reactivity_1.resetTracking)();\n      return res;\n    });\n    if (prepend) {\n      hooks.unshift(wrappedHook);\n    } else {\n      hooks.push(wrappedHook);\n    }\n    return wrappedHook;\n  } else if (true) {\n    const apiName = (0, shared_1.toHandlerKey)(ErrorTypeStrings[type].replace(/ hook$/, ''));\n    warn(`${apiName} is called when there is no active component instance to be ` + `associated with. ` + `Lifecycle injection APIs can only be used during execution of setup().` + (` If you are using async setup(), make sure to register lifecycle ` + `hooks before the first await statement.`));\n  }\n}\nconst createHook = lifecycle => function (hook) {\n  let target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentInstance;\n  return (\n    // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)\n    (!isInSSRComponentSetup || lifecycle === \"sp\" /* LifecycleHooks.SERVER_PREFETCH */) && injectHook(lifecycle, function () {\n      return hook(...arguments);\n    }, target)\n  );\n};\nconst onBeforeMount = createHook(\"bm\" /* LifecycleHooks.BEFORE_MOUNT */);\nexports.onBeforeMount = onBeforeMount;\nconst onMounted = createHook(\"m\" /* LifecycleHooks.MOUNTED */);\nexports.onMounted = onMounted;\nconst onBeforeUpdate = createHook(\"bu\" /* LifecycleHooks.BEFORE_UPDATE */);\nexports.onBeforeUpdate = onBeforeUpdate;\nconst onUpdated = createHook(\"u\" /* LifecycleHooks.UPDATED */);\nexports.onUpdated = onUpdated;\nconst onBeforeUnmount = createHook(\"bum\" /* LifecycleHooks.BEFORE_UNMOUNT */);\nexports.onBeforeUnmount = onBeforeUnmount;\nconst onUnmounted = createHook(\"um\" /* LifecycleHooks.UNMOUNTED */);\nexports.onUnmounted = onUnmounted;\nconst onServerPrefetch = createHook(\"sp\" /* LifecycleHooks.SERVER_PREFETCH */);\nexports.onServerPrefetch = onServerPrefetch;\nconst onRenderTriggered = createHook(\"rtg\" /* LifecycleHooks.RENDER_TRIGGERED */);\nexports.onRenderTriggered = onRenderTriggered;\nconst onRenderTracked = createHook(\"rtc\" /* LifecycleHooks.RENDER_TRACKED */);\nexports.onRenderTracked = onRenderTracked;\nfunction onErrorCaptured(hook) {\n  let target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentInstance;\n  injectHook(\"ec\" /* LifecycleHooks.ERROR_CAPTURED */, hook, target);\n}\nexports.onErrorCaptured = onErrorCaptured;\n/**\nRuntime helper for applying directives to a vnode. Example usage:\n\nconst comp = resolveComponent('comp')\nconst foo = resolveDirective('foo')\nconst bar = resolveDirective('bar')\n\nreturn withDirectives(h(comp), [\n  [foo, this.x],\n  [bar, this.y]\n])\n*/\nfunction validateDirectiveName(name) {\n  if ((0, shared_1.isBuiltInDirective)(name)) {\n    warn('Do not use built-in directive ids as custom directive id: ' + name);\n  }\n}\n/**\n * Adds directives to a VNode.\n */\nfunction withDirectives(vnode, directives) {\n  const internalInstance = currentRenderingInstance;\n  if (internalInstance === null) {\n     true && warn(`withDirectives can only be used inside render functions.`);\n    return vnode;\n  }\n  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;\n  const bindings = vnode.dirs || (vnode.dirs = []);\n  for (let i = 0; i < directives.length; i++) {\n    let [dir, value, arg, modifiers = shared_1.EMPTY_OBJ] = directives[i];\n    if (dir) {\n      if ((0, shared_1.isFunction)(dir)) {\n        dir = {\n          mounted: dir,\n          updated: dir\n        };\n      }\n      if (dir.deep) {\n        traverse(value);\n      }\n      bindings.push({\n        dir,\n        instance,\n        value,\n        oldValue: void 0,\n        arg,\n        modifiers\n      });\n    }\n  }\n  return vnode;\n}\nexports.withDirectives = withDirectives;\nfunction invokeDirectiveHook(vnode, prevVNode, instance, name) {\n  const bindings = vnode.dirs;\n  const oldBindings = prevVNode && prevVNode.dirs;\n  for (let i = 0; i < bindings.length; i++) {\n    const binding = bindings[i];\n    if (oldBindings) {\n      binding.oldValue = oldBindings[i].value;\n    }\n    let hook = binding.dir[name];\n    if (hook) {\n      // disable tracking inside all lifecycle hooks\n      // since they can potentially be called inside effects.\n      (0, reactivity_1.pauseTracking)();\n      callWithAsyncErrorHandling(hook, instance, 8 /* ErrorCodes.DIRECTIVE_HOOK */, [vnode.el, binding, vnode, prevVNode]);\n      (0, reactivity_1.resetTracking)();\n    }\n  }\n}\nconst COMPONENTS = 'components';\nconst DIRECTIVES = 'directives';\n/**\n * @private\n */\nfunction resolveComponent(name, maybeSelfReference) {\n  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;\n}\nexports.resolveComponent = resolveComponent;\nconst NULL_DYNAMIC_COMPONENT = Symbol();\n/**\n * @private\n */\nfunction resolveDynamicComponent(component) {\n  if ((0, shared_1.isString)(component)) {\n    return resolveAsset(COMPONENTS, component, false) || component;\n  } else {\n    // invalid types will fallthrough to createVNode and raise warning\n    return component || NULL_DYNAMIC_COMPONENT;\n  }\n}\nexports.resolveDynamicComponent = resolveDynamicComponent;\n/**\n * @private\n */\nfunction resolveDirective(name) {\n  return resolveAsset(DIRECTIVES, name);\n}\nexports.resolveDirective = resolveDirective;\n// implementation\nfunction resolveAsset(type, name) {\n  let warnMissing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let maybeSelfReference = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const instance = currentRenderingInstance || currentInstance;\n  if (instance) {\n    const Component = instance.type;\n    // explicit self name has highest priority\n    if (type === COMPONENTS) {\n      const selfName = getComponentName(Component, false /* do not include inferred name to avoid breaking existing code */);\n      if (selfName && (selfName === name || selfName === (0, shared_1.camelize)(name) || selfName === (0, shared_1.capitalize)((0, shared_1.camelize)(name)))) {\n        return Component;\n      }\n    }\n    const res =\n    // local registration\n    // check instance[type] first which is resolved for options API\n    resolve(instance[type] || Component[type], name) ||\n    // global registration\n    resolve(instance.appContext[type], name);\n    if (!res && maybeSelfReference) {\n      // fallback to implicit self-reference\n      return Component;\n    }\n    if ( true && warnMissing && !res) {\n      const extra = type === COMPONENTS ? `\\nIf this is a native custom element, make sure to exclude it from ` + `component resolution via compilerOptions.isCustomElement.` : ``;\n      warn(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);\n    }\n    return res;\n  } else if (true) {\n    warn(`resolve${(0, shared_1.capitalize)(type.slice(0, -1))} ` + `can only be used in render() or setup().`);\n  }\n}\nfunction resolve(registry, name) {\n  return registry && (registry[name] || registry[(0, shared_1.camelize)(name)] || registry[(0, shared_1.capitalize)((0, shared_1.camelize)(name))]);\n}\n/**\n * Actual implementation\n */\nfunction renderList(source, renderItem, cache, index) {\n  let ret;\n  const cached = cache && cache[index];\n  if ((0, shared_1.isArray)(source) || (0, shared_1.isString)(source)) {\n    ret = new Array(source.length);\n    for (let i = 0, l = source.length; i < l; i++) {\n      ret[i] = renderItem(source[i], i, undefined, cached && cached[i]);\n    }\n  } else if (typeof source === 'number') {\n    if ( true && !Number.isInteger(source)) {\n      warn(`The v-for range expect an integer value but got ${source}.`);\n    }\n    ret = new Array(source);\n    for (let i = 0; i < source; i++) {\n      ret[i] = renderItem(i + 1, i, undefined, cached && cached[i]);\n    }\n  } else if ((0, shared_1.isObject)(source)) {\n    if (source[Symbol.iterator]) {\n      ret = Array.from(source, (item, i) => renderItem(item, i, undefined, cached && cached[i]));\n    } else {\n      const keys = Object.keys(source);\n      ret = new Array(keys.length);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i];\n        ret[i] = renderItem(source[key], key, i, cached && cached[i]);\n      }\n    }\n  } else {\n    ret = [];\n  }\n  if (cache) {\n    cache[index] = ret;\n  }\n  return ret;\n}\nexports.renderList = renderList;\n/**\n * Compiler runtime helper for creating dynamic slots object\n * @private\n */\nfunction createSlots(slots, dynamicSlots) {\n  for (let i = 0; i < dynamicSlots.length; i++) {\n    const slot = dynamicSlots[i];\n    // array of dynamic slot generated by <template v-for=\"...\" #[...]>\n    if ((0, shared_1.isArray)(slot)) {\n      for (let j = 0; j < slot.length; j++) {\n        slots[slot[j].name] = slot[j].fn;\n      }\n    } else if (slot) {\n      // conditional single slot generated by <template v-if=\"...\" #foo>\n      slots[slot.name] = slot.key ? function () {\n        const res = slot.fn(...arguments);\n        // attach branch key so each conditional branch is considered a\n        // different fragment\n        if (res) res.key = slot.key;\n        return res;\n      } : slot.fn;\n    }\n  }\n  return slots;\n}\nexports.createSlots = createSlots;\n/**\n * Compiler runtime helper for rendering `<slot/>`\n * @private\n */\nfunction renderSlot(slots, name) {\n  let props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let\n  // this is not a user-facing function, so the fallback is always generated by\n  // the compiler and guaranteed to be a function returning an array\n  fallback = arguments.length > 3 ? arguments[3] : undefined;\n  let noSlotted = arguments.length > 4 ? arguments[4] : undefined;\n  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {\n    if (name !== 'default') props.name = name;\n    return createVNode('slot', props, fallback && fallback());\n  }\n  let slot = slots[name];\n  if ( true && slot && slot.length > 1) {\n    warn(`SSR-optimized slot function detected in a non-SSR-optimized render ` + `function. You need to mark this component with $dynamic-slots in the ` + `parent template.`);\n    slot = () => [];\n  }\n  // a compiled slot disables block tracking by default to avoid manual\n  // invocation interfering with template-based block tracking, but in\n  // `renderSlot` we can be sure that it's template-based so we can force\n  // enable it.\n  if (slot && slot._c) {\n    slot._d = false;\n  }\n  openBlock();\n  const validSlotContent = slot && ensureValidVNode(slot(props));\n  const rendered = createBlock(Fragment, {\n    key: props.key ||\n    // slot content array of a dynamic conditional slot may have a branch\n    // key attached in the `createSlots` helper, respect that\n    validSlotContent && validSlotContent.key || `_${name}`\n  }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 /* SlotFlags.STABLE */ ? 64 /* PatchFlags.STABLE_FRAGMENT */ : -2 /* PatchFlags.BAIL */);\n  if (!noSlotted && rendered.scopeId) {\n    rendered.slotScopeIds = [rendered.scopeId + '-s'];\n  }\n  if (slot && slot._c) {\n    slot._d = true;\n  }\n  return rendered;\n}\nexports.renderSlot = renderSlot;\nfunction ensureValidVNode(vnodes) {\n  return vnodes.some(child => {\n    if (!isVNode(child)) return true;\n    if (child.type === Comment) return false;\n    if (child.type === Fragment && !ensureValidVNode(child.children)) return false;\n    return true;\n  }) ? vnodes : null;\n}\n/**\n * For prefixing keys in v-on=\"obj\" with \"on\"\n * @private\n */\nfunction toHandlers(obj, preserveCaseIfNecessary) {\n  const ret = {};\n  if ( true && !(0, shared_1.isObject)(obj)) {\n    warn(`v-on with no argument expects an object value.`);\n    return ret;\n  }\n  for (const key in obj) {\n    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : (0, shared_1.toHandlerKey)(key)] = obj[key];\n  }\n  return ret;\n}\nexports.toHandlers = toHandlers;\n/**\n * #2437 In Vue 3, functional components do not have a public instance proxy but\n * they exist in the internal parent chain. For code that relies on traversing\n * public $parent chains, skip functional ones and go to the parent instead.\n */\nconst getPublicInstance = i => {\n  if (!i) return null;\n  if (isStatefulComponent(i)) return getExposeProxy(i) || i.proxy;\n  return getPublicInstance(i.parent);\n};\nconst publicPropertiesMap =\n// Move PURE marker to new line to workaround compiler discarding it\n// due to type annotation\n/*#__PURE__*/\n(0, shared_1.extend)(Object.create(null), {\n  $: i => i,\n  $el: i => i.vnode.el,\n  $data: i => i.data,\n  $props: i =>  true ? (0, reactivity_1.shallowReadonly)(i.props) : 0,\n  $attrs: i =>  true ? (0, reactivity_1.shallowReadonly)(i.attrs) : 0,\n  $slots: i =>  true ? (0, reactivity_1.shallowReadonly)(i.slots) : 0,\n  $refs: i =>  true ? (0, reactivity_1.shallowReadonly)(i.refs) : 0,\n  $parent: i => getPublicInstance(i.parent),\n  $root: i => getPublicInstance(i.root),\n  $emit: i => i.emit,\n  $options: i => __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,\n  $forceUpdate: i => i.f || (i.f = () => queueJob(i.update)),\n  $nextTick: i => i.n || (i.n = nextTick.bind(i.proxy)),\n  $watch: i => __VUE_OPTIONS_API__ ? instanceWatch.bind(i) : shared_1.NOOP\n});\nconst isReservedPrefix = key => key === '_' || key === '$';\nconst hasSetupBinding = (state, key) => state !== shared_1.EMPTY_OBJ && !state.__isScriptSetup && (0, shared_1.hasOwn)(state, key);\nconst PublicInstanceProxyHandlers = {\n  get(_ref9, key) {\n    let {\n      _: instance\n    } = _ref9;\n    const {\n      ctx,\n      setupState,\n      data,\n      props,\n      accessCache,\n      type,\n      appContext\n    } = instance;\n    // for internal formatters to know that this is a Vue instance\n    if ( true && key === '__isVue') {\n      return true;\n    }\n    // data / props / ctx\n    // This getter gets called for every property access on the render context\n    // during render and is a major hotspot. The most expensive part of this\n    // is the multiple hasOwn() calls. It's much faster to do a simple property\n    // access on a plain object, so we use an accessCache object (with null\n    // prototype) to memoize what access type a key corresponds to.\n    let normalizedProps;\n    if (key[0] !== '$') {\n      const n = accessCache[key];\n      if (n !== undefined) {\n        switch (n) {\n          case 1 /* AccessTypes.SETUP */:\n            return setupState[key];\n          case 2 /* AccessTypes.DATA */:\n            return data[key];\n          case 4 /* AccessTypes.CONTEXT */:\n            return ctx[key];\n          case 3 /* AccessTypes.PROPS */:\n            return props[key];\n          // default: just fallthrough\n        }\n      } else if (hasSetupBinding(setupState, key)) {\n        accessCache[key] = 1 /* AccessTypes.SETUP */;\n        return setupState[key];\n      } else if (data !== shared_1.EMPTY_OBJ && (0, shared_1.hasOwn)(data, key)) {\n        accessCache[key] = 2 /* AccessTypes.DATA */;\n        return data[key];\n      } else if (\n      // only cache other properties when instance has declared (thus stable)\n      // props\n      (normalizedProps = instance.propsOptions[0]) && (0, shared_1.hasOwn)(normalizedProps, key)) {\n        accessCache[key] = 3 /* AccessTypes.PROPS */;\n        return props[key];\n      } else if (ctx !== shared_1.EMPTY_OBJ && (0, shared_1.hasOwn)(ctx, key)) {\n        accessCache[key] = 4 /* AccessTypes.CONTEXT */;\n        return ctx[key];\n      } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {\n        accessCache[key] = 0 /* AccessTypes.OTHER */;\n      }\n    }\n\n    const publicGetter = publicPropertiesMap[key];\n    let cssModule, globalProperties;\n    // public $xxx properties\n    if (publicGetter) {\n      if (key === '$attrs') {\n        (0, reactivity_1.track)(instance, \"get\" /* TrackOpTypes.GET */, key);\n         true && markAttrsAccessed();\n      }\n      return publicGetter(instance);\n    } else if (\n    // css module (injected by vue-loader)\n    (cssModule = type.__cssModules) && (cssModule = cssModule[key])) {\n      return cssModule;\n    } else if (ctx !== shared_1.EMPTY_OBJ && (0, shared_1.hasOwn)(ctx, key)) {\n      // user may set custom properties to `this` that start with `$`\n      accessCache[key] = 4 /* AccessTypes.CONTEXT */;\n      return ctx[key];\n    } else if (\n    // global properties\n    globalProperties = appContext.config.globalProperties, (0, shared_1.hasOwn)(globalProperties, key)) {\n      {\n        return globalProperties[key];\n      }\n    } else if ( true && currentRenderingInstance && (!(0, shared_1.isString)(key) ||\n    // #1091 avoid internal isRef/isVNode checks on component instance leading\n    // to infinite warning loop\n    key.indexOf('__v') !== 0)) {\n      if (data !== shared_1.EMPTY_OBJ && isReservedPrefix(key[0]) && (0, shared_1.hasOwn)(data, key)) {\n        warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` + `character (\"$\" or \"_\") and is not proxied on the render context.`);\n      } else if (instance === currentRenderingInstance) {\n        warn(`Property ${JSON.stringify(key)} was accessed during render ` + `but is not defined on instance.`);\n      }\n    }\n  },\n  set(_ref10, key, value) {\n    let {\n      _: instance\n    } = _ref10;\n    const {\n      data,\n      setupState,\n      ctx\n    } = instance;\n    if (hasSetupBinding(setupState, key)) {\n      setupState[key] = value;\n      return true;\n    } else if ( true && setupState.__isScriptSetup && (0, shared_1.hasOwn)(setupState, key)) {\n      warn(`Cannot mutate <script setup> binding \"${key}\" from Options API.`);\n      return false;\n    } else if (data !== shared_1.EMPTY_OBJ && (0, shared_1.hasOwn)(data, key)) {\n      data[key] = value;\n      return true;\n    } else if ((0, shared_1.hasOwn)(instance.props, key)) {\n       true && warn(`Attempting to mutate prop \"${key}\". Props are readonly.`);\n      return false;\n    }\n    if (key[0] === '$' && key.slice(1) in instance) {\n       true && warn(`Attempting to mutate public property \"${key}\". ` + `Properties starting with $ are reserved and readonly.`);\n      return false;\n    } else {\n      if ( true && key in instance.appContext.config.globalProperties) {\n        Object.defineProperty(ctx, key, {\n          enumerable: true,\n          configurable: true,\n          value\n        });\n      } else {\n        ctx[key] = value;\n      }\n    }\n    return true;\n  },\n  has(_ref11, key) {\n    let {\n      _: {\n        data,\n        setupState,\n        accessCache,\n        ctx,\n        appContext,\n        propsOptions\n      }\n    } = _ref11;\n    let normalizedProps;\n    return !!accessCache[key] || data !== shared_1.EMPTY_OBJ && (0, shared_1.hasOwn)(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && (0, shared_1.hasOwn)(normalizedProps, key) || (0, shared_1.hasOwn)(ctx, key) || (0, shared_1.hasOwn)(publicPropertiesMap, key) || (0, shared_1.hasOwn)(appContext.config.globalProperties, key);\n  },\n  defineProperty(target, key, descriptor) {\n    if (descriptor.get != null) {\n      // invalidate key cache of a getter based property #5417\n      target._.accessCache[key] = 0;\n    } else if ((0, shared_1.hasOwn)(descriptor, 'value')) {\n      this.set(target, key, descriptor.value, null);\n    }\n    return Reflect.defineProperty(target, key, descriptor);\n  }\n};\nif (true) {\n  PublicInstanceProxyHandlers.ownKeys = target => {\n    warn(`Avoid app logic that relies on enumerating keys on a component instance. ` + `The keys will be empty in production mode to avoid performance overhead.`);\n    return Reflect.ownKeys(target);\n  };\n}\nconst RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/(0, shared_1.extend)({}, PublicInstanceProxyHandlers, {\n  get(target, key) {\n    // fast path for unscopables when using `with` block\n    if (key === Symbol.unscopables) {\n      return;\n    }\n    return PublicInstanceProxyHandlers.get(target, key, target);\n  },\n  has(_, key) {\n    const has = key[0] !== '_' && !(0, shared_1.isGloballyWhitelisted)(key);\n    if ( true && !has && PublicInstanceProxyHandlers.has(_, key)) {\n      warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);\n    }\n    return has;\n  }\n});\n// dev only\n// In dev mode, the proxy target exposes the same properties as seen on `this`\n// for easier console inspection. In prod mode it will be an empty object so\n// these properties definitions can be skipped.\nfunction createDevRenderContext(instance) {\n  const target = {};\n  // expose internal instance for proxy handlers\n  Object.defineProperty(target, `_`, {\n    configurable: true,\n    enumerable: false,\n    get: () => instance\n  });\n  // expose public properties\n  Object.keys(publicPropertiesMap).forEach(key => {\n    Object.defineProperty(target, key, {\n      configurable: true,\n      enumerable: false,\n      get: () => publicPropertiesMap[key](instance),\n      // intercepted by the proxy so no need for implementation,\n      // but needed to prevent set errors\n      set: shared_1.NOOP\n    });\n  });\n  return target;\n}\n// dev only\nfunction exposePropsOnRenderContext(instance) {\n  const {\n    ctx,\n    propsOptions: [propsOptions]\n  } = instance;\n  if (propsOptions) {\n    Object.keys(propsOptions).forEach(key => {\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => instance.props[key],\n        set: shared_1.NOOP\n      });\n    });\n  }\n}\n// dev only\nfunction exposeSetupStateOnRenderContext(instance) {\n  const {\n    ctx,\n    setupState\n  } = instance;\n  Object.keys((0, reactivity_1.toRaw)(setupState)).forEach(key => {\n    if (!setupState.__isScriptSetup) {\n      if (isReservedPrefix(key[0])) {\n        warn(`setup() return property ${JSON.stringify(key)} should not start with \"$\" or \"_\" ` + `which are reserved prefixes for Vue internals.`);\n        return;\n      }\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => setupState[key],\n        set: shared_1.NOOP\n      });\n    }\n  });\n}\nfunction createDuplicateChecker() {\n  const cache = Object.create(null);\n  return (type, key) => {\n    if (cache[key]) {\n      warn(`${type} property \"${key}\" is already defined in ${cache[key]}.`);\n    } else {\n      cache[key] = type;\n    }\n  };\n}\nlet shouldCacheAccess = true;\nfunction applyOptions(instance) {\n  const options = resolveMergedOptions(instance);\n  const publicThis = instance.proxy;\n  const ctx = instance.ctx;\n  // do not cache property access on public proxy during state initialization\n  shouldCacheAccess = false;\n  // call beforeCreate first before accessing other options since\n  // the hook may mutate resolved options (#2791)\n  if (options.beforeCreate) {\n    callHook(options.beforeCreate, instance, \"bc\" /* LifecycleHooks.BEFORE_CREATE */);\n  }\n\n  const {\n    // state\n    data: dataOptions,\n    computed: computedOptions,\n    methods,\n    watch: watchOptions,\n    provide: provideOptions,\n    inject: injectOptions,\n    // lifecycle\n    created,\n    beforeMount,\n    mounted,\n    beforeUpdate,\n    updated,\n    activated,\n    deactivated,\n    beforeDestroy,\n    beforeUnmount,\n    destroyed,\n    unmounted,\n    render,\n    renderTracked,\n    renderTriggered,\n    errorCaptured,\n    serverPrefetch,\n    // public API\n    expose,\n    inheritAttrs,\n    // assets\n    components,\n    directives,\n    filters\n  } = options;\n  const checkDuplicateProperties =  true ? createDuplicateChecker() : 0;\n  if (true) {\n    const [propsOptions] = instance.propsOptions;\n    if (propsOptions) {\n      for (const key in propsOptions) {\n        checkDuplicateProperties(\"Props\" /* OptionTypes.PROPS */, key);\n      }\n    }\n  }\n  // options initialization order (to be consistent with Vue 2):\n  // - props (already done outside of this function)\n  // - inject\n  // - methods\n  // - data (deferred since it relies on `this` access)\n  // - computed\n  // - watch (deferred since it relies on `this` access)\n  if (injectOptions) {\n    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);\n  }\n  if (methods) {\n    for (const key in methods) {\n      const methodHandler = methods[key];\n      if ((0, shared_1.isFunction)(methodHandler)) {\n        // In dev mode, we use the `createRenderContext` function to define\n        // methods to the proxy target, and those are read-only but\n        // reconfigurable, so it needs to be redefined here\n        if (true) {\n          Object.defineProperty(ctx, key, {\n            value: methodHandler.bind(publicThis),\n            configurable: true,\n            enumerable: true,\n            writable: true\n          });\n        } else {}\n        if (true) {\n          checkDuplicateProperties(\"Methods\" /* OptionTypes.METHODS */, key);\n        }\n      } else if (true) {\n        warn(`Method \"${key}\" has type \"${typeof methodHandler}\" in the component definition. ` + `Did you reference the function correctly?`);\n      }\n    }\n  }\n  if (dataOptions) {\n    if ( true && !(0, shared_1.isFunction)(dataOptions)) {\n      warn(`The data option must be a function. ` + `Plain object usage is no longer supported.`);\n    }\n    const data = dataOptions.call(publicThis, publicThis);\n    if ( true && (0, shared_1.isPromise)(data)) {\n      warn(`data() returned a Promise - note data() cannot be async; If you ` + `intend to perform data fetching before component renders, use ` + `async setup() + <Suspense>.`);\n    }\n    if (!(0, shared_1.isObject)(data)) {\n       true && warn(`data() should return an object.`);\n    } else {\n      instance.data = (0, reactivity_1.reactive)(data);\n      if (true) {\n        for (const key in data) {\n          checkDuplicateProperties(\"Data\" /* OptionTypes.DATA */, key);\n          // expose data on ctx during dev\n          if (!isReservedPrefix(key[0])) {\n            Object.defineProperty(ctx, key, {\n              configurable: true,\n              enumerable: true,\n              get: () => data[key],\n              set: shared_1.NOOP\n            });\n          }\n        }\n      }\n    }\n  }\n  // state initialization complete at this point - start caching access\n  shouldCacheAccess = true;\n  if (computedOptions) {\n    for (const key in computedOptions) {\n      const opt = computedOptions[key];\n      const get = (0, shared_1.isFunction)(opt) ? opt.bind(publicThis, publicThis) : (0, shared_1.isFunction)(opt.get) ? opt.get.bind(publicThis, publicThis) : shared_1.NOOP;\n      if ( true && get === shared_1.NOOP) {\n        warn(`Computed property \"${key}\" has no getter.`);\n      }\n      const set = !(0, shared_1.isFunction)(opt) && (0, shared_1.isFunction)(opt.set) ? opt.set.bind(publicThis) :  true ? () => {\n        warn(`Write operation failed: computed property \"${key}\" is readonly.`);\n      } : 0;\n      const c = computed({\n        get,\n        set\n      });\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => c.value,\n        set: v => c.value = v\n      });\n      if (true) {\n        checkDuplicateProperties(\"Computed\" /* OptionTypes.COMPUTED */, key);\n      }\n    }\n  }\n  if (watchOptions) {\n    for (const key in watchOptions) {\n      createWatcher(watchOptions[key], ctx, publicThis, key);\n    }\n  }\n  if (provideOptions) {\n    const provides = (0, shared_1.isFunction)(provideOptions) ? provideOptions.call(publicThis) : provideOptions;\n    Reflect.ownKeys(provides).forEach(key => {\n      provide(key, provides[key]);\n    });\n  }\n  if (created) {\n    callHook(created, instance, \"c\" /* LifecycleHooks.CREATED */);\n  }\n\n  function registerLifecycleHook(register, hook) {\n    if ((0, shared_1.isArray)(hook)) {\n      hook.forEach(_hook => register(_hook.bind(publicThis)));\n    } else if (hook) {\n      register(hook.bind(publicThis));\n    }\n  }\n  registerLifecycleHook(onBeforeMount, beforeMount);\n  registerLifecycleHook(onMounted, mounted);\n  registerLifecycleHook(onBeforeUpdate, beforeUpdate);\n  registerLifecycleHook(onUpdated, updated);\n  registerLifecycleHook(onActivated, activated);\n  registerLifecycleHook(onDeactivated, deactivated);\n  registerLifecycleHook(onErrorCaptured, errorCaptured);\n  registerLifecycleHook(onRenderTracked, renderTracked);\n  registerLifecycleHook(onRenderTriggered, renderTriggered);\n  registerLifecycleHook(onBeforeUnmount, beforeUnmount);\n  registerLifecycleHook(onUnmounted, unmounted);\n  registerLifecycleHook(onServerPrefetch, serverPrefetch);\n  if ((0, shared_1.isArray)(expose)) {\n    if (expose.length) {\n      const exposed = instance.exposed || (instance.exposed = {});\n      expose.forEach(key => {\n        Object.defineProperty(exposed, key, {\n          get: () => publicThis[key],\n          set: val => publicThis[key] = val\n        });\n      });\n    } else if (!instance.exposed) {\n      instance.exposed = {};\n    }\n  }\n  // options that are handled when creating the instance but also need to be\n  // applied from mixins\n  if (render && instance.render === shared_1.NOOP) {\n    instance.render = render;\n  }\n  if (inheritAttrs != null) {\n    instance.inheritAttrs = inheritAttrs;\n  }\n  // asset options.\n  if (components) instance.components = components;\n  if (directives) instance.directives = directives;\n}\nfunction resolveInjections(injectOptions, ctx) {\n  let checkDuplicateProperties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : shared_1.NOOP;\n  let unwrapRef = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if ((0, shared_1.isArray)(injectOptions)) {\n    injectOptions = normalizeInject(injectOptions);\n  }\n  for (const key in injectOptions) {\n    const opt = injectOptions[key];\n    let injected;\n    if ((0, shared_1.isObject)(opt)) {\n      if ('default' in opt) {\n        injected = inject(opt.from || key, opt.default, true /* treat default function as factory */);\n      } else {\n        injected = inject(opt.from || key);\n      }\n    } else {\n      injected = inject(opt);\n    }\n    if ((0, reactivity_1.isRef)(injected)) {\n      // TODO remove the check in 3.3\n      if (unwrapRef) {\n        Object.defineProperty(ctx, key, {\n          enumerable: true,\n          configurable: true,\n          get: () => injected.value,\n          set: v => injected.value = v\n        });\n      } else {\n        if (true) {\n          warn(`injected property \"${key}\" is a ref and will be auto-unwrapped ` + `and no longer needs \\`.value\\` in the next minor release. ` + `To opt-in to the new behavior now, ` + `set \\`app.config.unwrapInjectedRef = true\\` (this config is ` + `temporary and will not be needed in the future.)`);\n        }\n        ctx[key] = injected;\n      }\n    } else {\n      ctx[key] = injected;\n    }\n    if (true) {\n      checkDuplicateProperties(\"Inject\" /* OptionTypes.INJECT */, key);\n    }\n  }\n}\nfunction callHook(hook, instance, type) {\n  callWithAsyncErrorHandling((0, shared_1.isArray)(hook) ? hook.map(h => h.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);\n}\nfunction createWatcher(raw, ctx, publicThis, key) {\n  const getter = key.includes('.') ? createPathGetter(publicThis, key) : () => publicThis[key];\n  if ((0, shared_1.isString)(raw)) {\n    const handler = ctx[raw];\n    if ((0, shared_1.isFunction)(handler)) {\n      watch(getter, handler);\n    } else if (true) {\n      warn(`Invalid watch handler specified by key \"${raw}\"`, handler);\n    }\n  } else if ((0, shared_1.isFunction)(raw)) {\n    watch(getter, raw.bind(publicThis));\n  } else if ((0, shared_1.isObject)(raw)) {\n    if ((0, shared_1.isArray)(raw)) {\n      raw.forEach(r => createWatcher(r, ctx, publicThis, key));\n    } else {\n      const handler = (0, shared_1.isFunction)(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];\n      if ((0, shared_1.isFunction)(handler)) {\n        watch(getter, handler, raw);\n      } else if (true) {\n        warn(`Invalid watch handler specified by key \"${raw.handler}\"`, handler);\n      }\n    }\n  } else if (true) {\n    warn(`Invalid watch option: \"${key}\"`, raw);\n  }\n}\n/**\n * Resolve merged options and cache it on the component.\n * This is done only once per-component since the merging does not involve\n * instances.\n */\nfunction resolveMergedOptions(instance) {\n  const base = instance.type;\n  const {\n    mixins,\n    extends: extendsOptions\n  } = base;\n  const {\n    mixins: globalMixins,\n    optionsCache: cache,\n    config: {\n      optionMergeStrategies\n    }\n  } = instance.appContext;\n  const cached = cache.get(base);\n  let resolved;\n  if (cached) {\n    resolved = cached;\n  } else if (!globalMixins.length && !mixins && !extendsOptions) {\n    {\n      resolved = base;\n    }\n  } else {\n    resolved = {};\n    if (globalMixins.length) {\n      globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));\n    }\n    mergeOptions(resolved, base, optionMergeStrategies);\n  }\n  if ((0, shared_1.isObject)(base)) {\n    cache.set(base, resolved);\n  }\n  return resolved;\n}\nfunction mergeOptions(to, from, strats) {\n  let asMixin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const {\n    mixins,\n    extends: extendsOptions\n  } = from;\n  if (extendsOptions) {\n    mergeOptions(to, extendsOptions, strats, true);\n  }\n  if (mixins) {\n    mixins.forEach(m => mergeOptions(to, m, strats, true));\n  }\n  for (const key in from) {\n    if (asMixin && key === 'expose') {\n       true && warn(`\"expose\" option is ignored when declared in mixins or extends. ` + `It should only be declared in the base component itself.`);\n    } else {\n      const strat = internalOptionMergeStrats[key] || strats && strats[key];\n      to[key] = strat ? strat(to[key], from[key]) : from[key];\n    }\n  }\n  return to;\n}\nconst internalOptionMergeStrats = {\n  data: mergeDataFn,\n  props: mergeObjectOptions,\n  emits: mergeObjectOptions,\n  // objects\n  methods: mergeObjectOptions,\n  computed: mergeObjectOptions,\n  // lifecycle\n  beforeCreate: mergeAsArray,\n  created: mergeAsArray,\n  beforeMount: mergeAsArray,\n  mounted: mergeAsArray,\n  beforeUpdate: mergeAsArray,\n  updated: mergeAsArray,\n  beforeDestroy: mergeAsArray,\n  beforeUnmount: mergeAsArray,\n  destroyed: mergeAsArray,\n  unmounted: mergeAsArray,\n  activated: mergeAsArray,\n  deactivated: mergeAsArray,\n  errorCaptured: mergeAsArray,\n  serverPrefetch: mergeAsArray,\n  // assets\n  components: mergeObjectOptions,\n  directives: mergeObjectOptions,\n  // watch\n  watch: mergeWatchOptions,\n  // provide / inject\n  provide: mergeDataFn,\n  inject: mergeInject\n};\nfunction mergeDataFn(to, from) {\n  if (!from) {\n    return to;\n  }\n  if (!to) {\n    return from;\n  }\n  return function mergedDataFn() {\n    return shared_1.extend((0, shared_1.isFunction)(to) ? to.call(this, this) : to, (0, shared_1.isFunction)(from) ? from.call(this, this) : from);\n  };\n}\nfunction mergeInject(to, from) {\n  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));\n}\nfunction normalizeInject(raw) {\n  if ((0, shared_1.isArray)(raw)) {\n    const res = {};\n    for (let i = 0; i < raw.length; i++) {\n      res[raw[i]] = raw[i];\n    }\n    return res;\n  }\n  return raw;\n}\nfunction mergeAsArray(to, from) {\n  return to ? [...new Set([].concat(to, from))] : from;\n}\nfunction mergeObjectOptions(to, from) {\n  return to ? (0, shared_1.extend)((0, shared_1.extend)(Object.create(null), to), from) : from;\n}\nfunction mergeWatchOptions(to, from) {\n  if (!to) return from;\n  if (!from) return to;\n  const merged = (0, shared_1.extend)(Object.create(null), to);\n  for (const key in from) {\n    merged[key] = mergeAsArray(to[key], from[key]);\n  }\n  return merged;\n}\nfunction initProps(instance, rawProps, isStateful) {\n  let isSSR = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const props = {};\n  const attrs = {};\n  (0, shared_1.def)(attrs, InternalObjectKey, 1);\n  instance.propsDefaults = Object.create(null);\n  setFullProps(instance, rawProps, props, attrs);\n  // ensure all declared prop keys are present\n  for (const key in instance.propsOptions[0]) {\n    if (!(key in props)) {\n      props[key] = undefined;\n    }\n  }\n  // validation\n  if (true) {\n    validateProps(rawProps || {}, props, instance);\n  }\n  if (isStateful) {\n    // stateful\n    instance.props = isSSR ? props : (0, reactivity_1.shallowReactive)(props);\n  } else {\n    if (!instance.type.props) {\n      // functional w/ optional props, props === attrs\n      instance.props = attrs;\n    } else {\n      // functional w/ declared props\n      instance.props = props;\n    }\n  }\n  instance.attrs = attrs;\n}\nfunction isInHmrContext(instance) {\n  while (instance) {\n    if (instance.type.__hmrId) return true;\n    instance = instance.parent;\n  }\n}\nfunction updateProps(instance, rawProps, rawPrevProps, optimized) {\n  const {\n    props,\n    attrs,\n    vnode: {\n      patchFlag\n    }\n  } = instance;\n  const rawCurrentProps = (0, reactivity_1.toRaw)(props);\n  const [options] = instance.propsOptions;\n  let hasAttrsChanged = false;\n  if (\n  // always force full diff in dev\n  // - #1942 if hmr is enabled with sfc component\n  // - vite#872 non-sfc component used by sfc component\n  !( true && isInHmrContext(instance)) && (optimized || patchFlag > 0) && !(patchFlag & 16 /* PatchFlags.FULL_PROPS */)) {\n    if (patchFlag & 8 /* PatchFlags.PROPS */) {\n      // Compiler-generated props & no keys change, just set the updated\n      // the props.\n      const propsToUpdate = instance.vnode.dynamicProps;\n      for (let i = 0; i < propsToUpdate.length; i++) {\n        let key = propsToUpdate[i];\n        // skip if the prop key is a declared emit event listener\n        if (isEmitListener(instance.emitsOptions, key)) {\n          continue;\n        }\n        // PROPS flag guarantees rawProps to be non-null\n        const value = rawProps[key];\n        if (options) {\n          // attr / props separation was done on init and will be consistent\n          // in this code path, so just check if attrs have it.\n          if ((0, shared_1.hasOwn)(attrs, key)) {\n            if (value !== attrs[key]) {\n              attrs[key] = value;\n              hasAttrsChanged = true;\n            }\n          } else {\n            const camelizedKey = (0, shared_1.camelize)(key);\n            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false /* isAbsent */);\n          }\n        } else {\n          if (value !== attrs[key]) {\n            attrs[key] = value;\n            hasAttrsChanged = true;\n          }\n        }\n      }\n    }\n  } else {\n    // full props update.\n    if (setFullProps(instance, rawProps, props, attrs)) {\n      hasAttrsChanged = true;\n    }\n    // in case of dynamic props, check if we need to delete keys from\n    // the props object\n    let kebabKey;\n    for (const key in rawCurrentProps) {\n      if (!rawProps ||\n      // for camelCase\n      !(0, shared_1.hasOwn)(rawProps, key) && (\n      // it's possible the original props was passed in as kebab-case\n      // and converted to camelCase (#955)\n      (kebabKey = (0, shared_1.hyphenate)(key)) === key || !(0, shared_1.hasOwn)(rawProps, kebabKey))) {\n        if (options) {\n          if (rawPrevProps && (\n          // for camelCase\n          rawPrevProps[key] !== undefined ||\n          // for kebab-case\n          rawPrevProps[kebabKey] !== undefined)) {\n            props[key] = resolvePropValue(options, rawCurrentProps, key, undefined, instance, true /* isAbsent */);\n          }\n        } else {\n          delete props[key];\n        }\n      }\n    }\n    // in the case of functional component w/o props declaration, props and\n    // attrs point to the same object so it should already have been updated.\n    if (attrs !== rawCurrentProps) {\n      for (const key in attrs) {\n        if (!rawProps || !(0, shared_1.hasOwn)(rawProps, key) && !false) {\n          delete attrs[key];\n          hasAttrsChanged = true;\n        }\n      }\n    }\n  }\n  // trigger updates for $attrs in case it's used in component slots\n  if (hasAttrsChanged) {\n    (0, reactivity_1.trigger)(instance, \"set\" /* TriggerOpTypes.SET */, '$attrs');\n  }\n  if (true) {\n    validateProps(rawProps || {}, props, instance);\n  }\n}\nfunction setFullProps(instance, rawProps, props, attrs) {\n  const [options, needCastKeys] = instance.propsOptions;\n  let hasAttrsChanged = false;\n  let rawCastValues;\n  if (rawProps) {\n    for (let key in rawProps) {\n      // key, ref are reserved and never passed down\n      if ((0, shared_1.isReservedProp)(key)) {\n        continue;\n      }\n      const value = rawProps[key];\n      // prop option names are camelized during normalization, so to support\n      // kebab -> camel conversion here we need to camelize the key.\n      let camelKey;\n      if (options && (0, shared_1.hasOwn)(options, camelKey = (0, shared_1.camelize)(key))) {\n        if (!needCastKeys || !needCastKeys.includes(camelKey)) {\n          props[camelKey] = value;\n        } else {\n          (rawCastValues || (rawCastValues = {}))[camelKey] = value;\n        }\n      } else if (!isEmitListener(instance.emitsOptions, key)) {\n        if (!(key in attrs) || value !== attrs[key]) {\n          attrs[key] = value;\n          hasAttrsChanged = true;\n        }\n      }\n    }\n  }\n  if (needCastKeys) {\n    const rawCurrentProps = (0, reactivity_1.toRaw)(props);\n    const castValues = rawCastValues || shared_1.EMPTY_OBJ;\n    for (let i = 0; i < needCastKeys.length; i++) {\n      const key = needCastKeys[i];\n      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !(0, shared_1.hasOwn)(castValues, key));\n    }\n  }\n  return hasAttrsChanged;\n}\nfunction resolvePropValue(options, props, key, value, instance, isAbsent) {\n  const opt = options[key];\n  if (opt != null) {\n    const hasDefault = (0, shared_1.hasOwn)(opt, 'default');\n    // default values\n    if (hasDefault && value === undefined) {\n      const defaultValue = opt.default;\n      if (opt.type !== Function && (0, shared_1.isFunction)(defaultValue)) {\n        const {\n          propsDefaults\n        } = instance;\n        if (key in propsDefaults) {\n          value = propsDefaults[key];\n        } else {\n          setCurrentInstance(instance);\n          value = propsDefaults[key] = defaultValue.call(null, props);\n          unsetCurrentInstance();\n        }\n      } else {\n        value = defaultValue;\n      }\n    }\n    // boolean casting\n    if (opt[0 /* BooleanFlags.shouldCast */]) {\n      if (isAbsent && !hasDefault) {\n        value = false;\n      } else if (opt[1 /* BooleanFlags.shouldCastTrue */] && (value === '' || value === (0, shared_1.hyphenate)(key))) {\n        value = true;\n      }\n    }\n  }\n  return value;\n}\nfunction normalizePropsOptions(comp, appContext) {\n  let asMixin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const cache = appContext.propsCache;\n  const cached = cache.get(comp);\n  if (cached) {\n    return cached;\n  }\n  const raw = comp.props;\n  const normalized = {};\n  const needCastKeys = [];\n  // apply mixin/extends props\n  let hasExtends = false;\n  if (__VUE_OPTIONS_API__ && !(0, shared_1.isFunction)(comp)) {\n    const extendProps = raw => {\n      hasExtends = true;\n      const [props, keys] = normalizePropsOptions(raw, appContext, true);\n      (0, shared_1.extend)(normalized, props);\n      if (keys) needCastKeys.push(...keys);\n    };\n    if (!asMixin && appContext.mixins.length) {\n      appContext.mixins.forEach(extendProps);\n    }\n    if (comp.extends) {\n      extendProps(comp.extends);\n    }\n    if (comp.mixins) {\n      comp.mixins.forEach(extendProps);\n    }\n  }\n  if (!raw && !hasExtends) {\n    if ((0, shared_1.isObject)(comp)) {\n      cache.set(comp, shared_1.EMPTY_ARR);\n    }\n    return shared_1.EMPTY_ARR;\n  }\n  if ((0, shared_1.isArray)(raw)) {\n    for (let i = 0; i < raw.length; i++) {\n      if ( true && !(0, shared_1.isString)(raw[i])) {\n        warn(`props must be strings when using array syntax.`, raw[i]);\n      }\n      const normalizedKey = (0, shared_1.camelize)(raw[i]);\n      if (validatePropName(normalizedKey)) {\n        normalized[normalizedKey] = shared_1.EMPTY_OBJ;\n      }\n    }\n  } else if (raw) {\n    if ( true && !(0, shared_1.isObject)(raw)) {\n      warn(`invalid props options`, raw);\n    }\n    for (const key in raw) {\n      const normalizedKey = (0, shared_1.camelize)(key);\n      if (validatePropName(normalizedKey)) {\n        const opt = raw[key];\n        const prop = normalized[normalizedKey] = (0, shared_1.isArray)(opt) || (0, shared_1.isFunction)(opt) ? {\n          type: opt\n        } : Object.assign({}, opt);\n        if (prop) {\n          const booleanIndex = getTypeIndex(Boolean, prop.type);\n          const stringIndex = getTypeIndex(String, prop.type);\n          prop[0 /* BooleanFlags.shouldCast */] = booleanIndex > -1;\n          prop[1 /* BooleanFlags.shouldCastTrue */] = stringIndex < 0 || booleanIndex < stringIndex;\n          // if the prop needs boolean casting or default value\n          if (booleanIndex > -1 || (0, shared_1.hasOwn)(prop, 'default')) {\n            needCastKeys.push(normalizedKey);\n          }\n        }\n      }\n    }\n  }\n  const res = [normalized, needCastKeys];\n  if ((0, shared_1.isObject)(comp)) {\n    cache.set(comp, res);\n  }\n  return res;\n}\nfunction validatePropName(key) {\n  if (key[0] !== '$') {\n    return true;\n  } else if (true) {\n    warn(`Invalid prop name: \"${key}\" is a reserved property.`);\n  }\n  return false;\n}\n// use function string name to check type constructors\n// so that it works across vms / iframes.\nfunction getType(ctor) {\n  const match = ctor && ctor.toString().match(/^\\s*(function|class) (\\w+)/);\n  return match ? match[2] : ctor === null ? 'null' : '';\n}\nfunction isSameType(a, b) {\n  return getType(a) === getType(b);\n}\nfunction getTypeIndex(type, expectedTypes) {\n  if ((0, shared_1.isArray)(expectedTypes)) {\n    return expectedTypes.findIndex(t => isSameType(t, type));\n  } else if ((0, shared_1.isFunction)(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1;\n  }\n  return -1;\n}\n/**\n * dev only\n */\nfunction validateProps(rawProps, props, instance) {\n  const resolvedValues = (0, reactivity_1.toRaw)(props);\n  const options = instance.propsOptions[0];\n  for (const key in options) {\n    let opt = options[key];\n    if (opt == null) continue;\n    validateProp(key, resolvedValues[key], opt, !(0, shared_1.hasOwn)(rawProps, key) && !(0, shared_1.hasOwn)(rawProps, (0, shared_1.hyphenate)(key)));\n  }\n}\n/**\n * dev only\n */\nfunction validateProp(name, value, prop, isAbsent) {\n  const {\n    type,\n    required,\n    validator\n  } = prop;\n  // required!\n  if (required && isAbsent) {\n    warn('Missing required prop: \"' + name + '\"');\n    return;\n  }\n  // missing but optional\n  if (value == null && !prop.required) {\n    return;\n  }\n  // type check\n  if (type != null && type !== true) {\n    let isValid = false;\n    const types = (0, shared_1.isArray)(type) ? type : [type];\n    const expectedTypes = [];\n    // value is valid as long as one of the specified types match\n    for (let i = 0; i < types.length && !isValid; i++) {\n      const {\n        valid,\n        expectedType\n      } = assertType(value, types[i]);\n      expectedTypes.push(expectedType || '');\n      isValid = valid;\n    }\n    if (!isValid) {\n      warn(getInvalidTypeMessage(name, value, expectedTypes));\n      return;\n    }\n  }\n  // custom validator\n  if (validator && !validator(value)) {\n    warn('Invalid prop: custom validator check failed for prop \"' + name + '\".');\n  }\n}\nconst isSimpleType = /*#__PURE__*/(0, shared_1.makeMap)('String,Number,Boolean,Function,Symbol,BigInt');\n/**\n * dev only\n */\nfunction assertType(value, type) {\n  let valid;\n  const expectedType = getType(type);\n  if (isSimpleType(expectedType)) {\n    const t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    // for primitive wrapper objects\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = (0, shared_1.isObject)(value);\n  } else if (expectedType === 'Array') {\n    valid = (0, shared_1.isArray)(value);\n  } else if (expectedType === 'null') {\n    valid = value === null;\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid,\n    expectedType\n  };\n}\n/**\n * dev only\n */\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\n  let message = `Invalid prop: type check failed for prop \"${name}\".` + ` Expected ${expectedTypes.map(shared_1.capitalize).join(' | ')}`;\n  const expectedType = expectedTypes[0];\n  const receivedType = (0, shared_1.toRawType)(value);\n  const expectedValue = styleValue(value, expectedType);\n  const receivedValue = styleValue(value, receivedType);\n  // check if we need to specify expected value\n  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {\n    message += ` with value ${expectedValue}`;\n  }\n  message += `, got ${receivedType} `;\n  // check if we need to specify received value\n  if (isExplicable(receivedType)) {\n    message += `with value ${receivedValue}.`;\n  }\n  return message;\n}\n/**\n * dev only\n */\nfunction styleValue(value, type) {\n  if (type === 'String') {\n    return `\"${value}\"`;\n  } else if (type === 'Number') {\n    return `${Number(value)}`;\n  } else {\n    return `${value}`;\n  }\n}\n/**\n * dev only\n */\nfunction isExplicable(type) {\n  const explicitTypes = ['string', 'number', 'boolean'];\n  return explicitTypes.some(elem => type.toLowerCase() === elem);\n}\n/**\n * dev only\n */\nfunction isBoolean() {\n  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    args[_key5] = arguments[_key5];\n  }\n  return args.some(elem => elem.toLowerCase() === 'boolean');\n}\nconst isInternalKey = key => key[0] === '_' || key === '$stable';\nconst normalizeSlotValue = value => (0, shared_1.isArray)(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];\nconst normalizeSlot = (key, rawSlot, ctx) => {\n  if (rawSlot._n) {\n    // already normalized - #5353\n    return rawSlot;\n  }\n  const normalized = withCtx(function () {\n    if ( true && currentInstance) {\n      warn(`Slot \"${key}\" invoked outside of the render function: ` + `this will not track dependencies used in the slot. ` + `Invoke the slot function inside the render function instead.`);\n    }\n    return normalizeSlotValue(rawSlot(...arguments));\n  }, ctx);\n  normalized._c = false;\n  return normalized;\n};\nconst normalizeObjectSlots = (rawSlots, slots, instance) => {\n  const ctx = rawSlots._ctx;\n  for (const key in rawSlots) {\n    if (isInternalKey(key)) continue;\n    const value = rawSlots[key];\n    if ((0, shared_1.isFunction)(value)) {\n      slots[key] = normalizeSlot(key, value, ctx);\n    } else if (value != null) {\n      if (true) {\n        warn(`Non-function value encountered for slot \"${key}\". ` + `Prefer function slots for better performance.`);\n      }\n      const normalized = normalizeSlotValue(value);\n      slots[key] = () => normalized;\n    }\n  }\n};\nconst normalizeVNodeSlots = (instance, children) => {\n  if ( true && !isKeepAlive(instance.vnode) && !false) {\n    warn(`Non-function value encountered for default slot. ` + `Prefer function slots for better performance.`);\n  }\n  const normalized = normalizeSlotValue(children);\n  instance.slots.default = () => normalized;\n};\nconst initSlots = (instance, children) => {\n  if (instance.vnode.shapeFlag & 32 /* ShapeFlags.SLOTS_CHILDREN */) {\n    const type = children._;\n    if (type) {\n      // users can get the shallow readonly version of the slots object through `this.$slots`,\n      // we should avoid the proxy object polluting the slots of the internal instance\n      instance.slots = (0, reactivity_1.toRaw)(children);\n      // make compiler marker non-enumerable\n      (0, shared_1.def)(children, '_', type);\n    } else {\n      normalizeObjectSlots(children, instance.slots = {});\n    }\n  } else {\n    instance.slots = {};\n    if (children) {\n      normalizeVNodeSlots(instance, children);\n    }\n  }\n  (0, shared_1.def)(instance.slots, InternalObjectKey, 1);\n};\nconst updateSlots = (instance, children, optimized) => {\n  const {\n    vnode,\n    slots\n  } = instance;\n  let needDeletionCheck = true;\n  let deletionComparisonTarget = shared_1.EMPTY_OBJ;\n  if (vnode.shapeFlag & 32 /* ShapeFlags.SLOTS_CHILDREN */) {\n    const type = children._;\n    if (type) {\n      // compiled slots.\n      if ( true && isHmrUpdating) {\n        // Parent was HMR updated so slot content may have changed.\n        // force update slots and mark instance for hmr as well\n        (0, shared_1.extend)(slots, children);\n      } else if (optimized && type === 1 /* SlotFlags.STABLE */) {\n        // compiled AND stable.\n        // no need to update, and skip stale slots removal.\n        needDeletionCheck = false;\n      } else {\n        // compiled but dynamic (v-if/v-for on slots) - update slots, but skip\n        // normalization.\n        (0, shared_1.extend)(slots, children);\n        // #2893\n        // when rendering the optimized slots by manually written render function,\n        // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,\n        // i.e. let the `renderSlot` create the bailed Fragment\n        if (!optimized && type === 1 /* SlotFlags.STABLE */) {\n          delete slots._;\n        }\n      }\n    } else {\n      needDeletionCheck = !children.$stable;\n      normalizeObjectSlots(children, slots);\n    }\n    deletionComparisonTarget = children;\n  } else if (children) {\n    // non slot object children (direct value) passed to a component\n    normalizeVNodeSlots(instance, children);\n    deletionComparisonTarget = {\n      default: 1\n    };\n  }\n  // delete stale slots\n  if (needDeletionCheck) {\n    for (const key in slots) {\n      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {\n        delete slots[key];\n      }\n    }\n  }\n};\nfunction createAppContext() {\n  return {\n    app: null,\n    config: {\n      isNativeTag: shared_1.NO,\n      performance: false,\n      globalProperties: {},\n      optionMergeStrategies: {},\n      errorHandler: undefined,\n      warnHandler: undefined,\n      compilerOptions: {}\n    },\n    mixins: [],\n    components: {},\n    directives: {},\n    provides: Object.create(null),\n    optionsCache: new WeakMap(),\n    propsCache: new WeakMap(),\n    emitsCache: new WeakMap()\n  };\n}\nlet uid$1 = 0;\nfunction createAppAPI(render, hydrate) {\n  return function createApp(rootComponent) {\n    let rootProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (!(0, shared_1.isFunction)(rootComponent)) {\n      rootComponent = Object.assign({}, rootComponent);\n    }\n    if (rootProps != null && !(0, shared_1.isObject)(rootProps)) {\n       true && warn(`root props passed to app.mount() must be an object.`);\n      rootProps = null;\n    }\n    const context = createAppContext();\n    const installedPlugins = new Set();\n    let isMounted = false;\n    const app = context.app = {\n      _uid: uid$1++,\n      _component: rootComponent,\n      _props: rootProps,\n      _container: null,\n      _context: context,\n      _instance: null,\n      version,\n      get config() {\n        return context.config;\n      },\n      set config(v) {\n        if (true) {\n          warn(`app.config cannot be replaced. Modify individual options instead.`);\n        }\n      },\n      use(plugin) {\n        for (var _len6 = arguments.length, options = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n          options[_key6 - 1] = arguments[_key6];\n        }\n        if (installedPlugins.has(plugin)) {\n           true && warn(`Plugin has already been applied to target app.`);\n        } else if (plugin && (0, shared_1.isFunction)(plugin.install)) {\n          installedPlugins.add(plugin);\n          plugin.install(app, ...options);\n        } else if ((0, shared_1.isFunction)(plugin)) {\n          installedPlugins.add(plugin);\n          plugin(app, ...options);\n        } else if (true) {\n          warn(`A plugin must either be a function or an object with an \"install\" ` + `function.`);\n        }\n        return app;\n      },\n      mixin(mixin) {\n        if (__VUE_OPTIONS_API__) {\n          if (!context.mixins.includes(mixin)) {\n            context.mixins.push(mixin);\n          } else if (true) {\n            warn('Mixin has already been applied to target app' + (mixin.name ? `: ${mixin.name}` : ''));\n          }\n        } else if (true) {\n          warn('Mixins are only available in builds supporting Options API');\n        }\n        return app;\n      },\n      component(name, component) {\n        if (true) {\n          validateComponentName(name, context.config);\n        }\n        if (!component) {\n          return context.components[name];\n        }\n        if ( true && context.components[name]) {\n          warn(`Component \"${name}\" has already been registered in target app.`);\n        }\n        context.components[name] = component;\n        return app;\n      },\n      directive(name, directive) {\n        if (true) {\n          validateDirectiveName(name);\n        }\n        if (!directive) {\n          return context.directives[name];\n        }\n        if ( true && context.directives[name]) {\n          warn(`Directive \"${name}\" has already been registered in target app.`);\n        }\n        context.directives[name] = directive;\n        return app;\n      },\n      mount(rootContainer, isHydrate, isSVG) {\n        if (!isMounted) {\n          // #5571\n          if ( true && rootContainer.__vue_app__) {\n            warn(`There is already an app instance mounted on the host container.\\n` + ` If you want to mount another app on the same host container,` + ` you need to unmount the previous app by calling \\`app.unmount()\\` first.`);\n          }\n          const vnode = createVNode(rootComponent, rootProps);\n          // store app context on the root VNode.\n          // this will be set on the root instance on initial mount.\n          vnode.appContext = context;\n          // HMR root reload\n          if (true) {\n            context.reload = () => {\n              render(cloneVNode(vnode), rootContainer, isSVG);\n            };\n          }\n          if (isHydrate && hydrate) {\n            hydrate(vnode, rootContainer);\n          } else {\n            render(vnode, rootContainer, isSVG);\n          }\n          isMounted = true;\n          app._container = rootContainer;\n          rootContainer.__vue_app__ = app;\n          if (true) {\n            app._instance = vnode.component;\n            devtoolsInitApp(app, version);\n          }\n          return getExposeProxy(vnode.component) || vnode.component.proxy;\n        } else if (true) {\n          warn(`App has already been mounted.\\n` + `If you want to remount the same app, move your app creation logic ` + `into a factory function and create fresh app instances for each ` + `mount - e.g. \\`const createMyApp = () => createApp(App)\\``);\n        }\n      },\n      unmount() {\n        if (isMounted) {\n          render(null, app._container);\n          if (true) {\n            app._instance = null;\n            devtoolsUnmountApp(app);\n          }\n          delete app._container.__vue_app__;\n        } else if (true) {\n          warn(`Cannot unmount an app that is not mounted.`);\n        }\n      },\n      provide(key, value) {\n        if ( true && key in context.provides) {\n          warn(`App already provides property with key \"${String(key)}\". ` + `It will be overwritten with the new value.`);\n        }\n        context.provides[key] = value;\n        return app;\n      }\n    };\n    return app;\n  };\n}\n/**\n * Function for handling a template ref\n */\nfunction setRef(rawRef, oldRawRef, parentSuspense, vnode) {\n  let isUnmount = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  if ((0, shared_1.isArray)(rawRef)) {\n    rawRef.forEach((r, i) => setRef(r, oldRawRef && ((0, shared_1.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));\n    return;\n  }\n  if (isAsyncWrapper(vnode) && !isUnmount) {\n    // when mounting async components, nothing needs to be done,\n    // because the template ref is forwarded to inner component\n    return;\n  }\n  const refValue = vnode.shapeFlag & 4 /* ShapeFlags.STATEFUL_COMPONENT */ ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;\n  const value = isUnmount ? null : refValue;\n  const {\n    i: owner,\n    r: ref\n  } = rawRef;\n  if ( true && !owner) {\n    warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. ` + `A vnode with ref must be created inside the render function.`);\n    return;\n  }\n  const oldRef = oldRawRef && oldRawRef.r;\n  const refs = owner.refs === shared_1.EMPTY_OBJ ? owner.refs = {} : owner.refs;\n  const setupState = owner.setupState;\n  // dynamic ref changed. unset old ref\n  if (oldRef != null && oldRef !== ref) {\n    if ((0, shared_1.isString)(oldRef)) {\n      refs[oldRef] = null;\n      if ((0, shared_1.hasOwn)(setupState, oldRef)) {\n        setupState[oldRef] = null;\n      }\n    } else if ((0, reactivity_1.isRef)(oldRef)) {\n      oldRef.value = null;\n    }\n  }\n  if ((0, shared_1.isFunction)(ref)) {\n    callWithErrorHandling(ref, owner, 12 /* ErrorCodes.FUNCTION_REF */, [value, refs]);\n  } else {\n    const _isString = (0, shared_1.isString)(ref);\n    const _isRef = (0, reactivity_1.isRef)(ref);\n    if (_isString || _isRef) {\n      const doSet = () => {\n        if (rawRef.f) {\n          const existing = _isString ? (0, shared_1.hasOwn)(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;\n          if (isUnmount) {\n            (0, shared_1.isArray)(existing) && (0, shared_1.remove)(existing, refValue);\n          } else {\n            if (!(0, shared_1.isArray)(existing)) {\n              if (_isString) {\n                refs[ref] = [refValue];\n                if ((0, shared_1.hasOwn)(setupState, ref)) {\n                  setupState[ref] = refs[ref];\n                }\n              } else {\n                ref.value = [refValue];\n                if (rawRef.k) refs[rawRef.k] = ref.value;\n              }\n            } else if (!existing.includes(refValue)) {\n              existing.push(refValue);\n            }\n          }\n        } else if (_isString) {\n          refs[ref] = value;\n          if ((0, shared_1.hasOwn)(setupState, ref)) {\n            setupState[ref] = value;\n          }\n        } else if (_isRef) {\n          ref.value = value;\n          if (rawRef.k) refs[rawRef.k] = value;\n        } else if (true) {\n          warn('Invalid template ref type:', ref, `(${typeof ref})`);\n        }\n      };\n      if (value) {\n        doSet.id = -1;\n        queuePostRenderEffect(doSet, parentSuspense);\n      } else {\n        doSet();\n      }\n    } else if (true) {\n      warn('Invalid template ref type:', ref, `(${typeof ref})`);\n    }\n  }\n}\nlet hasMismatch = false;\nconst isSVGContainer = container => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';\nconst isComment = node => node.nodeType === 8 /* DOMNodeTypes.COMMENT */;\n// Note: hydration is DOM-specific\n// But we have to place it in core due to tight coupling with core - splitting\n// it out creates a ton of unnecessary complexity.\n// Hydration also depends on some renderer internal logic which needs to be\n// passed in via arguments.\nfunction createHydrationFunctions(rendererInternals) {\n  const {\n    mt: mountComponent,\n    p: patch,\n    o: {\n      patchProp,\n      createText,\n      nextSibling,\n      parentNode,\n      remove,\n      insert,\n      createComment\n    }\n  } = rendererInternals;\n  const hydrate = (vnode, container) => {\n    if (!container.hasChildNodes()) {\n       true && warn(`Attempting to hydrate existing markup but container is empty. ` + `Performing full mount instead.`);\n      patch(null, vnode, container);\n      flushPostFlushCbs();\n      container._vnode = vnode;\n      return;\n    }\n    hasMismatch = false;\n    hydrateNode(container.firstChild, vnode, null, null, null);\n    flushPostFlushCbs();\n    container._vnode = vnode;\n    if (hasMismatch && !false) {\n      // this error should show up in production\n      console.error(`Hydration completed but contains mismatches.`);\n    }\n  };\n  const hydrateNode = function (node, vnode, parentComponent, parentSuspense, slotScopeIds) {\n    let optimized = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    const isFragmentStart = isComment(node) && node.data === '[';\n    const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);\n    const {\n      type,\n      ref,\n      shapeFlag,\n      patchFlag\n    } = vnode;\n    let domType = node.nodeType;\n    vnode.el = node;\n    if (patchFlag === -2 /* PatchFlags.BAIL */) {\n      optimized = false;\n      vnode.dynamicChildren = null;\n    }\n    let nextNode = null;\n    switch (type) {\n      case Text:\n        if (domType !== 3 /* DOMNodeTypes.TEXT */) {\n          // #5728 empty text node inside a slot can cause hydration failure\n          // because the server rendered HTML won't contain a text node\n          if (vnode.children === '') {\n            insert(vnode.el = createText(''), parentNode(node), node);\n            nextNode = node;\n          } else {\n            nextNode = onMismatch();\n          }\n        } else {\n          if (node.data !== vnode.children) {\n            hasMismatch = true;\n             true && warn(`Hydration text mismatch:` + `\\n- Client: ${JSON.stringify(node.data)}` + `\\n- Server: ${JSON.stringify(vnode.children)}`);\n            node.data = vnode.children;\n          }\n          nextNode = nextSibling(node);\n        }\n        break;\n      case Comment:\n        if (domType !== 8 /* DOMNodeTypes.COMMENT */ || isFragmentStart) {\n          nextNode = onMismatch();\n        } else {\n          nextNode = nextSibling(node);\n        }\n        break;\n      case Static:\n        if (isFragmentStart) {\n          // entire template is static but SSRed as a fragment\n          node = nextSibling(node);\n          domType = node.nodeType;\n        }\n        if (domType === 1 /* DOMNodeTypes.ELEMENT */ || domType === 3 /* DOMNodeTypes.TEXT */) {\n          // determine anchor, adopt content\n          nextNode = node;\n          // if the static vnode has its content stripped during build,\n          // adopt it from the server-rendered HTML.\n          const needToAdoptContent = !vnode.children.length;\n          for (let i = 0; i < vnode.staticCount; i++) {\n            if (needToAdoptContent) vnode.children += nextNode.nodeType === 1 /* DOMNodeTypes.ELEMENT */ ? nextNode.outerHTML : nextNode.data;\n            if (i === vnode.staticCount - 1) {\n              vnode.anchor = nextNode;\n            }\n            nextNode = nextSibling(nextNode);\n          }\n          return isFragmentStart ? nextSibling(nextNode) : nextNode;\n        } else {\n          onMismatch();\n        }\n        break;\n      case Fragment:\n        if (!isFragmentStart) {\n          nextNode = onMismatch();\n        } else {\n          nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\n        }\n        break;\n      default:\n        if (shapeFlag & 1 /* ShapeFlags.ELEMENT */) {\n          if (domType !== 1 /* DOMNodeTypes.ELEMENT */ || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {\n            nextNode = onMismatch();\n          } else {\n            nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\n          }\n        } else if (shapeFlag & 6 /* ShapeFlags.COMPONENT */) {\n          // when setting up the render effect, if the initial vnode already\n          // has .el set, the component will perform hydration instead of mount\n          // on its sub-tree.\n          vnode.slotScopeIds = slotScopeIds;\n          const container = parentNode(node);\n          mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);\n          // component may be async, so in the case of fragments we cannot rely\n          // on component's rendered output to determine the end of the fragment\n          // instead, we do a lookahead to find the end anchor node.\n          nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);\n          // #4293 teleport as component root\n          if (nextNode && isComment(nextNode) && nextNode.data === 'teleport end') {\n            nextNode = nextSibling(nextNode);\n          }\n          // #3787\n          // if component is async, it may get moved / unmounted before its\n          // inner component is loaded, so we need to give it a placeholder\n          // vnode that matches its adopted DOM.\n          if (isAsyncWrapper(vnode)) {\n            let subTree;\n            if (isFragmentStart) {\n              subTree = createVNode(Fragment);\n              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;\n            } else {\n              subTree = node.nodeType === 3 ? createTextVNode('') : createVNode('div');\n            }\n            subTree.el = node;\n            vnode.component.subTree = subTree;\n          }\n        } else if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {\n          if (domType !== 8 /* DOMNodeTypes.COMMENT */) {\n            nextNode = onMismatch();\n          } else {\n            nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);\n          }\n        } else if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n          nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);\n        } else if (true) {\n          warn('Invalid HostVNode type:', type, `(${typeof type})`);\n        }\n    }\n    if (ref != null) {\n      setRef(ref, null, parentSuspense, vnode);\n    }\n    return nextNode;\n  };\n  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    optimized = optimized || !!vnode.dynamicChildren;\n    const {\n      type,\n      props,\n      patchFlag,\n      shapeFlag,\n      dirs\n    } = vnode;\n    // #4006 for form elements with non-string v-model value bindings\n    // e.g. <option :value=\"obj\">, <input type=\"checkbox\" :true-value=\"1\">\n    const forcePatchValue = type === 'input' && dirs || type === 'option';\n    // skip props & children if this is hoisted static nodes\n    // #5405 in dev, always hydrate children for HMR\n    if (true /* PatchFlags.HOISTED */) {\n      if (dirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, 'created');\n      }\n      // props\n      if (props) {\n        if (forcePatchValue || !optimized || patchFlag & (16 /* PatchFlags.FULL_PROPS */ | 32 /* PatchFlags.HYDRATE_EVENTS */)) {\n          for (const key in props) {\n            if (forcePatchValue && key.endsWith('value') || (0, shared_1.isOn)(key) && !(0, shared_1.isReservedProp)(key)) {\n              patchProp(el, key, null, props[key], false, undefined, parentComponent);\n            }\n          }\n        } else if (props.onClick) {\n          // Fast path for click listeners (which is most often) to avoid\n          // iterating through props.\n          patchProp(el, 'onClick', null, props.onClick, false, undefined, parentComponent);\n        }\n      }\n      // vnode / directive hooks\n      let vnodeHooks;\n      if (vnodeHooks = props && props.onVnodeBeforeMount) {\n        invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n      }\n      if (dirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');\n      }\n      if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {\n        queueEffectWithSuspense(() => {\n          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n          dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');\n        }, parentSuspense);\n      }\n      // children\n      if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */ &&\n      // skip if element has innerHTML / textContent\n      !(props && (props.innerHTML || props.textContent))) {\n        let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);\n        let hasWarned = false;\n        while (next) {\n          hasMismatch = true;\n          if ( true && !hasWarned) {\n            warn(`Hydration children mismatch in <${vnode.type}>: ` + `server rendered element contains more child nodes than client vdom.`);\n            hasWarned = true;\n          }\n          // The SSRed DOM contains more nodes than it should. Remove them.\n          const cur = next;\n          next = next.nextSibling;\n          remove(cur);\n        }\n      } else if (shapeFlag & 8 /* ShapeFlags.TEXT_CHILDREN */) {\n        if (el.textContent !== vnode.children) {\n          hasMismatch = true;\n           true && warn(`Hydration text content mismatch in <${vnode.type}>:\\n` + `- Client: ${el.textContent}\\n` + `- Server: ${vnode.children}`);\n          el.textContent = vnode.children;\n        }\n      }\n    }\n    return el.nextSibling;\n  };\n  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    optimized = optimized || !!parentVNode.dynamicChildren;\n    const children = parentVNode.children;\n    const l = children.length;\n    let hasWarned = false;\n    for (let i = 0; i < l; i++) {\n      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);\n      if (node) {\n        node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\n      } else if (vnode.type === Text && !vnode.children) {\n        continue;\n      } else {\n        hasMismatch = true;\n        if ( true && !hasWarned) {\n          warn(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` + `server rendered element contains fewer child nodes than client vdom.`);\n          hasWarned = true;\n        }\n        // the SSRed DOM didn't contain enough nodes. Mount the missing ones.\n        patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);\n      }\n    }\n    return node;\n  };\n  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    const {\n      slotScopeIds: fragmentSlotScopeIds\n    } = vnode;\n    if (fragmentSlotScopeIds) {\n      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;\n    }\n    const container = parentNode(node);\n    const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);\n    if (next && isComment(next) && next.data === ']') {\n      return nextSibling(vnode.anchor = next);\n    } else {\n      // fragment didn't hydrate successfully, since we didn't get a end anchor\n      // back. This should have led to node/children mismatch warnings.\n      hasMismatch = true;\n      // since the anchor is missing, we need to create one and insert it\n      insert(vnode.anchor = createComment(`]`), container, next);\n      return next;\n    }\n  };\n  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {\n    hasMismatch = true;\n     true && warn(`Hydration node mismatch:\\n- Client vnode:`, vnode.type, `\\n- Server rendered DOM:`, node, node.nodeType === 3 /* DOMNodeTypes.TEXT */ ? `(text)` : isComment(node) && node.data === '[' ? `(start of fragment)` : ``);\n    vnode.el = null;\n    if (isFragment) {\n      // remove excessive fragment nodes\n      const end = locateClosingAsyncAnchor(node);\n      while (true) {\n        const next = nextSibling(node);\n        if (next && next !== end) {\n          remove(next);\n        } else {\n          break;\n        }\n      }\n    }\n    const next = nextSibling(node);\n    const container = parentNode(node);\n    remove(node);\n    patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);\n    return next;\n  };\n  const locateClosingAsyncAnchor = node => {\n    let match = 0;\n    while (node) {\n      node = nextSibling(node);\n      if (node && isComment(node)) {\n        if (node.data === '[') match++;\n        if (node.data === ']') {\n          if (match === 0) {\n            return nextSibling(node);\n          } else {\n            match--;\n          }\n        }\n      }\n    }\n    return node;\n  };\n  return [hydrate, hydrateNode];\n}\n/* eslint-disable no-restricted-globals */\nlet supported;\nlet perf;\nfunction startMeasure(instance, type) {\n  if (instance.appContext.config.performance && isSupported()) {\n    perf.mark(`vue-${type}-${instance.uid}`);\n  }\n  if (true) {\n    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());\n  }\n}\nfunction endMeasure(instance, type) {\n  if (instance.appContext.config.performance && isSupported()) {\n    const startTag = `vue-${type}-${instance.uid}`;\n    const endTag = startTag + `:end`;\n    perf.mark(endTag);\n    perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);\n    perf.clearMarks(startTag);\n    perf.clearMarks(endTag);\n  }\n  if (true) {\n    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());\n  }\n}\nfunction isSupported() {\n  if (supported !== undefined) {\n    return supported;\n  }\n  if (typeof window !== 'undefined' && window.performance) {\n    supported = true;\n    perf = window.performance;\n  } else {\n    supported = false;\n  }\n  return supported;\n}\n/**\n * This is only called in esm-bundler builds.\n * It is called when a renderer is created, in `baseCreateRenderer` so that\n * importing runtime-core is side-effects free.\n *\n * istanbul-ignore-next\n */\nfunction initFeatureFlags() {\n  const needWarn = [];\n  if (typeof __VUE_OPTIONS_API__ !== 'boolean') {\n     true && needWarn.push(`__VUE_OPTIONS_API__`);\n    (0, shared_1.getGlobalThis)().__VUE_OPTIONS_API__ = true;\n  }\n  if (typeof __VUE_PROD_DEVTOOLS__ !== 'boolean') {\n     true && needWarn.push(`__VUE_PROD_DEVTOOLS__`);\n    (0, shared_1.getGlobalThis)().__VUE_PROD_DEVTOOLS__ = false;\n  }\n  if ( true && needWarn.length) {\n    const multi = needWarn.length > 1;\n    console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(', ')} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, ` + `which expects these compile-time feature flags to be globally injected ` + `via the bundler config in order to get better tree-shaking in the ` + `production bundle.\\n\\n` + `For more details, see https://link.vuejs.org/feature-flags.`);\n  }\n}\nconst queuePostRenderEffect = queueEffectWithSuspense;\n/**\n * The createRenderer function accepts two generic arguments:\n * HostNode and HostElement, corresponding to Node and Element types in the\n * host environment. For example, for runtime-dom, HostNode would be the DOM\n * `Node` interface and HostElement would be the DOM `Element` interface.\n *\n * Custom renderers can pass in the platform specific types like this:\n *\n * ``` js\n * const { render, createApp } = createRenderer<Node, Element>({\n *   patchProp,\n *   ...nodeOps\n * })\n * ```\n */\nfunction createRenderer(options) {\n  return baseCreateRenderer(options);\n}\nexports.createRenderer = createRenderer;\n// Separate API for creating hydration-enabled renderer.\n// Hydration logic is only used when calling this function, making it\n// tree-shakable.\nfunction createHydrationRenderer(options) {\n  return baseCreateRenderer(options, createHydrationFunctions);\n}\nexports.createHydrationRenderer = createHydrationRenderer;\n// implementation\nfunction baseCreateRenderer(options, createHydrationFns) {\n  // compile-time feature flags check\n  {\n    initFeatureFlags();\n  }\n  const target = (0, shared_1.getGlobalThis)();\n  target.__VUE__ = true;\n  if (true) {\n    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);\n  }\n  const {\n    insert: hostInsert,\n    remove: hostRemove,\n    patchProp: hostPatchProp,\n    createElement: hostCreateElement,\n    createText: hostCreateText,\n    createComment: hostCreateComment,\n    setText: hostSetText,\n    setElementText: hostSetElementText,\n    parentNode: hostParentNode,\n    nextSibling: hostNextSibling,\n    setScopeId: hostSetScopeId = shared_1.NOOP,\n    insertStaticContent: hostInsertStaticContent\n  } = options;\n  // Note: functions inside this closure should use `const xxx = () => {}`\n  // style in order to prevent being inlined by minifiers.\n  const patch = function (n1, n2, container) {\n    let anchor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let parentComponent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    let parentSuspense = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    let isSVG = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    let slotScopeIds = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n    let optimized = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] :  true && isHmrUpdating ? false : !!n2.dynamicChildren;\n    if (n1 === n2) {\n      return;\n    }\n    // patching & not same type, unmount old tree\n    if (n1 && !isSameVNodeType(n1, n2)) {\n      anchor = getNextHostNode(n1);\n      unmount(n1, parentComponent, parentSuspense, true);\n      n1 = null;\n    }\n    if (n2.patchFlag === -2 /* PatchFlags.BAIL */) {\n      optimized = false;\n      n2.dynamicChildren = null;\n    }\n    const {\n      type,\n      ref,\n      shapeFlag\n    } = n2;\n    switch (type) {\n      case Text:\n        processText(n1, n2, container, anchor);\n        break;\n      case Comment:\n        processCommentNode(n1, n2, container, anchor);\n        break;\n      case Static:\n        if (n1 == null) {\n          mountStaticNode(n2, container, anchor, isSVG);\n        } else if (true) {\n          patchStaticNode(n1, n2, container, isSVG);\n        }\n        break;\n      case Fragment:\n        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        break;\n      default:\n        if (shapeFlag & 1 /* ShapeFlags.ELEMENT */) {\n          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        } else if (shapeFlag & 6 /* ShapeFlags.COMPONENT */) {\n          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        } else if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {\n          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);\n        } else if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);\n        } else if (true) {\n          warn('Invalid VNode type:', type, `(${typeof type})`);\n        }\n    }\n    // set ref\n    if (ref != null && parentComponent) {\n      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);\n    }\n  };\n  const processText = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);\n    } else {\n      const el = n2.el = n1.el;\n      if (n2.children !== n1.children) {\n        hostSetText(el, n2.children);\n      }\n    }\n  };\n  const processCommentNode = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n      hostInsert(n2.el = hostCreateComment(n2.children || ''), container, anchor);\n    } else {\n      // there's no support for dynamic comments\n      n2.el = n1.el;\n    }\n  };\n  const mountStaticNode = (n2, container, anchor, isSVG) => {\n    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);\n  };\n  /**\n   * Dev / HMR only\n   */\n  const patchStaticNode = (n1, n2, container, isSVG) => {\n    // static nodes are only patched during dev for HMR\n    if (n2.children !== n1.children) {\n      const anchor = hostNextSibling(n1.anchor);\n      // remove existing\n      removeStaticNode(n1);\n      [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);\n    } else {\n      n2.el = n1.el;\n      n2.anchor = n1.anchor;\n    }\n  };\n  const moveStaticNode = (_ref12, container, nextSibling) => {\n    let {\n      el,\n      anchor\n    } = _ref12;\n    let next;\n    while (el && el !== anchor) {\n      next = hostNextSibling(el);\n      hostInsert(el, container, nextSibling);\n      el = next;\n    }\n    hostInsert(anchor, container, nextSibling);\n  };\n  const removeStaticNode = _ref13 => {\n    let {\n      el,\n      anchor\n    } = _ref13;\n    let next;\n    while (el && el !== anchor) {\n      next = hostNextSibling(el);\n      hostRemove(el);\n      el = next;\n    }\n    hostRemove(anchor);\n  };\n  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    isSVG = isSVG || n2.type === 'svg';\n    if (n1 == null) {\n      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n    } else {\n      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n    }\n  };\n  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    let el;\n    let vnodeHook;\n    const {\n      type,\n      props,\n      shapeFlag,\n      transition,\n      dirs\n    } = vnode;\n    el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);\n    // mount children first, since some props may rely on child content\n    // being already rendered, e.g. `<select value>`\n    if (shapeFlag & 8 /* ShapeFlags.TEXT_CHILDREN */) {\n      hostSetElementText(el, vnode.children);\n    } else if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n      mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized);\n    }\n    if (dirs) {\n      invokeDirectiveHook(vnode, null, parentComponent, 'created');\n    }\n    // scopeId\n    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);\n    // props\n    if (props) {\n      for (const key in props) {\n        if (key !== 'value' && !(0, shared_1.isReservedProp)(key)) {\n          hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\n        }\n      }\n      /**\n       * Special case for setting value on DOM elements:\n       * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)\n       * - it needs to be forced (#1471)\n       * #2353 proposes adding another renderer option to configure this, but\n       * the properties affects are so finite it is worth special casing it\n       * here to reduce the complexity. (Special casing it also should not\n       * affect non-DOM renderers)\n       */\n      if ('value' in props) {\n        hostPatchProp(el, 'value', null, props.value);\n      }\n      if (vnodeHook = props.onVnodeBeforeMount) {\n        invokeVNodeHook(vnodeHook, parentComponent, vnode);\n      }\n    }\n    if (true) {\n      Object.defineProperty(el, '__vnode', {\n        value: vnode,\n        enumerable: false\n      });\n      Object.defineProperty(el, '__vueParentComponent', {\n        value: parentComponent,\n        enumerable: false\n      });\n    }\n    if (dirs) {\n      invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');\n    }\n    // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved\n    // #1689 For inside suspense + suspense resolved case, just call it\n    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;\n    if (needCallTransitionHooks) {\n      transition.beforeEnter(el);\n    }\n    hostInsert(el, container, anchor);\n    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n        needCallTransitionHooks && transition.enter(el);\n        dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');\n      }, parentSuspense);\n    }\n  };\n  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {\n    if (scopeId) {\n      hostSetScopeId(el, scopeId);\n    }\n    if (slotScopeIds) {\n      for (let i = 0; i < slotScopeIds.length; i++) {\n        hostSetScopeId(el, slotScopeIds[i]);\n      }\n    }\n    if (parentComponent) {\n      let subTree = parentComponent.subTree;\n      if ( true && subTree.patchFlag > 0 && subTree.patchFlag & 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */) {\n        subTree = filterSingleRoot(subTree.children) || subTree;\n      }\n      if (vnode === subTree) {\n        const parentVNode = parentComponent.vnode;\n        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);\n      }\n    }\n  };\n  const mountChildren = function (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {\n    let start = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;\n    for (let i = start; i < children.length; i++) {\n      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);\n      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n    }\n  };\n  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    const el = n2.el = n1.el;\n    let {\n      patchFlag,\n      dynamicChildren,\n      dirs\n    } = n2;\n    // #1426 take the old vnode's patch flag into account since user may clone a\n    // compiler-generated vnode, which de-opts to FULL_PROPS\n    patchFlag |= n1.patchFlag & 16 /* PatchFlags.FULL_PROPS */;\n    const oldProps = n1.props || shared_1.EMPTY_OBJ;\n    const newProps = n2.props || shared_1.EMPTY_OBJ;\n    let vnodeHook;\n    // disable recurse in beforeUpdate hooks\n    parentComponent && toggleRecurse(parentComponent, false);\n    if (vnodeHook = newProps.onVnodeBeforeUpdate) {\n      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n    }\n    if (dirs) {\n      invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');\n    }\n    parentComponent && toggleRecurse(parentComponent, true);\n    if ( true && isHmrUpdating) {\n      // HMR updated, force full diff\n      patchFlag = 0;\n      optimized = false;\n      dynamicChildren = null;\n    }\n    const areChildrenSVG = isSVG && n2.type !== 'foreignObject';\n    if (dynamicChildren) {\n      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);\n      if ( true && parentComponent && parentComponent.type.__hmrId) {\n        traverseStaticChildren(n1, n2);\n      }\n    } else if (!optimized) {\n      // full diff\n      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);\n    }\n    if (patchFlag > 0) {\n      // the presence of a patchFlag means this element's render code was\n      // generated by the compiler and can take the fast path.\n      // in this path old node and new node are guaranteed to have the same shape\n      // (i.e. at the exact same position in the source template)\n      if (patchFlag & 16 /* PatchFlags.FULL_PROPS */) {\n        // element props contain dynamic keys, full diff needed\n        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\n      } else {\n        // class\n        // this flag is matched when the element has dynamic class bindings.\n        if (patchFlag & 2 /* PatchFlags.CLASS */) {\n          if (oldProps.class !== newProps.class) {\n            hostPatchProp(el, 'class', null, newProps.class, isSVG);\n          }\n        }\n        // style\n        // this flag is matched when the element has dynamic style bindings\n        if (patchFlag & 4 /* PatchFlags.STYLE */) {\n          hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);\n        }\n        // props\n        // This flag is matched when the element has dynamic prop/attr bindings\n        // other than class and style. The keys of dynamic prop/attrs are saved for\n        // faster iteration.\n        // Note dynamic keys like :[foo]=\"bar\" will cause this optimization to\n        // bail out and go through a full diff because we need to unset the old key\n        if (patchFlag & 8 /* PatchFlags.PROPS */) {\n          // if the flag is present then dynamicProps must be non-null\n          const propsToUpdate = n2.dynamicProps;\n          for (let i = 0; i < propsToUpdate.length; i++) {\n            const key = propsToUpdate[i];\n            const prev = oldProps[key];\n            const next = newProps[key];\n            // #1471 force patch value\n            if (next !== prev || key === 'value') {\n              hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);\n            }\n          }\n        }\n      }\n      // text\n      // This flag is matched when the element has only dynamic text children.\n      if (patchFlag & 1 /* PatchFlags.TEXT */) {\n        if (n1.children !== n2.children) {\n          hostSetElementText(el, n2.children);\n        }\n      }\n    } else if (!optimized && dynamicChildren == null) {\n      // unoptimized, full diff\n      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\n    }\n    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n        dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');\n      }, parentSuspense);\n    }\n  };\n  // The fast path for blocks.\n  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {\n    for (let i = 0; i < newChildren.length; i++) {\n      const oldVNode = oldChildren[i];\n      const newVNode = newChildren[i];\n      // Determine the container (parent element) for the patch.\n      const container =\n      // oldVNode may be an errored async setup() component inside Suspense\n      // which will not have a mounted element\n      oldVNode.el && (\n      // - In the case of a Fragment, we need to provide the actual parent\n      // of the Fragment itself so it can move its children.\n      oldVNode.type === Fragment ||\n      // - In the case of different nodes, there is going to be a replacement\n      // which also requires the correct parent container\n      !isSameVNodeType(oldVNode, newVNode) ||\n      // - In the case of a component, it could contain anything.\n      oldVNode.shapeFlag & (6 /* ShapeFlags.COMPONENT */ | 64 /* ShapeFlags.TELEPORT */)) ? hostParentNode(oldVNode.el) :\n      // In other cases, the parent container is not actually used so we\n      // just pass the block element here to avoid a DOM parentNode call.\n      fallbackContainer;\n      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);\n    }\n  };\n  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {\n    if (oldProps !== newProps) {\n      if (oldProps !== shared_1.EMPTY_OBJ) {\n        for (const key in oldProps) {\n          if (!(0, shared_1.isReservedProp)(key) && !(key in newProps)) {\n            hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\n          }\n        }\n      }\n      for (const key in newProps) {\n        // empty string is not valid prop\n        if ((0, shared_1.isReservedProp)(key)) continue;\n        const next = newProps[key];\n        const prev = oldProps[key];\n        // defer patching value\n        if (next !== prev && key !== 'value') {\n          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\n        }\n      }\n      if ('value' in newProps) {\n        hostPatchProp(el, 'value', oldProps.value, newProps.value);\n      }\n    }\n  };\n  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText('');\n    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText('');\n    let {\n      patchFlag,\n      dynamicChildren,\n      slotScopeIds: fragmentSlotScopeIds\n    } = n2;\n    if ( true && (\n    // #5523 dev root fragment may inherit directives\n    isHmrUpdating || patchFlag & 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */)) {\n      // HMR updated / Dev root fragment (w/ comments), force full diff\n      patchFlag = 0;\n      optimized = false;\n      dynamicChildren = null;\n    }\n    // check if this is a slot fragment with :slotted scope ids\n    if (fragmentSlotScopeIds) {\n      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;\n    }\n    if (n1 == null) {\n      hostInsert(fragmentStartAnchor, container, anchor);\n      hostInsert(fragmentEndAnchor, container, anchor);\n      // a fragment can only have array children\n      // since they are either generated by the compiler, or implicitly created\n      // from arrays.\n      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n    } else {\n      if (patchFlag > 0 && patchFlag & 64 /* PatchFlags.STABLE_FRAGMENT */ && dynamicChildren &&\n      // #2715 the previous fragment could've been a BAILed one as a result\n      // of renderSlot() with no valid children\n      n1.dynamicChildren) {\n        // a stable fragment (template root or <template v-for>) doesn't need to\n        // patch children order, but it may contain dynamicChildren.\n        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);\n        if ( true && parentComponent && parentComponent.type.__hmrId) {\n          traverseStaticChildren(n1, n2);\n        } else if (\n        // #2080 if the stable fragment has a key, it's a <template v-for> that may\n        //  get moved around. Make sure all root level vnodes inherit el.\n        // #2134 or if it's a component root, it may also get moved around\n        // as the component is being moved.\n        n2.key != null || parentComponent && n2 === parentComponent.subTree) {\n          traverseStaticChildren(n1, n2, true /* shallow */);\n        }\n      } else {\n        // keyed / unkeyed, or manual fragments.\n        // for keyed & unkeyed, since they are compiler generated from v-for,\n        // each child is guaranteed to be a block so the fragment will never\n        // have dynamicChildren.\n        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n      }\n    }\n  };\n  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    n2.slotScopeIds = slotScopeIds;\n    if (n1 == null) {\n      if (n2.shapeFlag & 512 /* ShapeFlags.COMPONENT_KEPT_ALIVE */) {\n        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);\n      } else {\n        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n      }\n    } else {\n      updateComponent(n1, n2, optimized);\n    }\n  };\n  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);\n    if ( true && instance.type.__hmrId) {\n      registerHMR(instance);\n    }\n    if (true) {\n      pushWarningContext(initialVNode);\n      startMeasure(instance, `mount`);\n    }\n    // inject renderer internals for keepAlive\n    if (isKeepAlive(initialVNode)) {\n      instance.ctx.renderer = internals;\n    }\n    // resolve props and slots for setup context\n    {\n      if (true) {\n        startMeasure(instance, `init`);\n      }\n      setupComponent(instance);\n      if (true) {\n        endMeasure(instance, `init`);\n      }\n    }\n    // setup() is async. This component relies on async logic to be resolved\n    // before proceeding\n    if (instance.asyncDep) {\n      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);\n      // Give it a placeholder if this is not hydration\n      // TODO handle self-defined fallback\n      if (!initialVNode.el) {\n        const placeholder = instance.subTree = createVNode(Comment);\n        processCommentNode(null, placeholder, container, anchor);\n      }\n      return;\n    }\n    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);\n    if (true) {\n      popWarningContext();\n      endMeasure(instance, `mount`);\n    }\n  };\n  const updateComponent = (n1, n2, optimized) => {\n    const instance = n2.component = n1.component;\n    if (shouldUpdateComponent(n1, n2, optimized)) {\n      if (instance.asyncDep && !instance.asyncResolved) {\n        // async & still pending - just update props and slots\n        // since the component's reactive effect for render isn't set-up yet\n        if (true) {\n          pushWarningContext(n2);\n        }\n        updateComponentPreRender(instance, n2, optimized);\n        if (true) {\n          popWarningContext();\n        }\n        return;\n      } else {\n        // normal update\n        instance.next = n2;\n        // in case the child component is also queued, remove it to avoid\n        // double updating the same child component in the same flush.\n        invalidateJob(instance.update);\n        // instance.update is the reactive effect.\n        instance.update();\n      }\n    } else {\n      // no update needed. just copy over properties\n      n2.el = n1.el;\n      instance.vnode = n2;\n    }\n  };\n  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\n    const componentUpdateFn = () => {\n      if (!instance.isMounted) {\n        let vnodeHook;\n        const {\n          el,\n          props\n        } = initialVNode;\n        const {\n          bm,\n          m,\n          parent\n        } = instance;\n        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);\n        toggleRecurse(instance, false);\n        // beforeMount hook\n        if (bm) {\n          (0, shared_1.invokeArrayFns)(bm);\n        }\n        // onVnodeBeforeMount\n        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {\n          invokeVNodeHook(vnodeHook, parent, initialVNode);\n        }\n        toggleRecurse(instance, true);\n        if (el && hydrateNode) {\n          // vnode has adopted host node - perform hydration instead of mount.\n          const hydrateSubTree = () => {\n            if (true) {\n              startMeasure(instance, `render`);\n            }\n            instance.subTree = renderComponentRoot(instance);\n            if (true) {\n              endMeasure(instance, `render`);\n            }\n            if (true) {\n              startMeasure(instance, `hydrate`);\n            }\n            hydrateNode(el, instance.subTree, instance, parentSuspense, null);\n            if (true) {\n              endMeasure(instance, `hydrate`);\n            }\n          };\n          if (isAsyncWrapperVNode) {\n            initialVNode.type.__asyncLoader().then(\n            // note: we are moving the render call into an async callback,\n            // which means it won't track dependencies - but it's ok because\n            // a server-rendered async wrapper is already in resolved state\n            // and it will never need to change.\n            () => !instance.isUnmounted && hydrateSubTree());\n          } else {\n            hydrateSubTree();\n          }\n        } else {\n          if (true) {\n            startMeasure(instance, `render`);\n          }\n          const subTree = instance.subTree = renderComponentRoot(instance);\n          if (true) {\n            endMeasure(instance, `render`);\n          }\n          if (true) {\n            startMeasure(instance, `patch`);\n          }\n          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);\n          if (true) {\n            endMeasure(instance, `patch`);\n          }\n          initialVNode.el = subTree.el;\n        }\n        // mounted hook\n        if (m) {\n          queuePostRenderEffect(m, parentSuspense);\n        }\n        // onVnodeMounted\n        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {\n          const scopedInitialVNode = initialVNode;\n          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);\n        }\n        // activated hook for keep-alive roots.\n        // #1742 activated hook must be accessed after first render\n        // since the hook may be injected by a child keep-alive\n        if (initialVNode.shapeFlag & 256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */ || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */) {\n          instance.a && queuePostRenderEffect(instance.a, parentSuspense);\n        }\n        instance.isMounted = true;\n        if (true) {\n          devtoolsComponentAdded(instance);\n        }\n        // #2458: deference mount-only object parameters to prevent memleaks\n        initialVNode = container = anchor = null;\n      } else {\n        // updateComponent\n        // This is triggered by mutation of component's own state (next: null)\n        // OR parent calling processComponent (next: VNode)\n        let {\n          next,\n          bu,\n          u,\n          parent,\n          vnode\n        } = instance;\n        let originNext = next;\n        let vnodeHook;\n        if (true) {\n          pushWarningContext(next || instance.vnode);\n        }\n        // Disallow component effect recursion during pre-lifecycle hooks.\n        toggleRecurse(instance, false);\n        if (next) {\n          next.el = vnode.el;\n          updateComponentPreRender(instance, next, optimized);\n        } else {\n          next = vnode;\n        }\n        // beforeUpdate hook\n        if (bu) {\n          (0, shared_1.invokeArrayFns)(bu);\n        }\n        // onVnodeBeforeUpdate\n        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {\n          invokeVNodeHook(vnodeHook, parent, next, vnode);\n        }\n        toggleRecurse(instance, true);\n        // render\n        if (true) {\n          startMeasure(instance, `render`);\n        }\n        const nextTree = renderComponentRoot(instance);\n        if (true) {\n          endMeasure(instance, `render`);\n        }\n        const prevTree = instance.subTree;\n        instance.subTree = nextTree;\n        if (true) {\n          startMeasure(instance, `patch`);\n        }\n        patch(prevTree, nextTree,\n        // parent may have changed if it's in a teleport\n        hostParentNode(prevTree.el),\n        // anchor may have changed if it's in a fragment\n        getNextHostNode(prevTree), instance, parentSuspense, isSVG);\n        if (true) {\n          endMeasure(instance, `patch`);\n        }\n        next.el = nextTree.el;\n        if (originNext === null) {\n          // self-triggered update. In case of HOC, update parent component\n          // vnode el. HOC is indicated by parent instance's subTree pointing\n          // to child component's vnode\n          updateHOCHostEl(instance, nextTree.el);\n        }\n        // updated hook\n        if (u) {\n          queuePostRenderEffect(u, parentSuspense);\n        }\n        // onVnodeUpdated\n        if (vnodeHook = next.props && next.props.onVnodeUpdated) {\n          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);\n        }\n        if (true) {\n          devtoolsComponentUpdated(instance);\n        }\n        if (true) {\n          popWarningContext();\n        }\n      }\n    };\n    // create reactive effect for rendering\n    const effect = instance.effect = new reactivity_1.ReactiveEffect(componentUpdateFn, () => queueJob(update), instance.scope // track it in component's effect scope\n    );\n\n    const update = instance.update = () => effect.run();\n    update.id = instance.uid;\n    // allowRecurse\n    // #1801, #2043 component render effects should allow recursive updates\n    toggleRecurse(instance, true);\n    if (true) {\n      effect.onTrack = instance.rtc ? e => (0, shared_1.invokeArrayFns)(instance.rtc, e) : void 0;\n      effect.onTrigger = instance.rtg ? e => (0, shared_1.invokeArrayFns)(instance.rtg, e) : void 0;\n      update.ownerInstance = instance;\n    }\n    update();\n  };\n  const updateComponentPreRender = (instance, nextVNode, optimized) => {\n    nextVNode.component = instance;\n    const prevProps = instance.vnode.props;\n    instance.vnode = nextVNode;\n    instance.next = null;\n    updateProps(instance, nextVNode.props, prevProps, optimized);\n    updateSlots(instance, nextVNode.children, optimized);\n    (0, reactivity_1.pauseTracking)();\n    // props update may have triggered pre-flush watchers.\n    // flush them before the render update.\n    flushPreFlushCbs();\n    (0, reactivity_1.resetTracking)();\n  };\n  const patchChildren = function (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds) {\n    let optimized = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;\n    const c1 = n1 && n1.children;\n    const prevShapeFlag = n1 ? n1.shapeFlag : 0;\n    const c2 = n2.children;\n    const {\n      patchFlag,\n      shapeFlag\n    } = n2;\n    // fast path\n    if (patchFlag > 0) {\n      if (patchFlag & 128 /* PatchFlags.KEYED_FRAGMENT */) {\n        // this could be either fully-keyed or mixed (some keyed some not)\n        // presence of patchFlag means children are guaranteed to be arrays\n        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        return;\n      } else if (patchFlag & 256 /* PatchFlags.UNKEYED_FRAGMENT */) {\n        // unkeyed\n        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        return;\n      }\n    }\n    // children has 3 possibilities: text, array or no children.\n    if (shapeFlag & 8 /* ShapeFlags.TEXT_CHILDREN */) {\n      // text children fast path\n      if (prevShapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n        unmountChildren(c1, parentComponent, parentSuspense);\n      }\n      if (c2 !== c1) {\n        hostSetElementText(container, c2);\n      }\n    } else {\n      if (prevShapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n        // prev children was array\n        if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n          // two arrays, cannot assume anything, do full diff\n          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        } else {\n          // no new children, just unmount old\n          unmountChildren(c1, parentComponent, parentSuspense, true);\n        }\n      } else {\n        // prev children was text OR null\n        // new children is array OR null\n        if (prevShapeFlag & 8 /* ShapeFlags.TEXT_CHILDREN */) {\n          hostSetElementText(container, '');\n        }\n        // mount new if array\n        if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        }\n      }\n    }\n  };\n  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    c1 = c1 || shared_1.EMPTY_ARR;\n    c2 = c2 || shared_1.EMPTY_ARR;\n    const oldLength = c1.length;\n    const newLength = c2.length;\n    const commonLength = Math.min(oldLength, newLength);\n    let i;\n    for (i = 0; i < commonLength; i++) {\n      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n    }\n    if (oldLength > newLength) {\n      // remove old\n      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);\n    } else {\n      // mount new\n      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);\n    }\n  };\n  // can be all-keyed or mixed\n  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n    let i = 0;\n    const l2 = c2.length;\n    let e1 = c1.length - 1; // prev ending index\n    let e2 = l2 - 1; // next ending index\n    // 1. sync from start\n    // (a b) c\n    // (a b) d e\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[i];\n      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n      if (isSameVNodeType(n1, n2)) {\n        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n      } else {\n        break;\n      }\n      i++;\n    }\n    // 2. sync from end\n    // a (b c)\n    // d e (b c)\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[e1];\n      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);\n      if (isSameVNodeType(n1, n2)) {\n        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n      } else {\n        break;\n      }\n      e1--;\n      e2--;\n    }\n    // 3. common sequence + mount\n    // (a b)\n    // (a b) c\n    // i = 2, e1 = 1, e2 = 2\n    // (a b)\n    // c (a b)\n    // i = 0, e1 = -1, e2 = 0\n    if (i > e1) {\n      if (i <= e2) {\n        const nextPos = e2 + 1;\n        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\n        while (i <= e2) {\n          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n          i++;\n        }\n      }\n    }\n    // 4. common sequence + unmount\n    // (a b) c\n    // (a b)\n    // i = 2, e1 = 2, e2 = 1\n    // a (b c)\n    // (b c)\n    // i = 0, e1 = 0, e2 = -1\n    else if (i > e2) {\n      while (i <= e1) {\n        unmount(c1[i], parentComponent, parentSuspense, true);\n        i++;\n      }\n    }\n    // 5. unknown sequence\n    // [i ... e1 + 1]: a b [c d e] f g\n    // [i ... e2 + 1]: a b [e d c h] f g\n    // i = 2, e1 = 4, e2 = 5\n    else {\n      const s1 = i; // prev starting index\n      const s2 = i; // next starting index\n      // 5.1 build key:index map for newChildren\n      const keyToNewIndexMap = new Map();\n      for (i = s2; i <= e2; i++) {\n        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n        if (nextChild.key != null) {\n          if ( true && keyToNewIndexMap.has(nextChild.key)) {\n            warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);\n          }\n          keyToNewIndexMap.set(nextChild.key, i);\n        }\n      }\n      // 5.2 loop through old children left to be patched and try to patch\n      // matching nodes & remove nodes that are no longer present\n      let j;\n      let patched = 0;\n      const toBePatched = e2 - s2 + 1;\n      let moved = false;\n      // used to track whether any node has moved\n      let maxNewIndexSoFar = 0;\n      // works as Map<newIndex, oldIndex>\n      // Note that oldIndex is offset by +1\n      // and oldIndex = 0 is a special value indicating the new node has\n      // no corresponding old node.\n      // used for determining longest stable subsequence\n      const newIndexToOldIndexMap = new Array(toBePatched);\n      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;\n      for (i = s1; i <= e1; i++) {\n        const prevChild = c1[i];\n        if (patched >= toBePatched) {\n          // all new children have been patched so this can only be a removal\n          unmount(prevChild, parentComponent, parentSuspense, true);\n          continue;\n        }\n        let newIndex;\n        if (prevChild.key != null) {\n          newIndex = keyToNewIndexMap.get(prevChild.key);\n        } else {\n          // key-less node, try to locate a key-less node of the same type\n          for (j = s2; j <= e2; j++) {\n            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {\n              newIndex = j;\n              break;\n            }\n          }\n        }\n        if (newIndex === undefined) {\n          unmount(prevChild, parentComponent, parentSuspense, true);\n        } else {\n          newIndexToOldIndexMap[newIndex - s2] = i + 1;\n          if (newIndex >= maxNewIndexSoFar) {\n            maxNewIndexSoFar = newIndex;\n          } else {\n            moved = true;\n          }\n          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n          patched++;\n        }\n      }\n      // 5.3 move and mount\n      // generate longest stable subsequence only when nodes have moved\n      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : shared_1.EMPTY_ARR;\n      j = increasingNewIndexSequence.length - 1;\n      // looping backwards so that we can use last patched node as anchor\n      for (i = toBePatched - 1; i >= 0; i--) {\n        const nextIndex = s2 + i;\n        const nextChild = c2[nextIndex];\n        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;\n        if (newIndexToOldIndexMap[i] === 0) {\n          // mount new\n          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        } else if (moved) {\n          // move if:\n          // There is no stable subsequence (e.g. a reverse)\n          // OR current node is not among the stable sequence\n          if (j < 0 || i !== increasingNewIndexSequence[j]) {\n            move(nextChild, container, anchor, 2 /* MoveType.REORDER */);\n          } else {\n            j--;\n          }\n        }\n      }\n    }\n  };\n  const move = function (vnode, container, anchor, moveType) {\n    let parentSuspense = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    const {\n      el,\n      type,\n      transition,\n      children,\n      shapeFlag\n    } = vnode;\n    if (shapeFlag & 6 /* ShapeFlags.COMPONENT */) {\n      move(vnode.component.subTree, container, anchor, moveType);\n      return;\n    }\n    if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n      vnode.suspense.move(container, anchor, moveType);\n      return;\n    }\n    if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {\n      type.move(vnode, container, anchor, internals);\n      return;\n    }\n    if (type === Fragment) {\n      hostInsert(el, container, anchor);\n      for (let i = 0; i < children.length; i++) {\n        move(children[i], container, anchor, moveType);\n      }\n      hostInsert(vnode.anchor, container, anchor);\n      return;\n    }\n    if (type === Static) {\n      moveStaticNode(vnode, container, anchor);\n      return;\n    }\n    // single nodes\n    const needTransition = moveType !== 2 /* MoveType.REORDER */ && shapeFlag & 1 /* ShapeFlags.ELEMENT */ && transition;\n    if (needTransition) {\n      if (moveType === 0 /* MoveType.ENTER */) {\n        transition.beforeEnter(el);\n        hostInsert(el, container, anchor);\n        queuePostRenderEffect(() => transition.enter(el), parentSuspense);\n      } else {\n        const {\n          leave,\n          delayLeave,\n          afterLeave\n        } = transition;\n        const remove = () => hostInsert(el, container, anchor);\n        const performLeave = () => {\n          leave(el, () => {\n            remove();\n            afterLeave && afterLeave();\n          });\n        };\n        if (delayLeave) {\n          delayLeave(el, remove, performLeave);\n        } else {\n          performLeave();\n        }\n      }\n    } else {\n      hostInsert(el, container, anchor);\n    }\n  };\n  const unmount = function (vnode, parentComponent, parentSuspense) {\n    let doRemove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let optimized = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const {\n      type,\n      props,\n      ref,\n      children,\n      dynamicChildren,\n      shapeFlag,\n      patchFlag,\n      dirs\n    } = vnode;\n    // unset ref\n    if (ref != null) {\n      setRef(ref, null, parentSuspense, vnode, true);\n    }\n    if (shapeFlag & 256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */) {\n      parentComponent.ctx.deactivate(vnode);\n      return;\n    }\n    const shouldInvokeDirs = shapeFlag & 1 /* ShapeFlags.ELEMENT */ && dirs;\n    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);\n    let vnodeHook;\n    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {\n      invokeVNodeHook(vnodeHook, parentComponent, vnode);\n    }\n    if (shapeFlag & 6 /* ShapeFlags.COMPONENT */) {\n      unmountComponent(vnode.component, parentSuspense, doRemove);\n    } else {\n      if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n        vnode.suspense.unmount(parentSuspense, doRemove);\n        return;\n      }\n      if (shouldInvokeDirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');\n      }\n      if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {\n        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);\n      } else if (dynamicChildren && (\n      // #1153: fast path should not be taken for non-stable (v-for) fragments\n      type !== Fragment || patchFlag > 0 && patchFlag & 64 /* PatchFlags.STABLE_FRAGMENT */)) {\n        // fast path for block nodes: only need to unmount dynamic children.\n        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);\n      } else if (type === Fragment && patchFlag & (128 /* PatchFlags.KEYED_FRAGMENT */ | 256 /* PatchFlags.UNKEYED_FRAGMENT */) || !optimized && shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n        unmountChildren(children, parentComponent, parentSuspense);\n      }\n      if (doRemove) {\n        remove(vnode);\n      }\n    }\n    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');\n      }, parentSuspense);\n    }\n  };\n  const remove = vnode => {\n    const {\n      type,\n      el,\n      anchor,\n      transition\n    } = vnode;\n    if (type === Fragment) {\n      if ( true && vnode.patchFlag > 0 && vnode.patchFlag & 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */ && transition && !transition.persisted) {\n        vnode.children.forEach(child => {\n          if (child.type === Comment) {\n            hostRemove(child.el);\n          } else {\n            remove(child);\n          }\n        });\n      } else {\n        removeFragment(el, anchor);\n      }\n      return;\n    }\n    if (type === Static) {\n      removeStaticNode(vnode);\n      return;\n    }\n    const performRemove = () => {\n      hostRemove(el);\n      if (transition && !transition.persisted && transition.afterLeave) {\n        transition.afterLeave();\n      }\n    };\n    if (vnode.shapeFlag & 1 /* ShapeFlags.ELEMENT */ && transition && !transition.persisted) {\n      const {\n        leave,\n        delayLeave\n      } = transition;\n      const performLeave = () => leave(el, performRemove);\n      if (delayLeave) {\n        delayLeave(vnode.el, performRemove, performLeave);\n      } else {\n        performLeave();\n      }\n    } else {\n      performRemove();\n    }\n  };\n  const removeFragment = (cur, end) => {\n    // For fragments, directly remove all contained DOM nodes.\n    // (fragment child nodes cannot have transition)\n    let next;\n    while (cur !== end) {\n      next = hostNextSibling(cur);\n      hostRemove(cur);\n      cur = next;\n    }\n    hostRemove(end);\n  };\n  const unmountComponent = (instance, parentSuspense, doRemove) => {\n    if ( true && instance.type.__hmrId) {\n      unregisterHMR(instance);\n    }\n    const {\n      bum,\n      scope,\n      update,\n      subTree,\n      um\n    } = instance;\n    // beforeUnmount hook\n    if (bum) {\n      (0, shared_1.invokeArrayFns)(bum);\n    }\n    // stop effects in component scope\n    scope.stop();\n    // update may be null if a component is unmounted before its async\n    // setup has resolved.\n    if (update) {\n      // so that scheduler will no longer invoke it\n      update.active = false;\n      unmount(subTree, instance, parentSuspense, doRemove);\n    }\n    // unmounted hook\n    if (um) {\n      queuePostRenderEffect(um, parentSuspense);\n    }\n    queuePostRenderEffect(() => {\n      instance.isUnmounted = true;\n    }, parentSuspense);\n    // A component with async dep inside a pending suspense is unmounted before\n    // its async dep resolves. This should remove the dep from the suspense, and\n    // cause the suspense to resolve immediately if that was the last dep.\n    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {\n      parentSuspense.deps--;\n      if (parentSuspense.deps === 0) {\n        parentSuspense.resolve();\n      }\n    }\n    if (true) {\n      devtoolsComponentRemoved(instance);\n    }\n  };\n  const unmountChildren = function (children, parentComponent, parentSuspense) {\n    let doRemove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let optimized = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    let start = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    for (let i = start; i < children.length; i++) {\n      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);\n    }\n  };\n  const getNextHostNode = vnode => {\n    if (vnode.shapeFlag & 6 /* ShapeFlags.COMPONENT */) {\n      return getNextHostNode(vnode.component.subTree);\n    }\n    if (vnode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n      return vnode.suspense.next();\n    }\n    return hostNextSibling(vnode.anchor || vnode.el);\n  };\n  const render = (vnode, container, isSVG) => {\n    if (vnode == null) {\n      if (container._vnode) {\n        unmount(container._vnode, null, null, true);\n      }\n    } else {\n      patch(container._vnode || null, vnode, container, null, null, null, isSVG);\n    }\n    flushPreFlushCbs();\n    flushPostFlushCbs();\n    container._vnode = vnode;\n  };\n  const internals = {\n    p: patch,\n    um: unmount,\n    m: move,\n    r: remove,\n    mt: mountComponent,\n    mc: mountChildren,\n    pc: patchChildren,\n    pbc: patchBlockChildren,\n    n: getNextHostNode,\n    o: options\n  };\n  let hydrate;\n  let hydrateNode;\n  if (createHydrationFns) {\n    [hydrate, hydrateNode] = createHydrationFns(internals);\n  }\n  return {\n    render,\n    hydrate,\n    createApp: createAppAPI(render, hydrate)\n  };\n}\nfunction toggleRecurse(_ref14, allowed) {\n  let {\n    effect,\n    update\n  } = _ref14;\n  effect.allowRecurse = update.allowRecurse = allowed;\n}\n/**\n * #1156\n * When a component is HMR-enabled, we need to make sure that all static nodes\n * inside a block also inherit the DOM element from the previous tree so that\n * HMR updates (which are full updates) can retrieve the element for patching.\n *\n * #2080\n * Inside keyed `template` fragment static children, if a fragment is moved,\n * the children will always be moved. Therefore, in order to ensure correct move\n * position, el should be inherited from previous nodes.\n */\nfunction traverseStaticChildren(n1, n2) {\n  let shallow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const ch1 = n1.children;\n  const ch2 = n2.children;\n  if ((0, shared_1.isArray)(ch1) && (0, shared_1.isArray)(ch2)) {\n    for (let i = 0; i < ch1.length; i++) {\n      // this is only called in the optimized path so array children are\n      // guaranteed to be vnodes\n      const c1 = ch1[i];\n      let c2 = ch2[i];\n      if (c2.shapeFlag & 1 /* ShapeFlags.ELEMENT */ && !c2.dynamicChildren) {\n        if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* PatchFlags.HYDRATE_EVENTS */) {\n          c2 = ch2[i] = cloneIfMounted(ch2[i]);\n          c2.el = c1.el;\n        }\n        if (!shallow) traverseStaticChildren(c1, c2);\n      }\n      // #6852 also inherit for text nodes\n      if (c2.type === Text) {\n        c2.el = c1.el;\n      }\n      // also inherit for comment nodes, but not placeholders (e.g. v-if which\n      // would have received .el during block patch)\n      if ( true && c2.type === Comment && !c2.el) {\n        c2.el = c1.el;\n      }\n    }\n  }\n}\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nfunction getSequence(arr) {\n  const p = arr.slice();\n  const result = [0];\n  let i, j, u, v, c;\n  const len = arr.length;\n  for (i = 0; i < len; i++) {\n    const arrI = arr[i];\n    if (arrI !== 0) {\n      j = result[result.length - 1];\n      if (arr[j] < arrI) {\n        p[i] = j;\n        result.push(i);\n        continue;\n      }\n      u = 0;\n      v = result.length - 1;\n      while (u < v) {\n        c = u + v >> 1;\n        if (arr[result[c]] < arrI) {\n          u = c + 1;\n        } else {\n          v = c;\n        }\n      }\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          p[i] = result[u - 1];\n        }\n        result[u] = i;\n      }\n    }\n  }\n  u = result.length;\n  v = result[u - 1];\n  while (u-- > 0) {\n    result[u] = v;\n    v = p[v];\n  }\n  return result;\n}\nconst isTeleport = type => type.__isTeleport;\nconst isTeleportDisabled = props => props && (props.disabled || props.disabled === '');\nconst isTargetSVG = target => typeof SVGElement !== 'undefined' && target instanceof SVGElement;\nconst resolveTarget = (props, select) => {\n  const targetSelector = props && props.to;\n  if ((0, shared_1.isString)(targetSelector)) {\n    if (!select) {\n       true && warn(`Current renderer does not support string target for Teleports. ` + `(missing querySelector renderer option)`);\n      return null;\n    } else {\n      const target = select(targetSelector);\n      if (!target) {\n         true && warn(`Failed to locate Teleport target with selector \"${targetSelector}\". ` + `Note the target element must exist before the component is mounted - ` + `i.e. the target cannot be rendered by the component itself, and ` + `ideally should be outside of the entire Vue component tree.`);\n      }\n      return target;\n    }\n  } else {\n    if ( true && !targetSelector && !isTeleportDisabled(props)) {\n      warn(`Invalid Teleport target: ${targetSelector}`);\n    }\n    return targetSelector;\n  }\n};\nconst TeleportImpl = {\n  __isTeleport: true,\n  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {\n    const {\n      mc: mountChildren,\n      pc: patchChildren,\n      pbc: patchBlockChildren,\n      o: {\n        insert,\n        querySelector,\n        createText,\n        createComment\n      }\n    } = internals;\n    const disabled = isTeleportDisabled(n2.props);\n    let {\n      shapeFlag,\n      children,\n      dynamicChildren\n    } = n2;\n    // #3302\n    // HMR updated, force full diff\n    if ( true && isHmrUpdating) {\n      optimized = false;\n      dynamicChildren = null;\n    }\n    if (n1 == null) {\n      // insert anchors in the main view\n      const placeholder = n2.el =  true ? createComment('teleport start') : 0;\n      const mainAnchor = n2.anchor =  true ? createComment('teleport end') : 0;\n      insert(placeholder, container, anchor);\n      insert(mainAnchor, container, anchor);\n      const target = n2.target = resolveTarget(n2.props, querySelector);\n      const targetAnchor = n2.targetAnchor = createText('');\n      if (target) {\n        insert(targetAnchor, target);\n        // #2652 we could be teleporting from a non-SVG tree into an SVG tree\n        isSVG = isSVG || isTargetSVG(target);\n      } else if ( true && !disabled) {\n        warn('Invalid Teleport target on mount:', target, `(${typeof target})`);\n      }\n      const mount = (container, anchor) => {\n        // Teleport *always* has Array children. This is enforced in both the\n        // compiler and vnode children normalization.\n        if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n          mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        }\n      };\n      if (disabled) {\n        mount(container, mainAnchor);\n      } else if (target) {\n        mount(target, targetAnchor);\n      }\n    } else {\n      // update content\n      n2.el = n1.el;\n      const mainAnchor = n2.anchor = n1.anchor;\n      const target = n2.target = n1.target;\n      const targetAnchor = n2.targetAnchor = n1.targetAnchor;\n      const wasDisabled = isTeleportDisabled(n1.props);\n      const currentContainer = wasDisabled ? container : target;\n      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;\n      isSVG = isSVG || isTargetSVG(target);\n      if (dynamicChildren) {\n        // fast path when the teleport happens to be a block root\n        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);\n        // even in block tree mode we need to make sure all root-level nodes\n        // in the teleport inherit previous DOM references so that they can\n        // be moved in future patches.\n        traverseStaticChildren(n1, n2, true);\n      } else if (!optimized) {\n        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);\n      }\n      if (disabled) {\n        if (!wasDisabled) {\n          // enabled -> disabled\n          // move into main container\n          moveTeleport(n2, container, mainAnchor, internals, 1 /* TeleportMoveTypes.TOGGLE */);\n        }\n      } else {\n        // target changed\n        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\n          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);\n          if (nextTarget) {\n            moveTeleport(n2, nextTarget, null, internals, 0 /* TeleportMoveTypes.TARGET_CHANGE */);\n          } else if (true) {\n            warn('Invalid Teleport target on update:', target, `(${typeof target})`);\n          }\n        } else if (wasDisabled) {\n          // disabled -> enabled\n          // move into teleport target\n          moveTeleport(n2, target, targetAnchor, internals, 1 /* TeleportMoveTypes.TOGGLE */);\n        }\n      }\n    }\n\n    updateCssVars(n2);\n  },\n  remove(vnode, parentComponent, parentSuspense, optimized, _ref15, doRemove) {\n    let {\n      um: unmount,\n      o: {\n        remove: hostRemove\n      }\n    } = _ref15;\n    const {\n      shapeFlag,\n      children,\n      anchor,\n      targetAnchor,\n      target,\n      props\n    } = vnode;\n    if (target) {\n      hostRemove(targetAnchor);\n    }\n    // an unmounted teleport should always remove its children if not disabled\n    if (doRemove || !isTeleportDisabled(props)) {\n      hostRemove(anchor);\n      if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n        for (let i = 0; i < children.length; i++) {\n          const child = children[i];\n          unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);\n        }\n      }\n    }\n  },\n  move: moveTeleport,\n  hydrate: hydrateTeleport\n};\nfunction moveTeleport(vnode, container, parentAnchor, _ref16) {\n  let {\n    o: {\n      insert\n    },\n    m: move\n  } = _ref16;\n  let moveType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2;\n  // move target anchor if this is a target change.\n  if (moveType === 0 /* TeleportMoveTypes.TARGET_CHANGE */) {\n    insert(vnode.targetAnchor, container, parentAnchor);\n  }\n  const {\n    el,\n    anchor,\n    shapeFlag,\n    children,\n    props\n  } = vnode;\n  const isReorder = moveType === 2 /* TeleportMoveTypes.REORDER */;\n  // move main view anchor if this is a re-order.\n  if (isReorder) {\n    insert(el, container, parentAnchor);\n  }\n  // if this is a re-order and teleport is enabled (content is in target)\n  // do not move children. So the opposite is: only move children if this\n  // is not a reorder, or the teleport is disabled\n  if (!isReorder || isTeleportDisabled(props)) {\n    // Teleport has either Array children or no children.\n    if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n      for (let i = 0; i < children.length; i++) {\n        move(children[i], container, parentAnchor, 2 /* MoveType.REORDER */);\n      }\n    }\n  }\n  // move main view anchor if this is a re-order.\n  if (isReorder) {\n    insert(anchor, container, parentAnchor);\n  }\n}\nfunction hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, _ref17, hydrateChildren) {\n  let {\n    o: {\n      nextSibling,\n      parentNode,\n      querySelector\n    }\n  } = _ref17;\n  const target = vnode.target = resolveTarget(vnode.props, querySelector);\n  if (target) {\n    // if multiple teleports rendered to the same target element, we need to\n    // pick up from where the last teleport finished instead of the first node\n    const targetNode = target._lpa || target.firstChild;\n    if (vnode.shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n      if (isTeleportDisabled(vnode.props)) {\n        vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);\n        vnode.targetAnchor = targetNode;\n      } else {\n        vnode.anchor = nextSibling(node);\n        // lookahead until we find the target anchor\n        // we cannot rely on return value of hydrateChildren() because there\n        // could be nested teleports\n        let targetAnchor = targetNode;\n        while (targetAnchor) {\n          targetAnchor = nextSibling(targetAnchor);\n          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === 'teleport anchor') {\n            vnode.targetAnchor = targetAnchor;\n            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);\n            break;\n          }\n        }\n        hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);\n      }\n    }\n    updateCssVars(vnode);\n  }\n  return vnode.anchor && nextSibling(vnode.anchor);\n}\n// Force-casted public typing for h and TSX props inference\nconst Teleport = TeleportImpl;\nexports.Teleport = Teleport;\nfunction updateCssVars(vnode) {\n  // presence of .ut method indicates owner component uses css vars.\n  // code path here can assume browser environment.\n  const ctx = vnode.ctx;\n  if (ctx && ctx.ut) {\n    let node = vnode.children[0].el;\n    while (node !== vnode.targetAnchor) {\n      if (node.nodeType === 1) node.setAttribute('data-v-owner', ctx.uid);\n      node = node.nextSibling;\n    }\n    ctx.ut();\n  }\n}\nconst Fragment = Symbol( true ? 'Fragment' : 0);\nexports.Fragment = Fragment;\nconst Text = Symbol( true ? 'Text' : 0);\nexports.Text = Text;\nconst Comment = Symbol( true ? 'Comment' : 0);\nexports.Comment = Comment;\nconst Static = Symbol( true ? 'Static' : 0);\nexports.Static = Static;\n// Since v-if and v-for are the two possible ways node structure can dynamically\n// change, once we consider v-if branches and each v-for fragment a block, we\n// can divide a template into nested blocks, and within each block the node\n// structure would be stable. This allows us to skip most children diffing\n// and only worry about the dynamic nodes (indicated by patch flags).\nconst blockStack = [];\nlet currentBlock = null;\n/**\n * Open a block.\n * This must be called before `createBlock`. It cannot be part of `createBlock`\n * because the children of the block are evaluated before `createBlock` itself\n * is called. The generated code typically looks like this:\n *\n * ```js\n * function render() {\n *   return (openBlock(),createBlock('div', null, [...]))\n * }\n * ```\n * disableTracking is true when creating a v-for fragment block, since a v-for\n * fragment always diffs its children.\n *\n * @private\n */\nfunction openBlock() {\n  let disableTracking = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  blockStack.push(currentBlock = disableTracking ? null : []);\n}\nexports.openBlock = openBlock;\nfunction closeBlock() {\n  blockStack.pop();\n  currentBlock = blockStack[blockStack.length - 1] || null;\n}\n// Whether we should be tracking dynamic child nodes inside a block.\n// Only tracks when this value is > 0\n// We are not using a simple boolean because this value may need to be\n// incremented/decremented by nested usage of v-once (see below)\nlet isBlockTreeEnabled = 1;\n/**\n * Block tracking sometimes needs to be disabled, for example during the\n * creation of a tree that needs to be cached by v-once. The compiler generates\n * code like this:\n *\n * ``` js\n * _cache[1] || (\n *   setBlockTracking(-1),\n *   _cache[1] = createVNode(...),\n *   setBlockTracking(1),\n *   _cache[1]\n * )\n * ```\n *\n * @private\n */\nfunction setBlockTracking(value) {\n  isBlockTreeEnabled += value;\n}\nexports.setBlockTracking = setBlockTracking;\nfunction setupBlock(vnode) {\n  // save current block children on the block vnode\n  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || shared_1.EMPTY_ARR : null;\n  // close block\n  closeBlock();\n  // a block is always going to be patched, so track it as a child of its\n  // parent block\n  if (isBlockTreeEnabled > 0 && currentBlock) {\n    currentBlock.push(vnode);\n  }\n  return vnode;\n}\n/**\n * @private\n */\nfunction createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {\n  return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true /* isBlock */));\n}\n\nexports.createElementBlock = createElementBlock;\n/**\n * Create a block root vnode. Takes the same exact arguments as `createVNode`.\n * A block root keeps track of dynamic nodes within the block in the\n * `dynamicChildren` array.\n *\n * @private\n */\nfunction createBlock(type, props, children, patchFlag, dynamicProps) {\n  return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */));\n}\n\nexports.createBlock = createBlock;\nfunction isVNode(value) {\n  return value ? value.__v_isVNode === true : false;\n}\nexports.isVNode = isVNode;\nfunction isSameVNodeType(n1, n2) {\n  if ( true && n2.shapeFlag & 6 /* ShapeFlags.COMPONENT */ && hmrDirtyComponents.has(n2.type)) {\n    // #7042, ensure the vnode being unmounted during HMR\n    // bitwise operations to remove keep alive flags\n    n1.shapeFlag &= ~256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */;\n    n2.shapeFlag &= ~512 /* ShapeFlags.COMPONENT_KEPT_ALIVE */;\n    // HMR only: if the component has been hot-updated, force a reload.\n    return false;\n  }\n  return n1.type === n2.type && n1.key === n2.key;\n}\nlet vnodeArgsTransformer;\n/**\n * Internal API for registering an arguments transform for createVNode\n * used for creating stubs in the test-utils\n * It is *internal* but needs to be exposed for test-utils to pick up proper\n * typings\n */\nfunction transformVNodeArgs(transformer) {\n  vnodeArgsTransformer = transformer;\n}\nexports.transformVNodeArgs = transformVNodeArgs;\nconst createVNodeWithArgsTransform = function () {\n  for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    args[_key7] = arguments[_key7];\n  }\n  return _createVNode(...(vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args));\n};\nconst InternalObjectKey = `__vInternal`;\nconst normalizeKey = _ref18 => {\n  let {\n    key\n  } = _ref18;\n  return key != null ? key : null;\n};\nconst normalizeRef = _ref19 => {\n  let {\n    ref,\n    ref_key,\n    ref_for\n  } = _ref19;\n  return ref != null ? (0, shared_1.isString)(ref) || (0, reactivity_1.isRef)(ref) || (0, shared_1.isFunction)(ref) ? {\n    i: currentRenderingInstance,\n    r: ref,\n    k: ref_key,\n    f: !!ref_for\n  } : ref : null;\n};\nfunction createBaseVNode(type) {\n  let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let patchFlag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let dynamicProps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  let shapeFlag = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : type === Fragment ? 0 : 1;\n  let isBlockNode = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  let needFullChildrenNormalization = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n  const vnode = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type,\n    props,\n    key: props && normalizeKey(props),\n    ref: props && normalizeRef(props),\n    scopeId: currentScopeId,\n    slotScopeIds: null,\n    children,\n    component: null,\n    suspense: null,\n    ssContent: null,\n    ssFallback: null,\n    dirs: null,\n    transition: null,\n    el: null,\n    anchor: null,\n    target: null,\n    targetAnchor: null,\n    staticCount: 0,\n    shapeFlag,\n    patchFlag,\n    dynamicProps,\n    dynamicChildren: null,\n    appContext: null,\n    ctx: currentRenderingInstance\n  };\n  if (needFullChildrenNormalization) {\n    normalizeChildren(vnode, children);\n    // normalize suspense children\n    if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n      type.normalize(vnode);\n    }\n  } else if (children) {\n    // compiled element vnode - if children is passed, only possible types are\n    // string or Array.\n    vnode.shapeFlag |= (0, shared_1.isString)(children) ? 8 /* ShapeFlags.TEXT_CHILDREN */ : 16 /* ShapeFlags.ARRAY_CHILDREN */;\n  }\n  // validate key\n  if ( true && vnode.key !== vnode.key) {\n    warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);\n  }\n  // track vnode for block tree\n  if (isBlockTreeEnabled > 0 &&\n  // avoid a block node from tracking itself\n  !isBlockNode &&\n  // has current parent block\n  currentBlock && (\n  // presence of a patch flag indicates this node needs patching on updates.\n  // component nodes also should always be patched, because even if the\n  // component doesn't need to update, it needs to persist the instance on to\n  // the next vnode so that it can be properly unmounted later.\n  vnode.patchFlag > 0 || shapeFlag & 6 /* ShapeFlags.COMPONENT */) &&\n  // the EVENTS flag is only for hydration and if it is the only flag, the\n  // vnode should not be considered dynamic due to handler caching.\n  vnode.patchFlag !== 32 /* PatchFlags.HYDRATE_EVENTS */) {\n    currentBlock.push(vnode);\n  }\n  return vnode;\n}\nexports.createElementVNode = createBaseVNode;\nconst createVNode =  true ? createVNodeWithArgsTransform : 0;\nexports.createVNode = createVNode;\nfunction _createVNode(type) {\n  let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let patchFlag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let dynamicProps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  let isBlockNode = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  if (!type || type === NULL_DYNAMIC_COMPONENT) {\n    if ( true && !type) {\n      warn(`Invalid vnode type when creating vnode: ${type}.`);\n    }\n    type = Comment;\n  }\n  if (isVNode(type)) {\n    // createVNode receiving an existing vnode. This happens in cases like\n    // <component :is=\"vnode\"/>\n    // #2078 make sure to merge refs during the clone instead of overwriting it\n    const cloned = cloneVNode(type, props, true /* mergeRef: true */);\n    if (children) {\n      normalizeChildren(cloned, children);\n    }\n    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {\n      if (cloned.shapeFlag & 6 /* ShapeFlags.COMPONENT */) {\n        currentBlock[currentBlock.indexOf(type)] = cloned;\n      } else {\n        currentBlock.push(cloned);\n      }\n    }\n    cloned.patchFlag |= -2 /* PatchFlags.BAIL */;\n    return cloned;\n  }\n  // class component normalization.\n  if (isClassComponent(type)) {\n    type = type.__vccOpts;\n  }\n  // class & style normalization.\n  if (props) {\n    // for reactive or proxy objects, we need to clone it to enable mutation.\n    props = guardReactiveProps(props);\n    let {\n      class: klass,\n      style\n    } = props;\n    if (klass && !(0, shared_1.isString)(klass)) {\n      props.class = (0, shared_1.normalizeClass)(klass);\n    }\n    if ((0, shared_1.isObject)(style)) {\n      // reactive state objects need to be cloned since they are likely to be\n      // mutated\n      if ((0, reactivity_1.isProxy)(style) && !(0, shared_1.isArray)(style)) {\n        style = (0, shared_1.extend)({}, style);\n      }\n      props.style = (0, shared_1.normalizeStyle)(style);\n    }\n  }\n  // encode the vnode type information into a bitmap\n  const shapeFlag = (0, shared_1.isString)(type) ? 1 /* ShapeFlags.ELEMENT */ : isSuspense(type) ? 128 /* ShapeFlags.SUSPENSE */ : isTeleport(type) ? 64 /* ShapeFlags.TELEPORT */ : (0, shared_1.isObject)(type) ? 4 /* ShapeFlags.STATEFUL_COMPONENT */ : (0, shared_1.isFunction)(type) ? 2 /* ShapeFlags.FUNCTIONAL_COMPONENT */ : 0;\n  if ( true && shapeFlag & 4 /* ShapeFlags.STATEFUL_COMPONENT */ && (0, reactivity_1.isProxy)(type)) {\n    type = (0, reactivity_1.toRaw)(type);\n    warn(`Vue received a Component which was made a reactive object. This can ` + `lead to unnecessary performance overhead, and should be avoided by ` + `marking the component with \\`markRaw\\` or using \\`shallowRef\\` ` + `instead of \\`ref\\`.`, `\\nComponent that was made reactive: `, type);\n  }\n  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);\n}\nfunction guardReactiveProps(props) {\n  if (!props) return null;\n  return (0, reactivity_1.isProxy)(props) || InternalObjectKey in props ? (0, shared_1.extend)({}, props) : props;\n}\nexports.guardReactiveProps = guardReactiveProps;\nfunction cloneVNode(vnode, extraProps) {\n  let mergeRef = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // This is intentionally NOT using spread or extend to avoid the runtime\n  // key enumeration cost.\n  const {\n    props,\n    ref,\n    patchFlag,\n    children\n  } = vnode;\n  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\n  const cloned = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type: vnode.type,\n    props: mergedProps,\n    key: mergedProps && normalizeKey(mergedProps),\n    ref: extraProps && extraProps.ref ?\n    // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\n    // if the vnode itself already has a ref, cloneVNode will need to merge\n    // the refs so the single vnode can be set on multiple refs\n    mergeRef && ref ? (0, shared_1.isArray)(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref,\n    scopeId: vnode.scopeId,\n    slotScopeIds: vnode.slotScopeIds,\n    children:  true && patchFlag === -1 /* PatchFlags.HOISTED */ && (0, shared_1.isArray)(children) ? children.map(deepCloneVNode) : children,\n    target: vnode.target,\n    targetAnchor: vnode.targetAnchor,\n    staticCount: vnode.staticCount,\n    shapeFlag: vnode.shapeFlag,\n    // if the vnode is cloned with extra props, we can no longer assume its\n    // existing patch flag to be reliable and need to add the FULL_PROPS flag.\n    // note: preserve flag for fragments since they use the flag for children\n    // fast paths only.\n    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 // hoisted node\n    ? 16 /* PatchFlags.FULL_PROPS */ : patchFlag | 16 /* PatchFlags.FULL_PROPS */ : patchFlag,\n    dynamicProps: vnode.dynamicProps,\n    dynamicChildren: vnode.dynamicChildren,\n    appContext: vnode.appContext,\n    dirs: vnode.dirs,\n    transition: vnode.transition,\n    // These should technically only be non-null on mounted VNodes. However,\n    // they *should* be copied for kept-alive vnodes. So we just always copy\n    // them since them being non-null during a mount doesn't affect the logic as\n    // they will simply be overwritten.\n    component: vnode.component,\n    suspense: vnode.suspense,\n    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\n    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\n    el: vnode.el,\n    anchor: vnode.anchor,\n    ctx: vnode.ctx,\n    ce: vnode.ce\n  };\n  return cloned;\n}\nexports.cloneVNode = cloneVNode;\n/**\n * Dev only, for HMR of hoisted vnodes reused in v-for\n * https://github.com/vitejs/vite/issues/2022\n */\nfunction deepCloneVNode(vnode) {\n  const cloned = cloneVNode(vnode);\n  if ((0, shared_1.isArray)(vnode.children)) {\n    cloned.children = vnode.children.map(deepCloneVNode);\n  }\n  return cloned;\n}\n/**\n * @private\n */\nfunction createTextVNode() {\n  let text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ' ';\n  let flag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return createVNode(Text, null, text, flag);\n}\nexports.createTextVNode = createTextVNode;\n/**\n * @private\n */\nfunction createStaticVNode(content, numberOfNodes) {\n  // A static vnode can contain multiple stringified elements, and the number\n  // of elements is necessary for hydration.\n  const vnode = createVNode(Static, null, content);\n  vnode.staticCount = numberOfNodes;\n  return vnode;\n}\nexports.createStaticVNode = createStaticVNode;\n/**\n * @private\n */\nfunction createCommentVNode() {\n  let text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  let asBlock = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);\n}\nexports.createCommentVNode = createCommentVNode;\nfunction normalizeVNode(child) {\n  if (child == null || typeof child === 'boolean') {\n    // empty placeholder\n    return createVNode(Comment);\n  } else if ((0, shared_1.isArray)(child)) {\n    // fragment\n    return createVNode(Fragment, null,\n    // #3666, avoid reference pollution when reusing vnode\n    child.slice());\n  } else if (typeof child === 'object') {\n    // already vnode, this should be the most common since compiled templates\n    // always produce all-vnode children arrays\n    return cloneIfMounted(child);\n  } else {\n    // strings and numbers\n    return createVNode(Text, null, String(child));\n  }\n}\n// optimized normalization for template-compiled render fns\nfunction cloneIfMounted(child) {\n  return child.el === null && child.patchFlag !== -1 /* PatchFlags.HOISTED */ || child.memo ? child : cloneVNode(child);\n}\nfunction normalizeChildren(vnode, children) {\n  let type = 0;\n  const {\n    shapeFlag\n  } = vnode;\n  if (children == null) {\n    children = null;\n  } else if ((0, shared_1.isArray)(children)) {\n    type = 16 /* ShapeFlags.ARRAY_CHILDREN */;\n  } else if (typeof children === 'object') {\n    if (shapeFlag & (1 /* ShapeFlags.ELEMENT */ | 64 /* ShapeFlags.TELEPORT */)) {\n      // Normalize slot to plain children for plain element and Teleport\n      const slot = children.default;\n      if (slot) {\n        // _c marker is added by withCtx() indicating this is a compiled slot\n        slot._c && (slot._d = false);\n        normalizeChildren(vnode, slot());\n        slot._c && (slot._d = true);\n      }\n      return;\n    } else {\n      type = 32 /* ShapeFlags.SLOTS_CHILDREN */;\n      const slotFlag = children._;\n      if (!slotFlag && !(InternalObjectKey in children)) {\n        children._ctx = currentRenderingInstance;\n      } else if (slotFlag === 3 /* SlotFlags.FORWARDED */ && currentRenderingInstance) {\n        // a child component receives forwarded slots from the parent.\n        // its slot type is determined by its parent's slot type.\n        if (currentRenderingInstance.slots._ === 1 /* SlotFlags.STABLE */) {\n          children._ = 1 /* SlotFlags.STABLE */;\n        } else {\n          children._ = 2 /* SlotFlags.DYNAMIC */;\n          vnode.patchFlag |= 1024 /* PatchFlags.DYNAMIC_SLOTS */;\n        }\n      }\n    }\n  } else if ((0, shared_1.isFunction)(children)) {\n    children = {\n      default: children,\n      _ctx: currentRenderingInstance\n    };\n    type = 32 /* ShapeFlags.SLOTS_CHILDREN */;\n  } else {\n    children = String(children);\n    // force teleport children to array so it can be moved around\n    if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {\n      type = 16 /* ShapeFlags.ARRAY_CHILDREN */;\n      children = [createTextVNode(children)];\n    } else {\n      type = 8 /* ShapeFlags.TEXT_CHILDREN */;\n    }\n  }\n\n  vnode.children = children;\n  vnode.shapeFlag |= type;\n}\nfunction mergeProps() {\n  const ret = {};\n  for (let i = 0; i < arguments.length; i++) {\n    const toMerge = i < 0 || arguments.length <= i ? undefined : arguments[i];\n    for (const key in toMerge) {\n      if (key === 'class') {\n        if (ret.class !== toMerge.class) {\n          ret.class = (0, shared_1.normalizeClass)([ret.class, toMerge.class]);\n        }\n      } else if (key === 'style') {\n        ret.style = (0, shared_1.normalizeStyle)([ret.style, toMerge.style]);\n      } else if ((0, shared_1.isOn)(key)) {\n        const existing = ret[key];\n        const incoming = toMerge[key];\n        if (incoming && existing !== incoming && !((0, shared_1.isArray)(existing) && existing.includes(incoming))) {\n          ret[key] = existing ? [].concat(existing, incoming) : incoming;\n        }\n      } else if (key !== '') {\n        ret[key] = toMerge[key];\n      }\n    }\n  }\n  return ret;\n}\nexports.mergeProps = mergeProps;\nfunction invokeVNodeHook(hook, instance, vnode) {\n  let prevVNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  callWithAsyncErrorHandling(hook, instance, 7 /* ErrorCodes.VNODE_HOOK */, [vnode, prevVNode]);\n}\nconst emptyAppContext = createAppContext();\nlet uid = 0;\nfunction createComponentInstance(vnode, parent, suspense) {\n  const type = vnode.type;\n  // inherit parent app context - or - if root, adopt from root vnode\n  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;\n  const instance = {\n    uid: uid++,\n    vnode,\n    type,\n    parent,\n    appContext,\n    root: null,\n    next: null,\n    subTree: null,\n    effect: null,\n    update: null,\n    scope: new reactivity_1.EffectScope(true /* detached */),\n    render: null,\n    proxy: null,\n    exposed: null,\n    exposeProxy: null,\n    withProxy: null,\n    provides: parent ? parent.provides : Object.create(appContext.provides),\n    accessCache: null,\n    renderCache: [],\n    // local resolved assets\n    components: null,\n    directives: null,\n    // resolved props and emits options\n    propsOptions: normalizePropsOptions(type, appContext),\n    emitsOptions: normalizeEmitsOptions(type, appContext),\n    // emit\n    emit: null,\n    emitted: null,\n    // props default value\n    propsDefaults: shared_1.EMPTY_OBJ,\n    // inheritAttrs\n    inheritAttrs: type.inheritAttrs,\n    // state\n    ctx: shared_1.EMPTY_OBJ,\n    data: shared_1.EMPTY_OBJ,\n    props: shared_1.EMPTY_OBJ,\n    attrs: shared_1.EMPTY_OBJ,\n    slots: shared_1.EMPTY_OBJ,\n    refs: shared_1.EMPTY_OBJ,\n    setupState: shared_1.EMPTY_OBJ,\n    setupContext: null,\n    // suspense related\n    suspense,\n    suspenseId: suspense ? suspense.pendingId : 0,\n    asyncDep: null,\n    asyncResolved: false,\n    // lifecycle hooks\n    // not using enums here because it results in computed properties\n    isMounted: false,\n    isUnmounted: false,\n    isDeactivated: false,\n    bc: null,\n    c: null,\n    bm: null,\n    m: null,\n    bu: null,\n    u: null,\n    um: null,\n    bum: null,\n    da: null,\n    a: null,\n    rtg: null,\n    rtc: null,\n    ec: null,\n    sp: null\n  };\n  if (true) {\n    instance.ctx = createDevRenderContext(instance);\n  } else {}\n  instance.root = parent ? parent.root : instance;\n  instance.emit = emit.bind(null, instance);\n  // apply custom element special handling\n  if (vnode.ce) {\n    vnode.ce(instance);\n  }\n  return instance;\n}\nlet currentInstance = null;\nconst getCurrentInstance = () => currentInstance || currentRenderingInstance;\nexports.getCurrentInstance = getCurrentInstance;\nconst setCurrentInstance = instance => {\n  currentInstance = instance;\n  instance.scope.on();\n};\nconst unsetCurrentInstance = () => {\n  currentInstance && currentInstance.scope.off();\n  currentInstance = null;\n};\nconst isBuiltInTag = /*#__PURE__*/(0, shared_1.makeMap)('slot,component');\nfunction validateComponentName(name, config) {\n  const appIsNativeTag = config.isNativeTag || shared_1.NO;\n  if (isBuiltInTag(name) || appIsNativeTag(name)) {\n    warn('Do not use built-in or reserved HTML elements as component id: ' + name);\n  }\n}\nfunction isStatefulComponent(instance) {\n  return instance.vnode.shapeFlag & 4 /* ShapeFlags.STATEFUL_COMPONENT */;\n}\n\nlet isInSSRComponentSetup = false;\nfunction setupComponent(instance) {\n  let isSSR = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  isInSSRComponentSetup = isSSR;\n  const {\n    props,\n    children\n  } = instance.vnode;\n  const isStateful = isStatefulComponent(instance);\n  initProps(instance, props, isStateful, isSSR);\n  initSlots(instance, children);\n  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : undefined;\n  isInSSRComponentSetup = false;\n  return setupResult;\n}\nfunction setupStatefulComponent(instance, isSSR) {\n  var _a;\n  const Component = instance.type;\n  if (true) {\n    if (Component.name) {\n      validateComponentName(Component.name, instance.appContext.config);\n    }\n    if (Component.components) {\n      const names = Object.keys(Component.components);\n      for (let i = 0; i < names.length; i++) {\n        validateComponentName(names[i], instance.appContext.config);\n      }\n    }\n    if (Component.directives) {\n      const names = Object.keys(Component.directives);\n      for (let i = 0; i < names.length; i++) {\n        validateDirectiveName(names[i]);\n      }\n    }\n    if (Component.compilerOptions && isRuntimeOnly()) {\n      warn(`\"compilerOptions\" is only supported when using a build of Vue that ` + `includes the runtime compiler. Since you are using a runtime-only ` + `build, the options should be passed via your build tool config instead.`);\n    }\n  }\n  // 0. create render proxy property access cache\n  instance.accessCache = Object.create(null);\n  // 1. create public instance / render proxy\n  // also mark it raw so it's never observed\n  instance.proxy = (0, reactivity_1.markRaw)(new Proxy(instance.ctx, PublicInstanceProxyHandlers));\n  if (true) {\n    exposePropsOnRenderContext(instance);\n  }\n  // 2. call setup()\n  const {\n    setup\n  } = Component;\n  if (setup) {\n    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;\n    setCurrentInstance(instance);\n    (0, reactivity_1.pauseTracking)();\n    const setupResult = callWithErrorHandling(setup, instance, 0 /* ErrorCodes.SETUP_FUNCTION */, [ true ? (0, reactivity_1.shallowReadonly)(instance.props) : 0, setupContext]);\n    (0, reactivity_1.resetTracking)();\n    unsetCurrentInstance();\n    if ((0, shared_1.isPromise)(setupResult)) {\n      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);\n      if (isSSR) {\n        // return the promise so server-renderer can wait on it\n        return setupResult.then(resolvedResult => {\n          handleSetupResult(instance, resolvedResult, isSSR);\n        }).catch(e => {\n          handleError(e, instance, 0 /* ErrorCodes.SETUP_FUNCTION */);\n        });\n      } else {\n        // async setup returned Promise.\n        // bail here and wait for re-entry.\n        instance.asyncDep = setupResult;\n        if ( true && !instance.suspense) {\n          const name = (_a = Component.name) !== null && _a !== void 0 ? _a : 'Anonymous';\n          warn(`Component <${name}>: setup function returned a promise, but no ` + `<Suspense> boundary was found in the parent component tree. ` + `A component with async setup() must be nested in a <Suspense> ` + `in order to be rendered.`);\n        }\n      }\n    } else {\n      handleSetupResult(instance, setupResult, isSSR);\n    }\n  } else {\n    finishComponentSetup(instance, isSSR);\n  }\n}\nfunction handleSetupResult(instance, setupResult, isSSR) {\n  if ((0, shared_1.isFunction)(setupResult)) {\n    // setup returned an inline render function\n    if (instance.type.__ssrInlineRender) {\n      // when the function's name is `ssrRender` (compiled by SFC inline mode),\n      // set it as ssrRender instead.\n      instance.ssrRender = setupResult;\n    } else {\n      instance.render = setupResult;\n    }\n  } else if ((0, shared_1.isObject)(setupResult)) {\n    if ( true && isVNode(setupResult)) {\n      warn(`setup() should not return VNodes directly - ` + `return a render function instead.`);\n    }\n    // setup returned bindings.\n    // assuming a render function compiled from template is present.\n    if (true) {\n      instance.devtoolsRawSetupState = setupResult;\n    }\n    instance.setupState = (0, reactivity_1.proxyRefs)(setupResult);\n    if (true) {\n      exposeSetupStateOnRenderContext(instance);\n    }\n  } else if ( true && setupResult !== undefined) {\n    warn(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);\n  }\n  finishComponentSetup(instance, isSSR);\n}\nlet compile;\nlet installWithProxy;\n/**\n * For runtime-dom to register the compiler.\n * Note the exported method uses any to avoid d.ts relying on the compiler types.\n */\nfunction registerRuntimeCompiler(_compile) {\n  compile = _compile;\n  installWithProxy = i => {\n    if (i.render._rc) {\n      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);\n    }\n  };\n}\nexports.registerRuntimeCompiler = registerRuntimeCompiler;\n// dev only\nconst isRuntimeOnly = () => !compile;\nexports.isRuntimeOnly = isRuntimeOnly;\nfunction finishComponentSetup(instance, isSSR, skipOptions) {\n  const Component = instance.type;\n  // template / render function normalization\n  // could be already set when returned from setup()\n  if (!instance.render) {\n    // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation\n    // is done by server-renderer\n    if (!isSSR && compile && !Component.render) {\n      const template = Component.template || resolveMergedOptions(instance).template;\n      if (template) {\n        if (true) {\n          startMeasure(instance, `compile`);\n        }\n        const {\n          isCustomElement,\n          compilerOptions\n        } = instance.appContext.config;\n        const {\n          delimiters,\n          compilerOptions: componentCompilerOptions\n        } = Component;\n        const finalCompilerOptions = (0, shared_1.extend)((0, shared_1.extend)({\n          isCustomElement,\n          delimiters\n        }, compilerOptions), componentCompilerOptions);\n        Component.render = compile(template, finalCompilerOptions);\n        if (true) {\n          endMeasure(instance, `compile`);\n        }\n      }\n    }\n    instance.render = Component.render || shared_1.NOOP;\n    // for runtime-compiled render functions using `with` blocks, the render\n    // proxy used needs a different `has` handler which is more performant and\n    // also only allows a whitelist of globals to fallthrough.\n    if (installWithProxy) {\n      installWithProxy(instance);\n    }\n  }\n  // support for 2.x options\n  if (__VUE_OPTIONS_API__ && !false) {\n    setCurrentInstance(instance);\n    (0, reactivity_1.pauseTracking)();\n    applyOptions(instance);\n    (0, reactivity_1.resetTracking)();\n    unsetCurrentInstance();\n  }\n  // warn missing template/render\n  // the runtime compilation of template in SSR is done by server-render\n  if ( true && !Component.render && instance.render === shared_1.NOOP && !isSSR) {\n    /* istanbul ignore if */\n    if (!compile && Component.template) {\n      warn(`Component provided template option but ` + `runtime compilation is not supported in this build of Vue.` + ` Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\".` /* should not happen */);\n    } else {\n      warn(`Component is missing template or render function.`);\n    }\n  }\n}\nfunction createAttrsProxy(instance) {\n  return new Proxy(instance.attrs,  true ? {\n    get(target, key) {\n      markAttrsAccessed();\n      (0, reactivity_1.track)(instance, \"get\" /* TrackOpTypes.GET */, '$attrs');\n      return target[key];\n    },\n    set() {\n      warn(`setupContext.attrs is readonly.`);\n      return false;\n    },\n    deleteProperty() {\n      warn(`setupContext.attrs is readonly.`);\n      return false;\n    }\n  } : 0);\n}\nfunction createSetupContext(instance) {\n  const expose = exposed => {\n    if (true) {\n      if (instance.exposed) {\n        warn(`expose() should be called only once per setup().`);\n      }\n      if (exposed != null) {\n        let exposedType = typeof exposed;\n        if (exposedType === 'object') {\n          if ((0, shared_1.isArray)(exposed)) {\n            exposedType = 'array';\n          } else if ((0, reactivity_1.isRef)(exposed)) {\n            exposedType = 'ref';\n          }\n        }\n        if (exposedType !== 'object') {\n          warn(`expose() should be passed a plain object, received ${exposedType}.`);\n        }\n      }\n    }\n    instance.exposed = exposed || {};\n  };\n  let attrs;\n  if (true) {\n    // We use getters in dev in case libs like test-utils overwrite instance\n    // properties (overwrites should not be done in prod)\n    return Object.freeze({\n      get attrs() {\n        return attrs || (attrs = createAttrsProxy(instance));\n      },\n      get slots() {\n        return (0, reactivity_1.shallowReadonly)(instance.slots);\n      },\n      get emit() {\n        return function (event) {\n          for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n            args[_key8 - 1] = arguments[_key8];\n          }\n          return instance.emit(event, ...args);\n        };\n      },\n      expose\n    });\n  } else {}\n}\nfunction getExposeProxy(instance) {\n  if (instance.exposed) {\n    return instance.exposeProxy || (instance.exposeProxy = new Proxy((0, reactivity_1.proxyRefs)((0, reactivity_1.markRaw)(instance.exposed)), {\n      get(target, key) {\n        if (key in target) {\n          return target[key];\n        } else if (key in publicPropertiesMap) {\n          return publicPropertiesMap[key](instance);\n        }\n      },\n      has(target, key) {\n        return key in target || key in publicPropertiesMap;\n      }\n    }));\n  }\n}\nconst classifyRE = /(?:^|[-_])(\\w)/g;\nconst classify = str => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\nfunction getComponentName(Component) {\n  let includeInferred = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return (0, shared_1.isFunction)(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;\n}\n/* istanbul ignore next */\nfunction formatComponentName(instance, Component) {\n  let isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let name = getComponentName(Component);\n  if (!name && Component.__file) {\n    const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\n    if (match) {\n      name = match[1];\n    }\n  }\n  if (!name && instance && instance.parent) {\n    // try to infer the name based on reverse resolution\n    const inferFromRegistry = registry => {\n      for (const key in registry) {\n        if (registry[key] === Component) {\n          return key;\n        }\n      }\n    };\n    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\n  }\n  return name ? classify(name) : isRoot ? `App` : `Anonymous`;\n}\nfunction isClassComponent(value) {\n  return (0, shared_1.isFunction)(value) && '__vccOpts' in value;\n}\nconst computed = (getterOrOptions, debugOptions) => {\n  // @ts-ignore\n  return (0, reactivity_1.computed)(getterOrOptions, debugOptions, isInSSRComponentSetup);\n};\nexports.computed = computed;\n// dev only\nconst warnRuntimeUsage = method => warn(`${method}() is a compiler-hint helper that is only usable inside ` + `<script setup> of a single file component. Its arguments should be ` + `compiled away and passing it at runtime has no effect.`);\n// implementation\nfunction defineProps() {\n  if (true) {\n    warnRuntimeUsage(`defineProps`);\n  }\n  return null;\n}\nexports.defineProps = defineProps;\n// implementation\nfunction defineEmits() {\n  if (true) {\n    warnRuntimeUsage(`defineEmits`);\n  }\n  return null;\n}\nexports.defineEmits = defineEmits;\n/**\n * Vue `<script setup>` compiler macro for declaring a component's exposed\n * instance properties when it is accessed by a parent component via template\n * refs.\n *\n * `<script setup>` components are closed by default - i.e. variables inside\n * the `<script setup>` scope is not exposed to parent unless explicitly exposed\n * via `defineExpose`.\n *\n * This is only usable inside `<script setup>`, is compiled away in the\n * output and should **not** be actually called at runtime.\n */\nfunction defineExpose(exposed) {\n  if (true) {\n    warnRuntimeUsage(`defineExpose`);\n  }\n}\nexports.defineExpose = defineExpose;\n/**\n * Vue `<script setup>` compiler macro for providing props default values when\n * using type-based `defineProps` declaration.\n *\n * Example usage:\n * ```ts\n * withDefaults(defineProps<{\n *   size?: number\n *   labels?: string[]\n * }>(), {\n *   size: 3,\n *   labels: () => ['default label']\n * })\n * ```\n *\n * This is only usable inside `<script setup>`, is compiled away in the output\n * and should **not** be actually called at runtime.\n */\nfunction withDefaults(props, defaults) {\n  if (true) {\n    warnRuntimeUsage(`withDefaults`);\n  }\n  return null;\n}\nexports.withDefaults = withDefaults;\nfunction useSlots() {\n  return getContext().slots;\n}\nexports.useSlots = useSlots;\nfunction useAttrs() {\n  return getContext().attrs;\n}\nexports.useAttrs = useAttrs;\nfunction getContext() {\n  const i = getCurrentInstance();\n  if ( true && !i) {\n    warn(`useContext() called without active instance.`);\n  }\n  return i.setupContext || (i.setupContext = createSetupContext(i));\n}\n/**\n * Runtime helper for merging default declarations. Imported by compiled code\n * only.\n * @internal\n */\nfunction mergeDefaults(raw, defaults) {\n  const props = (0, shared_1.isArray)(raw) ? raw.reduce((normalized, p) => (normalized[p] = {}, normalized), {}) : raw;\n  for (const key in defaults) {\n    const opt = props[key];\n    if (opt) {\n      if ((0, shared_1.isArray)(opt) || (0, shared_1.isFunction)(opt)) {\n        props[key] = {\n          type: opt,\n          default: defaults[key]\n        };\n      } else {\n        opt.default = defaults[key];\n      }\n    } else if (opt === null) {\n      props[key] = {\n        default: defaults[key]\n      };\n    } else if (true) {\n      warn(`props default key \"${key}\" has no corresponding declaration.`);\n    }\n  }\n  return props;\n}\nexports.mergeDefaults = mergeDefaults;\n/**\n * Used to create a proxy for the rest element when destructuring props with\n * defineProps().\n * @internal\n */\nfunction createPropsRestProxy(props, excludedKeys) {\n  const ret = {};\n  for (const key in props) {\n    if (!excludedKeys.includes(key)) {\n      Object.defineProperty(ret, key, {\n        enumerable: true,\n        get: () => props[key]\n      });\n    }\n  }\n  return ret;\n}\nexports.createPropsRestProxy = createPropsRestProxy;\n/**\n * `<script setup>` helper for persisting the current instance context over\n * async/await flows.\n *\n * `@vue/compiler-sfc` converts the following:\n *\n * ```ts\n * const x = await foo()\n * ```\n *\n * into:\n *\n * ```ts\n * let __temp, __restore\n * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)\n * ```\n * @internal\n */\nfunction withAsyncContext(getAwaitable) {\n  const ctx = getCurrentInstance();\n  if ( true && !ctx) {\n    warn(`withAsyncContext called without active current instance. ` + `This is likely a bug.`);\n  }\n  let awaitable = getAwaitable();\n  unsetCurrentInstance();\n  if ((0, shared_1.isPromise)(awaitable)) {\n    awaitable = awaitable.catch(e => {\n      setCurrentInstance(ctx);\n      throw e;\n    });\n  }\n  return [awaitable, () => setCurrentInstance(ctx)];\n}\nexports.withAsyncContext = withAsyncContext;\n// Actual implementation\nfunction h(type, propsOrChildren, children) {\n  const l = arguments.length;\n  if (l === 2) {\n    if ((0, shared_1.isObject)(propsOrChildren) && !(0, shared_1.isArray)(propsOrChildren)) {\n      // single vnode without props\n      if (isVNode(propsOrChildren)) {\n        return createVNode(type, null, [propsOrChildren]);\n      }\n      // props without children\n      return createVNode(type, propsOrChildren);\n    } else {\n      // omit props\n      return createVNode(type, null, propsOrChildren);\n    }\n  } else {\n    if (l > 3) {\n      children = Array.prototype.slice.call(arguments, 2);\n    } else if (l === 3 && isVNode(children)) {\n      children = [children];\n    }\n    return createVNode(type, propsOrChildren, children);\n  }\n}\nexports.h = h;\nconst ssrContextKey = Symbol( true ? `ssrContext` : 0);\nexports.ssrContextKey = ssrContextKey;\nconst useSSRContext = () => {\n  {\n    const ctx = inject(ssrContextKey);\n    if (!ctx) {\n       true && warn(`Server rendering context not provided. Make sure to only call ` + `useSSRContext() conditionally in the server build.`);\n    }\n    return ctx;\n  }\n};\nexports.useSSRContext = useSSRContext;\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */]);\n}\n\nfunction initCustomFormatter() {\n  /* eslint-disable no-restricted-globals */\n  if ( false || typeof window === 'undefined') {\n    return;\n  }\n  const vueStyle = {\n    style: 'color:#3ba776'\n  };\n  const numberStyle = {\n    style: 'color:#0b1bc9'\n  };\n  const stringStyle = {\n    style: 'color:#b62e24'\n  };\n  const keywordStyle = {\n    style: 'color:#9d288c'\n  };\n  // custom formatter for Chrome\n  // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html\n  const formatter = {\n    header(obj) {\n      // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup\n      if (!(0, shared_1.isObject)(obj)) {\n        return null;\n      }\n      if (obj.__isVue) {\n        return ['div', vueStyle, `VueInstance`];\n      } else if ((0, reactivity_1.isRef)(obj)) {\n        return ['div', {}, ['span', vueStyle, genRefFlag(obj)], '<', formatValue(obj.value), `>`];\n      } else if ((0, reactivity_1.isReactive)(obj)) {\n        return ['div', {}, ['span', vueStyle, isShallow(obj) ? 'ShallowReactive' : 'Reactive'], '<', formatValue(obj), `>${(0, reactivity_1.isReadonly)(obj) ? ` (readonly)` : ``}`];\n      } else if ((0, reactivity_1.isReadonly)(obj)) {\n        return ['div', {}, ['span', vueStyle, isShallow(obj) ? 'ShallowReadonly' : 'Readonly'], '<', formatValue(obj), '>'];\n      }\n      return null;\n    },\n    hasBody(obj) {\n      return obj && obj.__isVue;\n    },\n    body(obj) {\n      if (obj && obj.__isVue) {\n        return ['div', {}, ...formatInstance(obj.$)];\n      }\n    }\n  };\n  function formatInstance(instance) {\n    const blocks = [];\n    if (instance.type.props && instance.props) {\n      blocks.push(createInstanceBlock('props', (0, reactivity_1.toRaw)(instance.props)));\n    }\n    if (instance.setupState !== shared_1.EMPTY_OBJ) {\n      blocks.push(createInstanceBlock('setup', instance.setupState));\n    }\n    if (instance.data !== shared_1.EMPTY_OBJ) {\n      blocks.push(createInstanceBlock('data', (0, reactivity_1.toRaw)(instance.data)));\n    }\n    const computed = extractKeys(instance, 'computed');\n    if (computed) {\n      blocks.push(createInstanceBlock('computed', computed));\n    }\n    const injected = extractKeys(instance, 'inject');\n    if (injected) {\n      blocks.push(createInstanceBlock('injected', injected));\n    }\n    blocks.push(['div', {}, ['span', {\n      style: keywordStyle.style + ';opacity:0.66'\n    }, '$ (internal): '], ['object', {\n      object: instance\n    }]]);\n    return blocks;\n  }\n  function createInstanceBlock(type, target) {\n    target = (0, shared_1.extend)({}, target);\n    if (!Object.keys(target).length) {\n      return ['span', {}];\n    }\n    return ['div', {\n      style: 'line-height:1.25em;margin-bottom:0.6em'\n    }, ['div', {\n      style: 'color:#476582'\n    }, type], ['div', {\n      style: 'padding-left:1.25em'\n    }, ...Object.keys(target).map(key => {\n      return ['div', {}, ['span', keywordStyle, key + ': '], formatValue(target[key], false)];\n    })]];\n  }\n  function formatValue(v) {\n    let asRaw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (typeof v === 'number') {\n      return ['span', numberStyle, v];\n    } else if (typeof v === 'string') {\n      return ['span', stringStyle, JSON.stringify(v)];\n    } else if (typeof v === 'boolean') {\n      return ['span', keywordStyle, v];\n    } else if ((0, shared_1.isObject)(v)) {\n      return ['object', {\n        object: asRaw ? (0, reactivity_1.toRaw)(v) : v\n      }];\n    } else {\n      return ['span', stringStyle, String(v)];\n    }\n  }\n  function extractKeys(instance, type) {\n    const Comp = instance.type;\n    if ((0, shared_1.isFunction)(Comp)) {\n      return;\n    }\n    const extracted = {};\n    for (const key in instance.ctx) {\n      if (isKeyOfType(Comp, key, type)) {\n        extracted[key] = instance.ctx[key];\n      }\n    }\n    return extracted;\n  }\n  function isKeyOfType(Comp, key, type) {\n    const opts = Comp[type];\n    if ((0, shared_1.isArray)(opts) && opts.includes(key) || (0, shared_1.isObject)(opts) && key in opts) {\n      return true;\n    }\n    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\n      return true;\n    }\n    if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {\n      return true;\n    }\n  }\n  function genRefFlag(v) {\n    if (isShallow(v)) {\n      return `ShallowRef`;\n    }\n    if (v.effect) {\n      return `ComputedRef`;\n    }\n    return `Ref`;\n  }\n  if (window.devtoolsFormatters) {\n    window.devtoolsFormatters.push(formatter);\n  } else {\n    window.devtoolsFormatters = [formatter];\n  }\n}\nexports.initCustomFormatter = initCustomFormatter;\nfunction withMemo(memo, render, cache, index) {\n  const cached = cache[index];\n  if (cached && isMemoSame(cached, memo)) {\n    return cached;\n  }\n  const ret = render();\n  // shallow clone\n  ret.memo = memo.slice();\n  return cache[index] = ret;\n}\nexports.withMemo = withMemo;\nfunction isMemoSame(cached, memo) {\n  const prev = cached.memo;\n  if (prev.length != memo.length) {\n    return false;\n  }\n  for (let i = 0; i < prev.length; i++) {\n    if ((0, shared_1.hasChanged)(prev[i], memo[i])) {\n      return false;\n    }\n  }\n  // make sure to let parent block track it when returning cached\n  if (isBlockTreeEnabled > 0 && currentBlock) {\n    currentBlock.push(cached);\n  }\n  return true;\n}\nexports.isMemoSame = isMemoSame;\n// Core API ------------------------------------------------------------------\nconst version = \"3.2.47\";\nexports.version = version;\nconst _ssrUtils = {\n  createComponentInstance,\n  setupComponent,\n  renderComponentRoot,\n  setCurrentRenderingInstance,\n  isVNode,\n  normalizeVNode\n};\n/**\n * SSR utils for \\@vue/server-renderer. Only exposed in ssr-possible builds.\n * @internal\n */\nconst ssrUtils = _ssrUtils;\nexports.ssrUtils = ssrUtils;\n/**\n * @internal only exposed in compat builds\n */\nconst resolveFilter = null;\nexports.resolveFilter = resolveFilter;\n/**\n * @internal only exposed in compat builds.\n */\nconst compatUtils = null;\nexports.compatUtils = compatUtils;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWNvcmUvZGlzdC9ydW50aW1lLWNvcmUuZXNtLWJ1bmRsZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVJBO0FBQUE7QUFTQTtBQUNBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBSEE7QUFBQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVZBO0FBQUE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFIQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFIQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVFBO0FBRUE7QUFRQTtBQUVBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFHQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFJQTtBQUNBO0FBTUE7QUFDQTtBQUVBO0FBTUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFiLy4vbm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1jb3JlL2Rpc3QvcnVudGltZS1jb3JlLmVzbS1idW5kbGVyLmpzPzVjNDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUVsZW1lbnRCbG9jayA9IGV4cG9ydHMuY3JlYXRlQ29tbWVudFZOb2RlID0gZXhwb3J0cy5jcmVhdGVCbG9jayA9IGV4cG9ydHMuY29tcHV0ZWQgPSBleHBvcnRzLmNvbXBhdFV0aWxzID0gZXhwb3J0cy5jbG9uZVZOb2RlID0gZXhwb3J0cy5jYWxsV2l0aEVycm9ySGFuZGxpbmcgPSBleHBvcnRzLmNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nID0gZXhwb3J0cy5hc3NlcnROdW1iZXIgPSBleHBvcnRzLlRleHQgPSBleHBvcnRzLlRlbGVwb3J0ID0gZXhwb3J0cy5TdXNwZW5zZSA9IGV4cG9ydHMuU3RhdGljID0gZXhwb3J0cy5LZWVwQWxpdmUgPSBleHBvcnRzLkZyYWdtZW50ID0gZXhwb3J0cy5Db21tZW50ID0gZXhwb3J0cy5CYXNlVHJhbnNpdGlvbiA9IGV4cG9ydHMudG9IYW5kbGVyS2V5ID0gZXhwb3J0cy50b0Rpc3BsYXlTdHJpbmcgPSBleHBvcnRzLm5vcm1hbGl6ZVN0eWxlID0gZXhwb3J0cy5ub3JtYWxpemVQcm9wcyA9IGV4cG9ydHMubm9ybWFsaXplQ2xhc3MgPSBleHBvcnRzLmNhcGl0YWxpemUgPSBleHBvcnRzLmNhbWVsaXplID0gZXhwb3J0cy51bnJlZiA9IGV4cG9ydHMudHJpZ2dlclJlZiA9IGV4cG9ydHMudG9SZWZzID0gZXhwb3J0cy50b1JlZiA9IGV4cG9ydHMudG9SYXcgPSBleHBvcnRzLnN0b3AgPSBleHBvcnRzLnNoYWxsb3dSZWYgPSBleHBvcnRzLnNoYWxsb3dSZWFkb25seSA9IGV4cG9ydHMuc2hhbGxvd1JlYWN0aXZlID0gZXhwb3J0cy5yZWYgPSBleHBvcnRzLnJlYWRvbmx5ID0gZXhwb3J0cy5yZWFjdGl2ZSA9IGV4cG9ydHMucHJveHlSZWZzID0gZXhwb3J0cy5vblNjb3BlRGlzcG9zZSA9IGV4cG9ydHMubWFya1JhdyA9IGV4cG9ydHMuaXNTaGFsbG93ID0gZXhwb3J0cy5pc1JlZiA9IGV4cG9ydHMuaXNSZWFkb25seSA9IGV4cG9ydHMuaXNSZWFjdGl2ZSA9IGV4cG9ydHMuaXNQcm94eSA9IGV4cG9ydHMuZ2V0Q3VycmVudFNjb3BlID0gZXhwb3J0cy5lZmZlY3RTY29wZSA9IGV4cG9ydHMuZWZmZWN0ID0gZXhwb3J0cy5jdXN0b21SZWYgPSBleHBvcnRzLlJlYWN0aXZlRWZmZWN0ID0gZXhwb3J0cy5FZmZlY3RTY29wZSA9IHZvaWQgMDtcbmV4cG9ydHMucmVzb2x2ZUR5bmFtaWNDb21wb25lbnQgPSBleHBvcnRzLnJlc29sdmVEaXJlY3RpdmUgPSBleHBvcnRzLnJlc29sdmVDb21wb25lbnQgPSBleHBvcnRzLnJlbmRlclNsb3QgPSBleHBvcnRzLnJlbmRlckxpc3QgPSBleHBvcnRzLnJlZ2lzdGVyUnVudGltZUNvbXBpbGVyID0gZXhwb3J0cy5xdWV1ZVBvc3RGbHVzaENiID0gZXhwb3J0cy5wdXNoU2NvcGVJZCA9IGV4cG9ydHMucHJvdmlkZSA9IGV4cG9ydHMucG9wU2NvcGVJZCA9IGV4cG9ydHMub3BlbkJsb2NrID0gZXhwb3J0cy5vblVwZGF0ZWQgPSBleHBvcnRzLm9uVW5tb3VudGVkID0gZXhwb3J0cy5vblNlcnZlclByZWZldGNoID0gZXhwb3J0cy5vblJlbmRlclRyaWdnZXJlZCA9IGV4cG9ydHMub25SZW5kZXJUcmFja2VkID0gZXhwb3J0cy5vbk1vdW50ZWQgPSBleHBvcnRzLm9uRXJyb3JDYXB0dXJlZCA9IGV4cG9ydHMub25EZWFjdGl2YXRlZCA9IGV4cG9ydHMub25CZWZvcmVVcGRhdGUgPSBleHBvcnRzLm9uQmVmb3JlVW5tb3VudCA9IGV4cG9ydHMub25CZWZvcmVNb3VudCA9IGV4cG9ydHMub25BY3RpdmF0ZWQgPSBleHBvcnRzLm5leHRUaWNrID0gZXhwb3J0cy5tZXJnZVByb3BzID0gZXhwb3J0cy5tZXJnZURlZmF1bHRzID0gZXhwb3J0cy5pc1ZOb2RlID0gZXhwb3J0cy5pc1J1bnRpbWVPbmx5ID0gZXhwb3J0cy5pc01lbW9TYW1lID0gZXhwb3J0cy5pbmplY3QgPSBleHBvcnRzLmluaXRDdXN0b21Gb3JtYXR0ZXIgPSBleHBvcnRzLmhhbmRsZUVycm9yID0gZXhwb3J0cy5oID0gZXhwb3J0cy5ndWFyZFJlYWN0aXZlUHJvcHMgPSBleHBvcnRzLmdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiA9IGV4cG9ydHMuZ2V0Q3VycmVudEluc3RhbmNlID0gZXhwb3J0cy5kZXZ0b29scyA9IGV4cG9ydHMuZGVmaW5lUHJvcHMgPSBleHBvcnRzLmRlZmluZUV4cG9zZSA9IGV4cG9ydHMuZGVmaW5lRW1pdHMgPSBleHBvcnRzLmRlZmluZUNvbXBvbmVudCA9IGV4cG9ydHMuZGVmaW5lQXN5bmNDb21wb25lbnQgPSBleHBvcnRzLmNyZWF0ZVZOb2RlID0gZXhwb3J0cy5jcmVhdGVUZXh0Vk5vZGUgPSBleHBvcnRzLmNyZWF0ZVN0YXRpY1ZOb2RlID0gZXhwb3J0cy5jcmVhdGVTbG90cyA9IGV4cG9ydHMuY3JlYXRlUmVuZGVyZXIgPSBleHBvcnRzLmNyZWF0ZVByb3BzUmVzdFByb3h5ID0gZXhwb3J0cy5jcmVhdGVIeWRyYXRpb25SZW5kZXJlciA9IGV4cG9ydHMuY3JlYXRlRWxlbWVudFZOb2RlID0gdm9pZCAwO1xuZXhwb3J0cy53aXRoU2NvcGVJZCA9IGV4cG9ydHMud2l0aE1lbW8gPSBleHBvcnRzLndpdGhEaXJlY3RpdmVzID0gZXhwb3J0cy53aXRoRGVmYXVsdHMgPSBleHBvcnRzLndpdGhDdHggPSBleHBvcnRzLndpdGhBc3luY0NvbnRleHQgPSBleHBvcnRzLndhdGNoU3luY0VmZmVjdCA9IGV4cG9ydHMud2F0Y2hQb3N0RWZmZWN0ID0gZXhwb3J0cy53YXRjaEVmZmVjdCA9IGV4cG9ydHMud2F0Y2ggPSBleHBvcnRzLndhcm4gPSBleHBvcnRzLnZlcnNpb24gPSBleHBvcnRzLnVzZVRyYW5zaXRpb25TdGF0ZSA9IGV4cG9ydHMudXNlU2xvdHMgPSBleHBvcnRzLnVzZVNTUkNvbnRleHQgPSBleHBvcnRzLnVzZUF0dHJzID0gZXhwb3J0cy50cmFuc2Zvcm1WTm9kZUFyZ3MgPSBleHBvcnRzLnRvSGFuZGxlcnMgPSBleHBvcnRzLnNzclV0aWxzID0gZXhwb3J0cy5zc3JDb250ZXh0S2V5ID0gZXhwb3J0cy5zZXRUcmFuc2l0aW9uSG9va3MgPSBleHBvcnRzLnNldERldnRvb2xzSG9vayA9IGV4cG9ydHMuc2V0QmxvY2tUcmFja2luZyA9IGV4cG9ydHMucmVzb2x2ZVRyYW5zaXRpb25Ib29rcyA9IGV4cG9ydHMucmVzb2x2ZUZpbHRlciA9IHZvaWQgMDtcbmNvbnN0IHJlYWN0aXZpdHlfMSA9IHJlcXVpcmUoXCJAdnVlL3JlYWN0aXZpdHlcIik7XG52YXIgcmVhY3Rpdml0eV8yID0gcmVxdWlyZShcIkB2dWUvcmVhY3Rpdml0eVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVmZmVjdFNjb3BlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdGl2aXR5XzIuRWZmZWN0U2NvcGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZWFjdGl2ZUVmZmVjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3Rpdml0eV8yLlJlYWN0aXZlRWZmZWN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3VzdG9tUmVmXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdGl2aXR5XzIuY3VzdG9tUmVmOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZWZmZWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdGl2aXR5XzIuZWZmZWN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZWZmZWN0U2NvcGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0aXZpdHlfMi5lZmZlY3RTY29wZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEN1cnJlbnRTY29wZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3Rpdml0eV8yLmdldEN1cnJlbnRTY29wZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzUHJveHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0aXZpdHlfMi5pc1Byb3h5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNSZWFjdGl2ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3Rpdml0eV8yLmlzUmVhY3RpdmU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1JlYWRvbmx5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdGl2aXR5XzIuaXNSZWFkb25seTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzUmVmXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdGl2aXR5XzIuaXNSZWY7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1NoYWxsb3dcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0aXZpdHlfMi5pc1NoYWxsb3c7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYXJrUmF3XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdGl2aXR5XzIubWFya1JhdzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm9uU2NvcGVEaXNwb3NlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWFjdGl2aXR5XzIub25TY29wZURpc3Bvc2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwcm94eVJlZnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0aXZpdHlfMi5wcm94eVJlZnM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWFjdGl2ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3Rpdml0eV8yLnJlYWN0aXZlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVhZG9ubHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0aXZpdHlfMi5yZWFkb25seTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3Rpdml0eV8yLnJlZjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNoYWxsb3dSZWFjdGl2ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3Rpdml0eV8yLnNoYWxsb3dSZWFjdGl2ZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNoYWxsb3dSZWFkb25seVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3Rpdml0eV8yLnNoYWxsb3dSZWFkb25seTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNoYWxsb3dSZWZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0aXZpdHlfMi5zaGFsbG93UmVmOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RvcFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3Rpdml0eV8yLnN0b3A7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1Jhd1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3Rpdml0eV8yLnRvUmF3OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9SZWZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0aXZpdHlfMi50b1JlZjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvUmVmc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVhY3Rpdml0eV8yLnRvUmVmczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRyaWdnZXJSZWZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0aXZpdHlfMi50cmlnZ2VyUmVmOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidW5yZWZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlYWN0aXZpdHlfMi51bnJlZjsgfSB9KTtcbmNvbnN0IHNoYXJlZF8xID0gcmVxdWlyZShcIkB2dWUvc2hhcmVkXCIpO1xudmFyIHNoYXJlZF8yID0gcmVxdWlyZShcIkB2dWUvc2hhcmVkXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2FtZWxpemVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYXJlZF8yLmNhbWVsaXplOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2FwaXRhbGl6ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcmVkXzIuY2FwaXRhbGl6ZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5vcm1hbGl6ZUNsYXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFyZWRfMi5ub3JtYWxpemVDbGFzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5vcm1hbGl6ZVByb3BzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFyZWRfMi5ub3JtYWxpemVQcm9wczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5vcm1hbGl6ZVN0eWxlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFyZWRfMi5ub3JtYWxpemVTdHlsZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvRGlzcGxheVN0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcmVkXzIudG9EaXNwbGF5U3RyaW5nOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9IYW5kbGVyS2V5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFyZWRfMi50b0hhbmRsZXJLZXk7IH0gfSk7XG5jb25zdCBzdGFjayA9IFtdO1xuZnVuY3Rpb24gcHVzaFdhcm5pbmdDb250ZXh0KHZub2RlKSB7XG4gICAgc3RhY2sucHVzaCh2bm9kZSk7XG59XG5mdW5jdGlvbiBwb3BXYXJuaW5nQ29udGV4dCgpIHtcbiAgICBzdGFjay5wb3AoKTtcbn1cbmZ1bmN0aW9uIHdhcm4obXNnLCAuLi5hcmdzKSB7XG4gICAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBhdm9pZCBwcm9wcyBmb3JtYXR0aW5nIG9yIHdhcm4gaGFuZGxlciB0cmFja2luZyBkZXBzIHRoYXQgbWlnaHQgYmUgbXV0YXRlZFxuICAgIC8vIGR1cmluZyBwYXRjaCwgbGVhZGluZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgKDAsIHJlYWN0aXZpdHlfMS5wYXVzZVRyYWNraW5nKSgpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gc3RhY2subGVuZ3RoID8gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0uY29tcG9uZW50IDogbnVsbDtcbiAgICBjb25zdCBhcHBXYXJuSGFuZGxlciA9IGluc3RhbmNlICYmIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLndhcm5IYW5kbGVyO1xuICAgIGNvbnN0IHRyYWNlID0gZ2V0Q29tcG9uZW50VHJhY2UoKTtcbiAgICBpZiAoYXBwV2FybkhhbmRsZXIpIHtcbiAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGFwcFdhcm5IYW5kbGVyLCBpbnN0YW5jZSwgMTEgLyogRXJyb3JDb2Rlcy5BUFBfV0FSTl9IQU5ETEVSICovLCBbXG4gICAgICAgICAgICBtc2cgKyBhcmdzLmpvaW4oJycpLFxuICAgICAgICAgICAgaW5zdGFuY2UgJiYgaW5zdGFuY2UucHJveHksXG4gICAgICAgICAgICB0cmFjZVxuICAgICAgICAgICAgICAgIC5tYXAoKHsgdm5vZGUgfSkgPT4gYGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIHZub2RlLnR5cGUpfT5gKVxuICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgIHRyYWNlXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgd2FybkFyZ3MgPSBbYFtWdWUgd2Fybl06ICR7bXNnfWAsIC4uLmFyZ3NdO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHRyYWNlLmxlbmd0aCAmJlxuICAgICAgICAgICAgLy8gYXZvaWQgc3BhbW1pbmcgY29uc29sZSBkdXJpbmcgdGVzdHNcbiAgICAgICAgICAgICFmYWxzZSkge1xuICAgICAgICAgICAgd2FybkFyZ3MucHVzaChgXFxuYCwgLi4uZm9ybWF0VHJhY2UodHJhY2UpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLndhcm4oLi4ud2FybkFyZ3MpO1xuICAgIH1cbiAgICAoMCwgcmVhY3Rpdml0eV8xLnJlc2V0VHJhY2tpbmcpKCk7XG59XG5leHBvcnRzLndhcm4gPSB3YXJuO1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50VHJhY2UoKSB7XG4gICAgbGV0IGN1cnJlbnRWTm9kZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGlmICghY3VycmVudFZOb2RlKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLy8gd2UgY2FuJ3QganVzdCB1c2UgdGhlIHN0YWNrIGJlY2F1c2UgaXQgd2lsbCBiZSBpbmNvbXBsZXRlIGR1cmluZyB1cGRhdGVzXG4gICAgLy8gdGhhdCBkaWQgbm90IHN0YXJ0IGZyb20gdGhlIHJvb3QuIFJlLWNvbnN0cnVjdCB0aGUgcGFyZW50IGNoYWluIHVzaW5nXG4gICAgLy8gaW5zdGFuY2UgcGFyZW50IHBvaW50ZXJzLlxuICAgIGNvbnN0IG5vcm1hbGl6ZWRTdGFjayA9IFtdO1xuICAgIHdoaWxlIChjdXJyZW50Vk5vZGUpIHtcbiAgICAgICAgY29uc3QgbGFzdCA9IG5vcm1hbGl6ZWRTdGFja1swXTtcbiAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC52bm9kZSA9PT0gY3VycmVudFZOb2RlKSB7XG4gICAgICAgICAgICBsYXN0LnJlY3Vyc2VDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9ybWFsaXplZFN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgIHZub2RlOiBjdXJyZW50Vk5vZGUsXG4gICAgICAgICAgICAgICAgcmVjdXJzZUNvdW50OiAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnRJbnN0YW5jZSA9IGN1cnJlbnRWTm9kZS5jb21wb25lbnQgJiYgY3VycmVudFZOb2RlLmNvbXBvbmVudC5wYXJlbnQ7XG4gICAgICAgIGN1cnJlbnRWTm9kZSA9IHBhcmVudEluc3RhbmNlICYmIHBhcmVudEluc3RhbmNlLnZub2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZFN0YWNrO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGZvcm1hdFRyYWNlKHRyYWNlKSB7XG4gICAgY29uc3QgbG9ncyA9IFtdO1xuICAgIHRyYWNlLmZvckVhY2goKGVudHJ5LCBpKSA9PiB7XG4gICAgICAgIGxvZ3MucHVzaCguLi4oaSA9PT0gMCA/IFtdIDogW2BcXG5gXSksIC4uLmZvcm1hdFRyYWNlRW50cnkoZW50cnkpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbG9ncztcbn1cbmZ1bmN0aW9uIGZvcm1hdFRyYWNlRW50cnkoeyB2bm9kZSwgcmVjdXJzZUNvdW50IH0pIHtcbiAgICBjb25zdCBwb3N0Zml4ID0gcmVjdXJzZUNvdW50ID4gMCA/IGAuLi4gKCR7cmVjdXJzZUNvdW50fSByZWN1cnNpdmUgY2FsbHMpYCA6IGBgO1xuICAgIGNvbnN0IGlzUm9vdCA9IHZub2RlLmNvbXBvbmVudCA/IHZub2RlLmNvbXBvbmVudC5wYXJlbnQgPT0gbnVsbCA6IGZhbHNlO1xuICAgIGNvbnN0IG9wZW4gPSBgIGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUodm5vZGUuY29tcG9uZW50LCB2bm9kZS50eXBlLCBpc1Jvb3QpfWA7XG4gICAgY29uc3QgY2xvc2UgPSBgPmAgKyBwb3N0Zml4O1xuICAgIHJldHVybiB2bm9kZS5wcm9wc1xuICAgICAgICA/IFtvcGVuLCAuLi5mb3JtYXRQcm9wcyh2bm9kZS5wcm9wcyksIGNsb3NlXVxuICAgICAgICA6IFtvcGVuICsgY2xvc2VdO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGZvcm1hdFByb3BzKHByb3BzKSB7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAgICBrZXlzLnNsaWNlKDAsIDMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgcmVzLnB1c2goLi4uZm9ybWF0UHJvcChrZXksIHByb3BzW2tleV0pKTtcbiAgICB9KTtcbiAgICBpZiAoa2V5cy5sZW5ndGggPiAzKSB7XG4gICAgICAgIHJlcy5wdXNoKGAgLi4uYCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZm9ybWF0UHJvcChrZXksIHZhbHVlLCByYXcpIHtcbiAgICBpZiAoKDAsIHNoYXJlZF8xLmlzU3RyaW5nKSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PSR7dmFsdWV9YF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT0ke3ZhbHVlfWBdO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgcmVhY3Rpdml0eV8xLmlzUmVmKSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBmb3JtYXRQcm9wKGtleSwgKDAsIHJlYWN0aXZpdHlfMS50b1JhdykodmFsdWUudmFsdWUpLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09UmVmPGAsIHZhbHVlLCBgPmBdO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgc2hhcmVkXzEuaXNGdW5jdGlvbikodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBbYCR7a2V5fT1mbiR7dmFsdWUubmFtZSA/IGA8JHt2YWx1ZS5uYW1lfT5gIDogYGB9YF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9ICgwLCByZWFjdGl2aXR5XzEudG9SYXcpKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09YCwgdmFsdWVdO1xuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGFzc2VydE51bWJlcih2YWwsIHR5cGUpIHtcbiAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHdhcm4oYCR7dHlwZX0gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gYCArIGBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwpfS5gKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgICAgICB3YXJuKGAke3R5cGV9IGlzIE5hTiAtIGAgKyAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0TnVtYmVyID0gYXNzZXJ0TnVtYmVyO1xuY29uc3QgRXJyb3JUeXBlU3RyaW5ncyA9IHtcbiAgICBbXCJzcFwiIC8qIExpZmVjeWNsZUhvb2tzLlNFUlZFUl9QUkVGRVRDSCAqL106ICdzZXJ2ZXJQcmVmZXRjaCBob29rJyxcbiAgICBbXCJiY1wiIC8qIExpZmVjeWNsZUhvb2tzLkJFRk9SRV9DUkVBVEUgKi9dOiAnYmVmb3JlQ3JlYXRlIGhvb2snLFxuICAgIFtcImNcIiAvKiBMaWZlY3ljbGVIb29rcy5DUkVBVEVEICovXTogJ2NyZWF0ZWQgaG9vaycsXG4gICAgW1wiYm1cIiAvKiBMaWZlY3ljbGVIb29rcy5CRUZPUkVfTU9VTlQgKi9dOiAnYmVmb3JlTW91bnQgaG9vaycsXG4gICAgW1wibVwiIC8qIExpZmVjeWNsZUhvb2tzLk1PVU5URUQgKi9dOiAnbW91bnRlZCBob29rJyxcbiAgICBbXCJidVwiIC8qIExpZmVjeWNsZUhvb2tzLkJFRk9SRV9VUERBVEUgKi9dOiAnYmVmb3JlVXBkYXRlIGhvb2snLFxuICAgIFtcInVcIiAvKiBMaWZlY3ljbGVIb29rcy5VUERBVEVEICovXTogJ3VwZGF0ZWQnLFxuICAgIFtcImJ1bVwiIC8qIExpZmVjeWNsZUhvb2tzLkJFRk9SRV9VTk1PVU5UICovXTogJ2JlZm9yZVVubW91bnQgaG9vaycsXG4gICAgW1widW1cIiAvKiBMaWZlY3ljbGVIb29rcy5VTk1PVU5URUQgKi9dOiAndW5tb3VudGVkIGhvb2snLFxuICAgIFtcImFcIiAvKiBMaWZlY3ljbGVIb29rcy5BQ1RJVkFURUQgKi9dOiAnYWN0aXZhdGVkIGhvb2snLFxuICAgIFtcImRhXCIgLyogTGlmZWN5Y2xlSG9va3MuREVBQ1RJVkFURUQgKi9dOiAnZGVhY3RpdmF0ZWQgaG9vaycsXG4gICAgW1wiZWNcIiAvKiBMaWZlY3ljbGVIb29rcy5FUlJPUl9DQVBUVVJFRCAqL106ICdlcnJvckNhcHR1cmVkIGhvb2snLFxuICAgIFtcInJ0Y1wiIC8qIExpZmVjeWNsZUhvb2tzLlJFTkRFUl9UUkFDS0VEICovXTogJ3JlbmRlclRyYWNrZWQgaG9vaycsXG4gICAgW1wicnRnXCIgLyogTGlmZWN5Y2xlSG9va3MuUkVOREVSX1RSSUdHRVJFRCAqL106ICdyZW5kZXJUcmlnZ2VyZWQgaG9vaycsXG4gICAgWzAgLyogRXJyb3JDb2Rlcy5TRVRVUF9GVU5DVElPTiAqL106ICdzZXR1cCBmdW5jdGlvbicsXG4gICAgWzEgLyogRXJyb3JDb2Rlcy5SRU5ERVJfRlVOQ1RJT04gKi9dOiAncmVuZGVyIGZ1bmN0aW9uJyxcbiAgICBbMiAvKiBFcnJvckNvZGVzLldBVENIX0dFVFRFUiAqL106ICd3YXRjaGVyIGdldHRlcicsXG4gICAgWzMgLyogRXJyb3JDb2Rlcy5XQVRDSF9DQUxMQkFDSyAqL106ICd3YXRjaGVyIGNhbGxiYWNrJyxcbiAgICBbNCAvKiBFcnJvckNvZGVzLldBVENIX0NMRUFOVVAgKi9dOiAnd2F0Y2hlciBjbGVhbnVwIGZ1bmN0aW9uJyxcbiAgICBbNSAvKiBFcnJvckNvZGVzLk5BVElWRV9FVkVOVF9IQU5ETEVSICovXTogJ25hdGl2ZSBldmVudCBoYW5kbGVyJyxcbiAgICBbNiAvKiBFcnJvckNvZGVzLkNPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovXTogJ2NvbXBvbmVudCBldmVudCBoYW5kbGVyJyxcbiAgICBbNyAvKiBFcnJvckNvZGVzLlZOT0RFX0hPT0sgKi9dOiAndm5vZGUgaG9vaycsXG4gICAgWzggLyogRXJyb3JDb2Rlcy5ESVJFQ1RJVkVfSE9PSyAqL106ICdkaXJlY3RpdmUgaG9vaycsXG4gICAgWzkgLyogRXJyb3JDb2Rlcy5UUkFOU0lUSU9OX0hPT0sgKi9dOiAndHJhbnNpdGlvbiBob29rJyxcbiAgICBbMTAgLyogRXJyb3JDb2Rlcy5BUFBfRVJST1JfSEFORExFUiAqL106ICdhcHAgZXJyb3JIYW5kbGVyJyxcbiAgICBbMTEgLyogRXJyb3JDb2Rlcy5BUFBfV0FSTl9IQU5ETEVSICovXTogJ2FwcCB3YXJuSGFuZGxlcicsXG4gICAgWzEyIC8qIEVycm9yQ29kZXMuRlVOQ1RJT05fUkVGICovXTogJ3JlZiBmdW5jdGlvbicsXG4gICAgWzEzIC8qIEVycm9yQ29kZXMuQVNZTkNfQ09NUE9ORU5UX0xPQURFUiAqL106ICdhc3luYyBjb21wb25lbnQgbG9hZGVyJyxcbiAgICBbMTQgLyogRXJyb3JDb2Rlcy5TQ0hFRFVMRVIgKi9dOiAnc2NoZWR1bGVyIGZsdXNoLiBUaGlzIGlzIGxpa2VseSBhIFZ1ZSBpbnRlcm5hbHMgYnVnLiAnICtcbiAgICAgICAgJ1BsZWFzZSBvcGVuIGFuIGlzc3VlIGF0IGh0dHBzOi8vbmV3LWlzc3VlLnZ1ZWpzLm9yZy8/cmVwbz12dWVqcy9jb3JlJ1xufTtcbmZ1bmN0aW9uIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcbiAgICBsZXQgcmVzO1xuICAgIHRyeSB7XG4gICAgICAgIHJlcyA9IGFyZ3MgPyBmbiguLi5hcmdzKSA6IGZuKCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLmNhbGxXaXRoRXJyb3JIYW5kbGluZyA9IGNhbGxXaXRoRXJyb3JIYW5kbGluZztcbmZ1bmN0aW9uIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncykge1xuICAgIGlmICgoMCwgc2hhcmVkXzEuaXNGdW5jdGlvbikoZm4pKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpO1xuICAgICAgICBpZiAocmVzICYmICgwLCBzaGFyZWRfMS5pc1Byb21pc2UpKHJlcykpIHtcbiAgICAgICAgICAgIHJlcy5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZXMucHVzaChjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbltpXSwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbmV4cG9ydHMuY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcgPSBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZztcbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUsIHRocm93SW5EZXYgPSB0cnVlKSB7XG4gICAgY29uc3QgY29udGV4dFZOb2RlID0gaW5zdGFuY2UgPyBpbnN0YW5jZS52bm9kZSA6IG51bGw7XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIGxldCBjdXIgPSBpbnN0YW5jZS5wYXJlbnQ7XG4gICAgICAgIC8vIHRoZSBleHBvc2VkIGluc3RhbmNlIGlzIHRoZSByZW5kZXIgcHJveHkgdG8ga2VlcCBpdCBjb25zaXN0ZW50IHdpdGggMi54XG4gICAgICAgIGNvbnN0IGV4cG9zZWRJbnN0YW5jZSA9IGluc3RhbmNlLnByb3h5O1xuICAgICAgICAvLyBpbiBwcm9kdWN0aW9uIHRoZSBob29rIHJlY2VpdmVzIG9ubHkgdGhlIGVycm9yIGNvZGVcbiAgICAgICAgY29uc3QgZXJyb3JJbmZvID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gRXJyb3JUeXBlU3RyaW5nc1t0eXBlXSA6IHR5cGU7XG4gICAgICAgIHdoaWxlIChjdXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQ2FwdHVyZWRIb29rcyA9IGN1ci5lYztcbiAgICAgICAgICAgIGlmIChlcnJvckNhcHR1cmVkSG9va3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVycm9yQ2FwdHVyZWRIb29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzW2ldKGVyciwgZXhwb3NlZEluc3RhbmNlLCBlcnJvckluZm8pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHAtbGV2ZWwgaGFuZGxpbmdcbiAgICAgICAgY29uc3QgYXBwRXJyb3JIYW5kbGVyID0gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcuZXJyb3JIYW5kbGVyO1xuICAgICAgICBpZiAoYXBwRXJyb3JIYW5kbGVyKSB7XG4gICAgICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoYXBwRXJyb3JIYW5kbGVyLCBudWxsLCAxMCAvKiBFcnJvckNvZGVzLkFQUF9FUlJPUl9IQU5ETEVSICovLCBbZXJyLCBleHBvc2VkSW5zdGFuY2UsIGVycm9ySW5mb10pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2KTtcbn1cbmV4cG9ydHMuaGFuZGxlRXJyb3IgPSBoYW5kbGVFcnJvcjtcbmZ1bmN0aW9uIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2ID0gdHJ1ZSkge1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgY29uc3QgaW5mbyA9IEVycm9yVHlwZVN0cmluZ3NbdHlwZV07XG4gICAgICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcbiAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChjb250ZXh0Vk5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHdhcm4oYFVuaGFuZGxlZCBlcnJvciR7aW5mbyA/IGAgZHVyaW5nIGV4ZWN1dGlvbiBvZiAke2luZm99YCA6IGBgfWApO1xuICAgICAgICBpZiAoY29udGV4dFZOb2RlKSB7XG4gICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyYXNoIGluIGRldiBieSBkZWZhdWx0IHNvIGl0J3MgbW9yZSBub3RpY2VhYmxlXG4gICAgICAgIGlmICh0aHJvd0luRGV2KSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHJlY292ZXIgaW4gcHJvZCB0byByZWR1Y2UgdGhlIGltcGFjdCBvbiBlbmQtdXNlclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxufVxubGV0IGlzRmx1c2hpbmcgPSBmYWxzZTtcbmxldCBpc0ZsdXNoUGVuZGluZyA9IGZhbHNlO1xuY29uc3QgcXVldWUgPSBbXTtcbmxldCBmbHVzaEluZGV4ID0gMDtcbmNvbnN0IHBlbmRpbmdQb3N0Rmx1c2hDYnMgPSBbXTtcbmxldCBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBudWxsO1xubGV0IHBvc3RGbHVzaEluZGV4ID0gMDtcbmNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IC8qI19fUFVSRV9fKi8gUHJvbWlzZS5yZXNvbHZlKCk7XG5sZXQgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XG5jb25zdCBSRUNVUlNJT05fTElNSVQgPSAxMDA7XG5mdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgIGNvbnN0IHAgPSBjdXJyZW50Rmx1c2hQcm9taXNlIHx8IHJlc29sdmVkUHJvbWlzZTtcbiAgICByZXR1cm4gZm4gPyBwLnRoZW4odGhpcyA/IGZuLmJpbmQodGhpcykgOiBmbikgOiBwO1xufVxuZXhwb3J0cy5uZXh0VGljayA9IG5leHRUaWNrO1xuLy8gIzI3Njhcbi8vIFVzZSBiaW5hcnktc2VhcmNoIHRvIGZpbmQgYSBzdWl0YWJsZSBwb3NpdGlvbiBpbiB0aGUgcXVldWUsXG4vLyBzbyB0aGF0IHRoZSBxdWV1ZSBtYWludGFpbnMgdGhlIGluY3JlYXNpbmcgb3JkZXIgb2Ygam9iJ3MgaWQsXG4vLyB3aGljaCBjYW4gcHJldmVudCB0aGUgam9iIGZyb20gYmVpbmcgc2tpcHBlZCBhbmQgYWxzbyBjYW4gYXZvaWQgcmVwZWF0ZWQgcGF0Y2hpbmcuXG5mdW5jdGlvbiBmaW5kSW5zZXJ0aW9uSW5kZXgoaWQpIHtcbiAgICAvLyB0aGUgc3RhcnQgaW5kZXggc2hvdWxkIGJlIGBmbHVzaEluZGV4ICsgMWBcbiAgICBsZXQgc3RhcnQgPSBmbHVzaEluZGV4ICsgMTtcbiAgICBsZXQgZW5kID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgICAgICBjb25zdCBtaWRkbGUgPSAoc3RhcnQgKyBlbmQpID4+PiAxO1xuICAgICAgICBjb25zdCBtaWRkbGVKb2JJZCA9IGdldElkKHF1ZXVlW21pZGRsZV0pO1xuICAgICAgICBtaWRkbGVKb2JJZCA8IGlkID8gKHN0YXJ0ID0gbWlkZGxlICsgMSkgOiAoZW5kID0gbWlkZGxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0O1xufVxuZnVuY3Rpb24gcXVldWVKb2Ioam9iKSB7XG4gICAgLy8gdGhlIGRlZHVwZSBzZWFyY2ggdXNlcyB0aGUgc3RhcnRJbmRleCBhcmd1bWVudCBvZiBBcnJheS5pbmNsdWRlcygpXG4gICAgLy8gYnkgZGVmYXVsdCB0aGUgc2VhcmNoIGluZGV4IGluY2x1ZGVzIHRoZSBjdXJyZW50IGpvYiB0aGF0IGlzIGJlaW5nIHJ1blxuICAgIC8vIHNvIGl0IGNhbm5vdCByZWN1cnNpdmVseSB0cmlnZ2VyIGl0c2VsZiBhZ2Fpbi5cbiAgICAvLyBpZiB0aGUgam9iIGlzIGEgd2F0Y2goKSBjYWxsYmFjaywgdGhlIHNlYXJjaCB3aWxsIHN0YXJ0IHdpdGggYSArMSBpbmRleCB0b1xuICAgIC8vIGFsbG93IGl0IHJlY3Vyc2l2ZWx5IHRyaWdnZXIgaXRzZWxmIC0gaXQgaXMgdGhlIHVzZXIncyByZXNwb25zaWJpbGl0eSB0b1xuICAgIC8vIGVuc3VyZSBpdCBkb2Vzbid0IGVuZCB1cCBpbiBhbiBpbmZpbml0ZSBsb29wLlxuICAgIGlmICghcXVldWUubGVuZ3RoIHx8XG4gICAgICAgICFxdWV1ZS5pbmNsdWRlcyhqb2IsIGlzRmx1c2hpbmcgJiYgam9iLmFsbG93UmVjdXJzZSA/IGZsdXNoSW5kZXggKyAxIDogZmx1c2hJbmRleCkpIHtcbiAgICAgICAgaWYgKGpvYi5pZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGpvYik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxdWV1ZS5zcGxpY2UoZmluZEluc2VydGlvbkluZGV4KGpvYi5pZCksIDAsIGpvYik7XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVGbHVzaCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHF1ZXVlRmx1c2goKSB7XG4gICAgaWYgKCFpc0ZsdXNoaW5nICYmICFpc0ZsdXNoUGVuZGluZykge1xuICAgICAgICBpc0ZsdXNoUGVuZGluZyA9IHRydWU7XG4gICAgICAgIGN1cnJlbnRGbHVzaFByb21pc2UgPSByZXNvbHZlZFByb21pc2UudGhlbihmbHVzaEpvYnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGludmFsaWRhdGVKb2Ioam9iKSB7XG4gICAgY29uc3QgaSA9IHF1ZXVlLmluZGV4T2Yoam9iKTtcbiAgICBpZiAoaSA+IGZsdXNoSW5kZXgpIHtcbiAgICAgICAgcXVldWUuc3BsaWNlKGksIDEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHF1ZXVlUG9zdEZsdXNoQ2IoY2IpIHtcbiAgICBpZiAoISgwLCBzaGFyZWRfMS5pc0FycmF5KShjYikpIHtcbiAgICAgICAgaWYgKCFhY3RpdmVQb3N0Rmx1c2hDYnMgfHxcbiAgICAgICAgICAgICFhY3RpdmVQb3N0Rmx1c2hDYnMuaW5jbHVkZXMoY2IsIGNiLmFsbG93UmVjdXJzZSA/IHBvc3RGbHVzaEluZGV4ICsgMSA6IHBvc3RGbHVzaEluZGV4KSkge1xuICAgICAgICAgICAgcGVuZGluZ1Bvc3RGbHVzaENicy5wdXNoKGNiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gaWYgY2IgaXMgYW4gYXJyYXksIGl0IGlzIGEgY29tcG9uZW50IGxpZmVjeWNsZSBob29rIHdoaWNoIGNhbiBvbmx5IGJlXG4gICAgICAgIC8vIHRyaWdnZXJlZCBieSBhIGpvYiwgd2hpY2ggaXMgYWxyZWFkeSBkZWR1cGVkIGluIHRoZSBtYWluIHF1ZXVlLCBzb1xuICAgICAgICAvLyB3ZSBjYW4gc2tpcCBkdXBsaWNhdGUgY2hlY2sgaGVyZSB0byBpbXByb3ZlIHBlcmZcbiAgICAgICAgcGVuZGluZ1Bvc3RGbHVzaENicy5wdXNoKC4uLmNiKTtcbiAgICB9XG4gICAgcXVldWVGbHVzaCgpO1xufVxuZXhwb3J0cy5xdWV1ZVBvc3RGbHVzaENiID0gcXVldWVQb3N0Rmx1c2hDYjtcbmZ1bmN0aW9uIGZsdXNoUHJlRmx1c2hDYnMoc2VlbiwgXG4vLyBpZiBjdXJyZW50bHkgZmx1c2hpbmcsIHNraXAgdGhlIGN1cnJlbnQgam9iIGl0c2VsZlxuaSA9IGlzRmx1c2hpbmcgPyBmbHVzaEluZGV4ICsgMSA6IDApIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZm9yICg7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjYiA9IHF1ZXVlW2ldO1xuICAgICAgICBpZiAoY2IgJiYgY2IucHJlKSB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBjYikpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXVlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBmbHVzaFBvc3RGbHVzaENicyhzZWVuKSB7XG4gICAgaWYgKHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGRlZHVwZWQgPSBbLi4ubmV3IFNldChwZW5kaW5nUG9zdEZsdXNoQ2JzKV07XG4gICAgICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoID0gMDtcbiAgICAgICAgLy8gIzE5NDcgYWxyZWFkeSBoYXMgYWN0aXZlIHF1ZXVlLCBuZXN0ZWQgZmx1c2hQb3N0Rmx1c2hDYnMgY2FsbFxuICAgICAgICBpZiAoYWN0aXZlUG9zdEZsdXNoQ2JzKSB7XG4gICAgICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMucHVzaCguLi5kZWR1cGVkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBkZWR1cGVkO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICBzZWVuID0gc2VlbiB8fCBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzLnNvcnQoKGEsIGIpID0+IGdldElkKGEpIC0gZ2V0SWQoYikpO1xuICAgICAgICBmb3IgKHBvc3RGbHVzaEluZGV4ID0gMDsgcG9zdEZsdXNoSW5kZXggPCBhY3RpdmVQb3N0Rmx1c2hDYnMubGVuZ3RoOyBwb3N0Rmx1c2hJbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGFjdGl2ZVBvc3RGbHVzaENic1twb3N0Rmx1c2hJbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnNbcG9zdEZsdXNoSW5kZXhdKCk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcbiAgICAgICAgcG9zdEZsdXNoSW5kZXggPSAwO1xuICAgIH1cbn1cbmNvbnN0IGdldElkID0gKGpvYikgPT4gam9iLmlkID09IG51bGwgPyBJbmZpbml0eSA6IGpvYi5pZDtcbmNvbnN0IGNvbXBhcmF0b3IgPSAoYSwgYikgPT4ge1xuICAgIGNvbnN0IGRpZmYgPSBnZXRJZChhKSAtIGdldElkKGIpO1xuICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgIGlmIChhLnByZSAmJiAhYi5wcmUpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGlmIChiLnByZSAmJiAhYS5wcmUpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIGRpZmY7XG59O1xuZnVuY3Rpb24gZmx1c2hKb2JzKHNlZW4pIHtcbiAgICBpc0ZsdXNoUGVuZGluZyA9IGZhbHNlO1xuICAgIGlzRmx1c2hpbmcgPSB0cnVlO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgc2VlbiA9IHNlZW4gfHwgbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gICAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkIHNvIGl0cyByZW5kZXIgZWZmZWN0IHdpbGwgaGF2ZSBzbWFsbGVyXG4gICAgLy8gICAgcHJpb3JpdHkgbnVtYmVyKVxuICAgIC8vIDIuIElmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3MgdXBkYXRlLFxuICAgIC8vICAgIGl0cyB1cGRhdGUgY2FuIGJlIHNraXBwZWQuXG4gICAgcXVldWUuc29ydChjb21wYXJhdG9yKTtcbiAgICAvLyBjb25kaXRpb25hbCB1c2FnZSBvZiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZSBtdXN0IGJlIGRldGVybWluZWQgb3V0IG9mXG4gICAgLy8gdHJ5IC4uLiBjYXRjaCBibG9jayBzaW5jZSBSb2xsdXAgYnkgZGVmYXVsdCBkZS1vcHRpbWl6ZXMgdHJlZXNoYWtpbmdcbiAgICAvLyBpbnNpZGUgdHJ5LWNhdGNoLiBUaGlzIGNhbiBsZWF2ZSBhbGwgd2FybmluZyBjb2RlIHVuc2hha2VkLiBBbHRob3VnaFxuICAgIC8vIHRoZXkgd291bGQgZ2V0IGV2ZW50dWFsbHkgc2hha2VuIGJ5IGEgbWluaWZpZXIgbGlrZSB0ZXJzZXIsIHNvbWUgbWluaWZpZXJzXG4gICAgLy8gd291bGQgZmFpbCB0byBkbyB0aGF0IChlLmcuIGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9lc2J1aWxkL2lzc3Vlcy8xNjEwKVxuICAgIGNvbnN0IGNoZWNrID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgICAgID8gKGpvYikgPT4gY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGpvYilcbiAgICAgICAgOiBzaGFyZWRfMS5OT09QO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAoZmx1c2hJbmRleCA9IDA7IGZsdXNoSW5kZXggPCBxdWV1ZS5sZW5ndGg7IGZsdXNoSW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3Qgam9iID0gcXVldWVbZmx1c2hJbmRleF07XG4gICAgICAgICAgICBpZiAoam9iICYmIGpvYi5hY3RpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGVjayhqb2IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgcnVubmluZzpgLCBqb2IuaWQpXG4gICAgICAgICAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGpvYiwgbnVsbCwgMTQgLyogRXJyb3JDb2Rlcy5TQ0hFRFVMRVIgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBmbHVzaEluZGV4ID0gMDtcbiAgICAgICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoc2Vlbik7XG4gICAgICAgIGlzRmx1c2hpbmcgPSBmYWxzZTtcbiAgICAgICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIC8vIHNvbWUgcG9zdEZsdXNoQ2IgcXVldWVkIGpvYnMhXG4gICAgICAgIC8vIGtlZXAgZmx1c2hpbmcgdW50aWwgaXQgZHJhaW5zLlxuICAgICAgICBpZiAocXVldWUubGVuZ3RoIHx8IHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBmbHVzaEpvYnMoc2Vlbik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgZm4pIHtcbiAgICBpZiAoIXNlZW4uaGFzKGZuKSkge1xuICAgICAgICBzZWVuLnNldChmbiwgMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBjb3VudCA9IHNlZW4uZ2V0KGZuKTtcbiAgICAgICAgaWYgKGNvdW50ID4gUkVDVVJTSU9OX0xJTUlUKSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGZuLm93bmVySW5zdGFuY2U7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnROYW1lID0gaW5zdGFuY2UgJiYgZ2V0Q29tcG9uZW50TmFtZShpbnN0YW5jZS50eXBlKTtcbiAgICAgICAgICAgIHdhcm4oYE1heGltdW0gcmVjdXJzaXZlIHVwZGF0ZXMgZXhjZWVkZWQke2NvbXBvbmVudE5hbWUgPyBgIGluIGNvbXBvbmVudCA8JHtjb21wb25lbnROYW1lfT5gIDogYGB9LiBgICtcbiAgICAgICAgICAgICAgICBgVGhpcyBtZWFucyB5b3UgaGF2ZSBhIHJlYWN0aXZlIGVmZmVjdCB0aGF0IGlzIG11dGF0aW5nIGl0cyBvd24gYCArXG4gICAgICAgICAgICAgICAgYGRlcGVuZGVuY2llcyBhbmQgdGh1cyByZWN1cnNpdmVseSB0cmlnZ2VyaW5nIGl0c2VsZi4gUG9zc2libGUgc291cmNlcyBgICtcbiAgICAgICAgICAgICAgICBgaW5jbHVkZSBjb21wb25lbnQgdGVtcGxhdGUsIHJlbmRlciBmdW5jdGlvbiwgdXBkYXRlZCBob29rIG9yIGAgK1xuICAgICAgICAgICAgICAgIGB3YXRjaGVyIHNvdXJjZSBmdW5jdGlvbi5gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2Vlbi5zZXQoZm4sIGNvdW50ICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cbmxldCBpc0htclVwZGF0aW5nID0gZmFsc2U7XG5jb25zdCBobXJEaXJ0eUNvbXBvbmVudHMgPSBuZXcgU2V0KCk7XG4vLyBFeHBvc2UgdGhlIEhNUiBydW50aW1lIG9uIHRoZSBnbG9iYWwgb2JqZWN0XG4vLyBUaGlzIG1ha2VzIGl0IGVudGlyZWx5IHRyZWUtc2hha2FibGUgd2l0aG91dCBwb2xsdXRpbmcgdGhlIGV4cG9ydHMgYW5kIG1ha2VzXG4vLyBpdCBlYXNpZXIgdG8gYmUgdXNlZCBpbiB0b29saW5ncyBsaWtlIHZ1ZS1sb2FkZXJcbi8vIE5vdGU6IGZvciBhIGNvbXBvbmVudCB0byBiZSBlbGlnaWJsZSBmb3IgSE1SIGl0IGFsc28gbmVlZHMgdGhlIF9faG1ySWQgb3B0aW9uXG4vLyB0byBiZSBzZXQgc28gdGhhdCBpdHMgaW5zdGFuY2VzIGNhbiBiZSByZWdpc3RlcmVkIC8gcmVtb3ZlZC5cbmlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAoMCwgc2hhcmVkXzEuZ2V0R2xvYmFsVGhpcykoKS5fX1ZVRV9ITVJfUlVOVElNRV9fID0ge1xuICAgICAgICBjcmVhdGVSZWNvcmQ6IHRyeVdyYXAoY3JlYXRlUmVjb3JkKSxcbiAgICAgICAgcmVyZW5kZXI6IHRyeVdyYXAocmVyZW5kZXIpLFxuICAgICAgICByZWxvYWQ6IHRyeVdyYXAocmVsb2FkKVxuICAgIH07XG59XG5jb25zdCBtYXAgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiByZWdpc3RlckhNUihpbnN0YW5jZSkge1xuICAgIGNvbnN0IGlkID0gaW5zdGFuY2UudHlwZS5fX2htcklkO1xuICAgIGxldCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgICBpZiAoIXJlY29yZCkge1xuICAgICAgICBjcmVhdGVSZWNvcmQoaWQsIGluc3RhbmNlLnR5cGUpO1xuICAgICAgICByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgICB9XG4gICAgcmVjb3JkLmluc3RhbmNlcy5hZGQoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gdW5yZWdpc3RlckhNUihpbnN0YW5jZSkge1xuICAgIG1hcC5nZXQoaW5zdGFuY2UudHlwZS5fX2htcklkKS5pbnN0YW5jZXMuZGVsZXRlKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlY29yZChpZCwgaW5pdGlhbERlZikge1xuICAgIGlmIChtYXAuaGFzKGlkKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1hcC5zZXQoaWQsIHtcbiAgICAgICAgaW5pdGlhbERlZjogbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5pdGlhbERlZiksXG4gICAgICAgIGluc3RhbmNlczogbmV3IFNldCgpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDbGFzc0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICByZXR1cm4gaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpID8gY29tcG9uZW50Ll9fdmNjT3B0cyA6IGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIHJlcmVuZGVyKGlkLCBuZXdSZW5kZXIpIHtcbiAgICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgICBpZiAoIXJlY29yZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHVwZGF0ZSBpbml0aWFsIHJlY29yZCAoZm9yIG5vdC15ZXQtcmVuZGVyZWQgY29tcG9uZW50KVxuICAgIHJlY29yZC5pbml0aWFsRGVmLnJlbmRlciA9IG5ld1JlbmRlcjtcbiAgICBbLi4ucmVjb3JkLmluc3RhbmNlc10uZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICAgIGlmIChuZXdSZW5kZXIpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnJlbmRlciA9IG5ld1JlbmRlcjtcbiAgICAgICAgICAgIG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpLnJlbmRlciA9IG5ld1JlbmRlcjtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5yZW5kZXJDYWNoZSA9IFtdO1xuICAgICAgICAvLyB0aGlzIGZsYWcgZm9yY2VzIGNoaWxkIGNvbXBvbmVudHMgd2l0aCBzbG90IGNvbnRlbnQgdG8gdXBkYXRlXG4gICAgICAgIGlzSG1yVXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcmVsb2FkKGlkLCBuZXdDb21wKSB7XG4gICAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XG4gICAgaWYgKCFyZWNvcmQpXG4gICAgICAgIHJldHVybjtcbiAgICBuZXdDb21wID0gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQobmV3Q29tcCk7XG4gICAgLy8gdXBkYXRlIGluaXRpYWwgZGVmIChmb3Igbm90LXlldC1yZW5kZXJlZCBjb21wb25lbnRzKVxuICAgIHVwZGF0ZUNvbXBvbmVudERlZihyZWNvcmQuaW5pdGlhbERlZiwgbmV3Q29tcCk7XG4gICAgLy8gY3JlYXRlIGEgc25hcHNob3Qgd2hpY2ggYXZvaWRzIHRoZSBzZXQgYmVpbmcgbXV0YXRlZCBkdXJpbmcgdXBkYXRlc1xuICAgIGNvbnN0IGluc3RhbmNlcyA9IFsuLi5yZWNvcmQuaW5zdGFuY2VzXTtcbiAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcykge1xuICAgICAgICBjb25zdCBvbGRDb21wID0gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSk7XG4gICAgICAgIGlmICghaG1yRGlydHlDb21wb25lbnRzLmhhcyhvbGRDb21wKSkge1xuICAgICAgICAgICAgLy8gMS4gVXBkYXRlIGV4aXN0aW5nIGNvbXAgZGVmaW5pdGlvbiB0byBtYXRjaCBuZXcgb25lXG4gICAgICAgICAgICBpZiAob2xkQ29tcCAhPT0gcmVjb3JkLmluaXRpYWxEZWYpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVDb21wb25lbnREZWYob2xkQ29tcCwgbmV3Q29tcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAyLiBtYXJrIGRlZmluaXRpb24gZGlydHkuIFRoaXMgZm9yY2VzIHRoZSByZW5kZXJlciB0byByZXBsYWNlIHRoZVxuICAgICAgICAgICAgLy8gY29tcG9uZW50IG9uIHBhdGNoLlxuICAgICAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmFkZChvbGRDb21wKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLiBpbnZhbGlkYXRlIG9wdGlvbnMgcmVzb2x1dGlvbiBjYWNoZVxuICAgICAgICBpbnN0YW5jZS5hcHBDb250ZXh0Lm9wdGlvbnNDYWNoZS5kZWxldGUoaW5zdGFuY2UudHlwZSk7XG4gICAgICAgIC8vIDQuIGFjdHVhbGx5IHVwZGF0ZVxuICAgICAgICBpZiAoaW5zdGFuY2UuY2VSZWxvYWQpIHtcbiAgICAgICAgICAgIC8vIGN1c3RvbSBlbGVtZW50XG4gICAgICAgICAgICBobXJEaXJ0eUNvbXBvbmVudHMuYWRkKG9sZENvbXApO1xuICAgICAgICAgICAgaW5zdGFuY2UuY2VSZWxvYWQobmV3Q29tcC5zdHlsZXMpO1xuICAgICAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmRlbGV0ZShvbGRDb21wKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnN0YW5jZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIDQuIEZvcmNlIHRoZSBwYXJlbnQgaW5zdGFuY2UgdG8gcmUtcmVuZGVyLiBUaGlzIHdpbGwgY2F1c2UgYWxsIHVwZGF0ZWRcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudHMgdG8gYmUgdW5tb3VudGVkIGFuZCByZS1tb3VudGVkLiBRdWV1ZSB0aGUgdXBkYXRlIHNvIHRoYXQgd2VcbiAgICAgICAgICAgIC8vIGRvbid0IGVuZCB1cCBmb3JjaW5nIHRoZSBzYW1lIHBhcmVudCB0byByZS1yZW5kZXIgbXVsdGlwbGUgdGltZXMuXG4gICAgICAgICAgICBxdWV1ZUpvYihpbnN0YW5jZS5wYXJlbnQudXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCkge1xuICAgICAgICAgICAgLy8gcm9vdCBpbnN0YW5jZSBtb3VudGVkIHZpYSBjcmVhdGVBcHAoKSBoYXMgYSByZWxvYWQgbWV0aG9kXG4gICAgICAgICAgICBpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyByb290IGluc3RhbmNlIGluc2lkZSB0cmVlIGNyZWF0ZWQgdmlhIHJhdyByZW5kZXIoKS4gRm9yY2UgcmVsb2FkLlxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbSE1SXSBSb290IG9yIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UgbW9kaWZpZWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIDUuIG1ha2Ugc3VyZSB0byBjbGVhbnVwIGRpcnR5IGhtciBjb21wb25lbnRzIGFmdGVyIHVwZGF0ZVxuICAgIHF1ZXVlUG9zdEZsdXNoQ2IoKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcykge1xuICAgICAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmRlbGV0ZShub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbnN0YW5jZS50eXBlKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudERlZihvbGRDb21wLCBuZXdDb21wKSB7XG4gICAgKDAsIHNoYXJlZF8xLmV4dGVuZCkob2xkQ29tcCwgbmV3Q29tcCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2xkQ29tcCkge1xuICAgICAgICBpZiAoa2V5ICE9PSAnX19maWxlJyAmJiAhKGtleSBpbiBuZXdDb21wKSkge1xuICAgICAgICAgICAgZGVsZXRlIG9sZENvbXBba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRyeVdyYXAoZm4pIHtcbiAgICByZXR1cm4gKGlkLCBhcmcpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbihpZCwgYXJnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW0hNUl0gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIFZ1ZSBjb21wb25lbnQgaG90LXJlbG9hZC4gYCArXG4gICAgICAgICAgICAgICAgYEZ1bGwgcmVsb2FkIHJlcXVpcmVkLmApO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmxldCBkZXZ0b29scztcbmV4cG9ydHMuZGV2dG9vbHMgPSBkZXZ0b29scztcbmxldCBidWZmZXIgPSBbXTtcbmxldCBkZXZ0b29sc05vdEluc3RhbGxlZCA9IGZhbHNlO1xuZnVuY3Rpb24gZW1pdCQxKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICAgIGRldnRvb2xzLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBlbHNlIGlmICghZGV2dG9vbHNOb3RJbnN0YWxsZWQpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goeyBldmVudCwgYXJncyB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXREZXZ0b29sc0hvb2soaG9vaywgdGFyZ2V0KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBleHBvcnRzLmRldnRvb2xzID0gZGV2dG9vbHMgPSBob29rO1xuICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICBkZXZ0b29scy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgYnVmZmVyLmZvckVhY2goKHsgZXZlbnQsIGFyZ3MgfSkgPT4gZGV2dG9vbHMuZW1pdChldmVudCwgLi4uYXJncykpO1xuICAgICAgICBidWZmZXIgPSBbXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXG4gICAgLy8gaGFuZGxlIGxhdGUgZGV2dG9vbHMgaW5qZWN0aW9uIC0gb25seSBkbyB0aGlzIGlmIHdlIGFyZSBpbiBhbiBhY3R1YWxcbiAgICAvLyBicm93c2VyIGVudmlyb25tZW50IHRvIGF2b2lkIHRoZSB0aW1lciBoYW5kbGUgc3RhbGxpbmcgdGVzdCBydW5uZXIgZXhpdFxuICAgIC8vICgjNDgxNSlcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAvLyBzb21lIGVudnMgbW9jayB3aW5kb3cgYnV0IG5vdCBmdWxseVxuICAgICAgICB3aW5kb3cuSFRNTEVsZW1lbnQgJiZcbiAgICAgICAgLy8gYWxzbyBleGNsdWRlIGpzZG9tXG4gICAgICAgICEoKF9iID0gKF9hID0gd2luZG93Lm5hdmlnYXRvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVzZXJBZ2VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKCdqc2RvbScpKSkge1xuICAgICAgICBjb25zdCByZXBsYXkgPSAodGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gPVxuICAgICAgICAgICAgdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gfHwgW10pO1xuICAgICAgICByZXBsYXkucHVzaCgobmV3SG9vaykgPT4ge1xuICAgICAgICAgICAgc2V0RGV2dG9vbHNIb29rKG5ld0hvb2ssIHRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjbGVhciBidWZmZXIgYWZ0ZXIgM3MgLSB0aGUgdXNlciBwcm9iYWJseSBkb2Vzbid0IGhhdmUgZGV2dG9vbHMgaW5zdGFsbGVkXG4gICAgICAgIC8vIGF0IGFsbCwgYW5kIGtlZXBpbmcgdGhlIGJ1ZmZlciB3aWxsIGNhdXNlIG1lbW9yeSBsZWFrcyAoIzQ3MzgpXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkZXZ0b29scykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fID0gbnVsbDtcbiAgICAgICAgICAgICAgICBkZXZ0b29sc05vdEluc3RhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gbm9uLWJyb3dzZXIgZW52LCBhc3N1bWUgbm90IGluc3RhbGxlZFxuICAgICAgICBkZXZ0b29sc05vdEluc3RhbGxlZCA9IHRydWU7XG4gICAgICAgIGJ1ZmZlciA9IFtdO1xuICAgIH1cbn1cbmV4cG9ydHMuc2V0RGV2dG9vbHNIb29rID0gc2V0RGV2dG9vbHNIb29rO1xuZnVuY3Rpb24gZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbikge1xuICAgIGVtaXQkMShcImFwcDppbml0XCIgLyogRGV2dG9vbHNIb29rcy5BUFBfSU5JVCAqLywgYXBwLCB2ZXJzaW9uLCB7XG4gICAgICAgIEZyYWdtZW50LFxuICAgICAgICBUZXh0LFxuICAgICAgICBDb21tZW50LFxuICAgICAgICBTdGF0aWNcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGRldnRvb2xzVW5tb3VudEFwcChhcHApIHtcbiAgICBlbWl0JDEoXCJhcHA6dW5tb3VudFwiIC8qIERldnRvb2xzSG9va3MuQVBQX1VOTU9VTlQgKi8sIGFwcCk7XG59XG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudEFkZGVkID0gLyojX19QVVJFX18qLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXCJjb21wb25lbnQ6YWRkZWRcIiAvKiBEZXZ0b29sc0hvb2tzLkNPTVBPTkVOVF9BRERFRCAqLyk7XG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQgPSBcbi8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OnVwZGF0ZWRcIiAvKiBEZXZ0b29sc0hvb2tzLkNPTVBPTkVOVF9VUERBVEVEICovKTtcbmNvbnN0IF9kZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDpyZW1vdmVkXCIgLyogRGV2dG9vbHNIb29rcy5DT01QT05FTlRfUkVNT1ZFRCAqLyk7XG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQgPSAoY29tcG9uZW50KSA9PiB7XG4gICAgaWYgKGRldnRvb2xzICYmXG4gICAgICAgIHR5cGVvZiBkZXZ0b29scy5jbGVhbnVwQnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgY29tcG9uZW50IGlmIGl0IHdhc24ndCBidWZmZXJlZFxuICAgICAgICAhZGV2dG9vbHMuY2xlYW51cEJ1ZmZlcihjb21wb25lbnQpKSB7XG4gICAgICAgIF9kZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQoY29tcG9uZW50KTtcbiAgICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKGhvb2spIHtcbiAgICByZXR1cm4gKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICBlbWl0JDEoaG9vaywgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLCBjb21wb25lbnQudWlkLCBjb21wb25lbnQucGFyZW50ID8gY29tcG9uZW50LnBhcmVudC51aWQgOiB1bmRlZmluZWQsIGNvbXBvbmVudCk7XG4gICAgfTtcbn1cbmNvbnN0IGRldnRvb2xzUGVyZlN0YXJ0ID0gLyojX19QVVJFX18qLyBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhcInBlcmY6c3RhcnRcIiAvKiBEZXZ0b29sc0hvb2tzLlBFUkZPUk1BTkNFX1NUQVJUICovKTtcbmNvbnN0IGRldnRvb2xzUGVyZkVuZCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soXCJwZXJmOmVuZFwiIC8qIERldnRvb2xzSG9va3MuUEVSRk9STUFOQ0VfRU5EICovKTtcbmZ1bmN0aW9uIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKGhvb2spIHtcbiAgICByZXR1cm4gKGNvbXBvbmVudCwgdHlwZSwgdGltZSkgPT4ge1xuICAgICAgICBlbWl0JDEoaG9vaywgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLCBjb21wb25lbnQudWlkLCBjb21wb25lbnQsIHR5cGUsIHRpbWUpO1xuICAgIH07XG59XG5mdW5jdGlvbiBkZXZ0b29sc0NvbXBvbmVudEVtaXQoY29tcG9uZW50LCBldmVudCwgcGFyYW1zKSB7XG4gICAgZW1pdCQxKFwiY29tcG9uZW50OmVtaXRcIiAvKiBEZXZ0b29sc0hvb2tzLkNPTVBPTkVOVF9FTUlUICovLCBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsIGNvbXBvbmVudCwgZXZlbnQsIHBhcmFtcyk7XG59XG5mdW5jdGlvbiBlbWl0KGluc3RhbmNlLCBldmVudCwgLi4ucmF3QXJncykge1xuICAgIGlmIChpbnN0YW5jZS5pc1VubW91bnRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHMgfHwgc2hhcmVkXzEuRU1QVFlfT0JKO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgY29uc3QgeyBlbWl0c09wdGlvbnMsIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc10gfSA9IGluc3RhbmNlO1xuICAgICAgICBpZiAoZW1pdHNPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIShldmVudCBpbiBlbWl0c09wdGlvbnMpICYmXG4gICAgICAgICAgICAgICAgIShmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BzT3B0aW9ucyB8fCAhKCgwLCBzaGFyZWRfMS50b0hhbmRsZXJLZXkpKGV2ZW50KSBpbiBwcm9wc09wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBlbWl0dGVkIGV2ZW50IFwiJHtldmVudH1cIiBidXQgaXQgaXMgbmVpdGhlciBkZWNsYXJlZCBpbiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGB0aGUgZW1pdHMgb3B0aW9uIG5vciBhcyBhbiBcIiR7KDAsIHNoYXJlZF8xLnRvSGFuZGxlcktleSkoZXZlbnQpfVwiIHByb3AuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gZW1pdHNPcHRpb25zW2V2ZW50XTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIHNoYXJlZF8xLmlzRnVuY3Rpb24pKHZhbGlkYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbGlkYXRvciguLi5yYXdBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBJbnZhbGlkIGV2ZW50IGFyZ3VtZW50czogZXZlbnQgdmFsaWRhdGlvbiBmYWlsZWQgZm9yIGV2ZW50IFwiJHtldmVudH1cIi5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgYXJncyA9IHJhd0FyZ3M7XG4gICAgY29uc3QgaXNNb2RlbExpc3RlbmVyID0gZXZlbnQuc3RhcnRzV2l0aCgndXBkYXRlOicpO1xuICAgIC8vIGZvciB2LW1vZGVsIHVwZGF0ZTp4eHggZXZlbnRzLCBhcHBseSBtb2RpZmllcnMgb24gYXJnc1xuICAgIGNvbnN0IG1vZGVsQXJnID0gaXNNb2RlbExpc3RlbmVyICYmIGV2ZW50LnNsaWNlKDcpO1xuICAgIGlmIChtb2RlbEFyZyAmJiBtb2RlbEFyZyBpbiBwcm9wcykge1xuICAgICAgICBjb25zdCBtb2RpZmllcnNLZXkgPSBgJHttb2RlbEFyZyA9PT0gJ21vZGVsVmFsdWUnID8gJ21vZGVsJyA6IG1vZGVsQXJnfU1vZGlmaWVyc2A7XG4gICAgICAgIGNvbnN0IHsgbnVtYmVyLCB0cmltIH0gPSBwcm9wc1ttb2RpZmllcnNLZXldIHx8IHNoYXJlZF8xLkVNUFRZX09CSjtcbiAgICAgICAgaWYgKHRyaW0pIHtcbiAgICAgICAgICAgIGFyZ3MgPSByYXdBcmdzLm1hcChhID0+ICgoMCwgc2hhcmVkXzEuaXNTdHJpbmcpKGEpID8gYS50cmltKCkgOiBhKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bWJlcikge1xuICAgICAgICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKHNoYXJlZF8xLmxvb3NlVG9OdW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgIGRldnRvb2xzQ29tcG9uZW50RW1pdChpbnN0YW5jZSwgZXZlbnQsIGFyZ3MpO1xuICAgIH1cbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGNvbnN0IGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiBwcm9wc1soMCwgc2hhcmVkXzEudG9IYW5kbGVyS2V5KShsb3dlckNhc2VFdmVudCldKSB7XG4gICAgICAgICAgICB3YXJuKGBFdmVudCBcIiR7bG93ZXJDYXNlRXZlbnR9XCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgYCArXG4gICAgICAgICAgICAgICAgYCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgaW5zdGFuY2UudHlwZSl9IGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcIiR7ZXZlbnR9XCIuIGAgK1xuICAgICAgICAgICAgICAgIGBOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBgICtcbiAgICAgICAgICAgICAgICBgdi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIGAgK1xuICAgICAgICAgICAgICAgIGBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcIiR7KDAsIHNoYXJlZF8xLmh5cGhlbmF0ZSkoZXZlbnQpfVwiIGluc3RlYWQgb2YgXCIke2V2ZW50fVwiLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBoYW5kbGVyTmFtZTtcbiAgICBsZXQgaGFuZGxlciA9IHByb3BzWyhoYW5kbGVyTmFtZSA9ICgwLCBzaGFyZWRfMS50b0hhbmRsZXJLZXkpKGV2ZW50KSldIHx8XG4gICAgICAgIC8vIGFsc28gdHJ5IGNhbWVsQ2FzZSBldmVudCBoYW5kbGVyICgjMjI0OSlcbiAgICAgICAgcHJvcHNbKGhhbmRsZXJOYW1lID0gKDAsIHNoYXJlZF8xLnRvSGFuZGxlcktleSkoKDAsIHNoYXJlZF8xLmNhbWVsaXplKShldmVudCkpKV07XG4gICAgLy8gZm9yIHYtbW9kZWwgdXBkYXRlOnh4eCBldmVudHMsIGFsc28gdHJpZ2dlciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRcbiAgICAvLyBmb3IgcHJvcHMgcGFzc2VkIHZpYSBrZWJhYi1jYXNlXG4gICAgaWYgKCFoYW5kbGVyICYmIGlzTW9kZWxMaXN0ZW5lcikge1xuICAgICAgICBoYW5kbGVyID0gcHJvcHNbKGhhbmRsZXJOYW1lID0gKDAsIHNoYXJlZF8xLnRvSGFuZGxlcktleSkoKDAsIHNoYXJlZF8xLmh5cGhlbmF0ZSkoZXZlbnQpKSldO1xuICAgIH1cbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhoYW5kbGVyLCBpbnN0YW5jZSwgNiAvKiBFcnJvckNvZGVzLkNPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovLCBhcmdzKTtcbiAgICB9XG4gICAgY29uc3Qgb25jZUhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZSArIGBPbmNlYF07XG4gICAgaWYgKG9uY2VIYW5kbGVyKSB7XG4gICAgICAgIGlmICghaW5zdGFuY2UuZW1pdHRlZCkge1xuICAgICAgICAgICAgaW5zdGFuY2UuZW1pdHRlZCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UuZW1pdHRlZFtoYW5kbGVyTmFtZV0gPSB0cnVlO1xuICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhvbmNlSGFuZGxlciwgaW5zdGFuY2UsIDYgLyogRXJyb3JDb2Rlcy5DT01QT05FTlRfRVZFTlRfSEFORExFUiAqLywgYXJncyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplRW1pdHNPcHRpb25zKGNvbXAsIGFwcENvbnRleHQsIGFzTWl4aW4gPSBmYWxzZSkge1xuICAgIGNvbnN0IGNhY2hlID0gYXBwQ29udGV4dC5lbWl0c0NhY2hlO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChjb21wKTtcbiAgICBpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgY29uc3QgcmF3ID0gY29tcC5lbWl0cztcbiAgICBsZXQgbm9ybWFsaXplZCA9IHt9O1xuICAgIC8vIGFwcGx5IG1peGluL2V4dGVuZHMgcHJvcHNcbiAgICBsZXQgaGFzRXh0ZW5kcyA9IGZhbHNlO1xuICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICEoMCwgc2hhcmVkXzEuaXNGdW5jdGlvbikoY29tcCkpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5kRW1pdHMgPSAocmF3KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkRnJvbUV4dGVuZCA9IG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyhyYXcsIGFwcENvbnRleHQsIHRydWUpO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRGcm9tRXh0ZW5kKSB7XG4gICAgICAgICAgICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgKDAsIHNoYXJlZF8xLmV4dGVuZCkobm9ybWFsaXplZCwgbm9ybWFsaXplZEZyb21FeHRlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWFzTWl4aW4gJiYgYXBwQ29udGV4dC5taXhpbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhcHBDb250ZXh0Lm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcC5leHRlbmRzKSB7XG4gICAgICAgICAgICBleHRlbmRFbWl0cyhjb21wLmV4dGVuZHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wLm1peGlucykge1xuICAgICAgICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyYXcgJiYgIWhhc0V4dGVuZHMpIHtcbiAgICAgICAgaWYgKCgwLCBzaGFyZWRfMS5pc09iamVjdCkoY29tcCkpIHtcbiAgICAgICAgICAgIGNhY2hlLnNldChjb21wLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCgwLCBzaGFyZWRfMS5pc0FycmF5KShyYXcpKSB7XG4gICAgICAgIHJhdy5mb3JFYWNoKGtleSA9PiAobm9ybWFsaXplZFtrZXldID0gbnVsbCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgKDAsIHNoYXJlZF8xLmV4dGVuZCkobm9ybWFsaXplZCwgcmF3KTtcbiAgICB9XG4gICAgaWYgKCgwLCBzaGFyZWRfMS5pc09iamVjdCkoY29tcCkpIHtcbiAgICAgICAgY2FjaGUuc2V0KGNvbXAsIG5vcm1hbGl6ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbi8vIENoZWNrIGlmIGFuIGluY29taW5nIHByb3Aga2V5IGlzIGEgZGVjbGFyZWQgZW1pdCBldmVudCBsaXN0ZW5lci5cbi8vIGUuZy4gV2l0aCBgZW1pdHM6IHsgY2xpY2s6IG51bGwgfWAsIHByb3BzIG5hbWVkIGBvbkNsaWNrYCBhbmQgYG9uY2xpY2tgIGFyZVxuLy8gYm90aCBjb25zaWRlcmVkIG1hdGNoZWQgbGlzdGVuZXJzLlxuZnVuY3Rpb24gaXNFbWl0TGlzdGVuZXIob3B0aW9ucywga2V5KSB7XG4gICAgaWYgKCFvcHRpb25zIHx8ICEoMCwgc2hhcmVkXzEuaXNPbikoa2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGtleSA9IGtleS5zbGljZSgyKS5yZXBsYWNlKC9PbmNlJC8sICcnKTtcbiAgICByZXR1cm4gKCgwLCBzaGFyZWRfMS5oYXNPd24pKG9wdGlvbnMsIGtleVswXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDEpKSB8fFxuICAgICAgICAoMCwgc2hhcmVkXzEuaGFzT3duKShvcHRpb25zLCAoMCwgc2hhcmVkXzEuaHlwaGVuYXRlKShrZXkpKSB8fFxuICAgICAgICAoMCwgc2hhcmVkXzEuaGFzT3duKShvcHRpb25zLCBrZXkpKTtcbn1cbi8qKlxuICogbWFyayB0aGUgY3VycmVudCByZW5kZXJpbmcgaW5zdGFuY2UgZm9yIGFzc2V0IHJlc29sdXRpb24gKGUuZy5cbiAqIHJlc29sdmVDb21wb25lbnQsIHJlc29sdmVEaXJlY3RpdmUpIGR1cmluZyByZW5kZXJcbiAqL1xubGV0IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG5sZXQgY3VycmVudFNjb3BlSWQgPSBudWxsO1xuLyoqXG4gKiBOb3RlOiByZW5kZXJpbmcgY2FsbHMgbWF5YmUgbmVzdGVkLiBUaGUgZnVuY3Rpb24gcmV0dXJucyB0aGUgcGFyZW50IHJlbmRlcmluZ1xuICogaW5zdGFuY2UgaWYgcHJlc2VudCwgd2hpY2ggc2hvdWxkIGJlIHJlc3RvcmVkIGFmdGVyIHRoZSByZW5kZXIgaXMgZG9uZTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcHJldiA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpKVxuICogLy8gLi4ucmVuZGVyXG4gKiBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldilcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBwcmV2ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIGN1cnJlbnRTY29wZUlkID0gKGluc3RhbmNlICYmIGluc3RhbmNlLnR5cGUuX19zY29wZUlkKSB8fCBudWxsO1xuICAgIHJldHVybiBwcmV2O1xufVxuLyoqXG4gKiBTZXQgc2NvcGUgaWQgd2hlbiBjcmVhdGluZyBob2lzdGVkIHZub2Rlcy5cbiAqIEBwcml2YXRlIGNvbXBpbGVyIGhlbHBlclxuICovXG5mdW5jdGlvbiBwdXNoU2NvcGVJZChpZCkge1xuICAgIGN1cnJlbnRTY29wZUlkID0gaWQ7XG59XG5leHBvcnRzLnB1c2hTY29wZUlkID0gcHVzaFNjb3BlSWQ7XG4vKipcbiAqIFRlY2huaWNhbGx5IHdlIG5vIGxvbmdlciBuZWVkIHRoaXMgYWZ0ZXIgMy4wLjggYnV0IHdlIG5lZWQgdG8ga2VlcCB0aGUgc2FtZVxuICogQVBJIGZvciBiYWNrd2FyZHMgY29tcGF0IHcvIGNvZGUgZ2VuZXJhdGVkIGJ5IGNvbXBpbGVycy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBvcFNjb3BlSWQoKSB7XG4gICAgY3VycmVudFNjb3BlSWQgPSBudWxsO1xufVxuZXhwb3J0cy5wb3BTY29wZUlkID0gcG9wU2NvcGVJZDtcbi8qKlxuICogT25seSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgd2l0aFNjb3BlSWQgPSAoX2lkKSA9PiB3aXRoQ3R4O1xuZXhwb3J0cy53aXRoU2NvcGVJZCA9IHdpdGhTY29wZUlkO1xuLyoqXG4gKiBXcmFwIGEgc2xvdCBmdW5jdGlvbiB0byBtZW1vaXplIGN1cnJlbnQgcmVuZGVyaW5nIGluc3RhbmNlXG4gKiBAcHJpdmF0ZSBjb21waWxlciBoZWxwZXJcbiAqL1xuZnVuY3Rpb24gd2l0aEN0eChmbiwgY3R4ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLCBpc05vblNjb3BlZFNsb3QgLy8gZmFsc2Ugb25seVxuKSB7XG4gICAgaWYgKCFjdHgpXG4gICAgICAgIHJldHVybiBmbjtcbiAgICAvLyBhbHJlYWR5IG5vcm1hbGl6ZWRcbiAgICBpZiAoZm4uX24pIHtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH1cbiAgICBjb25zdCByZW5kZXJGbldpdGhDb250ZXh0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgLy8gSWYgYSB1c2VyIGNhbGxzIGEgY29tcGlsZWQgc2xvdCBpbnNpZGUgYSB0ZW1wbGF0ZSBleHByZXNzaW9uICgjMTc0NSksIGl0XG4gICAgICAgIC8vIGNhbiBtZXNzIHVwIGJsb2NrIHRyYWNraW5nLCBzbyBieSBkZWZhdWx0IHdlIGRpc2FibGUgYmxvY2sgdHJhY2tpbmcgYW5kXG4gICAgICAgIC8vIGZvcmNlIGJhaWwgb3V0IHdoZW4gaW52b2tpbmcgYSBjb21waWxlZCBzbG90IChpbmRpY2F0ZWQgYnkgdGhlIC5fZCBmbGFnKS5cbiAgICAgICAgLy8gVGhpcyBpc24ndCBuZWNlc3NhcnkgaWYgcmVuZGVyaW5nIGEgY29tcGlsZWQgYDxzbG90PmAsIHNvIHdlIGZsaXAgdGhlXG4gICAgICAgIC8vIC5fZCBmbGFnIG9mZiB3aGVuIGludm9raW5nIHRoZSB3cmFwcGVkIGZuIGluc2lkZSBgcmVuZGVyU2xvdGAuXG4gICAgICAgIGlmIChyZW5kZXJGbldpdGhDb250ZXh0Ll9kKSB7XG4gICAgICAgICAgICBzZXRCbG9ja1RyYWNraW5nKC0xKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2SW5zdGFuY2UgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoY3R4KTtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGZuKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKHByZXZJbnN0YW5jZSk7XG4gICAgICAgICAgICBpZiAocmVuZGVyRm5XaXRoQ29udGV4dC5fZCkge1xuICAgICAgICAgICAgICAgIHNldEJsb2NrVHJhY2tpbmcoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChjdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICAvLyBtYXJrIG5vcm1hbGl6ZWQgdG8gYXZvaWQgZHVwbGljYXRlZCB3cmFwcGluZ1xuICAgIHJlbmRlckZuV2l0aENvbnRleHQuX24gPSB0cnVlO1xuICAgIC8vIG1hcmsgdGhpcyBhcyBjb21waWxlZCBieSBkZWZhdWx0XG4gICAgLy8gdGhpcyBpcyB1c2VkIGluIHZub2RlLnRzIC0+IG5vcm1hbGl6ZUNoaWxkcmVuKCkgdG8gc2V0IHRoZSBzbG90XG4gICAgLy8gcmVuZGVyaW5nIGZsYWcuXG4gICAgcmVuZGVyRm5XaXRoQ29udGV4dC5fYyA9IHRydWU7XG4gICAgLy8gZGlzYWJsZSBibG9jayB0cmFja2luZyBieSBkZWZhdWx0XG4gICAgcmVuZGVyRm5XaXRoQ29udGV4dC5fZCA9IHRydWU7XG4gICAgcmV0dXJuIHJlbmRlckZuV2l0aENvbnRleHQ7XG59XG5leHBvcnRzLndpdGhDdHggPSB3aXRoQ3R4O1xuLyoqXG4gKiBkZXYgb25seSBmbGFnIHRvIHRyYWNrIHdoZXRoZXIgJGF0dHJzIHdhcyB1c2VkIGR1cmluZyByZW5kZXIuXG4gKiBJZiAkYXR0cnMgd2FzIHVzZWQgZHVyaW5nIHJlbmRlciB0aGVuIHRoZSB3YXJuaW5nIGZvciBmYWlsZWQgYXR0cnNcbiAqIGZhbGx0aHJvdWdoIGNhbiBiZSBzdXBwcmVzc2VkLlxuICovXG5sZXQgYWNjZXNzZWRBdHRycyA9IGZhbHNlO1xuZnVuY3Rpb24gbWFya0F0dHJzQWNjZXNzZWQoKSB7XG4gICAgYWNjZXNzZWRBdHRycyA9IHRydWU7XG59XG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKSB7XG4gICAgY29uc3QgeyB0eXBlOiBDb21wb25lbnQsIHZub2RlLCBwcm94eSwgd2l0aFByb3h5LCBwcm9wcywgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXSwgc2xvdHMsIGF0dHJzLCBlbWl0LCByZW5kZXIsIHJlbmRlckNhY2hlLCBkYXRhLCBzZXR1cFN0YXRlLCBjdHgsIGluaGVyaXRBdHRycyB9ID0gaW5zdGFuY2U7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBsZXQgZmFsbHRocm91Z2hBdHRycztcbiAgICBjb25zdCBwcmV2ID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGluc3RhbmNlKTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGFjY2Vzc2VkQXR0cnMgPSBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDQgLyogU2hhcGVGbGFncy5TVEFURUZVTF9DT01QT05FTlQgKi8pIHtcbiAgICAgICAgICAgIC8vIHdpdGhQcm94eSBpcyBhIHByb3h5IHdpdGggYSBkaWZmZXJlbnQgYGhhc2AgdHJhcCBvbmx5IGZvclxuICAgICAgICAgICAgLy8gcnVudGltZS1jb21waWxlZCByZW5kZXIgZnVuY3Rpb25zIHVzaW5nIGB3aXRoYCBibG9jay5cbiAgICAgICAgICAgIGNvbnN0IHByb3h5VG9Vc2UgPSB3aXRoUHJveHkgfHwgcHJveHk7XG4gICAgICAgICAgICByZXN1bHQgPSBub3JtYWxpemVWTm9kZShyZW5kZXIuY2FsbChwcm94eVRvVXNlLCBwcm94eVRvVXNlLCByZW5kZXJDYWNoZSwgcHJvcHMsIHNldHVwU3RhdGUsIGRhdGEsIGN0eCkpO1xuICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IGF0dHJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZnVuY3Rpb25hbFxuICAgICAgICAgICAgY29uc3QgcmVuZGVyID0gQ29tcG9uZW50O1xuICAgICAgICAgICAgLy8gaW4gZGV2LCBtYXJrIGF0dHJzIGFjY2Vzc2VkIGlmIG9wdGlvbmFsIHByb3BzIChhdHRycyA9PT0gcHJvcHMpXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGF0dHJzID09PSBwcm9wcykge1xuICAgICAgICAgICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBub3JtYWxpemVWTm9kZShyZW5kZXIubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgID8gcmVuZGVyKHByb3BzLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgYXR0cnMoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7IGF0dHJzLCBzbG90cywgZW1pdCB9KVxuICAgICAgICAgICAgICAgIDogcmVuZGVyKHByb3BzLCBudWxsIC8qIHdlIGtub3cgaXQgZG9lc24ndCBuZWVkIGl0ICovKSk7XG4gICAgICAgICAgICBmYWxsdGhyb3VnaEF0dHJzID0gQ29tcG9uZW50LnByb3BzXG4gICAgICAgICAgICAgICAgPyBhdHRyc1xuICAgICAgICAgICAgICAgIDogZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoKGF0dHJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGJsb2NrU3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMSAvKiBFcnJvckNvZGVzLlJFTkRFUl9GVU5DVElPTiAqLyk7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xuICAgIH1cbiAgICAvLyBhdHRyIG1lcmdpbmdcbiAgICAvLyBpbiBkZXYgbW9kZSwgY29tbWVudHMgYXJlIHByZXNlcnZlZCwgYW5kIGl0J3MgcG9zc2libGUgZm9yIGEgdGVtcGxhdGVcbiAgICAvLyB0byBoYXZlIGNvbW1lbnRzIGFsb25nIHNpZGUgdGhlIHJvb3QgZWxlbWVudCB3aGljaCBtYWtlcyBpdCBhIGZyYWdtZW50XG4gICAgbGV0IHJvb3QgPSByZXN1bHQ7XG4gICAgbGV0IHNldFJvb3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICByZXN1bHQucGF0Y2hGbGFnID4gMCAmJlxuICAgICAgICByZXN1bHQucGF0Y2hGbGFnICYgMjA0OCAvKiBQYXRjaEZsYWdzLkRFVl9ST09UX0ZSQUdNRU5UICovKSB7XG4gICAgICAgIFtyb290LCBzZXRSb290XSA9IGdldENoaWxkUm9vdChyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAoZmFsbHRocm91Z2hBdHRycyAmJiBpbmhlcml0QXR0cnMgIT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmYWxsdGhyb3VnaEF0dHJzKTtcbiAgICAgICAgY29uc3QgeyBzaGFwZUZsYWcgfSA9IHJvb3Q7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmICgxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqLyB8IDYgLyogU2hhcGVGbGFncy5DT01QT05FTlQgKi8pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzT3B0aW9ucyAmJiBrZXlzLnNvbWUoc2hhcmVkXzEuaXNNb2RlbExpc3RlbmVyKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIHYtbW9kZWwgbGlzdGVuZXIgKG9uVXBkYXRlOnh4eCkgaGFzIGEgY29ycmVzcG9uZGluZyBkZWNsYXJlZFxuICAgICAgICAgICAgICAgICAgICAvLyBwcm9wLCBpdCBpbmRpY2F0ZXMgdGhpcyBjb21wb25lbnQgZXhwZWN0cyB0byBoYW5kbGUgdi1tb2RlbCBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgc2hvdWxkIG5vdCBmYWxsdGhyb3VnaC5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVsYXRlZDogIzE1NDMsICMxNjQzLCAjMTk4OVxuICAgICAgICAgICAgICAgICAgICBmYWxsdGhyb3VnaEF0dHJzID0gZmlsdGVyTW9kZWxMaXN0ZW5lcnMoZmFsbHRocm91Z2hBdHRycywgcHJvcHNPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCwgZmFsbHRocm91Z2hBdHRycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWFjY2Vzc2VkQXR0cnMgJiYgcm9vdC50eXBlICE9PSBDb21tZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRBdHRycyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dHJhQXR0cnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFsbEF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhbGxBdHRyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBzaGFyZWRfMS5pc09uKShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgdi1tb2RlbCBoYW5kbGVycyB3aGVuIHRoZXkgZmFpbCB0byBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgc2hhcmVkXzEuaXNNb2RlbExpc3RlbmVyKShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGBvbmAsIGxvd2VyY2FzZSBmaXJzdCBsZXR0ZXIgdG8gcmVmbGVjdCBldmVudCBjYXNpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2N1cmF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRBdHRycy5wdXNoKGtleVsyXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cnMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleHRyYUF0dHJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBFeHRyYW5lb3VzIG5vbi1wcm9wcyBhdHRyaWJ1dGVzIChgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke2V4dHJhQXR0cnMuam9pbignLCAnKX0pIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRBdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgRXh0cmFuZW91cyBub24tZW1pdHMgZXZlbnQgbGlzdGVuZXJzIChgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke2V2ZW50QXR0cnMuam9pbignLCAnKX0pIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBJZiB0aGUgbGlzdGVuZXIgaXMgaW50ZW5kZWQgdG8gYmUgYSBjb21wb25lbnQgY3VzdG9tIGV2ZW50IGxpc3RlbmVyIG9ubHksIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGRlY2xhcmUgaXQgdXNpbmcgdGhlIFwiZW1pdHNcIiBvcHRpb24uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGluaGVyaXQgZGlyZWN0aXZlc1xuICAgIGlmICh2bm9kZS5kaXJzKSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcbiAgICAgICAgICAgIHdhcm4oYFJ1bnRpbWUgZGlyZWN0aXZlIHVzZWQgb24gY29tcG9uZW50IHdpdGggbm9uLWVsZW1lbnQgcm9vdCBub2RlLiBgICtcbiAgICAgICAgICAgICAgICBgVGhlIGRpcmVjdGl2ZXMgd2lsbCBub3QgZnVuY3Rpb24gYXMgaW50ZW5kZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2xvbmUgYmVmb3JlIG11dGF0aW5nIHNpbmNlIHRoZSByb290IG1heSBiZSBhIGhvaXN0ZWQgdm5vZGVcbiAgICAgICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCk7XG4gICAgICAgIHJvb3QuZGlycyA9IHJvb3QuZGlycyA/IHJvb3QuZGlycy5jb25jYXQodm5vZGUuZGlycykgOiB2bm9kZS5kaXJzO1xuICAgIH1cbiAgICAvLyBpbmhlcml0IHRyYW5zaXRpb24gZGF0YVxuICAgIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcbiAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBpbnNpZGUgPFRyYW5zaXRpb24+IHJlbmRlcnMgbm9uLWVsZW1lbnQgcm9vdCBub2RlIGAgK1xuICAgICAgICAgICAgICAgIGB0aGF0IGNhbm5vdCBiZSBhbmltYXRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByb290LnRyYW5zaXRpb24gPSB2bm9kZS50cmFuc2l0aW9uO1xuICAgIH1cbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNldFJvb3QpIHtcbiAgICAgICAgc2V0Um9vdChyb290KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHJvb3Q7XG4gICAgfVxuICAgIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBkZXYgb25seVxuICogSW4gZGV2IG1vZGUsIHRlbXBsYXRlIHJvb3QgbGV2ZWwgY29tbWVudHMgYXJlIHJlbmRlcmVkLCB3aGljaCB0dXJucyB0aGVcbiAqIHRlbXBsYXRlIGludG8gYSBmcmFnbWVudCByb290LCBidXQgd2UgbmVlZCB0byBsb2NhdGUgdGhlIHNpbmdsZSBlbGVtZW50XG4gKiByb290IGZvciBhdHRycyBhbmQgc2NvcGUgaWQgcHJvY2Vzc2luZy5cbiAqL1xuY29uc3QgZ2V0Q2hpbGRSb290ID0gKHZub2RlKSA9PiB7XG4gICAgY29uc3QgcmF3Q2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBjb25zdCBkeW5hbWljQ2hpbGRyZW4gPSB2bm9kZS5keW5hbWljQ2hpbGRyZW47XG4gICAgY29uc3QgY2hpbGRSb290ID0gZmlsdGVyU2luZ2xlUm9vdChyYXdDaGlsZHJlbik7XG4gICAgaWYgKCFjaGlsZFJvb3QpIHtcbiAgICAgICAgcmV0dXJuIFt2bm9kZSwgdW5kZWZpbmVkXTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSByYXdDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCk7XG4gICAgY29uc3QgZHluYW1pY0luZGV4ID0gZHluYW1pY0NoaWxkcmVuID8gZHluYW1pY0NoaWxkcmVuLmluZGV4T2YoY2hpbGRSb290KSA6IC0xO1xuICAgIGNvbnN0IHNldFJvb3QgPSAodXBkYXRlZFJvb3QpID0+IHtcbiAgICAgICAgcmF3Q2hpbGRyZW5baW5kZXhdID0gdXBkYXRlZFJvb3Q7XG4gICAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChkeW5hbWljSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbltkeW5hbWljSW5kZXhdID0gdXBkYXRlZFJvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1cGRhdGVkUm9vdC5wYXRjaEZsYWcgPiAwKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gWy4uLmR5bmFtaWNDaGlsZHJlbiwgdXBkYXRlZFJvb3RdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gW25vcm1hbGl6ZVZOb2RlKGNoaWxkUm9vdCksIHNldFJvb3RdO1xufTtcbmZ1bmN0aW9uIGZpbHRlclNpbmdsZVJvb3QoY2hpbGRyZW4pIHtcbiAgICBsZXQgc2luZ2xlUm9vdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChpc1ZOb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgLy8gaWdub3JlIHVzZXIgY29tbWVudFxuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IENvbW1lbnQgfHwgY2hpbGQuY2hpbGRyZW4gPT09ICd2LWlmJykge1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVSb290KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyBtb3JlIHRoYW4gMSBub24tY29tbWVudCBjaGlsZCwgcmV0dXJuIG5vd1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaW5nbGVSb290ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaW5nbGVSb290O1xufVxuY29uc3QgZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoID0gKGF0dHJzKSA9PiB7XG4gICAgbGV0IHJlcztcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnIHx8IGtleSA9PT0gJ3N0eWxlJyB8fCAoMCwgc2hhcmVkXzEuaXNPbikoa2V5KSkge1xuICAgICAgICAgICAgKHJlcyB8fCAocmVzID0ge30pKVtrZXldID0gYXR0cnNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGZpbHRlck1vZGVsTGlzdGVuZXJzID0gKGF0dHJzLCBwcm9wcykgPT4ge1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgICAgIGlmICghKDAsIHNoYXJlZF8xLmlzTW9kZWxMaXN0ZW5lcikoa2V5KSB8fCAhKGtleS5zbGljZSg5KSBpbiBwcm9wcykpIHtcbiAgICAgICAgICAgIHJlc1trZXldID0gYXR0cnNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGlzRWxlbWVudFJvb3QgPSAodm5vZGUpID0+IHtcbiAgICByZXR1cm4gKHZub2RlLnNoYXBlRmxhZyAmICg2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UICovIHwgMSAvKiBTaGFwZUZsYWdzLkVMRU1FTlQgKi8pIHx8XG4gICAgICAgIHZub2RlLnR5cGUgPT09IENvbW1lbnQgLy8gcG90ZW50aWFsIHYtaWYgYnJhbmNoIHN3aXRjaFxuICAgICk7XG59O1xuZnVuY3Rpb24gc2hvdWxkVXBkYXRlQ29tcG9uZW50KHByZXZWTm9kZSwgbmV4dFZOb2RlLCBvcHRpbWl6ZWQpIHtcbiAgICBjb25zdCB7IHByb3BzOiBwcmV2UHJvcHMsIGNoaWxkcmVuOiBwcmV2Q2hpbGRyZW4sIGNvbXBvbmVudCB9ID0gcHJldlZOb2RlO1xuICAgIGNvbnN0IHsgcHJvcHM6IG5leHRQcm9wcywgY2hpbGRyZW46IG5leHRDaGlsZHJlbiwgcGF0Y2hGbGFnIH0gPSBuZXh0Vk5vZGU7XG4gICAgY29uc3QgZW1pdHMgPSBjb21wb25lbnQuZW1pdHNPcHRpb25zO1xuICAgIC8vIFBhcmVudCBjb21wb25lbnQncyByZW5kZXIgZnVuY3Rpb24gd2FzIGhvdC11cGRhdGVkLiBTaW5jZSB0aGlzIG1heSBoYXZlXG4gICAgLy8gY2F1c2VkIHRoZSBjaGlsZCBjb21wb25lbnQncyBzbG90cyBjb250ZW50IHRvIGhhdmUgY2hhbmdlZCwgd2UgbmVlZCB0b1xuICAgIC8vIGZvcmNlIHRoZSBjaGlsZCB0byB1cGRhdGUgYXMgd2VsbC5cbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIChwcmV2Q2hpbGRyZW4gfHwgbmV4dENoaWxkcmVuKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBmb3JjZSBjaGlsZCB1cGRhdGUgZm9yIHJ1bnRpbWUgZGlyZWN0aXZlIG9yIHRyYW5zaXRpb24gb24gY29tcG9uZW50IHZub2RlLlxuICAgIGlmIChuZXh0Vk5vZGUuZGlycyB8fCBuZXh0Vk5vZGUudHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdGltaXplZCAmJiBwYXRjaEZsYWcgPj0gMCkge1xuICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTAyNCAvKiBQYXRjaEZsYWdzLkRZTkFNSUNfU0xPVFMgKi8pIHtcbiAgICAgICAgICAgIC8vIHNsb3QgY29udGVudCB0aGF0IHJlZmVyZW5jZXMgdmFsdWVzIHRoYXQgbWlnaHQgaGF2ZSBjaGFuZ2VkLFxuICAgICAgICAgICAgLy8gZS5nLiBpbiBhIHYtZm9yXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTYgLyogUGF0Y2hGbGFncy5GVUxMX1BST1BTICovKSB7XG4gICAgICAgICAgICBpZiAoIXByZXZQcm9wcykge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIW5leHRQcm9wcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByZXNlbmNlIG9mIHRoaXMgZmxhZyBpbmRpY2F0ZXMgcHJvcHMgYXJlIGFsd2F5cyBub24tbnVsbFxuICAgICAgICAgICAgcmV0dXJuIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhdGNoRmxhZyAmIDggLyogUGF0Y2hGbGFncy5QUk9QUyAqLykge1xuICAgICAgICAgICAgY29uc3QgZHluYW1pY1Byb3BzID0gbmV4dFZOb2RlLmR5bmFtaWNQcm9wcztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Byb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZHluYW1pY1Byb3BzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzRW1pdExpc3RlbmVyKGVtaXRzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyBwYXRoIGlzIG9ubHkgdGFrZW4gYnkgbWFudWFsbHkgd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zXG4gICAgICAgIC8vIHNvIHByZXNlbmNlIG9mIGFueSBjaGlsZHJlbiBsZWFkcyB0byBhIGZvcmNlZCB1cGRhdGVcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbiB8fCBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmICghbmV4dENoaWxkcmVuIHx8ICFuZXh0Q2hpbGRyZW4uJHN0YWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2UHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJldlByb3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gISFuZXh0UHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0c09wdGlvbnMpIHtcbiAgICBjb25zdCBuZXh0S2V5cyA9IE9iamVjdC5rZXlzKG5leHRQcm9wcyk7XG4gICAgaWYgKG5leHRLZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMocHJldlByb3BzKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbmV4dEtleXNbaV07XG4gICAgICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiZcbiAgICAgICAgICAgICFpc0VtaXRMaXN0ZW5lcihlbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUhPQ0hvc3RFbCh7IHZub2RlLCBwYXJlbnQgfSwgZWwgLy8gSG9zdE5vZGVcbikge1xuICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnN1YlRyZWUgPT09IHZub2RlKSB7XG4gICAgICAgICh2bm9kZSA9IHBhcmVudC52bm9kZSkuZWwgPSBlbDtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG59XG5jb25zdCBpc1N1c3BlbnNlID0gKHR5cGUpID0+IHR5cGUuX19pc1N1c3BlbnNlO1xuLy8gU3VzcGVuc2UgZXhwb3NlcyBhIGNvbXBvbmVudC1saWtlIEFQSSwgYW5kIGlzIHRyZWF0ZWQgbGlrZSBhIGNvbXBvbmVudFxuLy8gaW4gdGhlIGNvbXBpbGVyLCBidXQgaW50ZXJuYWxseSBpdCdzIGEgc3BlY2lhbCBidWlsdC1pbiB0eXBlIHRoYXQgaG9va3Ncbi8vIGRpcmVjdGx5IGludG8gdGhlIHJlbmRlcmVyLlxuY29uc3QgU3VzcGVuc2VJbXBsID0ge1xuICAgIG5hbWU6ICdTdXNwZW5zZScsXG4gICAgLy8gSW4gb3JkZXIgdG8gbWFrZSBTdXNwZW5zZSB0cmVlLXNoYWthYmxlLCB3ZSBuZWVkIHRvIGF2b2lkIGltcG9ydGluZyBpdFxuICAgIC8vIGRpcmVjdGx5IGluIHRoZSByZW5kZXJlci4gVGhlIHJlbmRlcmVyIGNoZWNrcyBmb3IgdGhlIF9faXNTdXNwZW5zZSBmbGFnXG4gICAgLy8gb24gYSB2bm9kZSdzIHR5cGUgYW5kIGNhbGxzIHRoZSBgcHJvY2Vzc2AgbWV0aG9kLCBwYXNzaW5nIGluIHJlbmRlcmVyXG4gICAgLy8gaW50ZXJuYWxzLlxuICAgIF9faXNTdXNwZW5zZTogdHJ1ZSxcbiAgICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgXG4gICAgLy8gcGxhdGZvcm0tc3BlY2lmaWMgaW1wbCBwYXNzZWQgZnJvbSByZW5kZXJlclxuICAgIHJlbmRlcmVySW50ZXJuYWxzKSB7XG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICAgICAgICBtb3VudFN1c3BlbnNlKG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRjaFN1c3BlbnNlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGh5ZHJhdGU6IGh5ZHJhdGVTdXNwZW5zZSxcbiAgICBjcmVhdGU6IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnksXG4gICAgbm9ybWFsaXplOiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuXG59O1xuLy8gRm9yY2UtY2FzdGVkIHB1YmxpYyB0eXBpbmcgZm9yIGggYW5kIFRTWCBwcm9wcyBpbmZlcmVuY2VcbmNvbnN0IFN1c3BlbnNlID0gKFN1c3BlbnNlSW1wbCk7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5mdW5jdGlvbiB0cmlnZ2VyRXZlbnQodm5vZGUsIG5hbWUpIHtcbiAgICBjb25zdCBldmVudExpc3RlbmVyID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHNbbmFtZV07XG4gICAgaWYgKCgwLCBzaGFyZWRfMS5pc0Z1bmN0aW9uKShldmVudExpc3RlbmVyKSkge1xuICAgICAgICBldmVudExpc3RlbmVyKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpIHtcbiAgICBjb25zdCB7IHA6IHBhdGNoLCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gICAgY29uc3QgaGlkZGVuQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3Qgc3VzcGVuc2UgPSAodm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnRTdXNwZW5zZSwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGhpZGRlbkNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSk7XG4gICAgLy8gc3RhcnQgbW91bnRpbmcgdGhlIGNvbnRlbnQgc3VidHJlZSBpbiBhbiBvZmYtZG9tIGNvbnRhaW5lclxuICAgIHBhdGNoKG51bGwsIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50KSwgaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzKTtcbiAgICAvLyBub3cgY2hlY2sgaWYgd2UgaGF2ZSBlbmNvdW50ZXJlZCBhbnkgYXN5bmMgZGVwc1xuICAgIGlmIChzdXNwZW5zZS5kZXBzID4gMCkge1xuICAgICAgICAvLyBoYXMgYXN5bmNcbiAgICAgICAgLy8gaW52b2tlIEBmYWxsYmFjayBldmVudFxuICAgICAgICB0cmlnZ2VyRXZlbnQodm5vZGUsICdvblBlbmRpbmcnKTtcbiAgICAgICAgdHJpZ2dlckV2ZW50KHZub2RlLCAnb25GYWxsYmFjaycpO1xuICAgICAgICAvLyBtb3VudCB0aGUgZmFsbGJhY2sgdHJlZVxuICAgICAgICBwYXRjaChudWxsLCB2bm9kZS5zc0ZhbGxiYWNrLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgICBpc1NWRywgc2xvdFNjb3BlSWRzKTtcbiAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCB2bm9kZS5zc0ZhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFN1c3BlbnNlIGhhcyBubyBhc3luYyBkZXBzLiBKdXN0IHJlc29sdmUuXG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXRjaFN1c3BlbnNlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7IHA6IHBhdGNoLCB1bTogdW5tb3VudCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSkge1xuICAgIGNvbnN0IHN1c3BlbnNlID0gKG4yLnN1c3BlbnNlID0gbjEuc3VzcGVuc2UpO1xuICAgIHN1c3BlbnNlLnZub2RlID0gbjI7XG4gICAgbjIuZWwgPSBuMS5lbDtcbiAgICBjb25zdCBuZXdCcmFuY2ggPSBuMi5zc0NvbnRlbnQ7XG4gICAgY29uc3QgbmV3RmFsbGJhY2sgPSBuMi5zc0ZhbGxiYWNrO1xuICAgIGNvbnN0IHsgYWN0aXZlQnJhbmNoLCBwZW5kaW5nQnJhbmNoLCBpc0luRmFsbGJhY2ssIGlzSHlkcmF0aW5nIH0gPSBzdXNwZW5zZTtcbiAgICBpZiAocGVuZGluZ0JyYW5jaCkge1xuICAgICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbmV3QnJhbmNoO1xuICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgcGVuZGluZ0JyYW5jaCkpIHtcbiAgICAgICAgICAgIC8vIHNhbWUgcm9vdCB0eXBlIGJ1dCBjb250ZW50IG1heSBoYXZlIGNoYW5nZWQuXG4gICAgICAgICAgICBwYXRjaChwZW5kaW5nQnJhbmNoLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0luRmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0ZhbGxiYWNrLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgICAgICAgICAgIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdGYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0b2dnbGVkIGJlZm9yZSBwZW5kaW5nIHRyZWUgaXMgcmVzb2x2ZWRcbiAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCsrO1xuICAgICAgICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdG9nZ2xlZCBiZWZvcmUgaHlkcmF0aW9uIGlzIGZpbmlzaGVkLCB0aGUgY3VycmVudCBET00gdHJlZSBpc1xuICAgICAgICAgICAgICAgIC8vIG5vIGxvbmdlciB2YWxpZC4gc2V0IGl0IGFzIHRoZSBhY3RpdmUgYnJhbmNoIHNvIGl0IHdpbGwgYmUgdW5tb3VudGVkXG4gICAgICAgICAgICAgICAgLy8gd2hlbiByZXNvbHZlZFxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLmlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoID0gcGVuZGluZ0JyYW5jaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVubW91bnQocGVuZGluZ0JyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgcGVuZGluZyBJRC4gdGhpcyBpcyB1c2VkIHRvIGludmFsaWRhdGUgYXN5bmMgY2FsbGJhY2tzXG4gICAgICAgICAgICAvLyByZXNldCBzdXNwZW5zZSBzdGF0ZVxuICAgICAgICAgICAgc3VzcGVuc2UuZGVwcyA9IDA7XG4gICAgICAgICAgICAvLyBkaXNjYXJkIGVmZmVjdHMgZnJvbSBwZW5kaW5nIGJyYW5jaFxuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgLy8gZGlzY2FyZCBwcmV2aW91cyBjb250YWluZXJcbiAgICAgICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgaWYgKGlzSW5GYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgaW4gZmFsbGJhY2sgc3RhdGVcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3RmFsbGJhY2ssIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjdGl2ZUJyYW5jaCAmJiBpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBhY3RpdmVCcmFuY2gpKSB7XG4gICAgICAgICAgICAgICAgLy8gdG9nZ2xlZCBcImJhY2tcIiB0byBjdXJyZW50IGFjdGl2ZSBicmFuY2hcbiAgICAgICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgcmVzb2x2ZVxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzd2l0Y2hlZCB0byBhIDNyZCBicmFuY2hcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xuICAgICAgICAgICAgLy8gcm9vdCBkaWQgbm90IGNoYW5nZSwganVzdCBub3JtYWwgcGF0Y2hcbiAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3QnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3QnJhbmNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJvb3Qgbm9kZSB0b2dnbGVkXG4gICAgICAgICAgICAvLyBpbnZva2UgQHBlbmRpbmcgZXZlbnRcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChuMiwgJ29uUGVuZGluZycpO1xuICAgICAgICAgICAgLy8gbW91bnQgcGVuZGluZyBicmFuY2ggaW4gb2ZmLWRvbSBjb250YWluZXJcbiAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XG4gICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQrKztcbiAgICAgICAgICAgIHBhdGNoKG51bGwsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGluY29taW5nIGJyYW5jaCBoYXMgbm8gYXN5bmMgZGVwcywgcmVzb2x2ZSBub3cuXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0aW1lb3V0LCBwZW5kaW5nSWQgfSA9IHN1c3BlbnNlO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nSWQgPT09IHBlbmRpbmdJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLmZhbGxiYWNrKG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVvdXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkodm5vZGUsIHBhcmVudCwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGhpZGRlbkNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBpc0h5ZHJhdGluZyA9IGZhbHNlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZmFsc2UgJiYgIWhhc1dhcm5lZCkge1xuICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICAvLyBAdHMtaWdub3JlIGBjb25zb2xlLmluZm9gIGNhbm5vdCBiZSBudWxsIGVycm9yXG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKGA8U3VzcGVuc2U+IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlIGFuZCBpdHMgQVBJIHdpbGwgbGlrZWx5IGNoYW5nZS5gKTtcbiAgICB9XG4gICAgY29uc3QgeyBwOiBwYXRjaCwgbTogbW92ZSwgdW06IHVubW91bnQsIG46IG5leHQsIG86IHsgcGFyZW50Tm9kZSwgcmVtb3ZlIH0gfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xuICAgIGNvbnN0IHRpbWVvdXQgPSB2bm9kZS5wcm9wcyA/ICgwLCBzaGFyZWRfMS50b051bWJlcikodm5vZGUucHJvcHMudGltZW91dCkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICBhc3NlcnROdW1iZXIodGltZW91dCwgYFN1c3BlbnNlIHRpbWVvdXRgKTtcbiAgICB9XG4gICAgY29uc3Qgc3VzcGVuc2UgPSB7XG4gICAgICAgIHZub2RlLFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgaXNTVkcsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgaGlkZGVuQ29udGFpbmVyLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIGRlcHM6IDAsXG4gICAgICAgIHBlbmRpbmdJZDogMCxcbiAgICAgICAgdGltZW91dDogdHlwZW9mIHRpbWVvdXQgPT09ICdudW1iZXInID8gdGltZW91dCA6IC0xLFxuICAgICAgICBhY3RpdmVCcmFuY2g6IG51bGwsXG4gICAgICAgIHBlbmRpbmdCcmFuY2g6IG51bGwsXG4gICAgICAgIGlzSW5GYWxsYmFjazogdHJ1ZSxcbiAgICAgICAgaXNIeWRyYXRpbmcsXG4gICAgICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcbiAgICAgICAgZWZmZWN0czogW10sXG4gICAgICAgIHJlc29sdmUocmVzdW1lID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VtZSAmJiAhc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgd2l0aG91dCBhIHBlbmRpbmcgYnJhbmNoLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuc2UuaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIG9uIGFuIGFscmVhZHkgdW5tb3VudGVkIHN1c3BlbnNlIGJvdW5kYXJ5LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdm5vZGUsIGFjdGl2ZUJyYW5jaCwgcGVuZGluZ0JyYW5jaCwgcGVuZGluZ0lkLCBlZmZlY3RzLCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciB9ID0gc3VzcGVuc2U7XG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5pc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXJlc3VtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5RW50ZXIgPSBhY3RpdmVCcmFuY2ggJiZcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0JyYW5jaC50cmFuc2l0aW9uICYmXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdCcmFuY2gudHJhbnNpdGlvbi5tb2RlID09PSAnb3V0LWluJztcbiAgICAgICAgICAgICAgICBpZiAoZGVsYXlFbnRlcikge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdJZCA9PT0gc3VzcGVuc2UucGVuZGluZ0lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZShwZW5kaW5nQnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgMCAvKiBNb3ZlVHlwZS5FTlRFUiAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgaW5pdGlhbCBhbmNob3Igb24gbW91bnRcbiAgICAgICAgICAgICAgICBsZXQgeyBhbmNob3IgfSA9IHN1c3BlbnNlO1xuICAgICAgICAgICAgICAgIC8vIHVubW91bnQgY3VycmVudCBhY3RpdmUgdHJlZVxuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVCcmFuY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGZhbGxiYWNrIHRyZWUgd2FzIG1vdW50ZWQsIGl0IG1heSBoYXZlIGJlZW4gbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgcGFydCBvZiBhIHBhcmVudCBzdXNwZW5zZS4gZ2V0IHRoZSBsYXRlc3QgYW5jaG9yIGZvciBpbnNlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gbmV4dChhY3RpdmVCcmFuY2gpO1xuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZGVsYXlFbnRlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGNvbnRlbnQgZnJvbSBvZmYtZG9tIGNvbnRhaW5lciB0byBhY3R1YWwgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIDAgLyogTW92ZVR5cGUuRU5URVIgKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgcGVuZGluZ0JyYW5jaCk7XG4gICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbnVsbDtcbiAgICAgICAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gZmx1c2ggYnVmZmVyZWQgZWZmZWN0c1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYSBwZW5kaW5nIHBhcmVudCBzdXNwZW5zZVxuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHN1c3BlbnNlLnBhcmVudDtcbiAgICAgICAgICAgIGxldCBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm91bmQgYSBwZW5kaW5nIHBhcmVudCBzdXNwZW5zZSwgbWVyZ2UgYnVmZmVyZWQgcG9zdCBqb2JzXG4gICAgICAgICAgICAgICAgICAgIC8vIGludG8gdGhhdCBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmVmZmVjdHMucHVzaCguLi5lZmZlY3RzKTtcbiAgICAgICAgICAgICAgICAgICAgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBubyBwZW5kaW5nIHBhcmVudCBzdXNwZW5zZSwgZmx1c2ggYWxsIGpvYnNcbiAgICAgICAgICAgIGlmICghaGFzVW5yZXNvbHZlZEFuY2VzdG9yKSB7XG4gICAgICAgICAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihlZmZlY3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMgPSBbXTtcbiAgICAgICAgICAgIC8vIGludm9rZSBAcmVzb2x2ZSBldmVudFxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KHZub2RlLCAnb25SZXNvbHZlJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZhbGxiYWNrKGZhbGxiYWNrVk5vZGUpIHtcbiAgICAgICAgICAgIGlmICghc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdm5vZGUsIGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGlzU1ZHIH0gPSBzdXNwZW5zZTtcbiAgICAgICAgICAgIC8vIGludm9rZSBAZmFsbGJhY2sgZXZlbnRcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgJ29uRmFsbGJhY2snKTtcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHQoYWN0aXZlQnJhbmNoKTtcbiAgICAgICAgICAgIGNvbnN0IG1vdW50RmFsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdXNwZW5zZS5pc0luRmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBtb3VudCB0aGUgZmFsbGJhY2sgdHJlZVxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIGZhbGxiYWNrVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgICAgICAgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIGZhbGxiYWNrVk5vZGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5RW50ZXIgPSBmYWxsYmFja1ZOb2RlLnRyYW5zaXRpb24gJiYgZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uLm1vZGUgPT09ICdvdXQtaW4nO1xuICAgICAgICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVCcmFuY2gudHJhbnNpdGlvbi5hZnRlckxlYXZlID0gbW91bnRGYWxsYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgICAvLyB1bm1vdW50IGN1cnJlbnQgYWN0aXZlIGJyYW5jaFxuICAgICAgICAgICAgdW5tb3VudChhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gbm8gc3VzcGVuc2Ugc28gdW5tb3VudCBob29rcyBmaXJlIG5vd1xuICAgICAgICAgICAgdHJ1ZSAvLyBzaG91bGRSZW1vdmVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIWRlbGF5RW50ZXIpIHtcbiAgICAgICAgICAgICAgICBtb3VudEZhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vdmUoY29udGFpbmVyLCBhbmNob3IsIHR5cGUpIHtcbiAgICAgICAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCAmJlxuICAgICAgICAgICAgICAgIG1vdmUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgdHlwZSk7XG4gICAgICAgICAgICBzdXNwZW5zZS5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIH0sXG4gICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmIG5leHQoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXJEZXAoaW5zdGFuY2UsIHNldHVwUmVuZGVyRWZmZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBpc0luUGVuZGluZ1N1c3BlbnNlID0gISFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoO1xuICAgICAgICAgICAgaWYgKGlzSW5QZW5kaW5nU3VzcGVuc2UpIHtcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5kZXBzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoeWRyYXRlZEVsID0gaW5zdGFuY2Uudm5vZGUuZWw7XG4gICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIC5hc3luY0RlcC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDAgLyogRXJyb3JDb2Rlcy5TRVRVUF9GVU5DVElPTiAqLyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jU2V0dXBSZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHJldHJ5IHdoZW4gdGhlIHNldHVwKCkgcHJvbWlzZSByZXNvbHZlcy5cbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGhhdmUgYmVlbiB1bm1vdW50ZWQgYmVmb3JlIHJlc29sdmUuXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmlzVW5tb3VudGVkIHx8XG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLmlzVW5tb3VudGVkIHx8XG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCAhPT0gaW5zdGFuY2Uuc3VzcGVuc2VJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJldHJ5IGZyb20gdGhpcyBjb21wb25lbnRcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5hc3luY1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZub2RlIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBhc3luY1NldHVwUmVzdWx0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGh5ZHJhdGVkRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdm5vZGUgbWF5IGhhdmUgYmVlbiByZXBsYWNlZCBpZiBhbiB1cGRhdGUgaGFwcGVuZWQgYmVmb3JlIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBhc3luYyBkZXAgaXMgcmVzb2x2ZWQuXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmVsID0gaHlkcmF0ZWRFbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSAhaHlkcmF0ZWRFbCAmJiBpbnN0YW5jZS5zdWJUcmVlLmVsO1xuICAgICAgICAgICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KGluc3RhbmNlLCB2bm9kZSwgXG4gICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IG1heSBoYXZlIGJlZW4gbW92ZWQgYmVmb3JlIHJlc29sdmUuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBub3QgYSBoeWRyYXRpb24sIGluc3RhbmNlLnN1YlRyZWUgd2lsbCBiZSB0aGUgY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVyLlxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUoaHlkcmF0ZWRFbCB8fCBpbnN0YW5jZS5zdWJUcmVlLmVsKSwgXG4gICAgICAgICAgICAgICAgLy8gYW5jaG9yIHdpbGwgbm90IGJlIHVzZWQgaWYgdGhpcyBpcyBoeWRyYXRpb24sIHNvIG9ubHkgbmVlZCB0b1xuICAgICAgICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBjb21tZW50IHBsYWNlaG9sZGVyIGNhc2UuXG4gICAgICAgICAgICAgICAgaHlkcmF0ZWRFbCA/IG51bGwgOiBuZXh0KGluc3RhbmNlLnN1YlRyZWUpLCBzdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZShwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChpbnN0YW5jZSwgdm5vZGUuZWwpO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb25seSBkZWNyZWFzZSBkZXBzIGNvdW50IGlmIHN1c3BlbnNlIGlzIG5vdCBhbHJlYWR5IHJlc29sdmVkXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5QZW5kaW5nU3VzcGVuc2UgJiYgLS1zdXNwZW5zZS5kZXBzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpIHtcbiAgICAgICAgICAgIHN1c3BlbnNlLmlzVW5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5hY3RpdmVCcmFuY2gpIHtcbiAgICAgICAgICAgICAgICB1bm1vdW50KHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgICAgICAgICB1bm1vdW50KHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHN1c3BlbnNlO1xufVxuZnVuY3Rpb24gaHlkcmF0ZVN1c3BlbnNlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlTm9kZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xuICAgIGNvbnN0IHN1c3BlbnNlID0gKHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50U3VzcGVuc2UsIHBhcmVudENvbXBvbmVudCwgbm9kZS5wYXJlbnROb2RlLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgbnVsbCwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pKTtcbiAgICAvLyB0aGVyZSBhcmUgdHdvIHBvc3NpYmxlIHNjZW5hcmlvcyBmb3Igc2VydmVyLXJlbmRlcmVkIHN1c3BlbnNlOlxuICAgIC8vIC0gc3VjY2Vzczogc3NyIGNvbnRlbnQgc2hvdWxkIGJlIGZ1bGx5IHJlc29sdmVkXG4gICAgLy8gLSBmYWlsdXJlOiBzc3IgY29udGVudCBzaG91bGQgYmUgdGhlIGZhbGxiYWNrIGJyYW5jaC5cbiAgICAvLyBob3dldmVyLCBvbiB0aGUgY2xpZW50IHdlIGRvbid0IHJlYWxseSBrbm93IGlmIGl0IGhhcyBmYWlsZWQgb3Igbm90XG4gICAgLy8gYXR0ZW1wdCB0byBoeWRyYXRlIHRoZSBET00gYXNzdW1pbmcgaXQgaGFzIHN1Y2NlZWRlZCwgYnV0IHdlIHN0aWxsXG4gICAgLy8gbmVlZCB0byBjb25zdHJ1Y3QgYSBzdXNwZW5zZSBib3VuZGFyeSBmaXJzdFxuICAgIGNvbnN0IHJlc3VsdCA9IGh5ZHJhdGVOb2RlKG5vZGUsIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50KSwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgIGlmIChzdXNwZW5zZS5kZXBzID09PSAwKSB7XG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlbih2bm9kZSkge1xuICAgIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XG4gICAgY29uc3QgaXNTbG90Q2hpbGRyZW4gPSBzaGFwZUZsYWcgJiAzMiAvKiBTaGFwZUZsYWdzLlNMT1RTX0NISUxEUkVOICovO1xuICAgIHZub2RlLnNzQ29udGVudCA9IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChpc1Nsb3RDaGlsZHJlbiA/IGNoaWxkcmVuLmRlZmF1bHQgOiBjaGlsZHJlbik7XG4gICAgdm5vZGUuc3NGYWxsYmFjayA9IGlzU2xvdENoaWxkcmVuXG4gICAgICAgID8gbm9ybWFsaXplU3VzcGVuc2VTbG90KGNoaWxkcmVuLmZhbGxiYWNrKVxuICAgICAgICA6IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VTbG90KHMpIHtcbiAgICBsZXQgYmxvY2s7XG4gICAgaWYgKCgwLCBzaGFyZWRfMS5pc0Z1bmN0aW9uKShzKSkge1xuICAgICAgICBjb25zdCB0cmFja0Jsb2NrID0gaXNCbG9ja1RyZWVFbmFibGVkICYmIHMuX2M7XG4gICAgICAgIGlmICh0cmFja0Jsb2NrKSB7XG4gICAgICAgICAgICAvLyBkaXNhYmxlVHJhY2tpbmc6IGZhbHNlXG4gICAgICAgICAgICAvLyBhbGxvdyBibG9jayB0cmFja2luZyBmb3IgY29tcGlsZWQgc2xvdHNcbiAgICAgICAgICAgIC8vIChzZWUgLi9jb21wb25lbnRSZW5kZXJDb250ZXh0LnRzKVxuICAgICAgICAgICAgcy5fZCA9IGZhbHNlO1xuICAgICAgICAgICAgb3BlbkJsb2NrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcyA9IHMoKTtcbiAgICAgICAgaWYgKHRyYWNrQmxvY2spIHtcbiAgICAgICAgICAgIHMuX2QgPSB0cnVlO1xuICAgICAgICAgICAgYmxvY2sgPSBjdXJyZW50QmxvY2s7XG4gICAgICAgICAgICBjbG9zZUJsb2NrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCgwLCBzaGFyZWRfMS5pc0FycmF5KShzKSkge1xuICAgICAgICBjb25zdCBzaW5nbGVDaGlsZCA9IGZpbHRlclNpbmdsZVJvb3Qocyk7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXNpbmdsZUNoaWxkKSB7XG4gICAgICAgICAgICB3YXJuKGA8U3VzcGVuc2U+IHNsb3RzIGV4cGVjdCBhIHNpbmdsZSByb290IG5vZGUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcyA9IHNpbmdsZUNoaWxkO1xuICAgIH1cbiAgICBzID0gbm9ybWFsaXplVk5vZGUocyk7XG4gICAgaWYgKGJsb2NrICYmICFzLmR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgICBzLmR5bmFtaWNDaGlsZHJlbiA9IGJsb2NrLmZpbHRlcihjID0+IGMgIT09IHMpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKGZuLCBzdXNwZW5zZSkge1xuICAgIGlmIChzdXNwZW5zZSAmJiBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgIGlmICgoMCwgc2hhcmVkXzEuaXNBcnJheSkoZm4pKSB7XG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goLi4uZm4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKGZuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcXVldWVQb3N0Rmx1c2hDYihmbik7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBicmFuY2gpIHtcbiAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBicmFuY2g7XG4gICAgY29uc3QgeyB2bm9kZSwgcGFyZW50Q29tcG9uZW50IH0gPSBzdXNwZW5zZTtcbiAgICBjb25zdCBlbCA9ICh2bm9kZS5lbCA9IGJyYW5jaC5lbCk7XG4gICAgLy8gaW4gY2FzZSBzdXNwZW5zZSBpcyB0aGUgcm9vdCBub2RlIG9mIGEgY29tcG9uZW50LFxuICAgIC8vIHJlY3Vyc2l2ZWx5IHVwZGF0ZSB0aGUgSE9DIGVsXG4gICAgaWYgKHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQuc3ViVHJlZSA9PT0gdm5vZGUpIHtcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LnZub2RlLmVsID0gZWw7XG4gICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChwYXJlbnRDb21wb25lbnQsIGVsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwcm92aWRlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICB3YXJuKGBwcm92aWRlKCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzO1xuICAgICAgICAvLyBieSBkZWZhdWx0IGFuIGluc3RhbmNlIGluaGVyaXRzIGl0cyBwYXJlbnQncyBwcm92aWRlcyBvYmplY3RcbiAgICAgICAgLy8gYnV0IHdoZW4gaXQgbmVlZHMgdG8gcHJvdmlkZSB2YWx1ZXMgb2YgaXRzIG93biwgaXQgY3JlYXRlcyBpdHNcbiAgICAgICAgLy8gb3duIHByb3ZpZGVzIG9iamVjdCB1c2luZyBwYXJlbnQgcHJvdmlkZXMgb2JqZWN0IGFzIHByb3RvdHlwZS5cbiAgICAgICAgLy8gdGhpcyB3YXkgaW4gYGluamVjdGAgd2UgY2FuIHNpbXBseSBsb29rIHVwIGluamVjdGlvbnMgZnJvbSBkaXJlY3RcbiAgICAgICAgLy8gcGFyZW50IGFuZCBsZXQgdGhlIHByb3RvdHlwZSBjaGFpbiBkbyB0aGUgd29yay5cbiAgICAgICAgY29uc3QgcGFyZW50UHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucGFyZW50ICYmIGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQucHJvdmlkZXM7XG4gICAgICAgIGlmIChwYXJlbnRQcm92aWRlcyA9PT0gcHJvdmlkZXMpIHtcbiAgICAgICAgICAgIHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRQcm92aWRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVFMgZG9lc24ndCBhbGxvdyBzeW1ib2wgYXMgaW5kZXggdHlwZVxuICAgICAgICBwcm92aWRlc1trZXldID0gdmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5wcm92aWRlID0gcHJvdmlkZTtcbmZ1bmN0aW9uIGluamVjdChrZXksIGRlZmF1bHRWYWx1ZSwgdHJlYXREZWZhdWx0QXNGYWN0b3J5ID0gZmFsc2UpIHtcbiAgICAvLyBmYWxsYmFjayB0byBgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlYCBzbyB0aGF0IHRoaXMgY2FuIGJlIGNhbGxlZCBpblxuICAgIC8vIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIC8vICMyNDAwXG4gICAgICAgIC8vIHRvIHN1cHBvcnQgYGFwcC51c2VgIHBsdWdpbnMsXG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIGFwcENvbnRleHQncyBgcHJvdmlkZXNgIGlmIHRoZSBpbnN0YW5jZSBpcyBhdCByb290XG4gICAgICAgIGNvbnN0IHByb3ZpZGVzID0gaW5zdGFuY2UucGFyZW50ID09IG51bGxcbiAgICAgICAgICAgID8gaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dCAmJiBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0LnByb3ZpZGVzXG4gICAgICAgICAgICA6IGluc3RhbmNlLnBhcmVudC5wcm92aWRlcztcbiAgICAgICAgaWYgKHByb3ZpZGVzICYmIGtleSBpbiBwcm92aWRlcykge1xuICAgICAgICAgICAgLy8gVFMgZG9lc24ndCBhbGxvdyBzeW1ib2wgYXMgaW5kZXggdHlwZVxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgJiYgKDAsIHNoYXJlZF8xLmlzRnVuY3Rpb24pKGRlZmF1bHRWYWx1ZSlcbiAgICAgICAgICAgICAgICA/IGRlZmF1bHRWYWx1ZS5jYWxsKGluc3RhbmNlLnByb3h5KVxuICAgICAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgd2FybihgaW5qZWN0aW9uIFwiJHtTdHJpbmcoa2V5KX1cIiBub3QgZm91bmQuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIHdhcm4oYGluamVjdCgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkgb3IgZnVuY3Rpb25hbCBjb21wb25lbnRzLmApO1xuICAgIH1cbn1cbmV4cG9ydHMuaW5qZWN0ID0gaW5qZWN0O1xuLy8gU2ltcGxlIGVmZmVjdC5cbmZ1bmN0aW9uIHdhdGNoRWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLndhdGNoRWZmZWN0ID0gd2F0Y2hFZmZlY3Q7XG5mdW5jdGlvbiB3YXRjaFBvc3RFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGZsdXNoOiAncG9zdCcgfSkgOiB7IGZsdXNoOiAncG9zdCcgfSk7XG59XG5leHBvcnRzLndhdGNoUG9zdEVmZmVjdCA9IHdhdGNoUG9zdEVmZmVjdDtcbmZ1bmN0aW9uIHdhdGNoU3luY0VmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZG9XYXRjaChlZmZlY3QsIG51bGwsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgZmx1c2g6ICdzeW5jJyB9KSA6IHsgZmx1c2g6ICdzeW5jJyB9KTtcbn1cbmV4cG9ydHMud2F0Y2hTeW5jRWZmZWN0ID0gd2F0Y2hTeW5jRWZmZWN0O1xuLy8gaW5pdGlhbCB2YWx1ZSBmb3Igd2F0Y2hlcnMgdG8gdHJpZ2dlciBvbiB1bmRlZmluZWQgaW5pdGlhbCB2YWx1ZXNcbmNvbnN0IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA9IHt9O1xuLy8gaW1wbGVtZW50YXRpb25cbmZ1bmN0aW9uIHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICEoMCwgc2hhcmVkXzEuaXNGdW5jdGlvbikoY2IpKSB7XG4gICAgICAgIHdhcm4oYFxcYHdhdGNoKGZuLCBvcHRpb25zPylcXGAgc2lnbmF0dXJlIGhhcyBiZWVuIG1vdmVkIHRvIGEgc2VwYXJhdGUgQVBJLiBgICtcbiAgICAgICAgICAgIGBVc2UgXFxgd2F0Y2hFZmZlY3QoZm4sIG9wdGlvbnM/KVxcYCBpbnN0ZWFkLiBcXGB3YXRjaFxcYCBub3cgb25seSBgICtcbiAgICAgICAgICAgIGBzdXBwb3J0cyBcXGB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zPykgc2lnbmF0dXJlLmApO1xuICAgIH1cbiAgICByZXR1cm4gZG9XYXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMud2F0Y2ggPSB3YXRjaDtcbmZ1bmN0aW9uIGRvV2F0Y2goc291cmNlLCBjYiwgeyBpbW1lZGlhdGUsIGRlZXAsIGZsdXNoLCBvblRyYWNrLCBvblRyaWdnZXIgfSA9IHNoYXJlZF8xLkVNUFRZX09CSikge1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWNiKSB7XG4gICAgICAgIGlmIChpbW1lZGlhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2Fybihgd2F0Y2goKSBcImltbWVkaWF0ZVwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSBgICtcbiAgICAgICAgICAgICAgICBgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVlcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3YXJuKGB3YXRjaCgpIFwiZGVlcFwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSBgICtcbiAgICAgICAgICAgICAgICBgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB3YXJuSW52YWxpZFNvdXJjZSA9IChzKSA9PiB7XG4gICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggc291cmNlOiBgLCBzLCBgQSB3YXRjaCBzb3VyY2UgY2FuIG9ubHkgYmUgYSBnZXR0ZXIvZWZmZWN0IGZ1bmN0aW9uLCBhIHJlZiwgYCArXG4gICAgICAgICAgICBgYSByZWFjdGl2ZSBvYmplY3QsIG9yIGFuIGFycmF5IG9mIHRoZXNlIHR5cGVzLmApO1xuICAgIH07XG4gICAgY29uc3QgaW5zdGFuY2UgPSAoMCwgcmVhY3Rpdml0eV8xLmdldEN1cnJlbnRTY29wZSkoKSA9PT0gKGN1cnJlbnRJbnN0YW5jZSA9PT0gbnVsbCB8fCBjdXJyZW50SW5zdGFuY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRJbnN0YW5jZS5zY29wZSkgPyBjdXJyZW50SW5zdGFuY2UgOiBudWxsO1xuICAgIC8vIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlXG4gICAgbGV0IGdldHRlcjtcbiAgICBsZXQgZm9yY2VUcmlnZ2VyID0gZmFsc2U7XG4gICAgbGV0IGlzTXVsdGlTb3VyY2UgPSBmYWxzZTtcbiAgICBpZiAoKDAsIHJlYWN0aXZpdHlfMS5pc1JlZikoc291cmNlKSkge1xuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UudmFsdWU7XG4gICAgICAgIGZvcmNlVHJpZ2dlciA9ICgwLCByZWFjdGl2aXR5XzEuaXNTaGFsbG93KShzb3VyY2UpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgcmVhY3Rpdml0eV8xLmlzUmVhY3RpdmUpKHNvdXJjZSkpIHtcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gc291cmNlO1xuICAgICAgICBkZWVwID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHNoYXJlZF8xLmlzQXJyYXkpKHNvdXJjZSkpIHtcbiAgICAgICAgaXNNdWx0aVNvdXJjZSA9IHRydWU7XG4gICAgICAgIGZvcmNlVHJpZ2dlciA9IHNvdXJjZS5zb21lKHMgPT4gKDAsIHJlYWN0aXZpdHlfMS5pc1JlYWN0aXZlKShzKSB8fCAoMCwgcmVhY3Rpdml0eV8xLmlzU2hhbGxvdykocykpO1xuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UubWFwKHMgPT4ge1xuICAgICAgICAgICAgaWYgKCgwLCByZWFjdGl2aXR5XzEuaXNSZWYpKHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHMudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoMCwgcmVhY3Rpdml0eV8xLmlzUmVhY3RpdmUpKHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYXZlcnNlKHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKDAsIHNoYXJlZF8xLmlzRnVuY3Rpb24pKHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhzLCBpbnN0YW5jZSwgMiAvKiBFcnJvckNvZGVzLldBVENIX0dFVFRFUiAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybkludmFsaWRTb3VyY2Uocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgc2hhcmVkXzEuaXNGdW5jdGlvbikoc291cmNlKSkge1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIC8vIGdldHRlciB3aXRoIGNiXG4gICAgICAgICAgICBnZXR0ZXIgPSAoKSA9PiBjYWxsV2l0aEVycm9ySGFuZGxpbmcoc291cmNlLCBpbnN0YW5jZSwgMiAvKiBFcnJvckNvZGVzLldBVENIX0dFVFRFUiAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBjYiAtPiBzaW1wbGUgZWZmZWN0XG4gICAgICAgICAgICBnZXR0ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLmlzVW5tb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNsZWFudXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoc291cmNlLCBpbnN0YW5jZSwgMyAvKiBFcnJvckNvZGVzLldBVENIX0NBTExCQUNLICovLCBbb25DbGVhbnVwXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZXR0ZXIgPSBzaGFyZWRfMS5OT09QO1xuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybkludmFsaWRTb3VyY2Uoc291cmNlKTtcbiAgICB9XG4gICAgaWYgKGNiICYmIGRlZXApIHtcbiAgICAgICAgY29uc3QgYmFzZUdldHRlciA9IGdldHRlcjtcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gdHJhdmVyc2UoYmFzZUdldHRlcigpKTtcbiAgICB9XG4gICAgbGV0IGNsZWFudXA7XG4gICAgbGV0IG9uQ2xlYW51cCA9IChmbikgPT4ge1xuICAgICAgICBjbGVhbnVwID0gZWZmZWN0Lm9uU3RvcCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIDQgLyogRXJyb3JDb2Rlcy5XQVRDSF9DTEVBTlVQICovKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8vIGluIFNTUiB0aGVyZSBpcyBubyBuZWVkIHRvIHNldHVwIGFuIGFjdHVhbCBlZmZlY3QsIGFuZCBpdCBzaG91bGQgYmUgbm9vcFxuICAgIC8vIHVubGVzcyBpdCdzIGVhZ2VyIG9yIHN5bmMgZmx1c2hcbiAgICBsZXQgc3NyQ2xlYW51cDtcbiAgICBpZiAoaXNJblNTUkNvbXBvbmVudFNldHVwKSB7XG4gICAgICAgIC8vIHdlIHdpbGwgYWxzbyBub3QgY2FsbCB0aGUgaW52YWxpZGF0ZSBjYWxsYmFjayAoKyBydW5uZXIgaXMgbm90IHNldCB1cClcbiAgICAgICAgb25DbGVhbnVwID0gc2hhcmVkXzEuTk9PUDtcbiAgICAgICAgaWYgKCFjYikge1xuICAgICAgICAgICAgZ2V0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhjYiwgaW5zdGFuY2UsIDMgLyogRXJyb3JDb2Rlcy5XQVRDSF9DQUxMQkFDSyAqLywgW1xuICAgICAgICAgICAgICAgIGdldHRlcigpLFxuICAgICAgICAgICAgICAgIGlzTXVsdGlTb3VyY2UgPyBbXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBvbkNsZWFudXBcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbHVzaCA9PT0gJ3N5bmMnKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB1c2VTU1JDb250ZXh0KCk7XG4gICAgICAgICAgICBzc3JDbGVhbnVwID0gY3R4Ll9fd2F0Y2hlckhhbmRsZXMgfHwgKGN0eC5fX3dhdGNoZXJIYW5kbGVzID0gW10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNoYXJlZF8xLk5PT1A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG9sZFZhbHVlID0gaXNNdWx0aVNvdXJjZVxuICAgICAgICA/IG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKS5maWxsKElOSVRJQUxfV0FUQ0hFUl9WQUxVRSlcbiAgICAgICAgOiBJTklUSUFMX1dBVENIRVJfVkFMVUU7XG4gICAgY29uc3Qgam9iID0gKCkgPT4ge1xuICAgICAgICBpZiAoIWVmZmVjdC5hY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIC8vIHdhdGNoKHNvdXJjZSwgY2IpXG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGVmZmVjdC5ydW4oKTtcbiAgICAgICAgICAgIGlmIChkZWVwIHx8XG4gICAgICAgICAgICAgICAgZm9yY2VUcmlnZ2VyIHx8XG4gICAgICAgICAgICAgICAgKGlzTXVsdGlTb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgPyBuZXdWYWx1ZS5zb21lKCh2LCBpKSA9PiAoMCwgc2hhcmVkXzEuaGFzQ2hhbmdlZCkodiwgb2xkVmFsdWVbaV0pKVxuICAgICAgICAgICAgICAgICAgICA6ICgwLCBzaGFyZWRfMS5oYXNDaGFuZ2VkKShuZXdWYWx1ZSwgb2xkVmFsdWUpKSB8fFxuICAgICAgICAgICAgICAgIChmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBjbGVhbnVwIGJlZm9yZSBydW5uaW5nIGNiIGFnYWluXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFudXApIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhjYiwgaW5zdGFuY2UsIDMgLyogRXJyb3JDb2Rlcy5XQVRDSF9DQUxMQkFDSyAqLywgW1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFzcyB1bmRlZmluZWQgYXMgdGhlIG9sZCB2YWx1ZSB3aGVuIGl0J3MgY2hhbmdlZCBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaXNNdWx0aVNvdXJjZSAmJiBvbGRWYWx1ZVswXSA9PT0gSU5JVElBTF9XQVRDSEVSX1ZBTFVFXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xlYW51cFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3YXRjaEVmZmVjdFxuICAgICAgICAgICAgZWZmZWN0LnJ1bigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBpbXBvcnRhbnQ6IG1hcmsgdGhlIGpvYiBhcyBhIHdhdGNoZXIgY2FsbGJhY2sgc28gdGhhdCBzY2hlZHVsZXIga25vd3NcbiAgICAvLyBpdCBpcyBhbGxvd2VkIHRvIHNlbGYtdHJpZ2dlciAoIzE3MjcpXG4gICAgam9iLmFsbG93UmVjdXJzZSA9ICEhY2I7XG4gICAgbGV0IHNjaGVkdWxlcjtcbiAgICBpZiAoZmx1c2ggPT09ICdzeW5jJykge1xuICAgICAgICBzY2hlZHVsZXIgPSBqb2I7IC8vIHRoZSBzY2hlZHVsZXIgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgZGlyZWN0bHlcbiAgICB9XG4gICAgZWxzZSBpZiAoZmx1c2ggPT09ICdwb3N0Jykge1xuICAgICAgICBzY2hlZHVsZXIgPSAoKSA9PiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3Qoam9iLCBpbnN0YW5jZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0OiAncHJlJ1xuICAgICAgICBqb2IucHJlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGluc3RhbmNlKVxuICAgICAgICAgICAgam9iLmlkID0gaW5zdGFuY2UudWlkO1xuICAgICAgICBzY2hlZHVsZXIgPSAoKSA9PiBxdWV1ZUpvYihqb2IpO1xuICAgIH1cbiAgICBjb25zdCBlZmZlY3QgPSBuZXcgcmVhY3Rpdml0eV8xLlJlYWN0aXZlRWZmZWN0KGdldHRlciwgc2NoZWR1bGVyKTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGVmZmVjdC5vblRyYWNrID0gb25UcmFjaztcbiAgICAgICAgZWZmZWN0Lm9uVHJpZ2dlciA9IG9uVHJpZ2dlcjtcbiAgICB9XG4gICAgLy8gaW5pdGlhbCBydW5cbiAgICBpZiAoY2IpIHtcbiAgICAgICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgICAgICAgam9iKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvbGRWYWx1ZSA9IGVmZmVjdC5ydW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChmbHVzaCA9PT0gJ3Bvc3QnKSB7XG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChlZmZlY3QucnVuLmJpbmQoZWZmZWN0KSwgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWZmZWN0LnJ1bigpO1xuICAgIH1cbiAgICBjb25zdCB1bndhdGNoID0gKCkgPT4ge1xuICAgICAgICBlZmZlY3Quc3RvcCgpO1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc2NvcGUpIHtcbiAgICAgICAgICAgICgwLCBzaGFyZWRfMS5yZW1vdmUpKGluc3RhbmNlLnNjb3BlLmVmZmVjdHMsIGVmZmVjdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmIChzc3JDbGVhbnVwKVxuICAgICAgICBzc3JDbGVhbnVwLnB1c2godW53YXRjaCk7XG4gICAgcmV0dXJuIHVud2F0Y2g7XG59XG4vLyB0aGlzLiR3YXRjaFxuZnVuY3Rpb24gaW5zdGFuY2VXYXRjaChzb3VyY2UsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcHVibGljVGhpcyA9IHRoaXMucHJveHk7XG4gICAgY29uc3QgZ2V0dGVyID0gKDAsIHNoYXJlZF8xLmlzU3RyaW5nKShzb3VyY2UpXG4gICAgICAgID8gc291cmNlLmluY2x1ZGVzKCcuJylcbiAgICAgICAgICAgID8gY3JlYXRlUGF0aEdldHRlcihwdWJsaWNUaGlzLCBzb3VyY2UpXG4gICAgICAgICAgICA6ICgpID0+IHB1YmxpY1RoaXNbc291cmNlXVxuICAgICAgICA6IHNvdXJjZS5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpO1xuICAgIGxldCBjYjtcbiAgICBpZiAoKDAsIHNoYXJlZF8xLmlzRnVuY3Rpb24pKHZhbHVlKSkge1xuICAgICAgICBjYiA9IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2IgPSB2YWx1ZS5oYW5kbGVyO1xuICAgICAgICBvcHRpb25zID0gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGN1ciA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICBzZXRDdXJyZW50SW5zdGFuY2UodGhpcyk7XG4gICAgY29uc3QgcmVzID0gZG9XYXRjaChnZXR0ZXIsIGNiLmJpbmQocHVibGljVGhpcyksIG9wdGlvbnMpO1xuICAgIGlmIChjdXIpIHtcbiAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGN1cik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY3JlYXRlUGF0aEdldHRlcihjdHgsIHBhdGgpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBsZXQgY3VyID0gY3R4O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aCAmJiBjdXI7IGkrKykge1xuICAgICAgICAgICAgY3VyID0gY3VyW3NlZ21lbnRzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VyO1xuICAgIH07XG59XG5mdW5jdGlvbiB0cmF2ZXJzZSh2YWx1ZSwgc2Vlbikge1xuICAgIGlmICghKDAsIHNoYXJlZF8xLmlzT2JqZWN0KSh2YWx1ZSkgfHwgdmFsdWVbXCJfX3Zfc2tpcFwiIC8qIFJlYWN0aXZlRmxhZ3MuU0tJUCAqL10pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZWVuID0gc2VlbiB8fCBuZXcgU2V0KCk7XG4gICAgaWYgKHNlZW4uaGFzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNlZW4uYWRkKHZhbHVlKTtcbiAgICBpZiAoKDAsIHJlYWN0aXZpdHlfMS5pc1JlZikodmFsdWUpKSB7XG4gICAgICAgIHRyYXZlcnNlKHZhbHVlLnZhbHVlLCBzZWVuKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHNoYXJlZF8xLmlzQXJyYXkpKHZhbHVlKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cmF2ZXJzZSh2YWx1ZVtpXSwgc2Vlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHNoYXJlZF8xLmlzU2V0KSh2YWx1ZSkgfHwgKDAsIHNoYXJlZF8xLmlzTWFwKSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICAgICAgdHJhdmVyc2Uodiwgc2Vlbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgc2hhcmVkXzEuaXNQbGFpbk9iamVjdCkodmFsdWUpKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICB0cmF2ZXJzZSh2YWx1ZVtrZXldLCBzZWVuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uU3RhdGUoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgIGlzTW91bnRlZDogZmFsc2UsXG4gICAgICAgIGlzTGVhdmluZzogZmFsc2UsXG4gICAgICAgIGlzVW5tb3VudGluZzogZmFsc2UsXG4gICAgICAgIGxlYXZpbmdWTm9kZXM6IG5ldyBNYXAoKVxuICAgIH07XG4gICAgb25Nb3VudGVkKCgpID0+IHtcbiAgICAgICAgc3RhdGUuaXNNb3VudGVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xuICAgICAgICBzdGF0ZS5pc1VubW91bnRpbmcgPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBzdGF0ZTtcbn1cbmV4cG9ydHMudXNlVHJhbnNpdGlvblN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlO1xuY29uc3QgVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IgPSBbRnVuY3Rpb24sIEFycmF5XTtcbmNvbnN0IEJhc2VUcmFuc2l0aW9uSW1wbCA9IHtcbiAgICBuYW1lOiBgQmFzZVRyYW5zaXRpb25gLFxuICAgIHByb3BzOiB7XG4gICAgICAgIG1vZGU6IFN0cmluZyxcbiAgICAgICAgYXBwZWFyOiBCb29sZWFuLFxuICAgICAgICBwZXJzaXN0ZWQ6IEJvb2xlYW4sXG4gICAgICAgIC8vIGVudGVyXG4gICAgICAgIG9uQmVmb3JlRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAgICAgICBvbkVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgICAgICAgb25BZnRlckVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgICAgICAgb25FbnRlckNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gICAgICAgIC8vIGxlYXZlXG4gICAgICAgIG9uQmVmb3JlTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAgICAgICBvbkxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgICAgICAgb25BZnRlckxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgICAgICAgb25MZWF2ZUNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gICAgICAgIC8vIGFwcGVhclxuICAgICAgICBvbkJlZm9yZUFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gICAgICAgIG9uQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgICAgICAgb25BZnRlckFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gICAgICAgIG9uQXBwZWFyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvclxuICAgIH0sXG4gICAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHVzZVRyYW5zaXRpb25TdGF0ZSgpO1xuICAgICAgICBsZXQgcHJldlRyYW5zaXRpb25LZXk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBjaGlsZHJlblswXTtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhhc0ZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gbG9jYXRlIGZpcnN0IG5vbi1jb21tZW50IGNoaWxkXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaGFzRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YXJuIG1vcmUgdGhhbiBvbmUgbm9uLWNvbW1lbnQgY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuKCc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50IG9yIGNvbXBvbmVudC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdVc2UgPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBuZWVkIHRvIHRyYWNrIHJlYWN0aXZpdHkgZm9yIHRoZXNlIHByb3BzIHNvIHVzZSB0aGUgcmF3XG4gICAgICAgICAgICAvLyBwcm9wcyBmb3IgYSBiaXQgYmV0dGVyIHBlcmZcbiAgICAgICAgICAgIGNvbnN0IHJhd1Byb3BzID0gKDAsIHJlYWN0aXZpdHlfMS50b1JhdykocHJvcHMpO1xuICAgICAgICAgICAgY29uc3QgeyBtb2RlIH0gPSByYXdQcm9wcztcbiAgICAgICAgICAgIC8vIGNoZWNrIG1vZGVcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICBtb2RlICYmXG4gICAgICAgICAgICAgICAgbW9kZSAhPT0gJ2luLW91dCcgJiZcbiAgICAgICAgICAgICAgICBtb2RlICE9PSAnb3V0LWluJyAmJlxuICAgICAgICAgICAgICAgIG1vZGUgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgICAgIHdhcm4oYGludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICR7bW9kZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc0xlYXZpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbiB0aGUgY2FzZSBvZiA8dHJhbnNpdGlvbj48a2VlcC1hbGl2ZS8+PC90cmFuc2l0aW9uPiwgd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gY29tcGFyZSB0aGUgdHlwZSBvZiB0aGUga2VwdC1hbGl2ZSBjaGlsZHJlbi5cbiAgICAgICAgICAgIGNvbnN0IGlubmVyQ2hpbGQgPSBnZXRLZWVwQWxpdmVDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICBpZiAoIWlubmVyQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbnRlckhvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhpbm5lckNoaWxkLCByYXdQcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhpbm5lckNoaWxkLCBlbnRlckhvb2tzKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZENoaWxkID0gaW5zdGFuY2Uuc3ViVHJlZTtcbiAgICAgICAgICAgIGNvbnN0IG9sZElubmVyQ2hpbGQgPSBvbGRDaGlsZCAmJiBnZXRLZWVwQWxpdmVDaGlsZChvbGRDaGlsZCk7XG4gICAgICAgICAgICBsZXQgdHJhbnNpdGlvbktleUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2V0VHJhbnNpdGlvbktleSB9ID0gaW5uZXJDaGlsZC50eXBlO1xuICAgICAgICAgICAgaWYgKGdldFRyYW5zaXRpb25LZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBnZXRUcmFuc2l0aW9uS2V5KCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZUcmFuc2l0aW9uS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldlRyYW5zaXRpb25LZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gcHJldlRyYW5zaXRpb25LZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldlRyYW5zaXRpb25LZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25LZXlDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYW5kbGUgbW9kZVxuICAgICAgICAgICAgaWYgKG9sZElubmVyQ2hpbGQgJiZcbiAgICAgICAgICAgICAgICBvbGRJbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQgJiZcbiAgICAgICAgICAgICAgICAoIWlzU2FtZVZOb2RlVHlwZShpbm5lckNoaWxkLCBvbGRJbm5lckNoaWxkKSB8fCB0cmFuc2l0aW9uS2V5Q2hhbmdlZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWF2aW5nSG9va3MgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKG9sZElubmVyQ2hpbGQsIHJhd1Byb3BzLCBzdGF0ZSwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBvbGQgdHJlZSdzIGhvb2tzIGluIGNhc2Ugb2YgZHluYW1pYyB0cmFuc2l0aW9uXG4gICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKG9sZElubmVyQ2hpbGQsIGxlYXZpbmdIb29rcyk7XG4gICAgICAgICAgICAgICAgLy8gc3dpdGNoaW5nIGJldHdlZW4gZGlmZmVyZW50IHZpZXdzXG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzTGVhdmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICAgICAgICAgICAgICBsZWF2aW5nSG9va3MuYWZ0ZXJMZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzTGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIzY4MzVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IGFsc28gbmVlZHMgdG8gYmUgdXBkYXRlZCB3aGVuIGFjdGl2ZSBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS51cGRhdGUuYWN0aXZlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnICYmIGlubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBsZWF2aW5nSG9va3MuZGVsYXlMZWF2ZSA9IChlbCwgZWFybHlSZW1vdmUsIGRlbGF5ZWRMZWF2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgb2xkSW5uZXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWF2aW5nVk5vZGVzQ2FjaGVbU3RyaW5nKG9sZElubmVyQ2hpbGQua2V5KV0gPSBvbGRJbm5lckNoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFybHkgcmVtb3ZhbCBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuX2xlYXZlQ2IgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFybHlSZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZW50ZXJIb29rcy5kZWxheWVkTGVhdmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXJIb29rcy5kZWxheWVkTGVhdmUgPSBkZWxheWVkTGVhdmU7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICB9O1xuICAgIH1cbn07XG4vLyBleHBvcnQgdGhlIHB1YmxpYyB0eXBlIGZvciBoL3RzeCBpbmZlcmVuY2Vcbi8vIGFsc28gdG8gYXZvaWQgaW5saW5lIGltcG9ydCgpIGluIGdlbmVyYXRlZCBkLnRzIGZpbGVzXG5jb25zdCBCYXNlVHJhbnNpdGlvbiA9IEJhc2VUcmFuc2l0aW9uSW1wbDtcbmV4cG9ydHMuQmFzZVRyYW5zaXRpb24gPSBCYXNlVHJhbnNpdGlvbjtcbmZ1bmN0aW9uIGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIHZub2RlKSB7XG4gICAgY29uc3QgeyBsZWF2aW5nVk5vZGVzIH0gPSBzdGF0ZTtcbiAgICBsZXQgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gbGVhdmluZ1ZOb2Rlcy5nZXQodm5vZGUudHlwZSk7XG4gICAgaWYgKCFsZWF2aW5nVk5vZGVzQ2FjaGUpIHtcbiAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGVhdmluZ1ZOb2Rlcy5zZXQodm5vZGUudHlwZSwgbGVhdmluZ1ZOb2Rlc0NhY2hlKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlYXZpbmdWTm9kZXNDYWNoZTtcbn1cbi8vIFRoZSB0cmFuc2l0aW9uIGhvb2tzIGFyZSBhdHRhY2hlZCB0byB0aGUgdm5vZGUgYXMgdm5vZGUudHJhbnNpdGlvblxuLy8gYW5kIHdpbGwgYmUgY2FsbGVkIGF0IGFwcHJvcHJpYXRlIHRpbWluZyBpbiB0aGUgcmVuZGVyZXIuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKHZub2RlLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlKSB7XG4gICAgY29uc3QgeyBhcHBlYXIsIG1vZGUsIHBlcnNpc3RlZCA9IGZhbHNlLCBvbkJlZm9yZUVudGVyLCBvbkVudGVyLCBvbkFmdGVyRW50ZXIsIG9uRW50ZXJDYW5jZWxsZWQsIG9uQmVmb3JlTGVhdmUsIG9uTGVhdmUsIG9uQWZ0ZXJMZWF2ZSwgb25MZWF2ZUNhbmNlbGxlZCwgb25CZWZvcmVBcHBlYXIsIG9uQXBwZWFyLCBvbkFmdGVyQXBwZWFyLCBvbkFwcGVhckNhbmNlbGxlZCB9ID0gcHJvcHM7XG4gICAgY29uc3Qga2V5ID0gU3RyaW5nKHZub2RlLmtleSk7XG4gICAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgdm5vZGUpO1xuICAgIGNvbnN0IGNhbGxIb29rID0gKGhvb2ssIGFyZ3MpID0+IHtcbiAgICAgICAgaG9vayAmJlxuICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgaW5zdGFuY2UsIDkgLyogRXJyb3JDb2Rlcy5UUkFOU0lUSU9OX0hPT0sgKi8sIGFyZ3MpO1xuICAgIH07XG4gICAgY29uc3QgY2FsbEFzeW5jSG9vayA9IChob29rLCBhcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IGRvbmUgPSBhcmdzWzFdO1xuICAgICAgICBjYWxsSG9vayhob29rLCBhcmdzKTtcbiAgICAgICAgaWYgKCgwLCBzaGFyZWRfMS5pc0FycmF5KShob29rKSkge1xuICAgICAgICAgICAgaWYgKGhvb2suZXZlcnkoaG9vayA9PiBob29rLmxlbmd0aCA8PSAxKSlcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaG9vay5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBob29rcyA9IHtcbiAgICAgICAgbW9kZSxcbiAgICAgICAgcGVyc2lzdGVkLFxuICAgICAgICBiZWZvcmVFbnRlcihlbCkge1xuICAgICAgICAgICAgbGV0IGhvb2sgPSBvbkJlZm9yZUVudGVyO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXBwZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2sgPSBvbkJlZm9yZUFwcGVhciB8fCBvbkJlZm9yZUVudGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZvciBzYW1lIGVsZW1lbnQgKHYtc2hvdylcbiAgICAgICAgICAgIGlmIChlbC5fbGVhdmVDYikge1xuICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiKHRydWUgLyogY2FuY2VsbGVkICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZvciB0b2dnbGVkIGVsZW1lbnQgd2l0aCBzYW1lIGtleSAodi1pZilcbiAgICAgICAgICAgIGNvbnN0IGxlYXZpbmdWTm9kZSA9IGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldO1xuICAgICAgICAgICAgaWYgKGxlYXZpbmdWTm9kZSAmJlxuICAgICAgICAgICAgICAgIGlzU2FtZVZOb2RlVHlwZSh2bm9kZSwgbGVhdmluZ1ZOb2RlKSAmJlxuICAgICAgICAgICAgICAgIGxlYXZpbmdWTm9kZS5lbC5fbGVhdmVDYikge1xuICAgICAgICAgICAgICAgIC8vIGZvcmNlIGVhcmx5IHJlbW92YWwgKG5vdCBjYW5jZWxsZWQpXG4gICAgICAgICAgICAgICAgbGVhdmluZ1ZOb2RlLmVsLl9sZWF2ZUNiKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsSG9vayhob29rLCBbZWxdKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW50ZXIoZWwpIHtcbiAgICAgICAgICAgIGxldCBob29rID0gb25FbnRlcjtcbiAgICAgICAgICAgIGxldCBhZnRlckhvb2sgPSBvbkFmdGVyRW50ZXI7XG4gICAgICAgICAgICBsZXQgY2FuY2VsSG9vayA9IG9uRW50ZXJDYW5jZWxsZWQ7XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChhcHBlYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9vayA9IG9uQXBwZWFyIHx8IG9uRW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVySG9vayA9IG9uQWZ0ZXJBcHBlYXIgfHwgb25BZnRlckVudGVyO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxIb29rID0gb25BcHBlYXJDYW5jZWxsZWQgfHwgb25FbnRlckNhbmNlbGxlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBkb25lID0gKGVsLl9lbnRlckNiID0gKGNhbmNlbGxlZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2soY2FuY2VsSG9vaywgW2VsXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhhZnRlckhvb2ssIFtlbF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaG9va3MuZGVsYXllZExlYXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLmRlbGF5ZWRMZWF2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbC5fZW50ZXJDYiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGhvb2spIHtcbiAgICAgICAgICAgICAgICBjYWxsQXN5bmNIb29rKGhvb2ssIFtlbCwgZG9uZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsZWF2ZShlbCwgcmVtb3ZlKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBTdHJpbmcodm5vZGUua2V5KTtcbiAgICAgICAgICAgIGlmIChlbC5fZW50ZXJDYikge1xuICAgICAgICAgICAgICAgIGVsLl9lbnRlckNiKHRydWUgLyogY2FuY2VsbGVkICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc1VubW91bnRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsSG9vayhvbkJlZm9yZUxlYXZlLCBbZWxdKTtcbiAgICAgICAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGRvbmUgPSAoZWwuX2xlYXZlQ2IgPSAoY2FuY2VsbGVkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxlZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhvbkxlYXZlQ2FuY2VsbGVkLCBbZWxdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxIb29rKG9uQWZ0ZXJMZWF2ZSwgW2VsXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XSA9PT0gdm5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgICAgICAgIGlmIChvbkxlYXZlKSB7XG4gICAgICAgICAgICAgICAgY2FsbEFzeW5jSG9vayhvbkxlYXZlLCBbZWwsIGRvbmVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2xvbmUodm5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKHZub2RlLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGhvb2tzO1xufVxuZXhwb3J0cy5yZXNvbHZlVHJhbnNpdGlvbkhvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcztcbi8vIHRoZSBwbGFjZWhvbGRlciByZWFsbHkgb25seSBoYW5kbGVzIG9uZSBzcGVjaWFsIGNhc2U6IEtlZXBBbGl2ZVxuLy8gaW4gdGhlIGNhc2Ugb2YgYSBLZWVwQWxpdmUgaW4gYSBsZWF2ZSBwaGFzZSB3ZSBuZWVkIHRvIHJldHVybiBhIEtlZXBBbGl2ZVxuLy8gcGxhY2Vob2xkZXIgd2l0aCBlbXB0eSBjb250ZW50IHRvIGF2b2lkIHRoZSBLZWVwQWxpdmUgaW5zdGFuY2UgZnJvbSBiZWluZ1xuLy8gdW5tb3VudGVkLlxuZnVuY3Rpb24gZW1wdHlQbGFjZWhvbGRlcih2bm9kZSkge1xuICAgIGlmIChpc0tlZXBBbGl2ZSh2bm9kZSkpIHtcbiAgICAgICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICAgICAgdm5vZGUuY2hpbGRyZW4gPSBudWxsO1xuICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0S2VlcEFsaXZlQ2hpbGQodm5vZGUpIHtcbiAgICByZXR1cm4gaXNLZWVwQWxpdmUodm5vZGUpXG4gICAgICAgID8gdm5vZGUuY2hpbGRyZW5cbiAgICAgICAgICAgID8gdm5vZGUuY2hpbGRyZW5bMF1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgIDogdm5vZGU7XG59XG5mdW5jdGlvbiBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUsIGhvb2tzKSB7XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYgLyogU2hhcGVGbGFncy5DT01QT05FTlQgKi8gJiYgdm5vZGUuY29tcG9uZW50KSB7XG4gICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSwgaG9va3MpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU2hhcGVGbGFncy5TVVNQRU5TRSAqLykge1xuICAgICAgICB2bm9kZS5zc0NvbnRlbnQudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzQ29udGVudCk7XG4gICAgICAgIHZub2RlLnNzRmFsbGJhY2sudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzRmFsbGJhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdm5vZGUudHJhbnNpdGlvbiA9IGhvb2tzO1xuICAgIH1cbn1cbmV4cG9ydHMuc2V0VHJhbnNpdGlvbkhvb2tzID0gc2V0VHJhbnNpdGlvbkhvb2tzO1xuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkcmVuLCBrZWVwQ29tbWVudCA9IGZhbHNlLCBwYXJlbnRLZXkpIHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgbGV0IGtleWVkRnJhZ21lbnRDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgLy8gIzUzNjAgaW5oZXJpdCBwYXJlbnQga2V5IGluIGNhc2Ugb2YgPHRlbXBsYXRlIHYtZm9yPlxuICAgICAgICBjb25zdCBrZXkgPSBwYXJlbnRLZXkgPT0gbnVsbFxuICAgICAgICAgICAgPyBjaGlsZC5rZXlcbiAgICAgICAgICAgIDogU3RyaW5nKHBhcmVudEtleSkgKyBTdHJpbmcoY2hpbGQua2V5ICE9IG51bGwgPyBjaGlsZC5rZXkgOiBpKTtcbiAgICAgICAgLy8gaGFuZGxlIGZyYWdtZW50IGNoaWxkcmVuIGNhc2UsIGUuZy4gdi1mb3JcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucGF0Y2hGbGFnICYgMTI4IC8qIFBhdGNoRmxhZ3MuS0VZRURfRlJBR01FTlQgKi8pXG4gICAgICAgICAgICAgICAga2V5ZWRGcmFnbWVudENvdW50Kys7XG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZC5jaGlsZHJlbiwga2VlcENvbW1lbnQsIGtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbW1lbnQgcGxhY2Vob2xkZXJzIHNob3VsZCBiZSBza2lwcGVkLCBlLmcuIHYtaWZcbiAgICAgICAgZWxzZSBpZiAoa2VlcENvbW1lbnQgfHwgY2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICAgICAgcmV0LnB1c2goa2V5ICE9IG51bGwgPyBjbG9uZVZOb2RlKGNoaWxkLCB7IGtleSB9KSA6IGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAjMTEyNiBpZiBhIHRyYW5zaXRpb24gY2hpbGRyZW4gbGlzdCBjb250YWlucyBtdWx0aXBsZSBzdWIgZnJhZ21lbnRzLCB0aGVzZVxuICAgIC8vIGZyYWdtZW50cyB3aWxsIGJlIG1lcmdlZCBpbnRvIGEgZmxhdCBjaGlsZHJlbiBhcnJheS4gU2luY2UgZWFjaCB2LWZvclxuICAgIC8vIGZyYWdtZW50IG1heSBjb250YWluIGRpZmZlcmVudCBzdGF0aWMgYmluZGluZ3MgaW5zaWRlLCB3ZSBuZWVkIHRvIGRlLW9wXG4gICAgLy8gdGhlc2UgY2hpbGRyZW4gdG8gZm9yY2UgZnVsbCBkaWZmcyB0byBlbnN1cmUgY29ycmVjdCBiZWhhdmlvci5cbiAgICBpZiAoa2V5ZWRGcmFnbWVudENvdW50ID4gMSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmV0W2ldLnBhdGNoRmxhZyA9IC0yIC8qIFBhdGNoRmxhZ3MuQkFJTCAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuZXhwb3J0cy5nZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4gPSBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW47XG4vLyBpbXBsZW1lbnRhdGlvbiwgY2xvc2UgdG8gbm8tb3BcbmZ1bmN0aW9uIGRlZmluZUNvbXBvbmVudChvcHRpb25zKSB7XG4gICAgcmV0dXJuICgwLCBzaGFyZWRfMS5pc0Z1bmN0aW9uKShvcHRpb25zKSA/IHsgc2V0dXA6IG9wdGlvbnMsIG5hbWU6IG9wdGlvbnMubmFtZSB9IDogb3B0aW9ucztcbn1cbmV4cG9ydHMuZGVmaW5lQ29tcG9uZW50ID0gZGVmaW5lQ29tcG9uZW50O1xuY29uc3QgaXNBc3luY1dyYXBwZXIgPSAoaSkgPT4gISFpLnR5cGUuX19hc3luY0xvYWRlcjtcbmZ1bmN0aW9uIGRlZmluZUFzeW5jQ29tcG9uZW50KHNvdXJjZSkge1xuICAgIGlmICgoMCwgc2hhcmVkXzEuaXNGdW5jdGlvbikoc291cmNlKSkge1xuICAgICAgICBzb3VyY2UgPSB7IGxvYWRlcjogc291cmNlIH07XG4gICAgfVxuICAgIGNvbnN0IHsgbG9hZGVyLCBsb2FkaW5nQ29tcG9uZW50LCBlcnJvckNvbXBvbmVudCwgZGVsYXkgPSAyMDAsIHRpbWVvdXQsIC8vIHVuZGVmaW5lZCA9IG5ldmVyIHRpbWVzIG91dFxuICAgIHN1c3BlbnNpYmxlID0gdHJ1ZSwgb25FcnJvcjogdXNlck9uRXJyb3IgfSA9IHNvdXJjZTtcbiAgICBsZXQgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICAgIGxldCByZXNvbHZlZENvbXA7XG4gICAgbGV0IHJldHJpZXMgPSAwO1xuICAgIGNvbnN0IHJldHJ5ID0gKCkgPT4ge1xuICAgICAgICByZXRyaWVzKys7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGxvYWQoKTtcbiAgICB9O1xuICAgIGNvbnN0IGxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGxldCB0aGlzUmVxdWVzdDtcbiAgICAgICAgcmV0dXJuIChwZW5kaW5nUmVxdWVzdCB8fFxuICAgICAgICAgICAgKHRoaXNSZXF1ZXN0ID0gcGVuZGluZ1JlcXVlc3QgPVxuICAgICAgICAgICAgICAgIGxvYWRlcigpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlcnIgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyT25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyUmV0cnkgPSAoKSA9PiByZXNvbHZlKHJldHJ5KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJGYWlsID0gKCkgPT4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlck9uRXJyb3IoZXJyLCB1c2VyUmV0cnksIHVzZXJGYWlsLCByZXRyaWVzICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChjb21wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzUmVxdWVzdCAhPT0gcGVuZGluZ1JlcXVlc3QgJiYgcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwZW5kaW5nUmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjb21wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBBc3luYyBjb21wb25lbnQgbG9hZGVyIHJlc29sdmVkIHRvIHVuZGVmaW5lZC4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYElmIHlvdSBhcmUgdXNpbmcgcmV0cnkoKSwgbWFrZSBzdXJlIHRvIHJldHVybiBpdHMgcmV0dXJuIHZhbHVlLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGludGVyb3AgbW9kdWxlIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb21wLl9fZXNNb2R1bGUgfHwgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb21wICYmICEoMCwgc2hhcmVkXzEuaXNPYmplY3QpKGNvbXApICYmICEoMCwgc2hhcmVkXzEuaXNGdW5jdGlvbikoY29tcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhc3luYyBjb21wb25lbnQgbG9hZCByZXN1bHQ6ICR7Y29tcH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZENvbXAgPSBjb21wO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcDtcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgIH07XG4gICAgcmV0dXJuIGRlZmluZUNvbXBvbmVudCh7XG4gICAgICAgIG5hbWU6ICdBc3luY0NvbXBvbmVudFdyYXBwZXInLFxuICAgICAgICBfX2FzeW5jTG9hZGVyOiBsb2FkLFxuICAgICAgICBnZXQgX19hc3luY1Jlc29sdmVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQ29tcDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0dXAoKSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgICAgICAgIC8vIGFscmVhZHkgcmVzb2x2ZWRcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZENvbXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMTMgLyogRXJyb3JDb2Rlcy5BU1lOQ19DT01QT05FTlRfTE9BREVSICovLCAhZXJyb3JDb21wb25lbnQgLyogZG8gbm90IHRocm93IGluIGRldiBpZiB1c2VyIHByb3ZpZGVkIGVycm9yIGNvbXBvbmVudCAqLyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gc3VzcGVuc2UtY29udHJvbGxlZCBvciBTU1IuXG4gICAgICAgICAgICBpZiAoKHN1c3BlbnNpYmxlICYmIGluc3RhbmNlLnN1c3BlbnNlKSB8fFxuICAgICAgICAgICAgICAgIChpc0luU1NSQ29tcG9uZW50U2V0dXApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWQoKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihjb21wID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChjb21wLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGVycm9yQ29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZVZOb2RlKGVycm9yQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvYWRlZCA9ICgwLCByZWFjdGl2aXR5XzEucmVmKShmYWxzZSk7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9ICgwLCByZWFjdGl2aXR5XzEucmVmKSgpO1xuICAgICAgICAgICAgY29uc3QgZGVsYXllZCA9ICgwLCByZWFjdGl2aXR5XzEucmVmKSghIWRlbGF5KTtcbiAgICAgICAgICAgIGlmIChkZWxheSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkZWxheWVkLnZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvYWRlZC52YWx1ZSAmJiAhZXJyb3IudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgQXN5bmMgY29tcG9uZW50IHRpbWVkIG91dCBhZnRlciAke3RpbWVvdXR9bXMuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9hZCgpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxvYWRlZC52YWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnBhcmVudCAmJiBpc0tlZXBBbGl2ZShpbnN0YW5jZS5wYXJlbnQudm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhcmVudCBpcyBrZWVwLWFsaXZlLCBmb3JjZSB1cGRhdGUgc28gdGhlIGxvYWRlZCBjb21wb25lbnQnc1xuICAgICAgICAgICAgICAgICAgICAvLyBuYW1lIGlzIHRha2VuIGludG8gYWNjb3VudFxuICAgICAgICAgICAgICAgICAgICBxdWV1ZUpvYihpbnN0YW5jZS5wYXJlbnQudXBkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobG9hZGVkLnZhbHVlICYmIHJlc29sdmVkQ29tcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvci52YWx1ZSAmJiBlcnJvckNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoZXJyb3JDb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci52YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobG9hZGluZ0NvbXBvbmVudCAmJiAhZGVsYXllZC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUobG9hZGluZ0NvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZpbmVBc3luY0NvbXBvbmVudCA9IGRlZmluZUFzeW5jQ29tcG9uZW50O1xuZnVuY3Rpb24gY3JlYXRlSW5uZXJDb21wKGNvbXAsIHBhcmVudCkge1xuICAgIGNvbnN0IHsgcmVmLCBwcm9wcywgY2hpbGRyZW4sIGNlIH0gPSBwYXJlbnQudm5vZGU7XG4gICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShjb21wLCBwcm9wcywgY2hpbGRyZW4pO1xuICAgIC8vIGVuc3VyZSBpbm5lciBjb21wb25lbnQgaW5oZXJpdHMgdGhlIGFzeW5jIHdyYXBwZXIncyByZWYgb3duZXJcbiAgICB2bm9kZS5yZWYgPSByZWY7XG4gICAgLy8gcGFzcyB0aGUgY3VzdG9tIGVsZW1lbnQgY2FsbGJhY2sgb24gdG8gdGhlIGlubmVyIGNvbXBcbiAgICAvLyBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIGFzeW5jIHdyYXBwZXJcbiAgICB2bm9kZS5jZSA9IGNlO1xuICAgIGRlbGV0ZSBwYXJlbnQudm5vZGUuY2U7XG4gICAgcmV0dXJuIHZub2RlO1xufVxuY29uc3QgaXNLZWVwQWxpdmUgPSAodm5vZGUpID0+IHZub2RlLnR5cGUuX19pc0tlZXBBbGl2ZTtcbmNvbnN0IEtlZXBBbGl2ZUltcGwgPSB7XG4gICAgbmFtZTogYEtlZXBBbGl2ZWAsXG4gICAgLy8gTWFya2VyIGZvciBzcGVjaWFsIGhhbmRsaW5nIGluc2lkZSB0aGUgcmVuZGVyZXIuIFdlIGFyZSBub3QgdXNpbmcgYSA9PT1cbiAgICAvLyBjaGVjayBkaXJlY3RseSBvbiBLZWVwQWxpdmUgaW4gdGhlIHJlbmRlcmVyLCBiZWNhdXNlIGltcG9ydGluZyBpdCBkaXJlY3RseVxuICAgIC8vIHdvdWxkIHByZXZlbnQgaXQgZnJvbSBiZWluZyB0cmVlLXNoYWtlbi5cbiAgICBfX2lzS2VlcEFsaXZlOiB0cnVlLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGluY2x1ZGU6IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldLFxuICAgICAgICBleGNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcbiAgICAgICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gICAgfSxcbiAgICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICAgIC8vIEtlZXBBbGl2ZSBjb21tdW5pY2F0ZXMgd2l0aCB0aGUgaW5zdGFudGlhdGVkIHJlbmRlcmVyIHZpYSB0aGVcbiAgICAgICAgLy8gY3R4IHdoZXJlIHRoZSByZW5kZXJlciBwYXNzZXMgaW4gaXRzIGludGVybmFscyxcbiAgICAgICAgLy8gYW5kIHRoZSBLZWVwQWxpdmUgaW5zdGFuY2UgZXhwb3NlcyBhY3RpdmF0ZS9kZWFjdGl2YXRlIGltcGxlbWVudGF0aW9ucy5cbiAgICAgICAgLy8gVGhlIHdob2xlIHBvaW50IG9mIHRoaXMgaXMgdG8gYXZvaWQgaW1wb3J0aW5nIEtlZXBBbGl2ZSBkaXJlY3RseSBpbiB0aGVcbiAgICAgICAgLy8gcmVuZGVyZXIgdG8gZmFjaWxpdGF0ZSB0cmVlLXNoYWtpbmcuXG4gICAgICAgIGNvbnN0IHNoYXJlZENvbnRleHQgPSBpbnN0YW5jZS5jdHg7XG4gICAgICAgIC8vIGlmIHRoZSBpbnRlcm5hbCByZW5kZXJlciBpcyBub3QgcmVnaXN0ZXJlZCwgaXQgaW5kaWNhdGVzIHRoYXQgdGhpcyBpcyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcsXG4gICAgICAgIC8vIGZvciBLZWVwQWxpdmUsIHdlIGp1c3QgbmVlZCB0byByZW5kZXIgaXRzIGNoaWxkcmVuXG4gICAgICAgIGlmICghc2hhcmVkQ29udGV4dC5yZW5kZXJlcikge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgc2xvdHMuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgPyBjaGlsZHJlblswXSA6IGNoaWxkcmVuO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBudWxsO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgICAgaW5zdGFuY2UuX192X2NhY2hlID0gY2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50U3VzcGVuc2UgPSBpbnN0YW5jZS5zdXNwZW5zZTtcbiAgICAgICAgY29uc3QgeyByZW5kZXJlcjogeyBwOiBwYXRjaCwgbTogbW92ZSwgdW06IF91bm1vdW50LCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9IH0gPSBzaGFyZWRDb250ZXh0O1xuICAgICAgICBjb25zdCBzdG9yYWdlQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHNoYXJlZENvbnRleHQuYWN0aXZhdGUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgICAgICAgIG1vdmUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCAwIC8qIE1vdmVUeXBlLkVOVEVSICovLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIHByb3BzIGhhdmUgY2hhbmdlZFxuICAgICAgICAgICAgcGF0Y2goaW5zdGFuY2Uudm5vZGUsIHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgdm5vZGUuc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc0RlYWN0aXZhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmEpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHNoYXJlZF8xLmludm9rZUFycmF5Rm5zKShpbnN0YW5jZS5hKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgdm5vZGVIb29rID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMub25Wbm9kZU1vdW50ZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHZub2RlSG9vaykge1xuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBpbnN0YW5jZS5wYXJlbnQsIHZub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjb21wb25lbnRzIHRyZWVcbiAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2hhcmVkQ29udGV4dC5kZWFjdGl2YXRlID0gKHZub2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudDtcbiAgICAgICAgICAgIG1vdmUodm5vZGUsIHN0b3JhZ2VDb250YWluZXIsIG51bGwsIDEgLyogTW92ZVR5cGUuTEVBVkUgKi8sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmRhKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBzaGFyZWRfMS5pbnZva2VBcnJheUZucykoaW5zdGFuY2UuZGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2bm9kZUhvb2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblZub2RlVW5tb3VudGVkO1xuICAgICAgICAgICAgICAgIGlmICh2bm9kZUhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgaW5zdGFuY2UucGFyZW50LCB2bm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmlzRGVhY3RpdmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgY29tcG9uZW50cyB0cmVlXG4gICAgICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHVubW91bnQodm5vZGUpIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBzaGFwZUZsYWcgc28gaXQgY2FuIGJlIHByb3Blcmx5IHVubW91bnRlZFxuICAgICAgICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xuICAgICAgICAgICAgX3VubW91bnQodm5vZGUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHJ1bmVDYWNoZShmaWx0ZXIpIHtcbiAgICAgICAgICAgIGNhY2hlLmZvckVhY2goKHZub2RlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh2bm9kZS50eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSAmJiAoIWZpbHRlciB8fCAhZmlsdGVyKG5hbWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkoa2V5KSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICghY3VycmVudCB8fCAhaXNTYW1lVk5vZGVUeXBlKGNhY2hlZCwgY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICB1bm1vdW50KGNhY2hlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBhY3RpdmUgaW5zdGFuY2Ugc2hvdWxkIG5vIGxvbmdlciBiZSBrZXB0LWFsaXZlLlxuICAgICAgICAgICAgICAgIC8vIHdlIGNhbid0IHVubW91bnQgaXQgbm93IGJ1dCBpdCBtaWdodCBiZSBsYXRlciwgc28gcmVzZXQgaXRzIGZsYWcgbm93LlxuICAgICAgICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICBrZXlzLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBydW5lIGNhY2hlIG9uIGluY2x1ZGUvZXhjbHVkZSBwcm9wIGNoYW5nZVxuICAgICAgICB3YXRjaCgoKSA9PiBbcHJvcHMuaW5jbHVkZSwgcHJvcHMuZXhjbHVkZV0sIChbaW5jbHVkZSwgZXhjbHVkZV0pID0+IHtcbiAgICAgICAgICAgIGluY2x1ZGUgJiYgcHJ1bmVDYWNoZShuYW1lID0+IG1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpO1xuICAgICAgICAgICAgZXhjbHVkZSAmJiBwcnVuZUNhY2hlKG5hbWUgPT4gIW1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpO1xuICAgICAgICB9LCBcbiAgICAgICAgLy8gcHJ1bmUgcG9zdC1yZW5kZXIgYWZ0ZXIgYGN1cnJlbnRgIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICAgICAgeyBmbHVzaDogJ3Bvc3QnLCBkZWVwOiB0cnVlIH0pO1xuICAgICAgICAvLyBjYWNoZSBzdWIgdHJlZSBhZnRlciByZW5kZXJcbiAgICAgICAgbGV0IHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XG4gICAgICAgIGNvbnN0IGNhY2hlU3VidHJlZSA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIGZpeCAjMTYyMSwgdGhlIHBlbmRpbmdDYWNoZUtleSBjb3VsZCBiZSAwXG4gICAgICAgICAgICBpZiAocGVuZGluZ0NhY2hlS2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjYWNoZS5zZXQocGVuZGluZ0NhY2hlS2V5LCBnZXRJbm5lckNoaWxkKGluc3RhbmNlLnN1YlRyZWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgb25Nb3VudGVkKGNhY2hlU3VidHJlZSk7XG4gICAgICAgIG9uVXBkYXRlZChjYWNoZVN1YnRyZWUpO1xuICAgICAgICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xuICAgICAgICAgICAgY2FjaGUuZm9yRWFjaChjYWNoZWQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3ViVHJlZSwgc3VzcGVuc2UgfSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChzdWJUcmVlKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkLnR5cGUgPT09IHZub2RlLnR5cGUgJiYgY2FjaGVkLmtleSA9PT0gdm5vZGUua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgaW5zdGFuY2Ugd2lsbCBiZSB1bm1vdW50ZWQgYXMgcGFydCBvZiBrZWVwLWFsaXZlJ3MgdW5tb3VudFxuICAgICAgICAgICAgICAgICAgICByZXNldFNoYXBlRmxhZyh2bm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBpbnZva2UgaXRzIGRlYWN0aXZhdGVkIGhvb2sgaGVyZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYSA9IHZub2RlLmNvbXBvbmVudC5kYTtcbiAgICAgICAgICAgICAgICAgICAgZGEgJiYgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGRhLCBzdXNwZW5zZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5tb3VudChjYWNoZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghc2xvdHMuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0KCk7XG4gICAgICAgICAgICBjb25zdCByYXdWTm9kZSA9IGNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEtlZXBBbGl2ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSBjb21wb25lbnQgY2hpbGQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1ZOb2RlKHJhd1ZOb2RlKSB8fFxuICAgICAgICAgICAgICAgICghKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDQgLyogU2hhcGVGbGFncy5TVEFURUZVTF9DT01QT05FTlQgKi8pICYmXG4gICAgICAgICAgICAgICAgICAgICEocmF3Vk5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNoYXBlRmxhZ3MuU1VTUEVOU0UgKi8pKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiByYXdWTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB2bm9kZSA9IGdldElubmVyQ2hpbGQocmF3Vk5vZGUpO1xuICAgICAgICAgICAgY29uc3QgY29tcCA9IHZub2RlLnR5cGU7XG4gICAgICAgICAgICAvLyBmb3IgYXN5bmMgY29tcG9uZW50cywgbmFtZSBjaGVjayBzaG91bGQgYmUgYmFzZWQgaW4gaXRzIGxvYWRlZFxuICAgICAgICAgICAgLy8gaW5uZXIgY29tcG9uZW50IGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoaXNBc3luY1dyYXBwZXIodm5vZGUpXG4gICAgICAgICAgICAgICAgPyB2bm9kZS50eXBlLl9fYXN5bmNSZXNvbHZlZCB8fCB7fVxuICAgICAgICAgICAgICAgIDogY29tcCk7XG4gICAgICAgICAgICBjb25zdCB7IGluY2x1ZGUsIGV4Y2x1ZGUsIG1heCB9ID0gcHJvcHM7XG4gICAgICAgICAgICBpZiAoKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSkgfHxcbiAgICAgICAgICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHZub2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiByYXdWTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleSA9PSBudWxsID8gY29tcCA6IHZub2RlLmtleTtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZFZOb2RlID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgICAgICAvLyBjbG9uZSB2bm9kZSBpZiBpdCdzIHJldXNlZCBiZWNhdXNlIHdlIGFyZSBnb2luZyB0byBtdXRhdGUgaXRcbiAgICAgICAgICAgIGlmICh2bm9kZS5lbCkge1xuICAgICAgICAgICAgICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTaGFwZUZsYWdzLlNVU1BFTlNFICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhd1ZOb2RlLnNzQ29udGVudCA9IHZub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vICMxNTEzIGl0J3MgcG9zc2libGUgZm9yIHRoZSByZXR1cm5lZCB2bm9kZSB0byBiZSBjbG9uZWQgZHVlIHRvIGF0dHJcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoIG9yIHNjb3BlSWQsIHNvIHRoZSB2bm9kZSBoZXJlIG1heSBub3QgYmUgdGhlIGZpbmFsIHZub2RlXG4gICAgICAgICAgICAvLyB0aGF0IGlzIG1vdW50ZWQuIEluc3RlYWQgb2YgY2FjaGluZyBpdCBkaXJlY3RseSwgd2Ugc3RvcmUgdGhlIHBlbmRpbmdcbiAgICAgICAgICAgIC8vIGtleSBhbmQgY2FjaGUgYGluc3RhbmNlLnN1YlRyZWVgICh0aGUgbm9ybWFsaXplZCB2bm9kZSkgaW5cbiAgICAgICAgICAgIC8vIGJlZm9yZU1vdW50L2JlZm9yZVVwZGF0ZSBob29rcy5cbiAgICAgICAgICAgIHBlbmRpbmdDYWNoZUtleSA9IGtleTtcbiAgICAgICAgICAgIGlmIChjYWNoZWRWTm9kZSkge1xuICAgICAgICAgICAgICAgIC8vIGNvcHkgb3ZlciBtb3VudGVkIHN0YXRlXG4gICAgICAgICAgICAgICAgdm5vZGUuZWwgPSBjYWNoZWRWTm9kZS5lbDtcbiAgICAgICAgICAgICAgICB2bm9kZS5jb21wb25lbnQgPSBjYWNoZWRWTm9kZS5jb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgdXBkYXRlIHRyYW5zaXRpb24gaG9va3Mgb24gc3ViVHJlZVxuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUsIHZub2RlLnRyYW5zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhdm9pZCB2bm9kZSBiZWluZyBtb3VudGVkIGFzIGZyZXNoXG4gICAgICAgICAgICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IDUxMiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVF9LRVBUX0FMSVZFICovO1xuICAgICAgICAgICAgICAgIC8vIG1ha2UgdGhpcyBrZXkgdGhlIGZyZXNoZXN0XG4gICAgICAgICAgICAgICAga2V5cy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcbiAgICAgICAgICAgICAgICBpZiAobWF4ICYmIGtleXMuc2l6ZSA+IHBhcnNlSW50KG1heCwgMTApKSB7XG4gICAgICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXlzLnZhbHVlcygpLm5leHQoKS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXZvaWQgdm5vZGUgYmVpbmcgdW5tb3VudGVkXG4gICAgICAgICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gMjU2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovO1xuICAgICAgICAgICAgY3VycmVudCA9IHZub2RlO1xuICAgICAgICAgICAgcmV0dXJuIGlzU3VzcGVuc2UocmF3Vk5vZGUudHlwZSkgPyByYXdWTm9kZSA6IHZub2RlO1xuICAgICAgICB9O1xuICAgIH1cbn07XG4vLyBleHBvcnQgdGhlIHB1YmxpYyB0eXBlIGZvciBoL3RzeCBpbmZlcmVuY2Vcbi8vIGFsc28gdG8gYXZvaWQgaW5saW5lIGltcG9ydCgpIGluIGdlbmVyYXRlZCBkLnRzIGZpbGVzXG5jb25zdCBLZWVwQWxpdmUgPSBLZWVwQWxpdmVJbXBsO1xuZXhwb3J0cy5LZWVwQWxpdmUgPSBLZWVwQWxpdmU7XG5mdW5jdGlvbiBtYXRjaGVzKHBhdHRlcm4sIG5hbWUpIHtcbiAgICBpZiAoKDAsIHNoYXJlZF8xLmlzQXJyYXkpKHBhdHRlcm4pKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnNvbWUoKHApID0+IG1hdGNoZXMocCwgbmFtZSkpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgc2hhcmVkXzEuaXNTdHJpbmcpKHBhdHRlcm4pKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5jbHVkZXMobmFtZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBzaGFyZWRfMS5pc1JlZ0V4cCkocGF0dGVybikpIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBvbkFjdGl2YXRlZChob29rLCB0YXJnZXQpIHtcbiAgICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJhXCIgLyogTGlmZWN5Y2xlSG9va3MuQUNUSVZBVEVEICovLCB0YXJnZXQpO1xufVxuZXhwb3J0cy5vbkFjdGl2YXRlZCA9IG9uQWN0aXZhdGVkO1xuZnVuY3Rpb24gb25EZWFjdGl2YXRlZChob29rLCB0YXJnZXQpIHtcbiAgICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJkYVwiIC8qIExpZmVjeWNsZUhvb2tzLkRFQUNUSVZBVEVEICovLCB0YXJnZXQpO1xufVxuZXhwb3J0cy5vbkRlYWN0aXZhdGVkID0gb25EZWFjdGl2YXRlZDtcbmZ1bmN0aW9uIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCB0eXBlLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcbiAgICAvLyBjYWNoZSB0aGUgZGVhY3RpdmF0ZSBicmFuY2ggY2hlY2sgd3JhcHBlciBmb3IgaW5qZWN0ZWQgaG9va3Mgc28gdGhlIHNhbWVcbiAgICAvLyBob29rIGNhbiBiZSBwcm9wZXJseSBkZWR1cGVkIGJ5IHRoZSBzY2hlZHVsZXIuIFwiX193ZGNcIiBzdGFuZHMgZm9yIFwid2l0aFxuICAgIC8vIGRlYWN0aXZhdGlvbiBjaGVja1wiLlxuICAgIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dkYyB8fFxuICAgICAgICAoaG9vay5fX3dkYyA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIG9ubHkgZmlyZSB0aGUgaG9vayBpZiB0aGUgdGFyZ2V0IGluc3RhbmNlIGlzIE5PVCBpbiBhIGRlYWN0aXZhdGVkIGJyYW5jaC5cbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0O1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5pc0RlYWN0aXZhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvb2soKTtcbiAgICAgICAgfSk7XG4gICAgaW5qZWN0SG9vayh0eXBlLCB3cmFwcGVkSG9vaywgdGFyZ2V0KTtcbiAgICAvLyBJbiBhZGRpdGlvbiB0byByZWdpc3RlcmluZyBpdCBvbiB0aGUgdGFyZ2V0IGluc3RhbmNlLCB3ZSB3YWxrIHVwIHRoZSBwYXJlbnRcbiAgICAvLyBjaGFpbiBhbmQgcmVnaXN0ZXIgaXQgb24gYWxsIGFuY2VzdG9yIGluc3RhbmNlcyB0aGF0IGFyZSBrZWVwLWFsaXZlIHJvb3RzLlxuICAgIC8vIFRoaXMgYXZvaWRzIHRoZSBuZWVkIHRvIHdhbGsgdGhlIGVudGlyZSBjb21wb25lbnQgdHJlZSB3aGVuIGludm9raW5nIHRoZXNlXG4gICAgLy8gaG9va3MsIGFuZCBtb3JlIGltcG9ydGFudGx5LCBhdm9pZHMgdGhlIG5lZWQgdG8gdHJhY2sgY2hpbGQgY29tcG9uZW50cyBpblxuICAgIC8vIGFycmF5cy5cbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0LnBhcmVudDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChpc0tlZXBBbGl2ZShjdXJyZW50LnBhcmVudC52bm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpbmplY3RUb0tlZXBBbGl2ZVJvb3Qod3JhcHBlZEhvb2ssIHR5cGUsIHRhcmdldCwgY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpbmplY3RUb0tlZXBBbGl2ZVJvb3QoaG9vaywgdHlwZSwgdGFyZ2V0LCBrZWVwQWxpdmVSb290KSB7XG4gICAgLy8gaW5qZWN0SG9vayB3cmFwcyB0aGUgb3JpZ2luYWwgZm9yIGVycm9yIGhhbmRsaW5nLCBzbyBtYWtlIHN1cmUgdG8gcmVtb3ZlXG4gICAgLy8gdGhlIHdyYXBwZWQgdmVyc2lvbi5cbiAgICBjb25zdCBpbmplY3RlZCA9IGluamVjdEhvb2sodHlwZSwgaG9vaywga2VlcEFsaXZlUm9vdCwgdHJ1ZSAvKiBwcmVwZW5kICovKTtcbiAgICBvblVubW91bnRlZCgoKSA9PiB7XG4gICAgICAgICgwLCBzaGFyZWRfMS5yZW1vdmUpKGtlZXBBbGl2ZVJvb3RbdHlwZV0sIGluamVjdGVkKTtcbiAgICB9LCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gcmVzZXRTaGFwZUZsYWcodm5vZGUpIHtcbiAgICAvLyBiaXR3aXNlIG9wZXJhdGlvbnMgdG8gcmVtb3ZlIGtlZXAgYWxpdmUgZmxhZ3NcbiAgICB2bm9kZS5zaGFwZUZsYWcgJj0gfjI1NiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLztcbiAgICB2bm9kZS5zaGFwZUZsYWcgJj0gfjUxMiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVF9LRVBUX0FMSVZFICovO1xufVxuZnVuY3Rpb24gZ2V0SW5uZXJDaGlsZCh2bm9kZSkge1xuICAgIHJldHVybiB2bm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU2hhcGVGbGFncy5TVVNQRU5TRSAqLyA/IHZub2RlLnNzQ29udGVudCA6IHZub2RlO1xufVxuZnVuY3Rpb24gaW5qZWN0SG9vayh0eXBlLCBob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UsIHByZXBlbmQgPSBmYWxzZSkge1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgaG9va3MgPSB0YXJnZXRbdHlwZV0gfHwgKHRhcmdldFt0eXBlXSA9IFtdKTtcbiAgICAgICAgLy8gY2FjaGUgdGhlIGVycm9yIGhhbmRsaW5nIHdyYXBwZXIgZm9yIGluamVjdGVkIGhvb2tzIHNvIHRoZSBzYW1lIGhvb2tcbiAgICAgICAgLy8gY2FuIGJlIHByb3Blcmx5IGRlZHVwZWQgYnkgdGhlIHNjaGVkdWxlci4gXCJfX3dlaFwiIHN0YW5kcyBmb3IgXCJ3aXRoIGVycm9yXG4gICAgICAgIC8vIGhhbmRsaW5nXCIuXG4gICAgICAgIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dlaCB8fFxuICAgICAgICAgICAgKGhvb2suX193ZWggPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkaXNhYmxlIHRyYWNraW5nIGluc2lkZSBhbGwgbGlmZWN5Y2xlIGhvb2tzXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhleSBjYW4gcG90ZW50aWFsbHkgYmUgY2FsbGVkIGluc2lkZSBlZmZlY3RzLlxuICAgICAgICAgICAgICAgICgwLCByZWFjdGl2aXR5XzEucGF1c2VUcmFja2luZykoKTtcbiAgICAgICAgICAgICAgICAvLyBTZXQgY3VycmVudEluc3RhbmNlIGR1cmluZyBob29rIGludm9jYXRpb24uXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhc3N1bWVzIHRoZSBob29rIGRvZXMgbm90IHN5bmNocm9ub3VzbHkgdHJpZ2dlciBvdGhlciBob29rcywgd2hpY2hcbiAgICAgICAgICAgICAgICAvLyBjYW4gb25seSBiZSBmYWxzZSB3aGVuIHRoZSB1c2VyIGRvZXMgc29tZXRoaW5nIHJlYWxseSBmdW5reS5cbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCB0YXJnZXQsIHR5cGUsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgKDAsIHJlYWN0aXZpdHlfMS5yZXNldFRyYWNraW5nKSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgICAgIGhvb2tzLnVuc2hpZnQod3JhcHBlZEhvb2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaG9va3MucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyYXBwZWRIb29rO1xuICAgIH1cbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgY29uc3QgYXBpTmFtZSA9ICgwLCBzaGFyZWRfMS50b0hhbmRsZXJLZXkpKEVycm9yVHlwZVN0cmluZ3NbdHlwZV0ucmVwbGFjZSgvIGhvb2skLywgJycpKTtcbiAgICAgICAgd2FybihgJHthcGlOYW1lfSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgY29tcG9uZW50IGluc3RhbmNlIHRvIGJlIGAgK1xuICAgICAgICAgICAgYGFzc29jaWF0ZWQgd2l0aC4gYCArXG4gICAgICAgICAgICBgTGlmZWN5Y2xlIGluamVjdGlvbiBBUElzIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGV4ZWN1dGlvbiBvZiBzZXR1cCgpLmAgK1xuICAgICAgICAgICAgKGAgSWYgeW91IGFyZSB1c2luZyBhc3luYyBzZXR1cCgpLCBtYWtlIHN1cmUgdG8gcmVnaXN0ZXIgbGlmZWN5Y2xlIGAgK1xuICAgICAgICAgICAgICAgIGBob29rcyBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0IHN0YXRlbWVudC5gKSk7XG4gICAgfVxufVxuY29uc3QgY3JlYXRlSG9vayA9IChsaWZlY3ljbGUpID0+IChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpID0+IFxuLy8gcG9zdC1jcmVhdGUgbGlmZWN5Y2xlIHJlZ2lzdHJhdGlvbnMgYXJlIG5vb3BzIGR1cmluZyBTU1IgKGV4Y2VwdCBmb3Igc2VydmVyUHJlZmV0Y2gpXG4oIWlzSW5TU1JDb21wb25lbnRTZXR1cCB8fCBsaWZlY3ljbGUgPT09IFwic3BcIiAvKiBMaWZlY3ljbGVIb29rcy5TRVJWRVJfUFJFRkVUQ0ggKi8pICYmXG4gICAgaW5qZWN0SG9vayhsaWZlY3ljbGUsICguLi5hcmdzKSA9PiBob29rKC4uLmFyZ3MpLCB0YXJnZXQpO1xuY29uc3Qgb25CZWZvcmVNb3VudCA9IGNyZWF0ZUhvb2soXCJibVwiIC8qIExpZmVjeWNsZUhvb2tzLkJFRk9SRV9NT1VOVCAqLyk7XG5leHBvcnRzLm9uQmVmb3JlTW91bnQgPSBvbkJlZm9yZU1vdW50O1xuY29uc3Qgb25Nb3VudGVkID0gY3JlYXRlSG9vayhcIm1cIiAvKiBMaWZlY3ljbGVIb29rcy5NT1VOVEVEICovKTtcbmV4cG9ydHMub25Nb3VudGVkID0gb25Nb3VudGVkO1xuY29uc3Qgb25CZWZvcmVVcGRhdGUgPSBjcmVhdGVIb29rKFwiYnVcIiAvKiBMaWZlY3ljbGVIb29rcy5CRUZPUkVfVVBEQVRFICovKTtcbmV4cG9ydHMub25CZWZvcmVVcGRhdGUgPSBvbkJlZm9yZVVwZGF0ZTtcbmNvbnN0IG9uVXBkYXRlZCA9IGNyZWF0ZUhvb2soXCJ1XCIgLyogTGlmZWN5Y2xlSG9va3MuVVBEQVRFRCAqLyk7XG5leHBvcnRzLm9uVXBkYXRlZCA9IG9uVXBkYXRlZDtcbmNvbnN0IG9uQmVmb3JlVW5tb3VudCA9IGNyZWF0ZUhvb2soXCJidW1cIiAvKiBMaWZlY3ljbGVIb29rcy5CRUZPUkVfVU5NT1VOVCAqLyk7XG5leHBvcnRzLm9uQmVmb3JlVW5tb3VudCA9IG9uQmVmb3JlVW5tb3VudDtcbmNvbnN0IG9uVW5tb3VudGVkID0gY3JlYXRlSG9vayhcInVtXCIgLyogTGlmZWN5Y2xlSG9va3MuVU5NT1VOVEVEICovKTtcbmV4cG9ydHMub25Vbm1vdW50ZWQgPSBvblVubW91bnRlZDtcbmNvbnN0IG9uU2VydmVyUHJlZmV0Y2ggPSBjcmVhdGVIb29rKFwic3BcIiAvKiBMaWZlY3ljbGVIb29rcy5TRVJWRVJfUFJFRkVUQ0ggKi8pO1xuZXhwb3J0cy5vblNlcnZlclByZWZldGNoID0gb25TZXJ2ZXJQcmVmZXRjaDtcbmNvbnN0IG9uUmVuZGVyVHJpZ2dlcmVkID0gY3JlYXRlSG9vayhcInJ0Z1wiIC8qIExpZmVjeWNsZUhvb2tzLlJFTkRFUl9UUklHR0VSRUQgKi8pO1xuZXhwb3J0cy5vblJlbmRlclRyaWdnZXJlZCA9IG9uUmVuZGVyVHJpZ2dlcmVkO1xuY29uc3Qgb25SZW5kZXJUcmFja2VkID0gY3JlYXRlSG9vayhcInJ0Y1wiIC8qIExpZmVjeWNsZUhvb2tzLlJFTkRFUl9UUkFDS0VEICovKTtcbmV4cG9ydHMub25SZW5kZXJUcmFja2VkID0gb25SZW5kZXJUcmFja2VkO1xuZnVuY3Rpb24gb25FcnJvckNhcHR1cmVkKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xuICAgIGluamVjdEhvb2soXCJlY1wiIC8qIExpZmVjeWNsZUhvb2tzLkVSUk9SX0NBUFRVUkVEICovLCBob29rLCB0YXJnZXQpO1xufVxuZXhwb3J0cy5vbkVycm9yQ2FwdHVyZWQgPSBvbkVycm9yQ2FwdHVyZWQ7XG4vKipcblJ1bnRpbWUgaGVscGVyIGZvciBhcHBseWluZyBkaXJlY3RpdmVzIHRvIGEgdm5vZGUuIEV4YW1wbGUgdXNhZ2U6XG5cbmNvbnN0IGNvbXAgPSByZXNvbHZlQ29tcG9uZW50KCdjb21wJylcbmNvbnN0IGZvbyA9IHJlc29sdmVEaXJlY3RpdmUoJ2ZvbycpXG5jb25zdCBiYXIgPSByZXNvbHZlRGlyZWN0aXZlKCdiYXInKVxuXG5yZXR1cm4gd2l0aERpcmVjdGl2ZXMoaChjb21wKSwgW1xuICBbZm9vLCB0aGlzLnhdLFxuICBbYmFyLCB0aGlzLnldXG5dKVxuKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKSB7XG4gICAgaWYgKCgwLCBzaGFyZWRfMS5pc0J1aWx0SW5EaXJlY3RpdmUpKG5hbWUpKSB7XG4gICAgICAgIHdhcm4oJ0RvIG5vdCB1c2UgYnVpbHQtaW4gZGlyZWN0aXZlIGlkcyBhcyBjdXN0b20gZGlyZWN0aXZlIGlkOiAnICsgbmFtZSk7XG4gICAgfVxufVxuLyoqXG4gKiBBZGRzIGRpcmVjdGl2ZXMgdG8gYSBWTm9kZS5cbiAqL1xuZnVuY3Rpb24gd2l0aERpcmVjdGl2ZXModm5vZGUsIGRpcmVjdGl2ZXMpIHtcbiAgICBjb25zdCBpbnRlcm5hbEluc3RhbmNlID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGB3aXRoRGlyZWN0aXZlcyBjYW4gb25seSBiZSB1c2VkIGluc2lkZSByZW5kZXIgZnVuY3Rpb25zLmApO1xuICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgfVxuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0RXhwb3NlUHJveHkoaW50ZXJuYWxJbnN0YW5jZSkgfHxcbiAgICAgICAgaW50ZXJuYWxJbnN0YW5jZS5wcm94eTtcbiAgICBjb25zdCBiaW5kaW5ncyA9IHZub2RlLmRpcnMgfHwgKHZub2RlLmRpcnMgPSBbXSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJlY3RpdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBbZGlyLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMgPSBzaGFyZWRfMS5FTVBUWV9PQkpdID0gZGlyZWN0aXZlc1tpXTtcbiAgICAgICAgaWYgKGRpcikge1xuICAgICAgICAgICAgaWYgKCgwLCBzaGFyZWRfMS5pc0Z1bmN0aW9uKShkaXIpKSB7XG4gICAgICAgICAgICAgICAgZGlyID0ge1xuICAgICAgICAgICAgICAgICAgICBtb3VudGVkOiBkaXIsXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQ6IGRpclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlyLmRlZXApIHtcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm5vZGU7XG59XG5leHBvcnRzLndpdGhEaXJlY3RpdmVzID0gd2l0aERpcmVjdGl2ZXM7XG5mdW5jdGlvbiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBwcmV2Vk5vZGUsIGluc3RhbmNlLCBuYW1lKSB7XG4gICAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzO1xuICAgIGNvbnN0IG9sZEJpbmRpbmdzID0gcHJldlZOb2RlICYmIHByZXZWTm9kZS5kaXJzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuICAgICAgICBpZiAob2xkQmluZGluZ3MpIHtcbiAgICAgICAgICAgIGJpbmRpbmcub2xkVmFsdWUgPSBvbGRCaW5kaW5nc1tpXS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaG9vayA9IGJpbmRpbmcuZGlyW25hbWVdO1xuICAgICAgICBpZiAoaG9vaykge1xuICAgICAgICAgICAgLy8gZGlzYWJsZSB0cmFja2luZyBpbnNpZGUgYWxsIGxpZmVjeWNsZSBob29rc1xuICAgICAgICAgICAgLy8gc2luY2UgdGhleSBjYW4gcG90ZW50aWFsbHkgYmUgY2FsbGVkIGluc2lkZSBlZmZlY3RzLlxuICAgICAgICAgICAgKDAsIHJlYWN0aXZpdHlfMS5wYXVzZVRyYWNraW5nKSgpO1xuICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgaW5zdGFuY2UsIDggLyogRXJyb3JDb2Rlcy5ESVJFQ1RJVkVfSE9PSyAqLywgW1xuICAgICAgICAgICAgICAgIHZub2RlLmVsLFxuICAgICAgICAgICAgICAgIGJpbmRpbmcsXG4gICAgICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICAgICAgcHJldlZOb2RlXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICgwLCByZWFjdGl2aXR5XzEucmVzZXRUcmFja2luZykoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IENPTVBPTkVOVFMgPSAnY29tcG9uZW50cyc7XG5jb25zdCBESVJFQ1RJVkVTID0gJ2RpcmVjdGl2ZXMnO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50KG5hbWUsIG1heWJlU2VsZlJlZmVyZW5jZSkge1xuICAgIHJldHVybiByZXNvbHZlQXNzZXQoQ09NUE9ORU5UUywgbmFtZSwgdHJ1ZSwgbWF5YmVTZWxmUmVmZXJlbmNlKSB8fCBuYW1lO1xufVxuZXhwb3J0cy5yZXNvbHZlQ29tcG9uZW50ID0gcmVzb2x2ZUNvbXBvbmVudDtcbmNvbnN0IE5VTExfRFlOQU1JQ19DT01QT05FTlQgPSBTeW1ib2woKTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgaWYgKCgwLCBzaGFyZWRfMS5pc1N0cmluZykoY29tcG9uZW50KSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIGNvbXBvbmVudCwgZmFsc2UpIHx8IGNvbXBvbmVudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGludmFsaWQgdHlwZXMgd2lsbCBmYWxsdGhyb3VnaCB0byBjcmVhdGVWTm9kZSBhbmQgcmFpc2Ugd2FybmluZ1xuICAgICAgICByZXR1cm4gKGNvbXBvbmVudCB8fCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UKTtcbiAgICB9XG59XG5leHBvcnRzLnJlc29sdmVEeW5hbWljQ29tcG9uZW50ID0gcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQ7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVEaXJlY3RpdmUobmFtZSkge1xuICAgIHJldHVybiByZXNvbHZlQXNzZXQoRElSRUNUSVZFUywgbmFtZSk7XG59XG5leHBvcnRzLnJlc29sdmVEaXJlY3RpdmUgPSByZXNvbHZlRGlyZWN0aXZlO1xuLy8gaW1wbGVtZW50YXRpb25cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCh0eXBlLCBuYW1lLCB3YXJuTWlzc2luZyA9IHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfHwgY3VycmVudEluc3RhbmNlO1xuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xuICAgICAgICAvLyBleHBsaWNpdCBzZWxmIG5hbWUgaGFzIGhpZ2hlc3QgcHJpb3JpdHlcbiAgICAgICAgaWYgKHR5cGUgPT09IENPTVBPTkVOVFMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGZOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQsIGZhbHNlIC8qIGRvIG5vdCBpbmNsdWRlIGluZmVycmVkIG5hbWUgdG8gYXZvaWQgYnJlYWtpbmcgZXhpc3RpbmcgY29kZSAqLyk7XG4gICAgICAgICAgICBpZiAoc2VsZk5hbWUgJiZcbiAgICAgICAgICAgICAgICAoc2VsZk5hbWUgPT09IG5hbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgc2VsZk5hbWUgPT09ICgwLCBzaGFyZWRfMS5jYW1lbGl6ZSkobmFtZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgc2VsZk5hbWUgPT09ICgwLCBzaGFyZWRfMS5jYXBpdGFsaXplKSgoMCwgc2hhcmVkXzEuY2FtZWxpemUpKG5hbWUpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29tcG9uZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IFxuICAgICAgICAvLyBsb2NhbCByZWdpc3RyYXRpb25cbiAgICAgICAgLy8gY2hlY2sgaW5zdGFuY2VbdHlwZV0gZmlyc3Qgd2hpY2ggaXMgcmVzb2x2ZWQgZm9yIG9wdGlvbnMgQVBJXG4gICAgICAgIHJlc29sdmUoaW5zdGFuY2VbdHlwZV0gfHwgQ29tcG9uZW50W3R5cGVdLCBuYW1lKSB8fFxuICAgICAgICAgICAgLy8gZ2xvYmFsIHJlZ2lzdHJhdGlvblxuICAgICAgICAgICAgcmVzb2x2ZShpbnN0YW5jZS5hcHBDb250ZXh0W3R5cGVdLCBuYW1lKTtcbiAgICAgICAgaWYgKCFyZXMgJiYgbWF5YmVTZWxmUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byBpbXBsaWNpdCBzZWxmLXJlZmVyZW5jZVxuICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhID0gdHlwZSA9PT0gQ09NUE9ORU5UU1xuICAgICAgICAgICAgICAgID8gYFxcbklmIHRoaXMgaXMgYSBuYXRpdmUgY3VzdG9tIGVsZW1lbnQsIG1ha2Ugc3VyZSB0byBleGNsdWRlIGl0IGZyb20gYCArXG4gICAgICAgICAgICAgICAgICAgIGBjb21wb25lbnQgcmVzb2x1dGlvbiB2aWEgY29tcGlsZXJPcHRpb25zLmlzQ3VzdG9tRWxlbWVudC5gXG4gICAgICAgICAgICAgICAgOiBgYDtcbiAgICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byByZXNvbHZlICR7dHlwZS5zbGljZSgwLCAtMSl9OiAke25hbWV9JHtleHRyYX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgd2FybihgcmVzb2x2ZSR7KDAsIHNoYXJlZF8xLmNhcGl0YWxpemUpKHR5cGUuc2xpY2UoMCwgLTEpKX0gYCArXG4gICAgICAgICAgICBgY2FuIG9ubHkgYmUgdXNlZCBpbiByZW5kZXIoKSBvciBzZXR1cCgpLmApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmUocmVnaXN0cnksIG5hbWUpIHtcbiAgICByZXR1cm4gKHJlZ2lzdHJ5ICYmXG4gICAgICAgIChyZWdpc3RyeVtuYW1lXSB8fFxuICAgICAgICAgICAgcmVnaXN0cnlbKDAsIHNoYXJlZF8xLmNhbWVsaXplKShuYW1lKV0gfHxcbiAgICAgICAgICAgIHJlZ2lzdHJ5WygwLCBzaGFyZWRfMS5jYXBpdGFsaXplKSgoMCwgc2hhcmVkXzEuY2FtZWxpemUpKG5hbWUpKV0pKTtcbn1cbi8qKlxuICogQWN0dWFsIGltcGxlbWVudGF0aW9uXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3Qoc291cmNlLCByZW5kZXJJdGVtLCBjYWNoZSwgaW5kZXgpIHtcbiAgICBsZXQgcmV0O1xuICAgIGNvbnN0IGNhY2hlZCA9IChjYWNoZSAmJiBjYWNoZVtpbmRleF0pO1xuICAgIGlmICgoMCwgc2hhcmVkXzEuaXNBcnJheSkoc291cmNlKSB8fCAoMCwgc2hhcmVkXzEuaXNTdHJpbmcpKHNvdXJjZSkpIHtcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oc291cmNlW2ldLCBpLCB1bmRlZmluZWQsIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIU51bWJlci5pc0ludGVnZXIoc291cmNlKSkge1xuICAgICAgICAgICAgd2FybihgVGhlIHYtZm9yIHJhbmdlIGV4cGVjdCBhbiBpbnRlZ2VyIHZhbHVlIGJ1dCBnb3QgJHtzb3VyY2V9LmApO1xuICAgICAgICB9XG4gICAgICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZTsgaSsrKSB7XG4gICAgICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKGkgKyAxLCBpLCB1bmRlZmluZWQsIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBzaGFyZWRfMS5pc09iamVjdCkoc291cmNlKSkge1xuICAgICAgICBpZiAoc291cmNlW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgICAgICAgIHJldCA9IEFycmF5LmZyb20oc291cmNlLCAoaXRlbSwgaSkgPT4gcmVuZGVySXRlbShpdGVtLCBpLCB1bmRlZmluZWQsIGNhY2hlZCAmJiBjYWNoZWRbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oc291cmNlW2tleV0sIGtleSwgaSwgY2FjaGVkICYmIGNhY2hlZFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldCA9IFtdO1xuICAgIH1cbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgY2FjaGVbaW5kZXhdID0gcmV0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuZXhwb3J0cy5yZW5kZXJMaXN0ID0gcmVuZGVyTGlzdDtcbi8qKlxuICogQ29tcGlsZXIgcnVudGltZSBoZWxwZXIgZm9yIGNyZWF0aW5nIGR5bmFtaWMgc2xvdHMgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVTbG90cyhzbG90cywgZHluYW1pY1Nsb3RzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljU2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2xvdCA9IGR5bmFtaWNTbG90c1tpXTtcbiAgICAgICAgLy8gYXJyYXkgb2YgZHluYW1pYyBzbG90IGdlbmVyYXRlZCBieSA8dGVtcGxhdGUgdi1mb3I9XCIuLi5cIiAjWy4uLl0+XG4gICAgICAgIGlmICgoMCwgc2hhcmVkXzEuaXNBcnJheSkoc2xvdCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2xvdC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHNsb3RzW3Nsb3Rbal0ubmFtZV0gPSBzbG90W2pdLmZuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNsb3QpIHtcbiAgICAgICAgICAgIC8vIGNvbmRpdGlvbmFsIHNpbmdsZSBzbG90IGdlbmVyYXRlZCBieSA8dGVtcGxhdGUgdi1pZj1cIi4uLlwiICNmb28+XG4gICAgICAgICAgICBzbG90c1tzbG90Lm5hbWVdID0gc2xvdC5rZXlcbiAgICAgICAgICAgICAgICA/ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHNsb3QuZm4oLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGF0dGFjaCBicmFuY2gga2V5IHNvIGVhY2ggY29uZGl0aW9uYWwgYnJhbmNoIGlzIGNvbnNpZGVyZWQgYVxuICAgICAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbnQgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5rZXkgPSBzbG90LmtleTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiBzbG90LmZuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzbG90cztcbn1cbmV4cG9ydHMuY3JlYXRlU2xvdHMgPSBjcmVhdGVTbG90cztcbi8qKlxuICogQ29tcGlsZXIgcnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBgPHNsb3QvPmBcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3Qoc2xvdHMsIG5hbWUsIHByb3BzID0ge30sIFxuLy8gdGhpcyBpcyBub3QgYSB1c2VyLWZhY2luZyBmdW5jdGlvbiwgc28gdGhlIGZhbGxiYWNrIGlzIGFsd2F5cyBnZW5lcmF0ZWQgYnlcbi8vIHRoZSBjb21waWxlciBhbmQgZ3VhcmFudGVlZCB0byBiZSBhIGZ1bmN0aW9uIHJldHVybmluZyBhbiBhcnJheVxuZmFsbGJhY2ssIG5vU2xvdHRlZCkge1xuICAgIGlmIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UuaXNDRSB8fFxuICAgICAgICAoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudCAmJlxuICAgICAgICAgICAgaXNBc3luY1dyYXBwZXIoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudCkgJiZcbiAgICAgICAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5wYXJlbnQuaXNDRSkpIHtcbiAgICAgICAgaWYgKG5hbWUgIT09ICdkZWZhdWx0JylcbiAgICAgICAgICAgIHByb3BzLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoJ3Nsb3QnLCBwcm9wcywgZmFsbGJhY2sgJiYgZmFsbGJhY2soKSk7XG4gICAgfVxuICAgIGxldCBzbG90ID0gc2xvdHNbbmFtZV07XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzbG90ICYmIHNsb3QubGVuZ3RoID4gMSkge1xuICAgICAgICB3YXJuKGBTU1Itb3B0aW1pemVkIHNsb3QgZnVuY3Rpb24gZGV0ZWN0ZWQgaW4gYSBub24tU1NSLW9wdGltaXplZCByZW5kZXIgYCArXG4gICAgICAgICAgICBgZnVuY3Rpb24uIFlvdSBuZWVkIHRvIG1hcmsgdGhpcyBjb21wb25lbnQgd2l0aCAkZHluYW1pYy1zbG90cyBpbiB0aGUgYCArXG4gICAgICAgICAgICBgcGFyZW50IHRlbXBsYXRlLmApO1xuICAgICAgICBzbG90ID0gKCkgPT4gW107XG4gICAgfVxuICAgIC8vIGEgY29tcGlsZWQgc2xvdCBkaXNhYmxlcyBibG9jayB0cmFja2luZyBieSBkZWZhdWx0IHRvIGF2b2lkIG1hbnVhbFxuICAgIC8vIGludm9jYXRpb24gaW50ZXJmZXJpbmcgd2l0aCB0ZW1wbGF0ZS1iYXNlZCBibG9jayB0cmFja2luZywgYnV0IGluXG4gICAgLy8gYHJlbmRlclNsb3RgIHdlIGNhbiBiZSBzdXJlIHRoYXQgaXQncyB0ZW1wbGF0ZS1iYXNlZCBzbyB3ZSBjYW4gZm9yY2VcbiAgICAvLyBlbmFibGUgaXQuXG4gICAgaWYgKHNsb3QgJiYgc2xvdC5fYykge1xuICAgICAgICBzbG90Ll9kID0gZmFsc2U7XG4gICAgfVxuICAgIG9wZW5CbG9jaygpO1xuICAgIGNvbnN0IHZhbGlkU2xvdENvbnRlbnQgPSBzbG90ICYmIGVuc3VyZVZhbGlkVk5vZGUoc2xvdChwcm9wcykpO1xuICAgIGNvbnN0IHJlbmRlcmVkID0gY3JlYXRlQmxvY2soRnJhZ21lbnQsIHtcbiAgICAgICAga2V5OiBwcm9wcy5rZXkgfHxcbiAgICAgICAgICAgIC8vIHNsb3QgY29udGVudCBhcnJheSBvZiBhIGR5bmFtaWMgY29uZGl0aW9uYWwgc2xvdCBtYXkgaGF2ZSBhIGJyYW5jaFxuICAgICAgICAgICAgLy8ga2V5IGF0dGFjaGVkIGluIHRoZSBgY3JlYXRlU2xvdHNgIGhlbHBlciwgcmVzcGVjdCB0aGF0XG4gICAgICAgICAgICAodmFsaWRTbG90Q29udGVudCAmJiB2YWxpZFNsb3RDb250ZW50LmtleSkgfHxcbiAgICAgICAgICAgIGBfJHtuYW1lfWBcbiAgICB9LCB2YWxpZFNsb3RDb250ZW50IHx8IChmYWxsYmFjayA/IGZhbGxiYWNrKCkgOiBbXSksIHZhbGlkU2xvdENvbnRlbnQgJiYgc2xvdHMuXyA9PT0gMSAvKiBTbG90RmxhZ3MuU1RBQkxFICovXG4gICAgICAgID8gNjQgLyogUGF0Y2hGbGFncy5TVEFCTEVfRlJBR01FTlQgKi9cbiAgICAgICAgOiAtMiAvKiBQYXRjaEZsYWdzLkJBSUwgKi8pO1xuICAgIGlmICghbm9TbG90dGVkICYmIHJlbmRlcmVkLnNjb3BlSWQpIHtcbiAgICAgICAgcmVuZGVyZWQuc2xvdFNjb3BlSWRzID0gW3JlbmRlcmVkLnNjb3BlSWQgKyAnLXMnXTtcbiAgICB9XG4gICAgaWYgKHNsb3QgJiYgc2xvdC5fYykge1xuICAgICAgICBzbG90Ll9kID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbmRlcmVkO1xufVxuZXhwb3J0cy5yZW5kZXJTbG90ID0gcmVuZGVyU2xvdDtcbmZ1bmN0aW9uIGVuc3VyZVZhbGlkVk5vZGUodm5vZGVzKSB7XG4gICAgcmV0dXJuIHZub2Rlcy5zb21lKGNoaWxkID0+IHtcbiAgICAgICAgaWYgKCFpc1ZOb2RlKGNoaWxkKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gQ29tbWVudClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50ICYmXG4gICAgICAgICAgICAhZW5zdXJlVmFsaWRWTm9kZShjaGlsZC5jaGlsZHJlbikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pXG4gICAgICAgID8gdm5vZGVzXG4gICAgICAgIDogbnVsbDtcbn1cbi8qKlxuICogRm9yIHByZWZpeGluZyBrZXlzIGluIHYtb249XCJvYmpcIiB3aXRoIFwib25cIlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdG9IYW5kbGVycyhvYmosIHByZXNlcnZlQ2FzZUlmTmVjZXNzYXJ5KSB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhKDAsIHNoYXJlZF8xLmlzT2JqZWN0KShvYmopKSB7XG4gICAgICAgIHdhcm4oYHYtb24gd2l0aCBubyBhcmd1bWVudCBleHBlY3RzIGFuIG9iamVjdCB2YWx1ZS5gKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIHJldFtwcmVzZXJ2ZUNhc2VJZk5lY2Vzc2FyeSAmJiAvW0EtWl0vLnRlc3Qoa2V5KVxuICAgICAgICAgICAgPyBgb246JHtrZXl9YFxuICAgICAgICAgICAgOiAoMCwgc2hhcmVkXzEudG9IYW5kbGVyS2V5KShrZXkpXSA9IG9ialtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuZXhwb3J0cy50b0hhbmRsZXJzID0gdG9IYW5kbGVycztcbi8qKlxuICogIzI0MzcgSW4gVnVlIDMsIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBkbyBub3QgaGF2ZSBhIHB1YmxpYyBpbnN0YW5jZSBwcm94eSBidXRcbiAqIHRoZXkgZXhpc3QgaW4gdGhlIGludGVybmFsIHBhcmVudCBjaGFpbi4gRm9yIGNvZGUgdGhhdCByZWxpZXMgb24gdHJhdmVyc2luZ1xuICogcHVibGljICRwYXJlbnQgY2hhaW5zLCBza2lwIGZ1bmN0aW9uYWwgb25lcyBhbmQgZ28gdG8gdGhlIHBhcmVudCBpbnN0ZWFkLlxuICovXG5jb25zdCBnZXRQdWJsaWNJbnN0YW5jZSA9IChpKSA9PiB7XG4gICAgaWYgKCFpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoaXNTdGF0ZWZ1bENvbXBvbmVudChpKSlcbiAgICAgICAgcmV0dXJuIGdldEV4cG9zZVByb3h5KGkpIHx8IGkucHJveHk7XG4gICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KTtcbn07XG5jb25zdCBwdWJsaWNQcm9wZXJ0aWVzTWFwID0gXG4vLyBNb3ZlIFBVUkUgbWFya2VyIHRvIG5ldyBsaW5lIHRvIHdvcmthcm91bmQgY29tcGlsZXIgZGlzY2FyZGluZyBpdFxuLy8gZHVlIHRvIHR5cGUgYW5ub3RhdGlvblxuLyojX19QVVJFX18qLyAoMCwgc2hhcmVkXzEuZXh0ZW5kKShPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gICAgJDogaSA9PiBpLFxuICAgICRlbDogaSA9PiBpLnZub2RlLmVsLFxuICAgICRkYXRhOiBpID0+IGkuZGF0YSxcbiAgICAkcHJvcHM6IGkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICgwLCByZWFjdGl2aXR5XzEuc2hhbGxvd1JlYWRvbmx5KShpLnByb3BzKSA6IGkucHJvcHMpLFxuICAgICRhdHRyczogaSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gKDAsIHJlYWN0aXZpdHlfMS5zaGFsbG93UmVhZG9ubHkpKGkuYXR0cnMpIDogaS5hdHRycyksXG4gICAgJHNsb3RzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAoMCwgcmVhY3Rpdml0eV8xLnNoYWxsb3dSZWFkb25seSkoaS5zbG90cykgOiBpLnNsb3RzKSxcbiAgICAkcmVmczogaSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gKDAsIHJlYWN0aXZpdHlfMS5zaGFsbG93UmVhZG9ubHkpKGkucmVmcykgOiBpLnJlZnMpLFxuICAgICRwYXJlbnQ6IGkgPT4gZ2V0UHVibGljSW5zdGFuY2UoaS5wYXJlbnQpLFxuICAgICRyb290OiBpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucm9vdCksXG4gICAgJGVtaXQ6IGkgPT4gaS5lbWl0LFxuICAgICRvcHRpb25zOiBpID0+IChfX1ZVRV9PUFRJT05TX0FQSV9fID8gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaSkgOiBpLnR5cGUpLFxuICAgICRmb3JjZVVwZGF0ZTogaSA9PiBpLmYgfHwgKGkuZiA9ICgpID0+IHF1ZXVlSm9iKGkudXBkYXRlKSksXG4gICAgJG5leHRUaWNrOiBpID0+IGkubiB8fCAoaS5uID0gbmV4dFRpY2suYmluZChpLnByb3h5KSksXG4gICAgJHdhdGNoOiBpID0+IChfX1ZVRV9PUFRJT05TX0FQSV9fID8gaW5zdGFuY2VXYXRjaC5iaW5kKGkpIDogc2hhcmVkXzEuTk9PUClcbn0pO1xuY29uc3QgaXNSZXNlcnZlZFByZWZpeCA9IChrZXkpID0+IGtleSA9PT0gJ18nIHx8IGtleSA9PT0gJyQnO1xuY29uc3QgaGFzU2V0dXBCaW5kaW5nID0gKHN0YXRlLCBrZXkpID0+IHN0YXRlICE9PSBzaGFyZWRfMS5FTVBUWV9PQkogJiYgIXN0YXRlLl9faXNTY3JpcHRTZXR1cCAmJiAoMCwgc2hhcmVkXzEuaGFzT3duKShzdGF0ZSwga2V5KTtcbmNvbnN0IFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyA9IHtcbiAgICBnZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXkpIHtcbiAgICAgICAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUsIGRhdGEsIHByb3BzLCBhY2Nlc3NDYWNoZSwgdHlwZSwgYXBwQ29udGV4dCB9ID0gaW5zdGFuY2U7XG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCBmb3JtYXR0ZXJzIHRvIGtub3cgdGhhdCB0aGlzIGlzIGEgVnVlIGluc3RhbmNlXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5ID09PSAnX19pc1Z1ZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRhdGEgLyBwcm9wcyAvIGN0eFxuICAgICAgICAvLyBUaGlzIGdldHRlciBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgcHJvcGVydHkgYWNjZXNzIG9uIHRoZSByZW5kZXIgY29udGV4dFxuICAgICAgICAvLyBkdXJpbmcgcmVuZGVyIGFuZCBpcyBhIG1ham9yIGhvdHNwb3QuIFRoZSBtb3N0IGV4cGVuc2l2ZSBwYXJ0IG9mIHRoaXNcbiAgICAgICAgLy8gaXMgdGhlIG11bHRpcGxlIGhhc093bigpIGNhbGxzLiBJdCdzIG11Y2ggZmFzdGVyIHRvIGRvIGEgc2ltcGxlIHByb3BlcnR5XG4gICAgICAgIC8vIGFjY2VzcyBvbiBhIHBsYWluIG9iamVjdCwgc28gd2UgdXNlIGFuIGFjY2Vzc0NhY2hlIG9iamVjdCAod2l0aCBudWxsXG4gICAgICAgIC8vIHByb3RvdHlwZSkgdG8gbWVtb2l6ZSB3aGF0IGFjY2VzcyB0eXBlIGEga2V5IGNvcnJlc3BvbmRzIHRvLlxuICAgICAgICBsZXQgbm9ybWFsaXplZFByb3BzO1xuICAgICAgICBpZiAoa2V5WzBdICE9PSAnJCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBhY2Nlc3NDYWNoZVtrZXldO1xuICAgICAgICAgICAgaWYgKG4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEgLyogQWNjZXNzVHlwZXMuU0VUVVAgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDIgLyogQWNjZXNzVHlwZXMuREFUQSAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNCAvKiBBY2Nlc3NUeXBlcy5DT05URVhUICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDMgLyogQWNjZXNzVHlwZXMuUFJPUFMgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdDoganVzdCBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc1NldHVwQmluZGluZyhzZXR1cFN0YXRlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDEgLyogQWNjZXNzVHlwZXMuU0VUVVAgKi87XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEgIT09IHNoYXJlZF8xLkVNUFRZX09CSiAmJiAoMCwgc2hhcmVkXzEuaGFzT3duKShkYXRhLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDIgLyogQWNjZXNzVHlwZXMuREFUQSAqLztcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAvLyBvbmx5IGNhY2hlIG90aGVyIHByb3BlcnRpZXMgd2hlbiBpbnN0YW5jZSBoYXMgZGVjbGFyZWQgKHRodXMgc3RhYmxlKVxuICAgICAgICAgICAgLy8gcHJvcHNcbiAgICAgICAgICAgIChub3JtYWxpemVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF0pICYmXG4gICAgICAgICAgICAgICAgKDAsIHNoYXJlZF8xLmhhc093bikobm9ybWFsaXplZFByb3BzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDMgLyogQWNjZXNzVHlwZXMuUFJPUFMgKi87XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdHggIT09IHNoYXJlZF8xLkVNUFRZX09CSiAmJiAoMCwgc2hhcmVkXzEuaGFzT3duKShjdHgsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gNCAvKiBBY2Nlc3NUeXBlcy5DT05URVhUICovO1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX1ZVRV9PUFRJT05TX0FQSV9fIHx8IHNob3VsZENhY2hlQWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDAgLyogQWNjZXNzVHlwZXMuT1RIRVIgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHVibGljR2V0dGVyID0gcHVibGljUHJvcGVydGllc01hcFtrZXldO1xuICAgICAgICBsZXQgY3NzTW9kdWxlLCBnbG9iYWxQcm9wZXJ0aWVzO1xuICAgICAgICAvLyBwdWJsaWMgJHh4eCBwcm9wZXJ0aWVzXG4gICAgICAgIGlmIChwdWJsaWNHZXR0ZXIpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICckYXR0cnMnKSB7XG4gICAgICAgICAgICAgICAgKDAsIHJlYWN0aXZpdHlfMS50cmFjaykoaW5zdGFuY2UsIFwiZ2V0XCIgLyogVHJhY2tPcFR5cGVzLkdFVCAqLywga2V5KTtcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwdWJsaWNHZXR0ZXIoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAvLyBjc3MgbW9kdWxlIChpbmplY3RlZCBieSB2dWUtbG9hZGVyKVxuICAgICAgICAoY3NzTW9kdWxlID0gdHlwZS5fX2Nzc01vZHVsZXMpICYmXG4gICAgICAgICAgICAoY3NzTW9kdWxlID0gY3NzTW9kdWxlW2tleV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gY3NzTW9kdWxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN0eCAhPT0gc2hhcmVkXzEuRU1QVFlfT0JKICYmICgwLCBzaGFyZWRfMS5oYXNPd24pKGN0eCwga2V5KSkge1xuICAgICAgICAgICAgLy8gdXNlciBtYXkgc2V0IGN1c3RvbSBwcm9wZXJ0aWVzIHRvIGB0aGlzYCB0aGF0IHN0YXJ0IHdpdGggYCRgXG4gICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gNCAvKiBBY2Nlc3NUeXBlcy5DT05URVhUICovO1xuICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAvLyBnbG9iYWwgcHJvcGVydGllc1xuICAgICAgICAoKGdsb2JhbFByb3BlcnRpZXMgPSBhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzKSxcbiAgICAgICAgICAgICgwLCBzaGFyZWRfMS5oYXNPd24pKGdsb2JhbFByb3BlcnRpZXMsIGtleSkpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSAmJlxuICAgICAgICAgICAgKCEoMCwgc2hhcmVkXzEuaXNTdHJpbmcpKGtleSkgfHxcbiAgICAgICAgICAgICAgICAvLyAjMTA5MSBhdm9pZCBpbnRlcm5hbCBpc1JlZi9pc1ZOb2RlIGNoZWNrcyBvbiBjb21wb25lbnQgaW5zdGFuY2UgbGVhZGluZ1xuICAgICAgICAgICAgICAgIC8vIHRvIGluZmluaXRlIHdhcm5pbmcgbG9vcFxuICAgICAgICAgICAgICAgIGtleS5pbmRleE9mKCdfX3YnKSAhPT0gMCkpIHtcbiAgICAgICAgICAgIGlmIChkYXRhICE9PSBzaGFyZWRfMS5FTVBUWV9PQkogJiYgaXNSZXNlcnZlZFByZWZpeChrZXlbMF0pICYmICgwLCBzaGFyZWRfMS5oYXNPd24pKGRhdGEsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IG11c3QgYmUgYWNjZXNzZWQgdmlhICRkYXRhIGJlY2F1c2UgaXQgc3RhcnRzIHdpdGggYSByZXNlcnZlZCBgICtcbiAgICAgICAgICAgICAgICAgICAgYGNoYXJhY3RlciAoXCIkXCIgb3IgXCJfXCIpIGFuZCBpcyBub3QgcHJveGllZCBvbiB0aGUgcmVuZGVyIGNvbnRleHQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnN0YW5jZSA9PT0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgd2FybihgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSB3YXMgYWNjZXNzZWQgZHVyaW5nIHJlbmRlciBgICtcbiAgICAgICAgICAgICAgICAgICAgYGJ1dCBpcyBub3QgZGVmaW5lZCBvbiBpbnN0YW5jZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2V0KHsgXzogaW5zdGFuY2UgfSwga2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCB7IGRhdGEsIHNldHVwU3RhdGUsIGN0eCB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGlmIChoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgICAgICAgc2V0dXBTdGF0ZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgIHNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwICYmXG4gICAgICAgICAgICAoMCwgc2hhcmVkXzEuaGFzT3duKShzZXR1cFN0YXRlLCBrZXkpKSB7XG4gICAgICAgICAgICB3YXJuKGBDYW5ub3QgbXV0YXRlIDxzY3JpcHQgc2V0dXA+IGJpbmRpbmcgXCIke2tleX1cIiBmcm9tIE9wdGlvbnMgQVBJLmApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEgIT09IHNoYXJlZF8xLkVNUFRZX09CSiAmJiAoMCwgc2hhcmVkXzEuaGFzT3duKShkYXRhLCBrZXkpKSB7XG4gICAgICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCBzaGFyZWRfMS5oYXNPd24pKGluc3RhbmNlLnByb3BzLCBrZXkpKSB7XG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHJvcCBcIiR7a2V5fVwiLiBQcm9wcyBhcmUgcmVhZG9ubHkuYCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleVswXSA9PT0gJyQnICYmIGtleS5zbGljZSgxKSBpbiBpbnN0YW5jZSkge1xuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgd2FybihgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHVibGljIHByb3BlcnR5IFwiJHtrZXl9XCIuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgUHJvcGVydGllcyBzdGFydGluZyB3aXRoICQgYXJlIHJlc2VydmVkIGFuZCByZWFkb25seS5gKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5IGluIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGhhcyh7IF86IHsgZGF0YSwgc2V0dXBTdGF0ZSwgYWNjZXNzQ2FjaGUsIGN0eCwgYXBwQ29udGV4dCwgcHJvcHNPcHRpb25zIH0gfSwga2V5KSB7XG4gICAgICAgIGxldCBub3JtYWxpemVkUHJvcHM7XG4gICAgICAgIHJldHVybiAoISFhY2Nlc3NDYWNoZVtrZXldIHx8XG4gICAgICAgICAgICAoZGF0YSAhPT0gc2hhcmVkXzEuRU1QVFlfT0JKICYmICgwLCBzaGFyZWRfMS5oYXNPd24pKGRhdGEsIGtleSkpIHx8XG4gICAgICAgICAgICBoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSB8fFxuICAgICAgICAgICAgKChub3JtYWxpemVkUHJvcHMgPSBwcm9wc09wdGlvbnNbMF0pICYmICgwLCBzaGFyZWRfMS5oYXNPd24pKG5vcm1hbGl6ZWRQcm9wcywga2V5KSkgfHxcbiAgICAgICAgICAgICgwLCBzaGFyZWRfMS5oYXNPd24pKGN0eCwga2V5KSB8fFxuICAgICAgICAgICAgKDAsIHNoYXJlZF8xLmhhc093bikocHVibGljUHJvcGVydGllc01hcCwga2V5KSB8fFxuICAgICAgICAgICAgKDAsIHNoYXJlZF8xLmhhc093bikoYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcywga2V5KSk7XG4gICAgfSxcbiAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgICAgICBpZiAoZGVzY3JpcHRvci5nZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gaW52YWxpZGF0ZSBrZXkgY2FjaGUgb2YgYSBnZXR0ZXIgYmFzZWQgcHJvcGVydHkgIzU0MTdcbiAgICAgICAgICAgIHRhcmdldC5fLmFjY2Vzc0NhY2hlW2tleV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCBzaGFyZWRfMS5oYXNPd24pKGRlc2NyaXB0b3IsICd2YWx1ZScpKSB7XG4gICAgICAgICAgICB0aGlzLnNldCh0YXJnZXQsIGtleSwgZGVzY3JpcHRvci52YWx1ZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn07XG5pZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFmYWxzZSkge1xuICAgIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5vd25LZXlzID0gKHRhcmdldCkgPT4ge1xuICAgICAgICB3YXJuKGBBdm9pZCBhcHAgbG9naWMgdGhhdCByZWxpZXMgb24gZW51bWVyYXRpbmcga2V5cyBvbiBhIGNvbXBvbmVudCBpbnN0YW5jZS4gYCArXG4gICAgICAgICAgICBgVGhlIGtleXMgd2lsbCBiZSBlbXB0eSBpbiBwcm9kdWN0aW9uIG1vZGUgdG8gYXZvaWQgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuYCk7XG4gICAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbiAgICB9O1xufVxuY29uc3QgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzID0gLyojX19QVVJFX18qLyAoMCwgc2hhcmVkXzEuZXh0ZW5kKSh7fSwgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLCB7XG4gICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICAgIC8vIGZhc3QgcGF0aCBmb3IgdW5zY29wYWJsZXMgd2hlbiB1c2luZyBgd2l0aGAgYmxvY2tcbiAgICAgICAgaWYgKGtleSA9PT0gU3ltYm9sLnVuc2NvcGFibGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5nZXQodGFyZ2V0LCBrZXksIHRhcmdldCk7XG4gICAgfSxcbiAgICBoYXMoXywga2V5KSB7XG4gICAgICAgIGNvbnN0IGhhcyA9IGtleVswXSAhPT0gJ18nICYmICEoMCwgc2hhcmVkXzEuaXNHbG9iYWxseVdoaXRlbGlzdGVkKShrZXkpO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFoYXMgJiYgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLmhhcyhfLCBrZXkpKSB7XG4gICAgICAgICAgICB3YXJuKGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IHNob3VsZCBub3Qgc3RhcnQgd2l0aCBfIHdoaWNoIGlzIGEgcmVzZXJ2ZWQgcHJlZml4IGZvciBWdWUgaW50ZXJuYWxzLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYXM7XG4gICAgfVxufSk7XG4vLyBkZXYgb25seVxuLy8gSW4gZGV2IG1vZGUsIHRoZSBwcm94eSB0YXJnZXQgZXhwb3NlcyB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzIHNlZW4gb24gYHRoaXNgXG4vLyBmb3IgZWFzaWVyIGNvbnNvbGUgaW5zcGVjdGlvbi4gSW4gcHJvZCBtb2RlIGl0IHdpbGwgYmUgYW4gZW1wdHkgb2JqZWN0IHNvXG4vLyB0aGVzZSBwcm9wZXJ0aWVzIGRlZmluaXRpb25zIGNhbiBiZSBza2lwcGVkLlxuZnVuY3Rpb24gY3JlYXRlRGV2UmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xuICAgIGNvbnN0IHRhcmdldCA9IHt9O1xuICAgIC8vIGV4cG9zZSBpbnRlcm5hbCBpbnN0YW5jZSBmb3IgcHJveHkgaGFuZGxlcnNcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBgX2AsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0OiAoKSA9PiBpbnN0YW5jZVxuICAgIH0pO1xuICAgIC8vIGV4cG9zZSBwdWJsaWMgcHJvcGVydGllc1xuICAgIE9iamVjdC5rZXlzKHB1YmxpY1Byb3BlcnRpZXNNYXApLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGdldDogKCkgPT4gcHVibGljUHJvcGVydGllc01hcFtrZXldKGluc3RhbmNlKSxcbiAgICAgICAgICAgIC8vIGludGVyY2VwdGVkIGJ5IHRoZSBwcm94eSBzbyBubyBuZWVkIGZvciBpbXBsZW1lbnRhdGlvbixcbiAgICAgICAgICAgIC8vIGJ1dCBuZWVkZWQgdG8gcHJldmVudCBzZXQgZXJyb3JzXG4gICAgICAgICAgICBzZXQ6IHNoYXJlZF8xLk5PT1BcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbi8vIGRldiBvbmx5XG5mdW5jdGlvbiBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xuICAgIGNvbnN0IHsgY3R4LCBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdIH0gPSBpbnN0YW5jZTtcbiAgICBpZiAocHJvcHNPcHRpb25zKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHByb3BzT3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBpbnN0YW5jZS5wcm9wc1trZXldLFxuICAgICAgICAgICAgICAgIHNldDogc2hhcmVkXzEuTk9PUFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIGRldiBvbmx5XG5mdW5jdGlvbiBleHBvc2VTZXR1cFN0YXRlT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XG4gICAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUgfSA9IGluc3RhbmNlO1xuICAgIE9iamVjdC5rZXlzKCgwLCByZWFjdGl2aXR5XzEudG9SYXcpKHNldHVwU3RhdGUpKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmICghc2V0dXBTdGF0ZS5fX2lzU2NyaXB0U2V0dXApIHtcbiAgICAgICAgICAgIGlmIChpc1Jlc2VydmVkUHJlZml4KGtleVswXSkpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBzZXR1cCgpIHJldHVybiBwcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IHNob3VsZCBub3Qgc3RhcnQgd2l0aCBcIiRcIiBvciBcIl9cIiBgICtcbiAgICAgICAgICAgICAgICAgICAgYHdoaWNoIGFyZSByZXNlcnZlZCBwcmVmaXhlcyBmb3IgVnVlIGludGVybmFscy5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHNldHVwU3RhdGVba2V5XSxcbiAgICAgICAgICAgICAgICBzZXQ6IHNoYXJlZF8xLk5PT1BcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVEdXBsaWNhdGVDaGVja2VyKCkge1xuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gKHR5cGUsIGtleSkgPT4ge1xuICAgICAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgICAgICAgd2FybihgJHt0eXBlfSBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiAke2NhY2hlW2tleV19LmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVba2V5XSA9IHR5cGU7XG4gICAgICAgIH1cbiAgICB9O1xufVxubGV0IHNob3VsZENhY2hlQWNjZXNzID0gdHJ1ZTtcbmZ1bmN0aW9uIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSk7XG4gICAgY29uc3QgcHVibGljVGhpcyA9IGluc3RhbmNlLnByb3h5O1xuICAgIGNvbnN0IGN0eCA9IGluc3RhbmNlLmN0eDtcbiAgICAvLyBkbyBub3QgY2FjaGUgcHJvcGVydHkgYWNjZXNzIG9uIHB1YmxpYyBwcm94eSBkdXJpbmcgc3RhdGUgaW5pdGlhbGl6YXRpb25cbiAgICBzaG91bGRDYWNoZUFjY2VzcyA9IGZhbHNlO1xuICAgIC8vIGNhbGwgYmVmb3JlQ3JlYXRlIGZpcnN0IGJlZm9yZSBhY2Nlc3Npbmcgb3RoZXIgb3B0aW9ucyBzaW5jZVxuICAgIC8vIHRoZSBob29rIG1heSBtdXRhdGUgcmVzb2x2ZWQgb3B0aW9ucyAoIzI3OTEpXG4gICAgaWYgKG9wdGlvbnMuYmVmb3JlQ3JlYXRlKSB7XG4gICAgICAgIGNhbGxIb29rKG9wdGlvbnMuYmVmb3JlQ3JlYXRlLCBpbnN0YW5jZSwgXCJiY1wiIC8qIExpZmVjeWNsZUhvb2tzLkJFRk9SRV9DUkVBVEUgKi8pO1xuICAgIH1cbiAgICBjb25zdCB7IFxuICAgIC8vIHN0YXRlXG4gICAgZGF0YTogZGF0YU9wdGlvbnMsIGNvbXB1dGVkOiBjb21wdXRlZE9wdGlvbnMsIG1ldGhvZHMsIHdhdGNoOiB3YXRjaE9wdGlvbnMsIHByb3ZpZGU6IHByb3ZpZGVPcHRpb25zLCBpbmplY3Q6IGluamVjdE9wdGlvbnMsIFxuICAgIC8vIGxpZmVjeWNsZVxuICAgIGNyZWF0ZWQsIGJlZm9yZU1vdW50LCBtb3VudGVkLCBiZWZvcmVVcGRhdGUsIHVwZGF0ZWQsIGFjdGl2YXRlZCwgZGVhY3RpdmF0ZWQsIGJlZm9yZURlc3Ryb3ksIGJlZm9yZVVubW91bnQsIGRlc3Ryb3llZCwgdW5tb3VudGVkLCByZW5kZXIsIHJlbmRlclRyYWNrZWQsIHJlbmRlclRyaWdnZXJlZCwgZXJyb3JDYXB0dXJlZCwgc2VydmVyUHJlZmV0Y2gsIFxuICAgIC8vIHB1YmxpYyBBUElcbiAgICBleHBvc2UsIGluaGVyaXRBdHRycywgXG4gICAgLy8gYXNzZXRzXG4gICAgY29tcG9uZW50cywgZGlyZWN0aXZlcywgZmlsdGVycyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBjcmVhdGVEdXBsaWNhdGVDaGVja2VyKCkgOiBudWxsO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgY29uc3QgW3Byb3BzT3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XG4gICAgICAgIGlmIChwcm9wc09wdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIlByb3BzXCIgLyogT3B0aW9uVHlwZXMuUFJPUFMgKi8sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gb3B0aW9ucyBpbml0aWFsaXphdGlvbiBvcmRlciAodG8gYmUgY29uc2lzdGVudCB3aXRoIFZ1ZSAyKTpcbiAgICAvLyAtIHByb3BzIChhbHJlYWR5IGRvbmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uKVxuICAgIC8vIC0gaW5qZWN0XG4gICAgLy8gLSBtZXRob2RzXG4gICAgLy8gLSBkYXRhIChkZWZlcnJlZCBzaW5jZSBpdCByZWxpZXMgb24gYHRoaXNgIGFjY2VzcylcbiAgICAvLyAtIGNvbXB1dGVkXG4gICAgLy8gLSB3YXRjaCAoZGVmZXJyZWQgc2luY2UgaXQgcmVsaWVzIG9uIGB0aGlzYCBhY2Nlc3MpXG4gICAgaWYgKGluamVjdE9wdGlvbnMpIHtcbiAgICAgICAgcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMsIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnVud3JhcEluamVjdGVkUmVmKTtcbiAgICB9XG4gICAgaWYgKG1ldGhvZHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWV0aG9kcykge1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kSGFuZGxlciA9IG1ldGhvZHNba2V5XTtcbiAgICAgICAgICAgIGlmICgoMCwgc2hhcmVkXzEuaXNGdW5jdGlvbikobWV0aG9kSGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBkZXYgbW9kZSwgd2UgdXNlIHRoZSBgY3JlYXRlUmVuZGVyQ29udGV4dGAgZnVuY3Rpb24gdG8gZGVmaW5lXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyB0byB0aGUgcHJveHkgdGFyZ2V0LCBhbmQgdGhvc2UgYXJlIHJlYWQtb25seSBidXRcbiAgICAgICAgICAgICAgICAvLyByZWNvbmZpZ3VyYWJsZSwgc28gaXQgbmVlZHMgdG8gYmUgcmVkZWZpbmVkIGhlcmVcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eFtrZXldID0gbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIk1ldGhvZHNcIiAvKiBPcHRpb25UeXBlcy5NRVRIT0RTICovLCBrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIHdhcm4oYE1ldGhvZCBcIiR7a2V5fVwiIGhhcyB0eXBlIFwiJHt0eXBlb2YgbWV0aG9kSGFuZGxlcn1cIiBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIGAgK1xuICAgICAgICAgICAgICAgICAgICBgRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhKDAsIHNoYXJlZF8xLmlzRnVuY3Rpb24pKGRhdGFPcHRpb25zKSkge1xuICAgICAgICAgICAgd2FybihgVGhlIGRhdGEgb3B0aW9uIG11c3QgYmUgYSBmdW5jdGlvbi4gYCArXG4gICAgICAgICAgICAgICAgYFBsYWluIG9iamVjdCB1c2FnZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBkYXRhT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICgwLCBzaGFyZWRfMS5pc1Byb21pc2UpKGRhdGEpKSB7XG4gICAgICAgICAgICB3YXJuKGBkYXRhKCkgcmV0dXJuZWQgYSBQcm9taXNlIC0gbm90ZSBkYXRhKCkgY2Fubm90IGJlIGFzeW5jOyBJZiB5b3UgYCArXG4gICAgICAgICAgICAgICAgYGludGVuZCB0byBwZXJmb3JtIGRhdGEgZmV0Y2hpbmcgYmVmb3JlIGNvbXBvbmVudCByZW5kZXJzLCB1c2UgYCArXG4gICAgICAgICAgICAgICAgYGFzeW5jIHNldHVwKCkgKyA8U3VzcGVuc2U+LmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIHNoYXJlZF8xLmlzT2JqZWN0KShkYXRhKSkge1xuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYGRhdGEoKSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmRhdGEgPSAoMCwgcmVhY3Rpdml0eV8xLnJlYWN0aXZlKShkYXRhKTtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkRhdGFcIiAvKiBPcHRpb25UeXBlcy5EQVRBICovLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBleHBvc2UgZGF0YSBvbiBjdHggZHVyaW5nIGRldlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcmVmaXgoa2V5WzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBkYXRhW2tleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiBzaGFyZWRfMS5OT09QXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBzdGF0ZSBpbml0aWFsaXphdGlvbiBjb21wbGV0ZSBhdCB0aGlzIHBvaW50IC0gc3RhcnQgY2FjaGluZyBhY2Nlc3NcbiAgICBzaG91bGRDYWNoZUFjY2VzcyA9IHRydWU7XG4gICAgaWYgKGNvbXB1dGVkT3B0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wdXRlZE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IGNvbXB1dGVkT3B0aW9uc1trZXldO1xuICAgICAgICAgICAgY29uc3QgZ2V0ID0gKDAsIHNoYXJlZF8xLmlzRnVuY3Rpb24pKG9wdClcbiAgICAgICAgICAgICAgICA/IG9wdC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpXG4gICAgICAgICAgICAgICAgOiAoMCwgc2hhcmVkXzEuaXNGdW5jdGlvbikob3B0LmdldClcbiAgICAgICAgICAgICAgICAgICAgPyBvcHQuZ2V0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcylcbiAgICAgICAgICAgICAgICAgICAgOiBzaGFyZWRfMS5OT09QO1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBnZXQgPT09IHNoYXJlZF8xLk5PT1ApIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBDb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGhhcyBubyBnZXR0ZXIuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXQgPSAhKDAsIHNoYXJlZF8xLmlzRnVuY3Rpb24pKG9wdCkgJiYgKDAsIHNoYXJlZF8xLmlzRnVuY3Rpb24pKG9wdC5zZXQpXG4gICAgICAgICAgICAgICAgPyBvcHQuc2V0LmJpbmQocHVibGljVGhpcylcbiAgICAgICAgICAgICAgICA6IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICA/ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYFdyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgcmVhZG9ubHkuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiBzaGFyZWRfMS5OT09QO1xuICAgICAgICAgICAgY29uc3QgYyA9IGNvbXB1dGVkKHtcbiAgICAgICAgICAgICAgICBnZXQsXG4gICAgICAgICAgICAgICAgc2V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gYy52YWx1ZSxcbiAgICAgICAgICAgICAgICBzZXQ6IHYgPT4gKGMudmFsdWUgPSB2KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiQ29tcHV0ZWRcIiAvKiBPcHRpb25UeXBlcy5DT01QVVRFRCAqLywga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAod2F0Y2hPcHRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHdhdGNoT3B0aW9ucykge1xuICAgICAgICAgICAgY3JlYXRlV2F0Y2hlcih3YXRjaE9wdGlvbnNba2V5XSwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwcm92aWRlT3B0aW9ucykge1xuICAgICAgICBjb25zdCBwcm92aWRlcyA9ICgwLCBzaGFyZWRfMS5pc0Z1bmN0aW9uKShwcm92aWRlT3B0aW9ucylcbiAgICAgICAgICAgID8gcHJvdmlkZU9wdGlvbnMuY2FsbChwdWJsaWNUaGlzKVxuICAgICAgICAgICAgOiBwcm92aWRlT3B0aW9ucztcbiAgICAgICAgUmVmbGVjdC5vd25LZXlzKHByb3ZpZGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBwcm92aWRlKGtleSwgcHJvdmlkZXNba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoY3JlYXRlZCkge1xuICAgICAgICBjYWxsSG9vayhjcmVhdGVkLCBpbnN0YW5jZSwgXCJjXCIgLyogTGlmZWN5Y2xlSG9va3MuQ1JFQVRFRCAqLyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhyZWdpc3RlciwgaG9vaykge1xuICAgICAgICBpZiAoKDAsIHNoYXJlZF8xLmlzQXJyYXkpKGhvb2spKSB7XG4gICAgICAgICAgICBob29rLmZvckVhY2goX2hvb2sgPT4gcmVnaXN0ZXIoX2hvb2suYmluZChwdWJsaWNUaGlzKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhvb2spIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyKGhvb2suYmluZChwdWJsaWNUaGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlTW91bnQsIGJlZm9yZU1vdW50KTtcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25Nb3VudGVkLCBtb3VudGVkKTtcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVVcGRhdGUsIGJlZm9yZVVwZGF0ZSk7XG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uVXBkYXRlZCwgdXBkYXRlZCk7XG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQWN0aXZhdGVkLCBhY3RpdmF0ZWQpO1xuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkRlYWN0aXZhdGVkLCBkZWFjdGl2YXRlZCk7XG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uRXJyb3JDYXB0dXJlZCwgZXJyb3JDYXB0dXJlZCk7XG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uUmVuZGVyVHJhY2tlZCwgcmVuZGVyVHJhY2tlZCk7XG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uUmVuZGVyVHJpZ2dlcmVkLCByZW5kZXJUcmlnZ2VyZWQpO1xuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZVVubW91bnQsIGJlZm9yZVVubW91bnQpO1xuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblVubW91bnRlZCwgdW5tb3VudGVkKTtcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25TZXJ2ZXJQcmVmZXRjaCwgc2VydmVyUHJlZmV0Y2gpO1xuICAgIGlmICgoMCwgc2hhcmVkXzEuaXNBcnJheSkoZXhwb3NlKSkge1xuICAgICAgICBpZiAoZXhwb3NlLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZXhwb3NlZCA9IGluc3RhbmNlLmV4cG9zZWQgfHwgKGluc3RhbmNlLmV4cG9zZWQgPSB7fSk7XG4gICAgICAgICAgICBleHBvc2UuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvc2VkLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBwdWJsaWNUaGlzW2tleV0sXG4gICAgICAgICAgICAgICAgICAgIHNldDogdmFsID0+IChwdWJsaWNUaGlzW2tleV0gPSB2YWwpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5zdGFuY2UuZXhwb3NlZCkge1xuICAgICAgICAgICAgaW5zdGFuY2UuZXhwb3NlZCA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG9wdGlvbnMgdGhhdCBhcmUgaGFuZGxlZCB3aGVuIGNyZWF0aW5nIHRoZSBpbnN0YW5jZSBidXQgYWxzbyBuZWVkIHRvIGJlXG4gICAgLy8gYXBwbGllZCBmcm9tIG1peGluc1xuICAgIGlmIChyZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBzaGFyZWRfMS5OT09QKSB7XG4gICAgICAgIGluc3RhbmNlLnJlbmRlciA9IHJlbmRlcjtcbiAgICB9XG4gICAgaWYgKGluaGVyaXRBdHRycyAhPSBudWxsKSB7XG4gICAgICAgIGluc3RhbmNlLmluaGVyaXRBdHRycyA9IGluaGVyaXRBdHRycztcbiAgICB9XG4gICAgLy8gYXNzZXQgb3B0aW9ucy5cbiAgICBpZiAoY29tcG9uZW50cylcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgaWYgKGRpcmVjdGl2ZXMpXG4gICAgICAgIGluc3RhbmNlLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMgPSBzaGFyZWRfMS5OT09QLCB1bndyYXBSZWYgPSBmYWxzZSkge1xuICAgIGlmICgoMCwgc2hhcmVkXzEuaXNBcnJheSkoaW5qZWN0T3B0aW9ucykpIHtcbiAgICAgICAgaW5qZWN0T3B0aW9ucyA9IG5vcm1hbGl6ZUluamVjdChpbmplY3RPcHRpb25zKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5qZWN0T3B0aW9ucykge1xuICAgICAgICBjb25zdCBvcHQgPSBpbmplY3RPcHRpb25zW2tleV07XG4gICAgICAgIGxldCBpbmplY3RlZDtcbiAgICAgICAgaWYgKCgwLCBzaGFyZWRfMS5pc09iamVjdCkob3B0KSkge1xuICAgICAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBvcHQpIHtcbiAgICAgICAgICAgICAgICBpbmplY3RlZCA9IGluamVjdChvcHQuZnJvbSB8fCBrZXksIG9wdC5kZWZhdWx0LCB0cnVlIC8qIHRyZWF0IGRlZmF1bHQgZnVuY3Rpb24gYXMgZmFjdG9yeSAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmplY3RlZCA9IGluamVjdChvcHQuZnJvbSB8fCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5qZWN0ZWQgPSBpbmplY3Qob3B0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIHJlYWN0aXZpdHlfMS5pc1JlZikoaW5qZWN0ZWQpKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHJlbW92ZSB0aGUgY2hlY2sgaW4gMy4zXG4gICAgICAgICAgICBpZiAodW53cmFwUmVmKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBpbmplY3RlZC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiB2ID0+IChpbmplY3RlZC52YWx1ZSA9IHYpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYGluamVjdGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgYSByZWYgYW5kIHdpbGwgYmUgYXV0by11bndyYXBwZWQgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgYW5kIG5vIGxvbmdlciBuZWVkcyBcXGAudmFsdWVcXGAgaW4gdGhlIG5leHQgbWlub3IgcmVsZWFzZS4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgVG8gb3B0LWluIHRvIHRoZSBuZXcgYmVoYXZpb3Igbm93LCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBzZXQgXFxgYXBwLmNvbmZpZy51bndyYXBJbmplY3RlZFJlZiA9IHRydWVcXGAgKHRoaXMgY29uZmlnIGlzIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYHRlbXBvcmFyeSBhbmQgd2lsbCBub3QgYmUgbmVlZGVkIGluIHRoZSBmdXR1cmUuKWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHhba2V5XSA9IGluamVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4W2tleV0gPSBpbmplY3RlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJJbmplY3RcIiAvKiBPcHRpb25UeXBlcy5JTkpFQ1QgKi8sIGtleSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjYWxsSG9vayhob29rLCBpbnN0YW5jZSwgdHlwZSkge1xuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKCgwLCBzaGFyZWRfMS5pc0FycmF5KShob29rKVxuICAgICAgICA/IGhvb2subWFwKGggPT4gaC5iaW5kKGluc3RhbmNlLnByb3h5KSlcbiAgICAgICAgOiBob29rLmJpbmQoaW5zdGFuY2UucHJveHkpLCBpbnN0YW5jZSwgdHlwZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyKHJhdywgY3R4LCBwdWJsaWNUaGlzLCBrZXkpIHtcbiAgICBjb25zdCBnZXR0ZXIgPSBrZXkuaW5jbHVkZXMoJy4nKVxuICAgICAgICA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywga2V5KVxuICAgICAgICA6ICgpID0+IHB1YmxpY1RoaXNba2V5XTtcbiAgICBpZiAoKDAsIHNoYXJlZF8xLmlzU3RyaW5nKShyYXcpKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBjdHhbcmF3XTtcbiAgICAgICAgaWYgKCgwLCBzaGFyZWRfMS5pc0Z1bmN0aW9uKShoYW5kbGVyKSkge1xuICAgICAgICAgICAgd2F0Y2goZ2V0dGVyLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXd9XCJgLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgc2hhcmVkXzEuaXNGdW5jdGlvbikocmF3KSkge1xuICAgICAgICB3YXRjaChnZXR0ZXIsIHJhdy5iaW5kKHB1YmxpY1RoaXMpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHNoYXJlZF8xLmlzT2JqZWN0KShyYXcpKSB7XG4gICAgICAgIGlmICgoMCwgc2hhcmVkXzEuaXNBcnJheSkocmF3KSkge1xuICAgICAgICAgICAgcmF3LmZvckVhY2gociA9PiBjcmVhdGVXYXRjaGVyKHIsIGN0eCwgcHVibGljVGhpcywga2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gKDAsIHNoYXJlZF8xLmlzRnVuY3Rpb24pKHJhdy5oYW5kbGVyKVxuICAgICAgICAgICAgICAgID8gcmF3LmhhbmRsZXIuYmluZChwdWJsaWNUaGlzKVxuICAgICAgICAgICAgICAgIDogY3R4W3Jhdy5oYW5kbGVyXTtcbiAgICAgICAgICAgIGlmICgoMCwgc2hhcmVkXzEuaXNGdW5jdGlvbikoaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICB3YXRjaChnZXR0ZXIsIGhhbmRsZXIsIHJhdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3LmhhbmRsZXJ9XCJgLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBvcHRpb246IFwiJHtrZXl9XCJgLCByYXcpO1xuICAgIH1cbn1cbi8qKlxuICogUmVzb2x2ZSBtZXJnZWQgb3B0aW9ucyBhbmQgY2FjaGUgaXQgb24gdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgaXMgZG9uZSBvbmx5IG9uY2UgcGVyLWNvbXBvbmVudCBzaW5jZSB0aGUgbWVyZ2luZyBkb2VzIG5vdCBpbnZvbHZlXG4gKiBpbnN0YW5jZXMuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKSB7XG4gICAgY29uc3QgYmFzZSA9IGluc3RhbmNlLnR5cGU7XG4gICAgY29uc3QgeyBtaXhpbnMsIGV4dGVuZHM6IGV4dGVuZHNPcHRpb25zIH0gPSBiYXNlO1xuICAgIGNvbnN0IHsgbWl4aW5zOiBnbG9iYWxNaXhpbnMsIG9wdGlvbnNDYWNoZTogY2FjaGUsIGNvbmZpZzogeyBvcHRpb25NZXJnZVN0cmF0ZWdpZXMgfSB9ID0gaW5zdGFuY2UuYXBwQ29udGV4dDtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoYmFzZSk7XG4gICAgbGV0IHJlc29sdmVkO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgcmVzb2x2ZWQgPSBjYWNoZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFnbG9iYWxNaXhpbnMubGVuZ3RoICYmICFtaXhpbnMgJiYgIWV4dGVuZHNPcHRpb25zKSB7XG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlc29sdmVkID0gYmFzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZWQgPSB7fTtcbiAgICAgICAgaWYgKGdsb2JhbE1peGlucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGdsb2JhbE1peGlucy5mb3JFYWNoKG0gPT4gbWVyZ2VPcHRpb25zKHJlc29sdmVkLCBtLCBvcHRpb25NZXJnZVN0cmF0ZWdpZXMsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIGJhc2UsIG9wdGlvbk1lcmdlU3RyYXRlZ2llcyk7XG4gICAgfVxuICAgIGlmICgoMCwgc2hhcmVkXzEuaXNPYmplY3QpKGJhc2UpKSB7XG4gICAgICAgIGNhY2hlLnNldChiYXNlLCByZXNvbHZlZCk7XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlZDtcbn1cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyh0bywgZnJvbSwgc3RyYXRzLCBhc01peGluID0gZmFsc2UpIHtcbiAgICBjb25zdCB7IG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMgfSA9IGZyb207XG4gICAgaWYgKGV4dGVuZHNPcHRpb25zKSB7XG4gICAgICAgIG1lcmdlT3B0aW9ucyh0bywgZXh0ZW5kc09wdGlvbnMsIHN0cmF0cywgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChtaXhpbnMpIHtcbiAgICAgICAgbWl4aW5zLmZvckVhY2goKG0pID0+IG1lcmdlT3B0aW9ucyh0bywgbSwgc3RyYXRzLCB0cnVlKSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcbiAgICAgICAgaWYgKGFzTWl4aW4gJiYga2V5ID09PSAnZXhwb3NlJykge1xuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgd2FybihgXCJleHBvc2VcIiBvcHRpb24gaXMgaWdub3JlZCB3aGVuIGRlY2xhcmVkIGluIG1peGlucyBvciBleHRlbmRzLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYEl0IHNob3VsZCBvbmx5IGJlIGRlY2xhcmVkIGluIHRoZSBiYXNlIGNvbXBvbmVudCBpdHNlbGYuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdHJhdCA9IGludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHNba2V5XSB8fCAoc3RyYXRzICYmIHN0cmF0c1trZXldKTtcbiAgICAgICAgICAgIHRvW2tleV0gPSBzdHJhdCA/IHN0cmF0KHRvW2tleV0sIGZyb21ba2V5XSkgOiBmcm9tW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvO1xufVxuY29uc3QgaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0cyA9IHtcbiAgICBkYXRhOiBtZXJnZURhdGFGbixcbiAgICBwcm9wczogbWVyZ2VPYmplY3RPcHRpb25zLFxuICAgIGVtaXRzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gICAgLy8gb2JqZWN0c1xuICAgIG1ldGhvZHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgICBjb21wdXRlZDogbWVyZ2VPYmplY3RPcHRpb25zLFxuICAgIC8vIGxpZmVjeWNsZVxuICAgIGJlZm9yZUNyZWF0ZTogbWVyZ2VBc0FycmF5LFxuICAgIGNyZWF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgICBiZWZvcmVNb3VudDogbWVyZ2VBc0FycmF5LFxuICAgIG1vdW50ZWQ6IG1lcmdlQXNBcnJheSxcbiAgICBiZWZvcmVVcGRhdGU6IG1lcmdlQXNBcnJheSxcbiAgICB1cGRhdGVkOiBtZXJnZUFzQXJyYXksXG4gICAgYmVmb3JlRGVzdHJveTogbWVyZ2VBc0FycmF5LFxuICAgIGJlZm9yZVVubW91bnQ6IG1lcmdlQXNBcnJheSxcbiAgICBkZXN0cm95ZWQ6IG1lcmdlQXNBcnJheSxcbiAgICB1bm1vdW50ZWQ6IG1lcmdlQXNBcnJheSxcbiAgICBhY3RpdmF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgICBkZWFjdGl2YXRlZDogbWVyZ2VBc0FycmF5LFxuICAgIGVycm9yQ2FwdHVyZWQ6IG1lcmdlQXNBcnJheSxcbiAgICBzZXJ2ZXJQcmVmZXRjaDogbWVyZ2VBc0FycmF5LFxuICAgIC8vIGFzc2V0c1xuICAgIGNvbXBvbmVudHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgICBkaXJlY3RpdmVzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gICAgLy8gd2F0Y2hcbiAgICB3YXRjaDogbWVyZ2VXYXRjaE9wdGlvbnMsXG4gICAgLy8gcHJvdmlkZSAvIGluamVjdFxuICAgIHByb3ZpZGU6IG1lcmdlRGF0YUZuLFxuICAgIGluamVjdDogbWVyZ2VJbmplY3Rcbn07XG5mdW5jdGlvbiBtZXJnZURhdGFGbih0bywgZnJvbSkge1xuICAgIGlmICghZnJvbSkge1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGlmICghdG8pIHtcbiAgICAgICAgcmV0dXJuIGZyb207XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4oKSB7XG4gICAgICAgIHJldHVybiAoc2hhcmVkXzEuZXh0ZW5kKSgoMCwgc2hhcmVkXzEuaXNGdW5jdGlvbikodG8pID8gdG8uY2FsbCh0aGlzLCB0aGlzKSA6IHRvLCAoMCwgc2hhcmVkXzEuaXNGdW5jdGlvbikoZnJvbSkgPyBmcm9tLmNhbGwodGhpcywgdGhpcykgOiBmcm9tKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VJbmplY3QodG8sIGZyb20pIHtcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RPcHRpb25zKG5vcm1hbGl6ZUluamVjdCh0byksIG5vcm1hbGl6ZUluamVjdChmcm9tKSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QocmF3KSB7XG4gICAgaWYgKCgwLCBzaGFyZWRfMS5pc0FycmF5KShyYXcpKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzW3Jhd1tpXV0gPSByYXdbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgcmV0dXJuIHJhdztcbn1cbmZ1bmN0aW9uIG1lcmdlQXNBcnJheSh0bywgZnJvbSkge1xuICAgIHJldHVybiB0byA/IFsuLi5uZXcgU2V0KFtdLmNvbmNhdCh0bywgZnJvbSkpXSA6IGZyb207XG59XG5mdW5jdGlvbiBtZXJnZU9iamVjdE9wdGlvbnModG8sIGZyb20pIHtcbiAgICByZXR1cm4gdG8gPyAoMCwgc2hhcmVkXzEuZXh0ZW5kKSgoMCwgc2hhcmVkXzEuZXh0ZW5kKShPYmplY3QuY3JlYXRlKG51bGwpLCB0byksIGZyb20pIDogZnJvbTtcbn1cbmZ1bmN0aW9uIG1lcmdlV2F0Y2hPcHRpb25zKHRvLCBmcm9tKSB7XG4gICAgaWYgKCF0bylcbiAgICAgICAgcmV0dXJuIGZyb207XG4gICAgaWYgKCFmcm9tKVxuICAgICAgICByZXR1cm4gdG87XG4gICAgY29uc3QgbWVyZ2VkID0gKDAsIHNoYXJlZF8xLmV4dGVuZCkoT2JqZWN0LmNyZWF0ZShudWxsKSwgdG8pO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcbiAgICAgICAgbWVyZ2VkW2tleV0gPSBtZXJnZUFzQXJyYXkodG9ba2V5XSwgZnJvbVtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmZ1bmN0aW9uIGluaXRQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIGlzU3RhdGVmdWwsIC8vIHJlc3VsdCBvZiBiaXR3aXNlIGZsYWcgY29tcGFyaXNvblxuaXNTU1IgPSBmYWxzZSkge1xuICAgIGNvbnN0IHByb3BzID0ge307XG4gICAgY29uc3QgYXR0cnMgPSB7fTtcbiAgICAoMCwgc2hhcmVkXzEuZGVmKShhdHRycywgSW50ZXJuYWxPYmplY3RLZXksIDEpO1xuICAgIGluc3RhbmNlLnByb3BzRGVmYXVsdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycyk7XG4gICAgLy8gZW5zdXJlIGFsbCBkZWNsYXJlZCBwcm9wIGtleXMgYXJlIHByZXNlbnRcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF0pIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHByb3BzKSkge1xuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB2YWxpZGF0aW9uXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzIHx8IHt9LCBwcm9wcywgaW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAoaXNTdGF0ZWZ1bCkge1xuICAgICAgICAvLyBzdGF0ZWZ1bFxuICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGlzU1NSID8gcHJvcHMgOiAoMCwgcmVhY3Rpdml0eV8xLnNoYWxsb3dSZWFjdGl2ZSkocHJvcHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFpbnN0YW5jZS50eXBlLnByb3BzKSB7XG4gICAgICAgICAgICAvLyBmdW5jdGlvbmFsIHcvIG9wdGlvbmFsIHByb3BzLCBwcm9wcyA9PT0gYXR0cnNcbiAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gYXR0cnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBmdW5jdGlvbmFsIHcvIGRlY2xhcmVkIHByb3BzXG4gICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluc3RhbmNlLmF0dHJzID0gYXR0cnM7XG59XG5mdW5jdGlvbiBpc0luSG1yQ29udGV4dChpbnN0YW5jZSkge1xuICAgIHdoaWxlIChpbnN0YW5jZSkge1xuICAgICAgICBpZiAoaW5zdGFuY2UudHlwZS5fX2htcklkKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGluc3RhbmNlID0gaW5zdGFuY2UucGFyZW50O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcmF3UHJldlByb3BzLCBvcHRpbWl6ZWQpIHtcbiAgICBjb25zdCB7IHByb3BzLCBhdHRycywgdm5vZGU6IHsgcGF0Y2hGbGFnIH0gfSA9IGluc3RhbmNlO1xuICAgIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9ICgwLCByZWFjdGl2aXR5XzEudG9SYXcpKHByb3BzKTtcbiAgICBjb25zdCBbb3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XG4gICAgbGV0IGhhc0F0dHJzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIGlmIChcbiAgICAvLyBhbHdheXMgZm9yY2UgZnVsbCBkaWZmIGluIGRldlxuICAgIC8vIC0gIzE5NDIgaWYgaG1yIGlzIGVuYWJsZWQgd2l0aCBzZmMgY29tcG9uZW50XG4gICAgLy8gLSB2aXRlIzg3MiBub24tc2ZjIGNvbXBvbmVudCB1c2VkIGJ5IHNmYyBjb21wb25lbnRcbiAgICAhKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0luSG1yQ29udGV4dChpbnN0YW5jZSkpICYmXG4gICAgICAgIChvcHRpbWl6ZWQgfHwgcGF0Y2hGbGFnID4gMCkgJiZcbiAgICAgICAgIShwYXRjaEZsYWcgJiAxNiAvKiBQYXRjaEZsYWdzLkZVTExfUFJPUFMgKi8pKSB7XG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiA4IC8qIFBhdGNoRmxhZ3MuUFJPUFMgKi8pIHtcbiAgICAgICAgICAgIC8vIENvbXBpbGVyLWdlbmVyYXRlZCBwcm9wcyAmIG5vIGtleXMgY2hhbmdlLCBqdXN0IHNldCB0aGUgdXBkYXRlZFxuICAgICAgICAgICAgLy8gdGhlIHByb3BzLlxuICAgICAgICAgICAgY29uc3QgcHJvcHNUb1VwZGF0ZSA9IGluc3RhbmNlLnZub2RlLmR5bmFtaWNQcm9wcztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBrZXkgPSBwcm9wc1RvVXBkYXRlW2ldO1xuICAgICAgICAgICAgICAgIC8vIHNraXAgaWYgdGhlIHByb3Aga2V5IGlzIGEgZGVjbGFyZWQgZW1pdCBldmVudCBsaXN0ZW5lclxuICAgICAgICAgICAgICAgIGlmIChpc0VtaXRMaXN0ZW5lcihpbnN0YW5jZS5lbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBST1BTIGZsYWcgZ3VhcmFudGVlcyByYXdQcm9wcyB0byBiZSBub24tbnVsbFxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAvLyBhdHRyIC8gcHJvcHMgc2VwYXJhdGlvbiB3YXMgZG9uZSBvbiBpbml0IGFuZCB3aWxsIGJlIGNvbnNpc3RlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhpcyBjb2RlIHBhdGgsIHNvIGp1c3QgY2hlY2sgaWYgYXR0cnMgaGF2ZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBzaGFyZWRfMS5oYXNPd24pKGF0dHJzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGF0dHJzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbWVsaXplZEtleSA9ICgwLCBzaGFyZWRfMS5jYW1lbGl6ZSkoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW2NhbWVsaXplZEtleV0gPSByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHJhd0N1cnJlbnRQcm9wcywgY2FtZWxpemVkS2V5LCB2YWx1ZSwgaW5zdGFuY2UsIGZhbHNlIC8qIGlzQWJzZW50ICovKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBmdWxsIHByb3BzIHVwZGF0ZS5cbiAgICAgICAgaWYgKHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycykpIHtcbiAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gY2FzZSBvZiBkeW5hbWljIHByb3BzLCBjaGVjayBpZiB3ZSBuZWVkIHRvIGRlbGV0ZSBrZXlzIGZyb21cbiAgICAgICAgLy8gdGhlIHByb3BzIG9iamVjdFxuICAgICAgICBsZXQga2ViYWJLZXk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJhd0N1cnJlbnRQcm9wcykge1xuICAgICAgICAgICAgaWYgKCFyYXdQcm9wcyB8fFxuICAgICAgICAgICAgICAgIC8vIGZvciBjYW1lbENhc2VcbiAgICAgICAgICAgICAgICAoISgwLCBzaGFyZWRfMS5oYXNPd24pKHJhd1Byb3BzLCBrZXkpICYmXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhlIG9yaWdpbmFsIHByb3BzIHdhcyBwYXNzZWQgaW4gYXMga2ViYWItY2FzZVxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgY29udmVydGVkIHRvIGNhbWVsQ2FzZSAoIzk1NSlcbiAgICAgICAgICAgICAgICAgICAgKChrZWJhYktleSA9ICgwLCBzaGFyZWRfMS5oeXBoZW5hdGUpKGtleSkpID09PSBrZXkgfHwgISgwLCBzaGFyZWRfMS5oYXNPd24pKHJhd1Byb3BzLCBrZWJhYktleSkpKSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdQcmV2UHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBjYW1lbENhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIChyYXdQcmV2UHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGtlYmFiLWNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdQcmV2UHJvcHNba2ViYWJLZXldICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1trZXldID0gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCByYXdDdXJyZW50UHJvcHMsIGtleSwgdW5kZWZpbmVkLCBpbnN0YW5jZSwgdHJ1ZSAvKiBpc0Fic2VudCAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpbiB0aGUgY2FzZSBvZiBmdW5jdGlvbmFsIGNvbXBvbmVudCB3L28gcHJvcHMgZGVjbGFyYXRpb24sIHByb3BzIGFuZFxuICAgICAgICAvLyBhdHRycyBwb2ludCB0byB0aGUgc2FtZSBvYmplY3Qgc28gaXQgc2hvdWxkIGFscmVhZHkgaGF2ZSBiZWVuIHVwZGF0ZWQuXG4gICAgICAgIGlmIChhdHRycyAhPT0gcmF3Q3VycmVudFByb3BzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgICAgICAgICAgICAgIGlmICghcmF3UHJvcHMgfHxcbiAgICAgICAgICAgICAgICAgICAgKCEoMCwgc2hhcmVkXzEuaGFzT3duKShyYXdQcm9wcywga2V5KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFmYWxzZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB0cmlnZ2VyIHVwZGF0ZXMgZm9yICRhdHRycyBpbiBjYXNlIGl0J3MgdXNlZCBpbiBjb21wb25lbnQgc2xvdHNcbiAgICBpZiAoaGFzQXR0cnNDaGFuZ2VkKSB7XG4gICAgICAgICgwLCByZWFjdGl2aXR5XzEudHJpZ2dlcikoaW5zdGFuY2UsIFwic2V0XCIgLyogVHJpZ2dlck9wVHlwZXMuU0VUICovLCAnJGF0dHJzJyk7XG4gICAgfVxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgdmFsaWRhdGVQcm9wcyhyYXdQcm9wcyB8fCB7fSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpIHtcbiAgICBjb25zdCBbb3B0aW9ucywgbmVlZENhc3RLZXlzXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgICBsZXQgaGFzQXR0cnNDaGFuZ2VkID0gZmFsc2U7XG4gICAgbGV0IHJhd0Nhc3RWYWx1ZXM7XG4gICAgaWYgKHJhd1Byb3BzKSB7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiByYXdQcm9wcykge1xuICAgICAgICAgICAgLy8ga2V5LCByZWYgYXJlIHJlc2VydmVkIGFuZCBuZXZlciBwYXNzZWQgZG93blxuICAgICAgICAgICAgaWYgKCgwLCBzaGFyZWRfMS5pc1Jlc2VydmVkUHJvcCkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByYXdQcm9wc1trZXldO1xuICAgICAgICAgICAgLy8gcHJvcCBvcHRpb24gbmFtZXMgYXJlIGNhbWVsaXplZCBkdXJpbmcgbm9ybWFsaXphdGlvbiwgc28gdG8gc3VwcG9ydFxuICAgICAgICAgICAgLy8ga2ViYWIgLT4gY2FtZWwgY29udmVyc2lvbiBoZXJlIHdlIG5lZWQgdG8gY2FtZWxpemUgdGhlIGtleS5cbiAgICAgICAgICAgIGxldCBjYW1lbEtleTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmICgwLCBzaGFyZWRfMS5oYXNPd24pKG9wdGlvbnMsIChjYW1lbEtleSA9ICgwLCBzaGFyZWRfMS5jYW1lbGl6ZSkoa2V5KSkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZWVkQ2FzdEtleXMgfHwgIW5lZWRDYXN0S2V5cy5pbmNsdWRlcyhjYW1lbEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbY2FtZWxLZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAocmF3Q2FzdFZhbHVlcyB8fCAocmF3Q2FzdFZhbHVlcyA9IHt9KSlbY2FtZWxLZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzRW1pdExpc3RlbmVyKGluc3RhbmNlLmVtaXRzT3B0aW9ucywga2V5KSkge1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBhdHRycykgfHwgdmFsdWUgIT09IGF0dHJzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobmVlZENhc3RLZXlzKSB7XG4gICAgICAgIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9ICgwLCByZWFjdGl2aXR5XzEudG9SYXcpKHByb3BzKTtcbiAgICAgICAgY29uc3QgY2FzdFZhbHVlcyA9IHJhd0Nhc3RWYWx1ZXMgfHwgc2hhcmVkXzEuRU1QVFlfT0JKO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5lZWRDYXN0S2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gbmVlZENhc3RLZXlzW2ldO1xuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcmF3Q3VycmVudFByb3BzLCBrZXksIGNhc3RWYWx1ZXNba2V5XSwgaW5zdGFuY2UsICEoMCwgc2hhcmVkXzEuaGFzT3duKShjYXN0VmFsdWVzLCBrZXkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFzQXR0cnNDaGFuZ2VkO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCBwcm9wcywga2V5LCB2YWx1ZSwgaW5zdGFuY2UsIGlzQWJzZW50KSB7XG4gICAgY29uc3Qgb3B0ID0gb3B0aW9uc1trZXldO1xuICAgIGlmIChvcHQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBoYXNEZWZhdWx0ID0gKDAsIHNoYXJlZF8xLmhhc093bikob3B0LCAnZGVmYXVsdCcpO1xuICAgICAgICAvLyBkZWZhdWx0IHZhbHVlc1xuICAgICAgICBpZiAoaGFzRGVmYXVsdCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBvcHQuZGVmYXVsdDtcbiAgICAgICAgICAgIGlmIChvcHQudHlwZSAhPT0gRnVuY3Rpb24gJiYgKDAsIHNoYXJlZF8xLmlzRnVuY3Rpb24pKGRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHByb3BzRGVmYXVsdHMgfSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gcHJvcHNEZWZhdWx0cykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3BzRGVmYXVsdHNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldID0gZGVmYXVsdFZhbHVlLmNhbGwobnVsbCwgcHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGJvb2xlYW4gY2FzdGluZ1xuICAgICAgICBpZiAob3B0WzAgLyogQm9vbGVhbkZsYWdzLnNob3VsZENhc3QgKi9dKSB7XG4gICAgICAgICAgICBpZiAoaXNBYnNlbnQgJiYgIWhhc0RlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0WzEgLyogQm9vbGVhbkZsYWdzLnNob3VsZENhc3RUcnVlICovXSAmJlxuICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09ICgwLCBzaGFyZWRfMS5oeXBoZW5hdGUpKGtleSkpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcbiAgICBjb25zdCBjYWNoZSA9IGFwcENvbnRleHQucHJvcHNDYWNoZTtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoY29tcCk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBjb25zdCByYXcgPSBjb21wLnByb3BzO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgICBjb25zdCBuZWVkQ2FzdEtleXMgPSBbXTtcbiAgICAvLyBhcHBseSBtaXhpbi9leHRlbmRzIHByb3BzXG4gICAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcbiAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhKDAsIHNoYXJlZF8xLmlzRnVuY3Rpb24pKGNvbXApKSB7XG4gICAgICAgIGNvbnN0IGV4dGVuZFByb3BzID0gKHJhdykgPT4ge1xuICAgICAgICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBbcHJvcHMsIGtleXNdID0gbm9ybWFsaXplUHJvcHNPcHRpb25zKHJhdywgYXBwQ29udGV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICAoMCwgc2hhcmVkXzEuZXh0ZW5kKShub3JtYWxpemVkLCBwcm9wcyk7XG4gICAgICAgICAgICBpZiAoa2V5cylcbiAgICAgICAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaCguLi5rZXlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXAuZXh0ZW5kcykge1xuICAgICAgICAgICAgZXh0ZW5kUHJvcHMoY29tcC5leHRlbmRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcC5taXhpbnMpIHtcbiAgICAgICAgICAgIGNvbXAubWl4aW5zLmZvckVhY2goZXh0ZW5kUHJvcHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XG4gICAgICAgIGlmICgoMCwgc2hhcmVkXzEuaXNPYmplY3QpKGNvbXApKSB7XG4gICAgICAgICAgICBjYWNoZS5zZXQoY29tcCwgc2hhcmVkXzEuRU1QVFlfQVJSKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2hhcmVkXzEuRU1QVFlfQVJSO1xuICAgIH1cbiAgICBpZiAoKDAsIHNoYXJlZF8xLmlzQXJyYXkpKHJhdykpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgISgwLCBzaGFyZWRfMS5pc1N0cmluZykocmF3W2ldKSkge1xuICAgICAgICAgICAgICAgIHdhcm4oYHByb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC5gLCByYXdbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9ICgwLCBzaGFyZWRfMS5jYW1lbGl6ZSkocmF3W2ldKTtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFtub3JtYWxpemVkS2V5XSA9IHNoYXJlZF8xLkVNUFRZX09CSjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChyYXcpIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhKDAsIHNoYXJlZF8xLmlzT2JqZWN0KShyYXcpKSB7XG4gICAgICAgICAgICB3YXJuKGBpbnZhbGlkIHByb3BzIG9wdGlvbnNgLCByYXcpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJhdykge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9ICgwLCBzaGFyZWRfMS5jYW1lbGl6ZSkoa2V5KTtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0ID0gcmF3W2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IChub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID1cbiAgICAgICAgICAgICAgICAgICAgKDAsIHNoYXJlZF8xLmlzQXJyYXkpKG9wdCkgfHwgKDAsIHNoYXJlZF8xLmlzRnVuY3Rpb24pKG9wdCkgPyB7IHR5cGU6IG9wdCB9IDogT2JqZWN0LmFzc2lnbih7fSwgb3B0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm9vbGVhbkluZGV4ID0gZ2V0VHlwZUluZGV4KEJvb2xlYW4sIHByb3AudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcFswIC8qIEJvb2xlYW5GbGFncy5zaG91bGRDYXN0ICovXSA9IGJvb2xlYW5JbmRleCA+IC0xO1xuICAgICAgICAgICAgICAgICAgICBwcm9wWzEgLyogQm9vbGVhbkZsYWdzLnNob3VsZENhc3RUcnVlICovXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwcm9wIG5lZWRzIGJvb2xlYW4gY2FzdGluZyBvciBkZWZhdWx0IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGlmIChib29sZWFuSW5kZXggPiAtMSB8fCAoMCwgc2hhcmVkXzEuaGFzT3duKShwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaChub3JtYWxpemVkS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXMgPSBbbm9ybWFsaXplZCwgbmVlZENhc3RLZXlzXTtcbiAgICBpZiAoKDAsIHNoYXJlZF8xLmlzT2JqZWN0KShjb21wKSkge1xuICAgICAgICBjYWNoZS5zZXQoY29tcCwgcmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcE5hbWUoa2V5KSB7XG4gICAgaWYgKGtleVswXSAhPT0gJyQnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgd2FybihgSW52YWxpZCBwcm9wIG5hbWU6IFwiJHtrZXl9XCIgaXMgYSByZXNlcnZlZCBwcm9wZXJ0eS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gdXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIHR5cGUgY29uc3RydWN0b3JzXG4vLyBzbyB0aGF0IGl0IHdvcmtzIGFjcm9zcyB2bXMgLyBpZnJhbWVzLlxuZnVuY3Rpb24gZ2V0VHlwZShjdG9yKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBjdG9yICYmIGN0b3IudG9TdHJpbmcoKS5tYXRjaCgvXlxccyooZnVuY3Rpb258Y2xhc3MpIChcXHcrKS8pO1xuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzJdIDogY3RvciA9PT0gbnVsbCA/ICdudWxsJyA6ICcnO1xufVxuZnVuY3Rpb24gaXNTYW1lVHlwZShhLCBiKSB7XG4gICAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYik7XG59XG5mdW5jdGlvbiBnZXRUeXBlSW5kZXgodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xuICAgIGlmICgoMCwgc2hhcmVkXzEuaXNBcnJheSkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkVHlwZXMuZmluZEluZGV4KHQgPT4gaXNTYW1lVHlwZSh0LCB0eXBlKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBzaGFyZWRfMS5pc0Z1bmN0aW9uKShleHBlY3RlZFR5cGVzKSkge1xuICAgICAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuLyoqXG4gKiBkZXYgb25seVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzLCBwcm9wcywgaW5zdGFuY2UpIHtcbiAgICBjb25zdCByZXNvbHZlZFZhbHVlcyA9ICgwLCByZWFjdGl2aXR5XzEudG9SYXcpKHByb3BzKTtcbiAgICBjb25zdCBvcHRpb25zID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IG9wdCA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgaWYgKG9wdCA9PSBudWxsKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHZhbGlkYXRlUHJvcChrZXksIHJlc29sdmVkVmFsdWVzW2tleV0sIG9wdCwgISgwLCBzaGFyZWRfMS5oYXNPd24pKHJhd1Byb3BzLCBrZXkpICYmICEoMCwgc2hhcmVkXzEuaGFzT3duKShyYXdQcm9wcywgKDAsIHNoYXJlZF8xLmh5cGhlbmF0ZSkoa2V5KSkpO1xuICAgIH1cbn1cbi8qKlxuICogZGV2IG9ubHlcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wKG5hbWUsIHZhbHVlLCBwcm9wLCBpc0Fic2VudCkge1xuICAgIGNvbnN0IHsgdHlwZSwgcmVxdWlyZWQsIHZhbGlkYXRvciB9ID0gcHJvcDtcbiAgICAvLyByZXF1aXJlZCFcbiAgICBpZiAocmVxdWlyZWQgJiYgaXNBYnNlbnQpIHtcbiAgICAgICAgd2FybignTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gbWlzc2luZyBidXQgb3B0aW9uYWxcbiAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHR5cGUgY2hlY2tcbiAgICBpZiAodHlwZSAhPSBudWxsICYmIHR5cGUgIT09IHRydWUpIHtcbiAgICAgICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdHlwZXMgPSAoMCwgc2hhcmVkXzEuaXNBcnJheSkodHlwZSkgPyB0eXBlIDogW3R5cGVdO1xuICAgICAgICBjb25zdCBleHBlY3RlZFR5cGVzID0gW107XG4gICAgICAgIC8vIHZhbHVlIGlzIHZhbGlkIGFzIGxvbmcgYXMgb25lIG9mIHRoZSBzcGVjaWZpZWQgdHlwZXMgbWF0Y2hcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGggJiYgIWlzVmFsaWQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgeyB2YWxpZCwgZXhwZWN0ZWRUeXBlIH0gPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlc1tpXSk7XG4gICAgICAgICAgICBleHBlY3RlZFR5cGVzLnB1c2goZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSB2YWxpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgIHdhcm4oZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY3VzdG9tIHZhbGlkYXRvclxuICAgIGlmICh2YWxpZGF0b3IgJiYgIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgICAgd2FybignSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicpO1xuICAgIH1cbn1cbmNvbnN0IGlzU2ltcGxlVHlwZSA9IC8qI19fUFVSRV9fKi8gKDAsIHNoYXJlZF8xLm1ha2VNYXApKCdTdHJpbmcsTnVtYmVyLEJvb2xlYW4sRnVuY3Rpb24sU3ltYm9sLEJpZ0ludCcpO1xuLyoqXG4gKiBkZXYgb25seVxuICovXG5mdW5jdGlvbiBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlKSB7XG4gICAgbGV0IHZhbGlkO1xuICAgIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gICAgaWYgKGlzU2ltcGxlVHlwZShleHBlY3RlZFR5cGUpKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXG4gICAgICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgdmFsaWQgPSAoMCwgc2hhcmVkXzEuaXNPYmplY3QpKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgICAgIHZhbGlkID0gKDAsIHNoYXJlZF8xLmlzQXJyYXkpKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnbnVsbCcpIHtcbiAgICAgICAgdmFsaWQgPSB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB2YWxpZCxcbiAgICAgICAgZXhwZWN0ZWRUeXBlXG4gICAgfTtcbn1cbi8qKlxuICogZGV2IG9ubHlcbiAqL1xuZnVuY3Rpb24gZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBgSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIiR7bmFtZX1cIi5gICtcbiAgICAgICAgYCBFeHBlY3RlZCAke2V4cGVjdGVkVHlwZXMubWFwKHNoYXJlZF8xLmNhcGl0YWxpemUpLmpvaW4oJyB8ICcpfWA7XG4gICAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlc1swXTtcbiAgICBjb25zdCByZWNlaXZlZFR5cGUgPSAoMCwgc2hhcmVkXzEudG9SYXdUeXBlKSh2YWx1ZSk7XG4gICAgY29uc3QgZXhwZWN0ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIGV4cGVjdGVkVHlwZSk7XG4gICAgY29uc3QgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IGV4cGVjdGVkIHZhbHVlXG4gICAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXG4gICAgICAgICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYCB3aXRoIHZhbHVlICR7ZXhwZWN0ZWRWYWx1ZX1gO1xuICAgIH1cbiAgICBtZXNzYWdlICs9IGAsIGdvdCAke3JlY2VpdmVkVHlwZX0gYDtcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgcmVjZWl2ZWQgdmFsdWVcbiAgICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcbiAgICAgICAgbWVzc2FnZSArPSBgd2l0aCB2YWx1ZSAke3JlY2VpdmVkVmFsdWV9LmA7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xufVxuLyoqXG4gKiBkZXYgb25seVxuICovXG5mdW5jdGlvbiBzdHlsZVZhbHVlKHZhbHVlLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGAke051bWJlcih2YWx1ZSl9YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBgJHt2YWx1ZX1gO1xuICAgIH1cbn1cbi8qKlxuICogZGV2IG9ubHlcbiAqL1xuZnVuY3Rpb24gaXNFeHBsaWNhYmxlKHR5cGUpIHtcbiAgICBjb25zdCBleHBsaWNpdFR5cGVzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcbiAgICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKGVsZW0gPT4gdHlwZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtKTtcbn1cbi8qKlxuICogZGV2IG9ubHlcbiAqL1xuZnVuY3Rpb24gaXNCb29sZWFuKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gYXJncy5zb21lKGVsZW0gPT4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbicpO1xufVxuY29uc3QgaXNJbnRlcm5hbEtleSA9IChrZXkpID0+IGtleVswXSA9PT0gJ18nIHx8IGtleSA9PT0gJyRzdGFibGUnO1xuY29uc3Qgbm9ybWFsaXplU2xvdFZhbHVlID0gKHZhbHVlKSA9PiAoMCwgc2hhcmVkXzEuaXNBcnJheSkodmFsdWUpXG4gICAgPyB2YWx1ZS5tYXAobm9ybWFsaXplVk5vZGUpXG4gICAgOiBbbm9ybWFsaXplVk5vZGUodmFsdWUpXTtcbmNvbnN0IG5vcm1hbGl6ZVNsb3QgPSAoa2V5LCByYXdTbG90LCBjdHgpID0+IHtcbiAgICBpZiAocmF3U2xvdC5fbikge1xuICAgICAgICAvLyBhbHJlYWR5IG5vcm1hbGl6ZWQgLSAjNTM1M1xuICAgICAgICByZXR1cm4gcmF3U2xvdDtcbiAgICB9XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHdpdGhDdHgoKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjdXJyZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHdhcm4oYFNsb3QgXCIke2tleX1cIiBpbnZva2VkIG91dHNpZGUgb2YgdGhlIHJlbmRlciBmdW5jdGlvbjogYCArXG4gICAgICAgICAgICAgICAgYHRoaXMgd2lsbCBub3QgdHJhY2sgZGVwZW5kZW5jaWVzIHVzZWQgaW4gdGhlIHNsb3QuIGAgK1xuICAgICAgICAgICAgICAgIGBJbnZva2UgdGhlIHNsb3QgZnVuY3Rpb24gaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9ybWFsaXplU2xvdFZhbHVlKHJhd1Nsb3QoLi4uYXJncykpO1xuICAgIH0sIGN0eCk7XG4gICAgbm9ybWFsaXplZC5fYyA9IGZhbHNlO1xuICAgIHJldHVybiBub3JtYWxpemVkO1xufTtcbmNvbnN0IG5vcm1hbGl6ZU9iamVjdFNsb3RzID0gKHJhd1Nsb3RzLCBzbG90cywgaW5zdGFuY2UpID0+IHtcbiAgICBjb25zdCBjdHggPSByYXdTbG90cy5fY3R4O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd1Nsb3RzKSB7XG4gICAgICAgIGlmIChpc0ludGVybmFsS2V5KGtleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSByYXdTbG90c1trZXldO1xuICAgICAgICBpZiAoKDAsIHNoYXJlZF8xLmlzRnVuY3Rpb24pKHZhbHVlKSkge1xuICAgICAgICAgICAgc2xvdHNba2V5XSA9IG5vcm1hbGl6ZVNsb3Qoa2V5LCB2YWx1ZSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgIShmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIHNsb3QgXCIke2tleX1cIi4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBQcmVmZXIgZnVuY3Rpb24gc2xvdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTbG90VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgc2xvdHNba2V5XSA9ICgpID0+IG5vcm1hbGl6ZWQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3Qgbm9ybWFsaXplVk5vZGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4pID0+IHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICFpc0tlZXBBbGl2ZShpbnN0YW5jZS52bm9kZSkgJiZcbiAgICAgICAgIShmYWxzZSkpIHtcbiAgICAgICAgd2FybihgTm9uLWZ1bmN0aW9uIHZhbHVlIGVuY291bnRlcmVkIGZvciBkZWZhdWx0IHNsb3QuIGAgK1xuICAgICAgICAgICAgYFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmApO1xuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplU2xvdFZhbHVlKGNoaWxkcmVuKTtcbiAgICBpbnN0YW5jZS5zbG90cy5kZWZhdWx0ID0gKCkgPT4gbm9ybWFsaXplZDtcbn07XG5jb25zdCBpbml0U2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlLnZub2RlLnNoYXBlRmxhZyAmIDMyIC8qIFNoYXBlRmxhZ3MuU0xPVFNfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAvLyB1c2VycyBjYW4gZ2V0IHRoZSBzaGFsbG93IHJlYWRvbmx5IHZlcnNpb24gb2YgdGhlIHNsb3RzIG9iamVjdCB0aHJvdWdoIGB0aGlzLiRzbG90c2AsXG4gICAgICAgICAgICAvLyB3ZSBzaG91bGQgYXZvaWQgdGhlIHByb3h5IG9iamVjdCBwb2xsdXRpbmcgdGhlIHNsb3RzIG9mIHRoZSBpbnRlcm5hbCBpbnN0YW5jZVxuICAgICAgICAgICAgaW5zdGFuY2Uuc2xvdHMgPSAoMCwgcmVhY3Rpdml0eV8xLnRvUmF3KShjaGlsZHJlbik7XG4gICAgICAgICAgICAvLyBtYWtlIGNvbXBpbGVyIG1hcmtlciBub24tZW51bWVyYWJsZVxuICAgICAgICAgICAgKDAsIHNoYXJlZF8xLmRlZikoY2hpbGRyZW4sICdfJywgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgKGluc3RhbmNlLnNsb3RzID0ge30pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaW5zdGFuY2Uuc2xvdHMgPSB7fTtcbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBub3JtYWxpemVWTm9kZVNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKDAsIHNoYXJlZF8xLmRlZikoaW5zdGFuY2Uuc2xvdHMsIEludGVybmFsT2JqZWN0S2V5LCAxKTtcbn07XG5jb25zdCB1cGRhdGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4sIG9wdGltaXplZCkgPT4ge1xuICAgIGNvbnN0IHsgdm5vZGUsIHNsb3RzIH0gPSBpbnN0YW5jZTtcbiAgICBsZXQgbmVlZERlbGV0aW9uQ2hlY2sgPSB0cnVlO1xuICAgIGxldCBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBzaGFyZWRfMS5FTVBUWV9PQko7XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDMyIC8qIFNoYXBlRmxhZ3MuU0xPVFNfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAvLyBjb21waWxlZCBzbG90cy5cbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIC8vIFBhcmVudCB3YXMgSE1SIHVwZGF0ZWQgc28gc2xvdCBjb250ZW50IG1heSBoYXZlIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgdXBkYXRlIHNsb3RzIGFuZCBtYXJrIGluc3RhbmNlIGZvciBobXIgYXMgd2VsbFxuICAgICAgICAgICAgICAgICgwLCBzaGFyZWRfMS5leHRlbmQpKHNsb3RzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpbWl6ZWQgJiYgdHlwZSA9PT0gMSAvKiBTbG90RmxhZ3MuU1RBQkxFICovKSB7XG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZWQgQU5EIHN0YWJsZS5cbiAgICAgICAgICAgICAgICAvLyBubyBuZWVkIHRvIHVwZGF0ZSwgYW5kIHNraXAgc3RhbGUgc2xvdHMgcmVtb3ZhbC5cbiAgICAgICAgICAgICAgICBuZWVkRGVsZXRpb25DaGVjayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZWQgYnV0IGR5bmFtaWMgKHYtaWYvdi1mb3Igb24gc2xvdHMpIC0gdXBkYXRlIHNsb3RzLCBidXQgc2tpcFxuICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6YXRpb24uXG4gICAgICAgICAgICAgICAgKDAsIHNoYXJlZF8xLmV4dGVuZCkoc2xvdHMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAvLyAjMjg5M1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gcmVuZGVyaW5nIHRoZSBvcHRpbWl6ZWQgc2xvdHMgYnkgbWFudWFsbHkgd3JpdHRlbiByZW5kZXIgZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBkZWxldGUgdGhlIGBzbG90cy5fYCBmbGFnIGlmIG5lY2Vzc2FyeSB0byBtYWtlIHN1YnNlcXVlbnQgdXBkYXRlcyByZWxpYWJsZSxcbiAgICAgICAgICAgICAgICAvLyBpLmUuIGxldCB0aGUgYHJlbmRlclNsb3RgIGNyZWF0ZSB0aGUgYmFpbGVkIEZyYWdtZW50XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpbWl6ZWQgJiYgdHlwZSA9PT0gMSAvKiBTbG90RmxhZ3MuU1RBQkxFICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzbG90cy5fO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gIWNoaWxkcmVuLiRzdGFibGU7XG4gICAgICAgICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgc2xvdHMpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IGNoaWxkcmVuO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgICAgICAvLyBub24gc2xvdCBvYmplY3QgY2hpbGRyZW4gKGRpcmVjdCB2YWx1ZSkgcGFzc2VkIHRvIGEgY29tcG9uZW50XG4gICAgICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcbiAgICAgICAgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0geyBkZWZhdWx0OiAxIH07XG4gICAgfVxuICAgIC8vIGRlbGV0ZSBzdGFsZSBzbG90c1xuICAgIGlmIChuZWVkRGVsZXRpb25DaGVjaykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuICAgICAgICAgICAgaWYgKCFpc0ludGVybmFsS2V5KGtleSkgJiYgIShrZXkgaW4gZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzbG90c1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUFwcENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXBwOiBudWxsLFxuICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgIGlzTmF0aXZlVGFnOiBzaGFyZWRfMS5OTyxcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlOiBmYWxzZSxcbiAgICAgICAgICAgIGdsb2JhbFByb3BlcnRpZXM6IHt9LFxuICAgICAgICAgICAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiB7fSxcbiAgICAgICAgICAgIGVycm9ySGFuZGxlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgd2FybkhhbmRsZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbXBpbGVyT3B0aW9uczoge31cbiAgICAgICAgfSxcbiAgICAgICAgbWl4aW5zOiBbXSxcbiAgICAgICAgY29tcG9uZW50czoge30sXG4gICAgICAgIGRpcmVjdGl2ZXM6IHt9LFxuICAgICAgICBwcm92aWRlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgb3B0aW9uc0NhY2hlOiBuZXcgV2Vha01hcCgpLFxuICAgICAgICBwcm9wc0NhY2hlOiBuZXcgV2Vha01hcCgpLFxuICAgICAgICBlbWl0c0NhY2hlOiBuZXcgV2Vha01hcCgpXG4gICAgfTtcbn1cbmxldCB1aWQkMSA9IDA7XG5mdW5jdGlvbiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUFwcChyb290Q29tcG9uZW50LCByb290UHJvcHMgPSBudWxsKSB7XG4gICAgICAgIGlmICghKDAsIHNoYXJlZF8xLmlzRnVuY3Rpb24pKHJvb3RDb21wb25lbnQpKSB7XG4gICAgICAgICAgICByb290Q29tcG9uZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgcm9vdENvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvb3RQcm9wcyAhPSBudWxsICYmICEoMCwgc2hhcmVkXzEuaXNPYmplY3QpKHJvb3RQcm9wcykpIHtcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGByb290IHByb3BzIHBhc3NlZCB0byBhcHAubW91bnQoKSBtdXN0IGJlIGFuIG9iamVjdC5gKTtcbiAgICAgICAgICAgIHJvb3RQcm9wcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcbiAgICAgICAgY29uc3QgaW5zdGFsbGVkUGx1Z2lucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IGlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBhcHAgPSAoY29udGV4dC5hcHAgPSB7XG4gICAgICAgICAgICBfdWlkOiB1aWQkMSsrLFxuICAgICAgICAgICAgX2NvbXBvbmVudDogcm9vdENvbXBvbmVudCxcbiAgICAgICAgICAgIF9wcm9wczogcm9vdFByb3BzLFxuICAgICAgICAgICAgX2NvbnRhaW5lcjogbnVsbCxcbiAgICAgICAgICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgX2luc3RhbmNlOiBudWxsLFxuICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgIGdldCBjb25maWcoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29uZmlnO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBjb25maWcodikge1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgYXBwLmNvbmZpZyBjYW5ub3QgYmUgcmVwbGFjZWQuIE1vZGlmeSBpbmRpdmlkdWFsIG9wdGlvbnMgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXNlKHBsdWdpbiwgLi4ub3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmhhcyhwbHVnaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGBQbHVnaW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHAuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBsdWdpbiAmJiAoMCwgc2hhcmVkXzEuaXNGdW5jdGlvbikocGx1Z2luLmluc3RhbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5pbnN0YWxsKGFwcCwgLi4ub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCgwLCBzaGFyZWRfMS5pc0Z1bmN0aW9uKShwbHVnaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbihhcHAsIC4uLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQSBwbHVnaW4gbXVzdCBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3Qgd2l0aCBhbiBcImluc3RhbGxcIiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBmdW5jdGlvbi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtaXhpbihtaXhpbikge1xuICAgICAgICAgICAgICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5taXhpbnMuaW5jbHVkZXMobWl4aW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1peGlucy5wdXNoKG1peGluKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oJ01peGluIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1peGluLm5hbWUgPyBgOiAke21peGluLm5hbWV9YCA6ICcnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ01peGlucyBhcmUgb25seSBhdmFpbGFibGUgaW4gYnVpbGRzIHN1cHBvcnRpbmcgT3B0aW9ucyBBUEknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21wb25lbnQobmFtZSwgY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgY29udGV4dC5jb25maWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb21wb25lbnRzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgXCIke25hbWV9XCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGluIHRhcmdldCBhcHAuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpcmVjdGl2ZShuYW1lLCBkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgRGlyZWN0aXZlIFwiJHtuYW1lfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0gPSBkaXJlY3RpdmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3VudChyb290Q29udGFpbmVyLCBpc0h5ZHJhdGUsIGlzU1ZHKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gIzU1NzFcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiByb290Q29udGFpbmVyLl9fdnVlX2FwcF9fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBUaGVyZSBpcyBhbHJlYWR5IGFuIGFwcCBpbnN0YW5jZSBtb3VudGVkIG9uIHRoZSBob3N0IGNvbnRhaW5lci5cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgIElmIHlvdSB3YW50IHRvIG1vdW50IGFub3RoZXIgYXBwIG9uIHRoZSBzYW1lIGhvc3QgY29udGFpbmVyLGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAgeW91IG5lZWQgdG8gdW5tb3VudCB0aGUgcHJldmlvdXMgYXBwIGJ5IGNhbGxpbmcgXFxgYXBwLnVubW91bnQoKVxcYCBmaXJzdC5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIGFwcCBjb250ZXh0IG9uIHRoZSByb290IFZOb2RlLlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgYmUgc2V0IG9uIHRoZSByb290IGluc3RhbmNlIG9uIGluaXRpYWwgbW91bnQuXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmFwcENvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAvLyBITVIgcm9vdCByZWxvYWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZWxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyKGNsb25lVk5vZGUodm5vZGUpLCByb290Q29udGFpbmVyLCBpc1NWRyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0h5ZHJhdGUgJiYgaHlkcmF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZSh2bm9kZSwgcm9vdENvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXIodm5vZGUsIHJvb3RDb250YWluZXIsIGlzU1ZHKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBhcHAuX2NvbnRhaW5lciA9IHJvb3RDb250YWluZXI7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RDb250YWluZXIuX192dWVfYXBwX18gPSBhcHA7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gdm5vZGUuY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEV4cG9zZVByb3h5KHZub2RlLmNvbXBvbmVudCkgfHwgdm5vZGUuY29tcG9uZW50LnByb3h5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQXBwIGhhcyBhbHJlYWR5IGJlZW4gbW91bnRlZC5cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBJZiB5b3Ugd2FudCB0byByZW1vdW50IHRoZSBzYW1lIGFwcCwgbW92ZSB5b3VyIGFwcCBjcmVhdGlvbiBsb2dpYyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpbnRvIGEgZmFjdG9yeSBmdW5jdGlvbiBhbmQgY3JlYXRlIGZyZXNoIGFwcCBpbnN0YW5jZXMgZm9yIGVhY2ggYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgbW91bnQgLSBlLmcuIFxcYGNvbnN0IGNyZWF0ZU15QXBwID0gKCkgPT4gY3JlYXRlQXBwKEFwcClcXGBgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5tb3VudCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNNb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcihudWxsLCBhcHAuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldnRvb2xzVW5tb3VudEFwcChhcHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhcHAuX2NvbnRhaW5lci5fX3Z1ZV9hcHBfXztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENhbm5vdCB1bm1vdW50IGFuIGFwcCB0aGF0IGlzIG5vdCBtb3VudGVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm92aWRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGtleSBpbiBjb250ZXh0LnByb3ZpZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEFwcCBhbHJlYWR5IHByb3ZpZGVzIHByb3BlcnR5IHdpdGgga2V5IFwiJHtTdHJpbmcoa2V5KX1cIi4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgSXQgd2lsbCBiZSBvdmVyd3JpdHRlbiB3aXRoIHRoZSBuZXcgdmFsdWUuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleHQucHJvdmlkZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXBwO1xuICAgIH07XG59XG4vKipcbiAqIEZ1bmN0aW9uIGZvciBoYW5kbGluZyBhIHRlbXBsYXRlIHJlZlxuICovXG5mdW5jdGlvbiBzZXRSZWYocmF3UmVmLCBvbGRSYXdSZWYsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgaXNVbm1vdW50ID0gZmFsc2UpIHtcbiAgICBpZiAoKDAsIHNoYXJlZF8xLmlzQXJyYXkpKHJhd1JlZikpIHtcbiAgICAgICAgcmF3UmVmLmZvckVhY2goKHIsIGkpID0+IHNldFJlZihyLCBvbGRSYXdSZWYgJiYgKCgwLCBzaGFyZWRfMS5pc0FycmF5KShvbGRSYXdSZWYpID8gb2xkUmF3UmVmW2ldIDogb2xkUmF3UmVmKSwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCBpc1VubW91bnQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNBc3luY1dyYXBwZXIodm5vZGUpICYmICFpc1VubW91bnQpIHtcbiAgICAgICAgLy8gd2hlbiBtb3VudGluZyBhc3luYyBjb21wb25lbnRzLCBub3RoaW5nIG5lZWRzIHRvIGJlIGRvbmUsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIHRlbXBsYXRlIHJlZiBpcyBmb3J3YXJkZWQgdG8gaW5uZXIgY29tcG9uZW50XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVmVmFsdWUgPSB2bm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNoYXBlRmxhZ3MuU1RBVEVGVUxfQ09NUE9ORU5UICovXG4gICAgICAgID8gZ2V0RXhwb3NlUHJveHkodm5vZGUuY29tcG9uZW50KSB8fCB2bm9kZS5jb21wb25lbnQucHJveHlcbiAgICAgICAgOiB2bm9kZS5lbDtcbiAgICBjb25zdCB2YWx1ZSA9IGlzVW5tb3VudCA/IG51bGwgOiByZWZWYWx1ZTtcbiAgICBjb25zdCB7IGk6IG93bmVyLCByOiByZWYgfSA9IHJhd1JlZjtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFvd25lcikge1xuICAgICAgICB3YXJuKGBNaXNzaW5nIHJlZiBvd25lciBjb250ZXh0LiByZWYgY2Fubm90IGJlIHVzZWQgb24gaG9pc3RlZCB2bm9kZXMuIGAgK1xuICAgICAgICAgICAgYEEgdm5vZGUgd2l0aCByZWYgbXVzdCBiZSBjcmVhdGVkIGluc2lkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uLmApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9sZFJlZiA9IG9sZFJhd1JlZiAmJiBvbGRSYXdSZWYucjtcbiAgICBjb25zdCByZWZzID0gb3duZXIucmVmcyA9PT0gc2hhcmVkXzEuRU1QVFlfT0JKID8gKG93bmVyLnJlZnMgPSB7fSkgOiBvd25lci5yZWZzO1xuICAgIGNvbnN0IHNldHVwU3RhdGUgPSBvd25lci5zZXR1cFN0YXRlO1xuICAgIC8vIGR5bmFtaWMgcmVmIGNoYW5nZWQuIHVuc2V0IG9sZCByZWZcbiAgICBpZiAob2xkUmVmICE9IG51bGwgJiYgb2xkUmVmICE9PSByZWYpIHtcbiAgICAgICAgaWYgKCgwLCBzaGFyZWRfMS5pc1N0cmluZykob2xkUmVmKSkge1xuICAgICAgICAgICAgcmVmc1tvbGRSZWZdID0gbnVsbDtcbiAgICAgICAgICAgIGlmICgoMCwgc2hhcmVkXzEuaGFzT3duKShzZXR1cFN0YXRlLCBvbGRSZWYpKSB7XG4gICAgICAgICAgICAgICAgc2V0dXBTdGF0ZVtvbGRSZWZdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwgcmVhY3Rpdml0eV8xLmlzUmVmKShvbGRSZWYpKSB7XG4gICAgICAgICAgICBvbGRSZWYudmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgoMCwgc2hhcmVkXzEuaXNGdW5jdGlvbikocmVmKSkge1xuICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcocmVmLCBvd25lciwgMTIgLyogRXJyb3JDb2Rlcy5GVU5DVElPTl9SRUYgKi8sIFt2YWx1ZSwgcmVmc10pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgX2lzU3RyaW5nID0gKDAsIHNoYXJlZF8xLmlzU3RyaW5nKShyZWYpO1xuICAgICAgICBjb25zdCBfaXNSZWYgPSAoMCwgcmVhY3Rpdml0eV8xLmlzUmVmKShyZWYpO1xuICAgICAgICBpZiAoX2lzU3RyaW5nIHx8IF9pc1JlZikge1xuICAgICAgICAgICAgY29uc3QgZG9TZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJhd1JlZi5mKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gX2lzU3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICgwLCBzaGFyZWRfMS5oYXNPd24pKHNldHVwU3RhdGUsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNldHVwU3RhdGVbcmVmXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVmc1tyZWZdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5tb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHNoYXJlZF8xLmlzQXJyYXkpKGV4aXN0aW5nKSAmJiAoMCwgc2hhcmVkXzEucmVtb3ZlKShleGlzdGluZywgcmVmVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgc2hhcmVkXzEuaXNBcnJheSkoZXhpc3RpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZzW3JlZl0gPSBbcmVmVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIHNoYXJlZF8xLmhhc093bikoc2V0dXBTdGF0ZSwgcmVmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBTdGF0ZVtyZWZdID0gcmVmc1tyZWZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYudmFsdWUgPSBbcmVmVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmF3UmVmLmspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZzW3Jhd1JlZi5rXSA9IHJlZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghZXhpc3RpbmcuaW5jbHVkZXMocmVmVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcucHVzaChyZWZWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX2lzU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZnNbcmVmXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIHNoYXJlZF8xLmhhc093bikoc2V0dXBTdGF0ZSwgcmVmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBTdGF0ZVtyZWZdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX2lzUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZi52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmF3UmVmLmspXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZzW3Jhd1JlZi5rXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTonLCByZWYsIGAoJHt0eXBlb2YgcmVmfSlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZG9TZXQuaWQgPSAtMTtcbiAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZG9TZXQsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvU2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICB3YXJuKCdJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOicsIHJlZiwgYCgke3R5cGVvZiByZWZ9KWApO1xuICAgICAgICB9XG4gICAgfVxufVxubGV0IGhhc01pc21hdGNoID0gZmFsc2U7XG5jb25zdCBpc1NWR0NvbnRhaW5lciA9IChjb250YWluZXIpID0+IC9zdmcvLnRlc3QoY29udGFpbmVyLm5hbWVzcGFjZVVSSSkgJiYgY29udGFpbmVyLnRhZ05hbWUgIT09ICdmb3JlaWduT2JqZWN0JztcbmNvbnN0IGlzQ29tbWVudCA9IChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4IC8qIERPTU5vZGVUeXBlcy5DT01NRU5UICovO1xuLy8gTm90ZTogaHlkcmF0aW9uIGlzIERPTS1zcGVjaWZpY1xuLy8gQnV0IHdlIGhhdmUgdG8gcGxhY2UgaXQgaW4gY29yZSBkdWUgdG8gdGlnaHQgY291cGxpbmcgd2l0aCBjb3JlIC0gc3BsaXR0aW5nXG4vLyBpdCBvdXQgY3JlYXRlcyBhIHRvbiBvZiB1bm5lY2Vzc2FyeSBjb21wbGV4aXR5LlxuLy8gSHlkcmF0aW9uIGFsc28gZGVwZW5kcyBvbiBzb21lIHJlbmRlcmVyIGludGVybmFsIGxvZ2ljIHdoaWNoIG5lZWRzIHRvIGJlXG4vLyBwYXNzZWQgaW4gdmlhIGFyZ3VtZW50cy5cbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyhyZW5kZXJlckludGVybmFscykge1xuICAgIGNvbnN0IHsgbXQ6IG1vdW50Q29tcG9uZW50LCBwOiBwYXRjaCwgbzogeyBwYXRjaFByb3AsIGNyZWF0ZVRleHQsIG5leHRTaWJsaW5nLCBwYXJlbnROb2RlLCByZW1vdmUsIGluc2VydCwgY3JlYXRlQ29tbWVudCB9IH0gPSByZW5kZXJlckludGVybmFscztcbiAgICBjb25zdCBoeWRyYXRlID0gKHZub2RlLCBjb250YWluZXIpID0+IHtcbiAgICAgICAgaWYgKCFjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICB3YXJuKGBBdHRlbXB0aW5nIHRvIGh5ZHJhdGUgZXhpc3RpbmcgbWFya3VwIGJ1dCBjb250YWluZXIgaXMgZW1wdHkuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgUGVyZm9ybWluZyBmdWxsIG1vdW50IGluc3RlYWQuYCk7XG4gICAgICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyKTtcbiAgICAgICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XG4gICAgICAgICAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaGFzTWlzbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgaHlkcmF0ZU5vZGUoY29udGFpbmVyLmZpcnN0Q2hpbGQsIHZub2RlLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcbiAgICAgICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xuICAgICAgICBpZiAoaGFzTWlzbWF0Y2ggJiYgIWZhbHNlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGVycm9yIHNob3VsZCBzaG93IHVwIGluIHByb2R1Y3Rpb25cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEh5ZHJhdGlvbiBjb21wbGV0ZWQgYnV0IGNvbnRhaW5zIG1pc21hdGNoZXMuYCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGh5ZHJhdGVOb2RlID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzRnJhZ21lbnRTdGFydCA9IGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09ICdbJztcbiAgICAgICAgY29uc3Qgb25NaXNtYXRjaCA9ICgpID0+IGhhbmRsZU1pc21hdGNoKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIGlzRnJhZ21lbnRTdGFydCk7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcmVmLCBzaGFwZUZsYWcsIHBhdGNoRmxhZyB9ID0gdm5vZGU7XG4gICAgICAgIGxldCBkb21UeXBlID0gbm9kZS5ub2RlVHlwZTtcbiAgICAgICAgdm5vZGUuZWwgPSBub2RlO1xuICAgICAgICBpZiAocGF0Y2hGbGFnID09PSAtMiAvKiBQYXRjaEZsYWdzLkJBSUwgKi8pIHtcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dE5vZGUgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgVGV4dDpcbiAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMyAvKiBET01Ob2RlVHlwZXMuVEVYVCAqLykge1xuICAgICAgICAgICAgICAgICAgICAvLyAjNTcyOCBlbXB0eSB0ZXh0IG5vZGUgaW5zaWRlIGEgc2xvdCBjYW4gY2F1c2UgaHlkcmF0aW9uIGZhaWx1cmVcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgc2VydmVyIHJlbmRlcmVkIEhUTUwgd29uJ3QgY29udGFpbiBhIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICBpZiAodm5vZGUuY2hpbGRyZW4gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnQoKHZub2RlLmVsID0gY3JlYXRlVGV4dCgnJykpLCBwYXJlbnROb2RlKG5vZGUpLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhICE9PSB2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIHRleHQgbWlzbWF0Y2g6YCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcXG4tIENsaWVudDogJHtKU09OLnN0cmluZ2lmeShub2RlLmRhdGEpfWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXFxuLSBTZXJ2ZXI6ICR7SlNPTi5zdHJpbmdpZnkodm5vZGUuY2hpbGRyZW4pfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENvbW1lbnQ6XG4gICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDggLyogRE9NTm9kZVR5cGVzLkNPTU1FTlQgKi8gfHwgaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFN0YXRpYzpcbiAgICAgICAgICAgICAgICBpZiAoaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVudGlyZSB0ZW1wbGF0ZSBpcyBzdGF0aWMgYnV0IFNTUmVkIGFzIGEgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBkb21UeXBlID0gbm9kZS5ub2RlVHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgPT09IDEgLyogRE9NTm9kZVR5cGVzLkVMRU1FTlQgKi8gfHwgZG9tVHlwZSA9PT0gMyAvKiBET01Ob2RlVHlwZXMuVEVYVCAqLykge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgYW5jaG9yLCBhZG9wdCBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHN0YXRpYyB2bm9kZSBoYXMgaXRzIGNvbnRlbnQgc3RyaXBwZWQgZHVyaW5nIGJ1aWxkLFxuICAgICAgICAgICAgICAgICAgICAvLyBhZG9wdCBpdCBmcm9tIHRoZSBzZXJ2ZXItcmVuZGVyZWQgSFRNTC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVlZFRvQWRvcHRDb250ZW50ID0gIXZub2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2bm9kZS5zdGF0aWNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVlZFRvQWRvcHRDb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuICs9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlLm5vZGVUeXBlID09PSAxIC8qIERPTU5vZGVUeXBlcy5FTEVNRU5UICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5leHROb2RlLm91dGVySFRNTFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXh0Tm9kZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IHZub2RlLnN0YXRpY0NvdW50IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLmFuY2hvciA9IG5leHROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhuZXh0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRnJhZ21lbnRTdGFydCA/IG5leHRTaWJsaW5nKG5leHROb2RlKSA6IG5leHROb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb25NaXNtYXRjaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IGh5ZHJhdGVGcmFnbWVudChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEgLyogU2hhcGVGbGFncy5FTEVNRU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSAxIC8qIERPTU5vZGVUeXBlcy5FTEVNRU5UICovIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS50eXBlLnRvTG93ZXJDYXNlKCkgIT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRWxlbWVudChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDYgLyogU2hhcGVGbGFncy5DT01QT05FTlQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBzZXR0aW5nIHVwIHRoZSByZW5kZXIgZWZmZWN0LCBpZiB0aGUgaW5pdGlhbCB2bm9kZSBhbHJlYWR5XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyAuZWwgc2V0LCB0aGUgY29tcG9uZW50IHdpbGwgcGVyZm9ybSBoeWRyYXRpb24gaW5zdGVhZCBvZiBtb3VudFxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBpdHMgc3ViLXRyZWUuXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLnNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbW91bnRDb21wb25lbnQodm5vZGUsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkdDb250YWluZXIoY29udGFpbmVyKSwgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IG1heSBiZSBhc3luYywgc28gaW4gdGhlIGNhc2Ugb2YgZnJhZ21lbnRzIHdlIGNhbm5vdCByZWx5XG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIGNvbXBvbmVudCdzIHJlbmRlcmVkIG91dHB1dCB0byBkZXRlcm1pbmUgdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zdGVhZCwgd2UgZG8gYSBsb29rYWhlYWQgdG8gZmluZCB0aGUgZW5kIGFuY2hvciBub2RlLlxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IGlzRnJhZ21lbnRTdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBsb2NhdGVDbG9zaW5nQXN5bmNBbmNob3Iobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vICM0MjkzIHRlbGVwb3J0IGFzIGNvbXBvbmVudCByb290XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Tm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21tZW50KG5leHROb2RlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUuZGF0YSA9PT0gJ3RlbGVwb3J0IGVuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobmV4dE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICMzNzg3XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGNvbXBvbmVudCBpcyBhc3luYywgaXQgbWF5IGdldCBtb3ZlZCAvIHVubW91bnRlZCBiZWZvcmUgaXRzXG4gICAgICAgICAgICAgICAgICAgIC8vIGlubmVyIGNvbXBvbmVudCBpcyBsb2FkZWQsIHNvIHdlIG5lZWQgdG8gZ2l2ZSBpdCBhIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZub2RlIHRoYXQgbWF0Y2hlcyBpdHMgYWRvcHRlZCBET00uXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlcih2bm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdWJUcmVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWUgPSBjcmVhdGVWTm9kZShGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZS5hbmNob3IgPSBuZXh0Tm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5leHROb2RlLnByZXZpb3VzU2libGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnRhaW5lci5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ub2RlVHlwZSA9PT0gMyA/IGNyZWF0ZVRleHRWTm9kZSgnJykgOiBjcmVhdGVWTm9kZSgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlLmVsID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudC5zdWJUcmVlID0gc3ViVHJlZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBTaGFwZUZsYWdzLlRFTEVQT1JUICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSA4IC8qIERPTU5vZGVUeXBlcy5DT01NRU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gdm5vZGUudHlwZS5oeWRyYXRlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgMTI4IC8qIFNoYXBlRmxhZ3MuU1VTUEVOU0UgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKHBhcmVudE5vZGUobm9kZSkpLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGh5ZHJhdGVOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgSG9zdFZOb2RlIHR5cGU6JywgdHlwZSwgYCgke3R5cGVvZiB0eXBlfSlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRSZWYocmVmLCBudWxsLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0Tm9kZTtcbiAgICB9O1xuICAgIGNvbnN0IGh5ZHJhdGVFbGVtZW50ID0gKGVsLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICAgICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICAgICAgICBjb25zdCB7IHR5cGUsIHByb3BzLCBwYXRjaEZsYWcsIHNoYXBlRmxhZywgZGlycyB9ID0gdm5vZGU7XG4gICAgICAgIC8vICM0MDA2IGZvciBmb3JtIGVsZW1lbnRzIHdpdGggbm9uLXN0cmluZyB2LW1vZGVsIHZhbHVlIGJpbmRpbmdzXG4gICAgICAgIC8vIGUuZy4gPG9wdGlvbiA6dmFsdWU9XCJvYmpcIj4sIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiA6dHJ1ZS12YWx1ZT1cIjFcIj5cbiAgICAgICAgY29uc3QgZm9yY2VQYXRjaFZhbHVlID0gKHR5cGUgPT09ICdpbnB1dCcgJiYgZGlycykgfHwgdHlwZSA9PT0gJ29wdGlvbic7XG4gICAgICAgIC8vIHNraXAgcHJvcHMgJiBjaGlsZHJlbiBpZiB0aGlzIGlzIGhvaXN0ZWQgc3RhdGljIG5vZGVzXG4gICAgICAgIC8vICM1NDA1IGluIGRldiwgYWx3YXlzIGh5ZHJhdGUgY2hpbGRyZW4gZm9yIEhNUlxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IGZvcmNlUGF0Y2hWYWx1ZSB8fCBwYXRjaEZsYWcgIT09IC0xIC8qIFBhdGNoRmxhZ3MuSE9JU1RFRCAqLykge1xuICAgICAgICAgICAgaWYgKGRpcnMpIHtcbiAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdjcmVhdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcm9wc1xuICAgICAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmNlUGF0Y2hWYWx1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAhb3B0aW1pemVkIHx8XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRmxhZyAmICgxNiAvKiBQYXRjaEZsYWdzLkZVTExfUFJPUFMgKi8gfCAzMiAvKiBQYXRjaEZsYWdzLkhZRFJBVEVfRVZFTlRTICovKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChmb3JjZVBhdGNoVmFsdWUgJiYga2V5LmVuZHNXaXRoKCd2YWx1ZScpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoMCwgc2hhcmVkXzEuaXNPbikoa2V5KSAmJiAhKDAsIHNoYXJlZF8xLmlzUmVzZXJ2ZWRQcm9wKShrZXkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldLCBmYWxzZSwgdW5kZWZpbmVkLCBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3BzLm9uQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBjbGljayBsaXN0ZW5lcnMgKHdoaWNoIGlzIG1vc3Qgb2Z0ZW4pIHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGluZyB0aHJvdWdoIHByb3BzLlxuICAgICAgICAgICAgICAgICAgICBwYXRjaFByb3AoZWwsICdvbkNsaWNrJywgbnVsbCwgcHJvcHMub25DbGljaywgZmFsc2UsIHVuZGVmaW5lZCwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB2bm9kZSAvIGRpcmVjdGl2ZSBob29rc1xuICAgICAgICAgICAgbGV0IHZub2RlSG9va3M7XG4gICAgICAgICAgICBpZiAoKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpcnMpIHtcbiAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdiZWZvcmVNb3VudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2tzID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpIHx8IGRpcnMpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZub2RlSG9va3MgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ21vdW50ZWQnKTtcbiAgICAgICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGlsZHJlblxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8gJiZcbiAgICAgICAgICAgICAgICAvLyBza2lwIGlmIGVsZW1lbnQgaGFzIGlubmVySFRNTCAvIHRleHRDb250ZW50XG4gICAgICAgICAgICAgICAgIShwcm9wcyAmJiAocHJvcHMuaW5uZXJIVE1MIHx8IHByb3BzLnRleHRDb250ZW50KSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihlbC5maXJzdENoaWxkLCB2bm9kZSwgZWwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFoYXNXYXJuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBpbiA8JHt2bm9kZS50eXBlfT46IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBzZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBtb3JlIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBTU1JlZCBET00gY29udGFpbnMgbW9yZSBub2RlcyB0aGFuIGl0IHNob3VsZC4gUmVtb3ZlIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1ciA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmUoY3VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA4IC8qIFNoYXBlRmxhZ3MuVEVYVF9DSElMRFJFTiAqLykge1xuICAgICAgICAgICAgICAgIGlmIChlbC50ZXh0Q29udGVudCAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiB0ZXh0IGNvbnRlbnQgbWlzbWF0Y2ggaW4gPCR7dm5vZGUudHlwZX0+OlxcbmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAtIENsaWVudDogJHtlbC50ZXh0Q29udGVudH1cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgLSBTZXJ2ZXI6ICR7dm5vZGUuY2hpbGRyZW59YCk7XG4gICAgICAgICAgICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbC5uZXh0U2libGluZztcbiAgICB9O1xuICAgIGNvbnN0IGh5ZHJhdGVDaGlsZHJlbiA9IChub2RlLCBwYXJlbnRWTm9kZSwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISFwYXJlbnRWTm9kZS5keW5hbWljQ2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50Vk5vZGUuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGwgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZub2RlID0gb3B0aW1pemVkXG4gICAgICAgICAgICAgICAgPyBjaGlsZHJlbltpXVxuICAgICAgICAgICAgICAgIDogKGNoaWxkcmVuW2ldID0gbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGh5ZHJhdGVOb2RlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2bm9kZS50eXBlID09PSBUZXh0ICYmICF2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWhhc1dhcm5lZCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gY2hpbGRyZW4gbWlzbWF0Y2ggaW4gPCR7Y29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKX0+OiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBzZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBmZXdlciBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmApO1xuICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aGUgU1NSZWQgRE9NIGRpZG4ndCBjb250YWluIGVub3VnaCBub2Rlcy4gTW91bnQgdGhlIG1pc3Npbmcgb25lcy5cbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpLCBzbG90U2NvcGVJZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgY29uc3QgaHlkcmF0ZUZyYWdtZW50ID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBjb25zdCB7IHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IHZub2RlO1xuICAgICAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkc1xuICAgICAgICAgICAgICAgID8gc2xvdFNjb3BlSWRzLmNvbmNhdChmcmFnbWVudFNsb3RTY29wZUlkcylcbiAgICAgICAgICAgICAgICA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XG4gICAgICAgIGNvbnN0IG5leHQgPSBoeWRyYXRlQ2hpbGRyZW4obmV4dFNpYmxpbmcobm9kZSksIHZub2RlLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgaWYgKG5leHQgJiYgaXNDb21tZW50KG5leHQpICYmIG5leHQuZGF0YSA9PT0gJ10nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcoKHZub2RlLmFuY2hvciA9IG5leHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZyYWdtZW50IGRpZG4ndCBoeWRyYXRlIHN1Y2Nlc3NmdWxseSwgc2luY2Ugd2UgZGlkbid0IGdldCBhIGVuZCBhbmNob3JcbiAgICAgICAgICAgIC8vIGJhY2suIFRoaXMgc2hvdWxkIGhhdmUgbGVkIHRvIG5vZGUvY2hpbGRyZW4gbWlzbWF0Y2ggd2FybmluZ3MuXG4gICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgYW5jaG9yIGlzIG1pc3NpbmcsIHdlIG5lZWQgdG8gY3JlYXRlIG9uZSBhbmQgaW5zZXJ0IGl0XG4gICAgICAgICAgICBpbnNlcnQoKHZub2RlLmFuY2hvciA9IGNyZWF0ZUNvbW1lbnQoYF1gKSksIGNvbnRhaW5lciwgbmV4dCk7XG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlTWlzbWF0Y2ggPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgaXNGcmFnbWVudCkgPT4ge1xuICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIG5vZGUgbWlzbWF0Y2g6XFxuLSBDbGllbnQgdm5vZGU6YCwgdm5vZGUudHlwZSwgYFxcbi0gU2VydmVyIHJlbmRlcmVkIERPTTpgLCBub2RlLCBub2RlLm5vZGVUeXBlID09PSAzIC8qIERPTU5vZGVUeXBlcy5URVhUICovXG4gICAgICAgICAgICAgICAgPyBgKHRleHQpYFxuICAgICAgICAgICAgICAgIDogaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gJ1snXG4gICAgICAgICAgICAgICAgICAgID8gYChzdGFydCBvZiBmcmFnbWVudClgXG4gICAgICAgICAgICAgICAgICAgIDogYGApO1xuICAgICAgICB2bm9kZS5lbCA9IG51bGw7XG4gICAgICAgIGlmIChpc0ZyYWdtZW50KSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZXhjZXNzaXZlIGZyYWdtZW50IG5vZGVzXG4gICAgICAgICAgICBjb25zdCBlbmQgPSBsb2NhdGVDbG9zaW5nQXN5bmNBbmNob3Iobm9kZSk7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0ICE9PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKG5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcbiAgICAgICAgcmVtb3ZlKG5vZGUpO1xuICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyLCBuZXh0LCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpLCBzbG90U2NvcGVJZHMpO1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICAgIGNvbnN0IGxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvciA9IChub2RlKSA9PiB7XG4gICAgICAgIGxldCBtYXRjaCA9IDA7XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBub2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZSAmJiBpc0NvbW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhID09PSAnWycpXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoKys7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2gtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIHJldHVybiBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdO1xufVxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXG5sZXQgc3VwcG9ydGVkO1xubGV0IHBlcmY7XG5mdW5jdGlvbiBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIHR5cGUpIHtcbiAgICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICBwZXJmLm1hcmsoYHZ1ZS0ke3R5cGV9LSR7aW5zdGFuY2UudWlkfWApO1xuICAgIH1cbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICBkZXZ0b29sc1BlcmZTdGFydChpbnN0YW5jZSwgdHlwZSwgaXNTdXBwb3J0ZWQoKSA/IHBlcmYubm93KCkgOiBEYXRlLm5vdygpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbmRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XG4gICAgaWYgKGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnBlcmZvcm1hbmNlICYmIGlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUYWcgPSBgdnVlLSR7dHlwZX0tJHtpbnN0YW5jZS51aWR9YDtcbiAgICAgICAgY29uc3QgZW5kVGFnID0gc3RhcnRUYWcgKyBgOmVuZGA7XG4gICAgICAgIHBlcmYubWFyayhlbmRUYWcpO1xuICAgICAgICBwZXJmLm1lYXN1cmUoYDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIGluc3RhbmNlLnR5cGUpfT4gJHt0eXBlfWAsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICB9XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgZGV2dG9vbHNQZXJmRW5kKGluc3RhbmNlLCB0eXBlLCBpc1N1cHBvcnRlZCgpID8gcGVyZi5ub3coKSA6IERhdGUubm93KCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICAgIGlmIChzdXBwb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc3VwcG9ydGVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBlcmZvcm1hbmNlKSB7XG4gICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHBlcmYgPSB3aW5kb3cucGVyZm9ybWFuY2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cHBvcnRlZDtcbn1cbi8qKlxuICogVGhpcyBpcyBvbmx5IGNhbGxlZCBpbiBlc20tYnVuZGxlciBidWlsZHMuXG4gKiBJdCBpcyBjYWxsZWQgd2hlbiBhIHJlbmRlcmVyIGlzIGNyZWF0ZWQsIGluIGBiYXNlQ3JlYXRlUmVuZGVyZXJgIHNvIHRoYXRcbiAqIGltcG9ydGluZyBydW50aW1lLWNvcmUgaXMgc2lkZS1lZmZlY3RzIGZyZWUuXG4gKlxuICogaXN0YW5idWwtaWdub3JlLW5leHRcbiAqL1xuZnVuY3Rpb24gaW5pdEZlYXR1cmVGbGFncygpIHtcbiAgICBjb25zdCBuZWVkV2FybiA9IFtdO1xuICAgIGlmICh0eXBlb2YgX19WVUVfT1BUSU9OU19BUElfXyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBuZWVkV2Fybi5wdXNoKGBfX1ZVRV9PUFRJT05TX0FQSV9fYCk7XG4gICAgICAgICgwLCBzaGFyZWRfMS5nZXRHbG9iYWxUaGlzKSgpLl9fVlVFX09QVElPTlNfQVBJX18gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBuZWVkV2Fybi5wdXNoKGBfX1ZVRV9QUk9EX0RFVlRPT0xTX19gKTtcbiAgICAgICAgKDAsIHNoYXJlZF8xLmdldEdsb2JhbFRoaXMpKCkuX19WVUVfUFJPRF9ERVZUT09MU19fID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbmVlZFdhcm4ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG11bHRpID0gbmVlZFdhcm4ubGVuZ3RoID4gMTtcbiAgICAgICAgY29uc29sZS53YXJuKGBGZWF0dXJlIGZsYWcke211bHRpID8gYHNgIDogYGB9ICR7bmVlZFdhcm4uam9pbignLCAnKX0gJHttdWx0aSA/IGBhcmVgIDogYGlzYH0gbm90IGV4cGxpY2l0bHkgZGVmaW5lZC4gWW91IGFyZSBydW5uaW5nIHRoZSBlc20tYnVuZGxlciBidWlsZCBvZiBWdWUsIGAgK1xuICAgICAgICAgICAgYHdoaWNoIGV4cGVjdHMgdGhlc2UgY29tcGlsZS10aW1lIGZlYXR1cmUgZmxhZ3MgdG8gYmUgZ2xvYmFsbHkgaW5qZWN0ZWQgYCArXG4gICAgICAgICAgICBgdmlhIHRoZSBidW5kbGVyIGNvbmZpZyBpbiBvcmRlciB0byBnZXQgYmV0dGVyIHRyZWUtc2hha2luZyBpbiB0aGUgYCArXG4gICAgICAgICAgICBgcHJvZHVjdGlvbiBidW5kbGUuXFxuXFxuYCArXG4gICAgICAgICAgICBgRm9yIG1vcmUgZGV0YWlscywgc2VlIGh0dHBzOi8vbGluay52dWVqcy5vcmcvZmVhdHVyZS1mbGFncy5gKTtcbiAgICB9XG59XG5jb25zdCBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QgPSBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZTtcbi8qKlxuICogVGhlIGNyZWF0ZVJlbmRlcmVyIGZ1bmN0aW9uIGFjY2VwdHMgdHdvIGdlbmVyaWMgYXJndW1lbnRzOlxuICogSG9zdE5vZGUgYW5kIEhvc3RFbGVtZW50LCBjb3JyZXNwb25kaW5nIHRvIE5vZGUgYW5kIEVsZW1lbnQgdHlwZXMgaW4gdGhlXG4gKiBob3N0IGVudmlyb25tZW50LiBGb3IgZXhhbXBsZSwgZm9yIHJ1bnRpbWUtZG9tLCBIb3N0Tm9kZSB3b3VsZCBiZSB0aGUgRE9NXG4gKiBgTm9kZWAgaW50ZXJmYWNlIGFuZCBIb3N0RWxlbWVudCB3b3VsZCBiZSB0aGUgRE9NIGBFbGVtZW50YCBpbnRlcmZhY2UuXG4gKlxuICogQ3VzdG9tIHJlbmRlcmVycyBjYW4gcGFzcyBpbiB0aGUgcGxhdGZvcm0gc3BlY2lmaWMgdHlwZXMgbGlrZSB0aGlzOlxuICpcbiAqIGBgYCBqc1xuICogY29uc3QgeyByZW5kZXIsIGNyZWF0ZUFwcCB9ID0gY3JlYXRlUmVuZGVyZXI8Tm9kZSwgRWxlbWVudD4oe1xuICogICBwYXRjaFByb3AsXG4gKiAgIC4uLm5vZGVPcHNcbiAqIH0pXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmVuZGVyZXIob3B0aW9ucykge1xuICAgIHJldHVybiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucyk7XG59XG5leHBvcnRzLmNyZWF0ZVJlbmRlcmVyID0gY3JlYXRlUmVuZGVyZXI7XG4vLyBTZXBhcmF0ZSBBUEkgZm9yIGNyZWF0aW5nIGh5ZHJhdGlvbi1lbmFibGVkIHJlbmRlcmVyLlxuLy8gSHlkcmF0aW9uIGxvZ2ljIGlzIG9ubHkgdXNlZCB3aGVuIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiwgbWFraW5nIGl0XG4vLyB0cmVlLXNoYWthYmxlLlxuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIob3B0aW9ucykge1xuICAgIHJldHVybiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucywgY3JlYXRlSHlkcmF0aW9uRnVuY3Rpb25zKTtcbn1cbmV4cG9ydHMuY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIgPSBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcjtcbi8vIGltcGxlbWVudGF0aW9uXG5mdW5jdGlvbiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucywgY3JlYXRlSHlkcmF0aW9uRm5zKSB7XG4gICAgLy8gY29tcGlsZS10aW1lIGZlYXR1cmUgZmxhZ3MgY2hlY2tcbiAgICB7XG4gICAgICAgIGluaXRGZWF0dXJlRmxhZ3MoKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gKDAsIHNoYXJlZF8xLmdldEdsb2JhbFRoaXMpKCk7XG4gICAgdGFyZ2V0Ll9fVlVFX18gPSB0cnVlO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgIHNldERldnRvb2xzSG9vayh0YXJnZXQuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXywgdGFyZ2V0KTtcbiAgICB9XG4gICAgY29uc3QgeyBpbnNlcnQ6IGhvc3RJbnNlcnQsIHJlbW92ZTogaG9zdFJlbW92ZSwgcGF0Y2hQcm9wOiBob3N0UGF0Y2hQcm9wLCBjcmVhdGVFbGVtZW50OiBob3N0Q3JlYXRlRWxlbWVudCwgY3JlYXRlVGV4dDogaG9zdENyZWF0ZVRleHQsIGNyZWF0ZUNvbW1lbnQ6IGhvc3RDcmVhdGVDb21tZW50LCBzZXRUZXh0OiBob3N0U2V0VGV4dCwgc2V0RWxlbWVudFRleHQ6IGhvc3RTZXRFbGVtZW50VGV4dCwgcGFyZW50Tm9kZTogaG9zdFBhcmVudE5vZGUsIG5leHRTaWJsaW5nOiBob3N0TmV4dFNpYmxpbmcsIHNldFNjb3BlSWQ6IGhvc3RTZXRTY29wZUlkID0gc2hhcmVkXzEuTk9PUCwgaW5zZXJ0U3RhdGljQ29udGVudDogaG9zdEluc2VydFN0YXRpY0NvbnRlbnQgfSA9IG9wdGlvbnM7XG4gICAgLy8gTm90ZTogZnVuY3Rpb25zIGluc2lkZSB0aGlzIGNsb3N1cmUgc2hvdWxkIHVzZSBgY29uc3QgeHh4ID0gKCkgPT4ge31gXG4gICAgLy8gc3R5bGUgaW4gb3JkZXIgdG8gcHJldmVudCBiZWluZyBpbmxpbmVkIGJ5IG1pbmlmaWVycy5cbiAgICBjb25zdCBwYXRjaCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yID0gbnVsbCwgcGFyZW50Q29tcG9uZW50ID0gbnVsbCwgcGFyZW50U3VzcGVuc2UgPSBudWxsLCBpc1NWRyA9IGZhbHNlLCBzbG90U2NvcGVJZHMgPSBudWxsLCBvcHRpbWl6ZWQgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZyA/IGZhbHNlIDogISFuMi5keW5hbWljQ2hpbGRyZW4pID0+IHtcbiAgICAgICAgaWYgKG4xID09PSBuMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhdGNoaW5nICYgbm90IHNhbWUgdHlwZSwgdW5tb3VudCBvbGQgdHJlZVxuICAgICAgICBpZiAobjEgJiYgIWlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBnZXROZXh0SG9zdE5vZGUobjEpO1xuICAgICAgICAgICAgdW5tb3VudChuMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgICAgICBuMSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4yLnBhdGNoRmxhZyA9PT0gLTIgLyogUGF0Y2hGbGFncy5CQUlMICovKSB7XG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG4yLmR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZyB9ID0gbjI7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBUZXh0OlxuICAgICAgICAgICAgICAgIHByb2Nlc3NUZXh0KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDb21tZW50OlxuICAgICAgICAgICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU3RhdGljOlxuICAgICAgICAgICAgICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdW50U3RhdGljTm9kZShuMiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoU3RhdGljTm9kZShuMSwgbjIsIGNvbnRhaW5lciwgaXNTVkcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0ZyYWdtZW50KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqLykge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRWxlbWVudChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NDb21wb25lbnQobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQgLyogU2hhcGVGbGFncy5URUxFUE9SVCAqLykge1xuICAgICAgICAgICAgICAgICAgICB0eXBlLnByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBpbnRlcm5hbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU2hhcGVGbGFncy5TVVNQRU5TRSAqLykge1xuICAgICAgICAgICAgICAgICAgICB0eXBlLnByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBpbnRlcm5hbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBWTm9kZSB0eXBlOicsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNldCByZWZcbiAgICAgICAgaWYgKHJlZiAhPSBudWxsICYmIHBhcmVudENvbXBvbmVudCkge1xuICAgICAgICAgICAgc2V0UmVmKHJlZiwgbjEgJiYgbjEucmVmLCBwYXJlbnRTdXNwZW5zZSwgbjIgfHwgbjEsICFuMik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHByb2Nlc3NUZXh0ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoKG4yLmVsID0gaG9zdENyZWF0ZVRleHQobjIuY2hpbGRyZW4pKSwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZWwgPSAobjIuZWwgPSBuMS5lbCk7XG4gICAgICAgICAgICBpZiAobjIuY2hpbGRyZW4gIT09IG4xLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaG9zdFNldFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJvY2Vzc0NvbW1lbnROb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoKG4yLmVsID0gaG9zdENyZWF0ZUNvbW1lbnQobjIuY2hpbGRyZW4gfHwgJycpKSwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBzdXBwb3J0IGZvciBkeW5hbWljIGNvbW1lbnRzXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtb3VudFN0YXRpY05vZGUgPSAobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRykgPT4ge1xuICAgICAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChuMi5jaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBuMi5lbCwgbjIuYW5jaG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldiAvIEhNUiBvbmx5XG4gICAgICovXG4gICAgY29uc3QgcGF0Y2hTdGF0aWNOb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBpc1NWRykgPT4ge1xuICAgICAgICAvLyBzdGF0aWMgbm9kZXMgYXJlIG9ubHkgcGF0Y2hlZCBkdXJpbmcgZGV2IGZvciBITVJcbiAgICAgICAgaWYgKG4yLmNoaWxkcmVuICE9PSBuMS5jaGlsZHJlbikge1xuICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gaG9zdE5leHRTaWJsaW5nKG4xLmFuY2hvcik7XG4gICAgICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmdcbiAgICAgICAgICAgIHJlbW92ZVN0YXRpY05vZGUobjEpO1xuICAgICAgICAgICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQobjIuY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgICAgICAgbjIuYW5jaG9yID0gbjEuYW5jaG9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSwgY29udGFpbmVyLCBuZXh0U2libGluZykgPT4ge1xuICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcbiAgICAgICAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xuICAgICAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XG4gICAgICAgICAgICBlbCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaG9zdEluc2VydChhbmNob3IsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSkgPT4ge1xuICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcbiAgICAgICAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xuICAgICAgICAgICAgaG9zdFJlbW92ZShlbCk7XG4gICAgICAgICAgICBlbCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaG9zdFJlbW92ZShhbmNob3IpO1xuICAgIH07XG4gICAgY29uc3QgcHJvY2Vzc0VsZW1lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgbjIudHlwZSA9PT0gJ3N2Zyc7XG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICAgICAgICBtb3VudEVsZW1lbnQobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0Y2hFbGVtZW50KG4xLCBuMiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbW91bnRFbGVtZW50ID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIGxldCBlbDtcbiAgICAgICAgbGV0IHZub2RlSG9vaztcbiAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgc2hhcGVGbGFnLCB0cmFuc2l0aW9uLCBkaXJzIH0gPSB2bm9kZTtcbiAgICAgICAgZWwgPSB2bm9kZS5lbCA9IGhvc3RDcmVhdGVFbGVtZW50KHZub2RlLnR5cGUsIGlzU1ZHLCBwcm9wcyAmJiBwcm9wcy5pcywgcHJvcHMpO1xuICAgICAgICAvLyBtb3VudCBjaGlsZHJlbiBmaXJzdCwgc2luY2Ugc29tZSBwcm9wcyBtYXkgcmVseSBvbiBjaGlsZCBjb250ZW50XG4gICAgICAgIC8vIGJlaW5nIGFscmVhZHkgcmVuZGVyZWQsIGUuZy4gYDxzZWxlY3QgdmFsdWU+YFxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgOCAvKiBTaGFwZUZsYWdzLlRFWFRfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgdm5vZGUuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4odm5vZGUuY2hpbGRyZW4sIGVsLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyAmJiB0eXBlICE9PSAnZm9yZWlnbk9iamVjdCcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlycykge1xuICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnY3JlYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNjb3BlSWRcbiAgICAgICAgc2V0U2NvcGVJZChlbCwgdm5vZGUsIHZub2RlLnNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgLy8gcHJvcHNcbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICd2YWx1ZScgJiYgISgwLCBzaGFyZWRfMS5pc1Jlc2VydmVkUHJvcCkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIG51bGwsIHByb3BzW2tleV0sIGlzU1ZHLCB2bm9kZS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNwZWNpYWwgY2FzZSBmb3Igc2V0dGluZyB2YWx1ZSBvbiBET00gZWxlbWVudHM6XG4gICAgICAgICAgICAgKiAtIGl0IGNhbiBiZSBvcmRlci1zZW5zaXRpdmUgKGUuZy4gc2hvdWxkIGJlIHNldCAqYWZ0ZXIqIG1pbi9tYXgsICMyMzI1LCAjNDAyNClcbiAgICAgICAgICAgICAqIC0gaXQgbmVlZHMgdG8gYmUgZm9yY2VkICgjMTQ3MSlcbiAgICAgICAgICAgICAqICMyMzUzIHByb3Bvc2VzIGFkZGluZyBhbm90aGVyIHJlbmRlcmVyIG9wdGlvbiB0byBjb25maWd1cmUgdGhpcywgYnV0XG4gICAgICAgICAgICAgKiB0aGUgcHJvcGVydGllcyBhZmZlY3RzIGFyZSBzbyBmaW5pdGUgaXQgaXMgd29ydGggc3BlY2lhbCBjYXNpbmcgaXRcbiAgICAgICAgICAgICAqIGhlcmUgdG8gcmVkdWNlIHRoZSBjb21wbGV4aXR5LiAoU3BlY2lhbCBjYXNpbmcgaXQgYWxzbyBzaG91bGQgbm90XG4gICAgICAgICAgICAgKiBhZmZlY3Qgbm9uLURPTSByZW5kZXJlcnMpXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICgndmFsdWUnIGluIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ3ZhbHVlJywgbnVsbCwgcHJvcHMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwgJ19fdm5vZGUnLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZub2RlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwgJ19fdnVlUGFyZW50Q29tcG9uZW50Jywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJzKSB7XG4gICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdiZWZvcmVNb3VudCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vICMxNTgzIEZvciBpbnNpZGUgc3VzcGVuc2UgKyBzdXNwZW5zZSBub3QgcmVzb2x2ZWQgY2FzZSwgZW50ZXIgaG9vayBzaG91bGQgY2FsbCB3aGVuIHN1c3BlbnNlIHJlc29sdmVkXG4gICAgICAgIC8vICMxNjg5IEZvciBpbnNpZGUgc3VzcGVuc2UgKyBzdXNwZW5zZSByZXNvbHZlZCBjYXNlLCBqdXN0IGNhbGwgaXRcbiAgICAgICAgY29uc3QgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSAoIXBhcmVudFN1c3BlbnNlIHx8IChwYXJlbnRTdXNwZW5zZSAmJiAhcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCkpICYmXG4gICAgICAgICAgICB0cmFuc2l0aW9uICYmXG4gICAgICAgICAgICAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQ7XG4gICAgICAgIGlmIChuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xuICAgICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSB8fFxuICAgICAgICAgICAgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgfHxcbiAgICAgICAgICAgIGRpcnMpIHtcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdm5vZGVIb29rICYmIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICAgICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzICYmIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgICAgICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnbW91bnRlZCcpO1xuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZXRTY29wZUlkID0gKGVsLCB2bm9kZSwgc2NvcGVJZCwgc2xvdFNjb3BlSWRzLCBwYXJlbnRDb21wb25lbnQpID0+IHtcbiAgICAgICAgaWYgKHNjb3BlSWQpIHtcbiAgICAgICAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzY29wZUlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2xvdFNjb3BlSWRzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsb3RTY29wZUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGhvc3RTZXRTY29wZUlkKGVsLCBzbG90U2NvcGVJZHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGxldCBzdWJUcmVlID0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWU7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgc3ViVHJlZS5wYXRjaEZsYWcgPiAwICYmXG4gICAgICAgICAgICAgICAgc3ViVHJlZS5wYXRjaEZsYWcgJiAyMDQ4IC8qIFBhdGNoRmxhZ3MuREVWX1JPT1RfRlJBR01FTlQgKi8pIHtcbiAgICAgICAgICAgICAgICBzdWJUcmVlID1cbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyU2luZ2xlUm9vdChzdWJUcmVlLmNoaWxkcmVuKSB8fCBzdWJUcmVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZub2RlID09PSBzdWJUcmVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Vk5vZGUgPSBwYXJlbnRDb21wb25lbnQudm5vZGU7XG4gICAgICAgICAgICAgICAgc2V0U2NvcGVJZChlbCwgcGFyZW50Vk5vZGUsIHBhcmVudFZOb2RlLnNjb3BlSWQsIHBhcmVudFZOb2RlLnNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50LnBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHN0YXJ0ID0gMCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSAoY2hpbGRyZW5baV0gPSBvcHRpbWl6ZWRcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGNoaWxkcmVuW2ldKVxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pKTtcbiAgICAgICAgICAgIHBhdGNoKG51bGwsIGNoaWxkLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcGF0Y2hFbGVtZW50ID0gKG4xLCBuMiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gKG4yLmVsID0gbjEuZWwpO1xuICAgICAgICBsZXQgeyBwYXRjaEZsYWcsIGR5bmFtaWNDaGlsZHJlbiwgZGlycyB9ID0gbjI7XG4gICAgICAgIC8vICMxNDI2IHRha2UgdGhlIG9sZCB2bm9kZSdzIHBhdGNoIGZsYWcgaW50byBhY2NvdW50IHNpbmNlIHVzZXIgbWF5IGNsb25lIGFcbiAgICAgICAgLy8gY29tcGlsZXItZ2VuZXJhdGVkIHZub2RlLCB3aGljaCBkZS1vcHRzIHRvIEZVTExfUFJPUFNcbiAgICAgICAgcGF0Y2hGbGFnIHw9IG4xLnBhdGNoRmxhZyAmIDE2IC8qIFBhdGNoRmxhZ3MuRlVMTF9QUk9QUyAqLztcbiAgICAgICAgY29uc3Qgb2xkUHJvcHMgPSBuMS5wcm9wcyB8fCBzaGFyZWRfMS5FTVBUWV9PQko7XG4gICAgICAgIGNvbnN0IG5ld1Byb3BzID0gbjIucHJvcHMgfHwgc2hhcmVkXzEuRU1QVFlfT0JKO1xuICAgICAgICBsZXQgdm5vZGVIb29rO1xuICAgICAgICAvLyBkaXNhYmxlIHJlY3Vyc2UgaW4gYmVmb3JlVXBkYXRlIGhvb2tzXG4gICAgICAgIHBhcmVudENvbXBvbmVudCAmJiB0b2dnbGVSZWN1cnNlKHBhcmVudENvbXBvbmVudCwgZmFsc2UpO1xuICAgICAgICBpZiAoKHZub2RlSG9vayA9IG5ld1Byb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpKSB7XG4gICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcnMpIHtcbiAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sobjIsIG4xLCBwYXJlbnRDb21wb25lbnQsICdiZWZvcmVVcGRhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnRDb21wb25lbnQgJiYgdG9nZ2xlUmVjdXJzZShwYXJlbnRDb21wb25lbnQsIHRydWUpO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICAgICAgICAgIC8vIEhNUiB1cGRhdGVkLCBmb3JjZSBmdWxsIGRpZmZcbiAgICAgICAgICAgIHBhdGNoRmxhZyA9IDA7XG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJlQ2hpbGRyZW5TVkcgPSBpc1NWRyAmJiBuMi50eXBlICE9PSAnZm9yZWlnbk9iamVjdCc7XG4gICAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihuMS5keW5hbWljQ2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiwgZWwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGFyZUNoaWxkcmVuU1ZHLCBzbG90U2NvcGVJZHMpO1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnR5cGUuX19obXJJZCkge1xuICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghb3B0aW1pemVkKSB7XG4gICAgICAgICAgICAvLyBmdWxsIGRpZmZcbiAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBlbCwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgYXJlQ2hpbGRyZW5TVkcsIHNsb3RTY29wZUlkcywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XG4gICAgICAgICAgICAvLyB0aGUgcHJlc2VuY2Ugb2YgYSBwYXRjaEZsYWcgbWVhbnMgdGhpcyBlbGVtZW50J3MgcmVuZGVyIGNvZGUgd2FzXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZWQgYnkgdGhlIGNvbXBpbGVyIGFuZCBjYW4gdGFrZSB0aGUgZmFzdCBwYXRoLlxuICAgICAgICAgICAgLy8gaW4gdGhpcyBwYXRoIG9sZCBub2RlIGFuZCBuZXcgbm9kZSBhcmUgZ3VhcmFudGVlZCB0byBoYXZlIHRoZSBzYW1lIHNoYXBlXG4gICAgICAgICAgICAvLyAoaS5lLiBhdCB0aGUgZXhhY3Qgc2FtZSBwb3NpdGlvbiBpbiB0aGUgc291cmNlIHRlbXBsYXRlKVxuICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDE2IC8qIFBhdGNoRmxhZ3MuRlVMTF9QUk9QUyAqLykge1xuICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgcHJvcHMgY29udGFpbiBkeW5hbWljIGtleXMsIGZ1bGwgZGlmZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBwYXRjaFByb3BzKGVsLCBuMiwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjbGFzc1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGR5bmFtaWMgY2xhc3MgYmluZGluZ3MuXG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDIgLyogUGF0Y2hGbGFncy5DTEFTUyAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkUHJvcHMuY2xhc3MgIT09IG5ld1Byb3BzLmNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCAnY2xhc3MnLCBudWxsLCBuZXdQcm9wcy5jbGFzcywgaXNTVkcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHN0eWxlXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBmbGFnIGlzIG1hdGNoZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgZHluYW1pYyBzdHlsZSBiaW5kaW5nc1xuICAgICAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiA0IC8qIFBhdGNoRmxhZ3MuU1RZTEUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ3N0eWxlJywgb2xkUHJvcHMuc3R5bGUsIG5ld1Byb3BzLnN0eWxlLCBpc1NWRyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHByb3BzXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBmbGFnIGlzIG1hdGNoZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgZHluYW1pYyBwcm9wL2F0dHIgYmluZGluZ3NcbiAgICAgICAgICAgICAgICAvLyBvdGhlciB0aGFuIGNsYXNzIGFuZCBzdHlsZS4gVGhlIGtleXMgb2YgZHluYW1pYyBwcm9wL2F0dHJzIGFyZSBzYXZlZCBmb3JcbiAgICAgICAgICAgICAgICAvLyBmYXN0ZXIgaXRlcmF0aW9uLlxuICAgICAgICAgICAgICAgIC8vIE5vdGUgZHluYW1pYyBrZXlzIGxpa2UgOltmb29dPVwiYmFyXCIgd2lsbCBjYXVzZSB0aGlzIG9wdGltaXphdGlvbiB0b1xuICAgICAgICAgICAgICAgIC8vIGJhaWwgb3V0IGFuZCBnbyB0aHJvdWdoIGEgZnVsbCBkaWZmIGJlY2F1c2Ugd2UgbmVlZCB0byB1bnNldCB0aGUgb2xkIGtleVxuICAgICAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiA4IC8qIFBhdGNoRmxhZ3MuUFJPUFMgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGZsYWcgaXMgcHJlc2VudCB0aGVuIGR5bmFtaWNQcm9wcyBtdXN0IGJlIG5vbi1udWxsXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBuMi5keW5hbWljUHJvcHM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAjMTQ3MSBmb3JjZSBwYXRjaCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHByZXYgfHwga2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBwcmV2LCBuZXh0LCBpc1NWRywgbjEuY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXh0XG4gICAgICAgICAgICAvLyBUaGlzIGZsYWcgaXMgbWF0Y2hlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBvbmx5IGR5bmFtaWMgdGV4dCBjaGlsZHJlbi5cbiAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiAxIC8qIFBhdGNoRmxhZ3MuVEVYVCAqLykge1xuICAgICAgICAgICAgICAgIGlmIChuMS5jaGlsZHJlbiAhPT0gbjIuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFvcHRpbWl6ZWQgJiYgZHluYW1pY0NoaWxkcmVuID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHVub3B0aW1pemVkLCBmdWxsIGRpZmZcbiAgICAgICAgICAgIHBhdGNoUHJvcHMoZWwsIG4yLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHZub2RlSG9vayA9IG5ld1Byb3BzLm9uVm5vZGVVcGRhdGVkKSB8fCBkaXJzKSB7XG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XG4gICAgICAgICAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCAndXBkYXRlZCcpO1xuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBUaGUgZmFzdCBwYXRoIGZvciBibG9ja3MuXG4gICAgY29uc3QgcGF0Y2hCbG9ja0NoaWxkcmVuID0gKG9sZENoaWxkcmVuLCBuZXdDaGlsZHJlbiwgZmFsbGJhY2tDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgb2xkVk5vZGUgPSBvbGRDaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZOb2RlID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGNvbnRhaW5lciAocGFyZW50IGVsZW1lbnQpIGZvciB0aGUgcGF0Y2guXG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBcbiAgICAgICAgICAgIC8vIG9sZFZOb2RlIG1heSBiZSBhbiBlcnJvcmVkIGFzeW5jIHNldHVwKCkgY29tcG9uZW50IGluc2lkZSBTdXNwZW5zZVxuICAgICAgICAgICAgLy8gd2hpY2ggd2lsbCBub3QgaGF2ZSBhIG1vdW50ZWQgZWxlbWVudFxuICAgICAgICAgICAgb2xkVk5vZGUuZWwgJiZcbiAgICAgICAgICAgICAgICAvLyAtIEluIHRoZSBjYXNlIG9mIGEgRnJhZ21lbnQsIHdlIG5lZWQgdG8gcHJvdmlkZSB0aGUgYWN0dWFsIHBhcmVudFxuICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBGcmFnbWVudCBpdHNlbGYgc28gaXQgY2FuIG1vdmUgaXRzIGNoaWxkcmVuLlxuICAgICAgICAgICAgICAgIChvbGRWTm9kZS50eXBlID09PSBGcmFnbWVudCB8fFxuICAgICAgICAgICAgICAgICAgICAvLyAtIEluIHRoZSBjYXNlIG9mIGRpZmZlcmVudCBub2RlcywgdGhlcmUgaXMgZ29pbmcgdG8gYmUgYSByZXBsYWNlbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBhbHNvIHJlcXVpcmVzIHRoZSBjb3JyZWN0IHBhcmVudCBjb250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgIWlzU2FtZVZOb2RlVHlwZShvbGRWTm9kZSwgbmV3Vk5vZGUpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIC0gSW4gdGhlIGNhc2Ugb2YgYSBjb21wb25lbnQsIGl0IGNvdWxkIGNvbnRhaW4gYW55dGhpbmcuXG4gICAgICAgICAgICAgICAgICAgIG9sZFZOb2RlLnNoYXBlRmxhZyAmICg2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UICovIHwgNjQgLyogU2hhcGVGbGFncy5URUxFUE9SVCAqLykpXG4gICAgICAgICAgICAgICAgPyBob3N0UGFyZW50Tm9kZShvbGRWTm9kZS5lbClcbiAgICAgICAgICAgICAgICA6IC8vIEluIG90aGVyIGNhc2VzLCB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBub3QgYWN0dWFsbHkgdXNlZCBzbyB3ZVxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHBhc3MgdGhlIGJsb2NrIGVsZW1lbnQgaGVyZSB0byBhdm9pZCBhIERPTSBwYXJlbnROb2RlIGNhbGwuXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrQ29udGFpbmVyO1xuICAgICAgICAgICAgcGF0Y2gob2xkVk5vZGUsIG5ld1ZOb2RlLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwYXRjaFByb3BzID0gKGVsLCB2bm9kZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRykgPT4ge1xuICAgICAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzKSB7XG4gICAgICAgICAgICBpZiAob2xkUHJvcHMgIT09IHNoYXJlZF8xLkVNUFRZX09CSikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKDAsIHNoYXJlZF8xLmlzUmVzZXJ2ZWRQcm9wKShrZXkpICYmICEoa2V5IGluIG5ld1Byb3BzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBvbGRQcm9wc1trZXldLCBudWxsLCBpc1NWRywgdm5vZGUuY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdQcm9wcykge1xuICAgICAgICAgICAgICAgIC8vIGVtcHR5IHN0cmluZyBpcyBub3QgdmFsaWQgcHJvcFxuICAgICAgICAgICAgICAgIGlmICgoMCwgc2hhcmVkXzEuaXNSZXNlcnZlZFByb3ApKGtleSkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xuICAgICAgICAgICAgICAgIC8vIGRlZmVyIHBhdGNoaW5nIHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHByZXYgJiYga2V5ICE9PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgcHJldiwgbmV4dCwgaXNTVkcsIHZub2RlLmNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgndmFsdWUnIGluIG5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ3ZhbHVlJywgb2xkUHJvcHMudmFsdWUsIG5ld1Byb3BzLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJvY2Vzc0ZyYWdtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBjb25zdCBmcmFnbWVudFN0YXJ0QW5jaG9yID0gKG4yLmVsID0gbjEgPyBuMS5lbCA6IGhvc3RDcmVhdGVUZXh0KCcnKSk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50RW5kQW5jaG9yID0gKG4yLmFuY2hvciA9IG4xID8gbjEuYW5jaG9yIDogaG9zdENyZWF0ZVRleHQoJycpKTtcbiAgICAgICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IG4yO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAvLyAjNTUyMyBkZXYgcm9vdCBmcmFnbWVudCBtYXkgaW5oZXJpdCBkaXJlY3RpdmVzXG4gICAgICAgICAgICAoaXNIbXJVcGRhdGluZyB8fCBwYXRjaEZsYWcgJiAyMDQ4IC8qIFBhdGNoRmxhZ3MuREVWX1JPT1RfRlJBR01FTlQgKi8pKSB7XG4gICAgICAgICAgICAvLyBITVIgdXBkYXRlZCAvIERldiByb290IGZyYWdtZW50ICh3LyBjb21tZW50cyksIGZvcmNlIGZ1bGwgZGlmZlxuICAgICAgICAgICAgcGF0Y2hGbGFnID0gMDtcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIGEgc2xvdCBmcmFnbWVudCB3aXRoIDpzbG90dGVkIHNjb3BlIGlkc1xuICAgICAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkc1xuICAgICAgICAgICAgICAgID8gc2xvdFNjb3BlSWRzLmNvbmNhdChmcmFnbWVudFNsb3RTY29wZUlkcylcbiAgICAgICAgICAgICAgICA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICAgICAgICBob3N0SW5zZXJ0KGZyYWdtZW50U3RhcnRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRFbmRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgICAgIC8vIGEgZnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBhcnJheSBjaGlsZHJlblxuICAgICAgICAgICAgLy8gc2luY2UgdGhleSBhcmUgZWl0aGVyIGdlbmVyYXRlZCBieSB0aGUgY29tcGlsZXIsIG9yIGltcGxpY2l0bHkgY3JlYXRlZFxuICAgICAgICAgICAgLy8gZnJvbSBhcnJheXMuXG4gICAgICAgICAgICBtb3VudENoaWxkcmVuKG4yLmNoaWxkcmVuLCBjb250YWluZXIsIGZyYWdtZW50RW5kQW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyA+IDAgJiZcbiAgICAgICAgICAgICAgICBwYXRjaEZsYWcgJiA2NCAvKiBQYXRjaEZsYWdzLlNUQUJMRV9GUkFHTUVOVCAqLyAmJlxuICAgICAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbiAmJlxuICAgICAgICAgICAgICAgIC8vICMyNzE1IHRoZSBwcmV2aW91cyBmcmFnbWVudCBjb3VsZCd2ZSBiZWVuIGEgQkFJTGVkIG9uZSBhcyBhIHJlc3VsdFxuICAgICAgICAgICAgICAgIC8vIG9mIHJlbmRlclNsb3QoKSB3aXRoIG5vIHZhbGlkIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgLy8gYSBzdGFibGUgZnJhZ21lbnQgKHRlbXBsYXRlIHJvb3Qgb3IgPHRlbXBsYXRlIHYtZm9yPikgZG9lc24ndCBuZWVkIHRvXG4gICAgICAgICAgICAgICAgLy8gcGF0Y2ggY2hpbGRyZW4gb3JkZXIsIGJ1dCBpdCBtYXkgY29udGFpbiBkeW5hbWljQ2hpbGRyZW4uXG4gICAgICAgICAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKG4xLmR5bmFtaWNDaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC50eXBlLl9faG1ySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAvLyAjMjA4MCBpZiB0aGUgc3RhYmxlIGZyYWdtZW50IGhhcyBhIGtleSwgaXQncyBhIDx0ZW1wbGF0ZSB2LWZvcj4gdGhhdCBtYXlcbiAgICAgICAgICAgICAgICAvLyAgZ2V0IG1vdmVkIGFyb3VuZC4gTWFrZSBzdXJlIGFsbCByb290IGxldmVsIHZub2RlcyBpbmhlcml0IGVsLlxuICAgICAgICAgICAgICAgIC8vICMyMTM0IG9yIGlmIGl0J3MgYSBjb21wb25lbnQgcm9vdCwgaXQgbWF5IGFsc28gZ2V0IG1vdmVkIGFyb3VuZFxuICAgICAgICAgICAgICAgIC8vIGFzIHRoZSBjb21wb25lbnQgaXMgYmVpbmcgbW92ZWQuXG4gICAgICAgICAgICAgICAgbjIua2V5ICE9IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgKHBhcmVudENvbXBvbmVudCAmJiBuMiA9PT0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCB0cnVlIC8qIHNoYWxsb3cgKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGtleWVkIC8gdW5rZXllZCwgb3IgbWFudWFsIGZyYWdtZW50cy5cbiAgICAgICAgICAgICAgICAvLyBmb3Iga2V5ZWQgJiB1bmtleWVkLCBzaW5jZSB0aGV5IGFyZSBjb21waWxlciBnZW5lcmF0ZWQgZnJvbSB2LWZvcixcbiAgICAgICAgICAgICAgICAvLyBlYWNoIGNoaWxkIGlzIGd1YXJhbnRlZWQgdG8gYmUgYSBibG9jayBzbyB0aGUgZnJhZ21lbnQgd2lsbCBuZXZlclxuICAgICAgICAgICAgICAgIC8vIGhhdmUgZHluYW1pY0NoaWxkcmVuLlxuICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBjb250YWluZXIsIGZyYWdtZW50RW5kQW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwcm9jZXNzQ29tcG9uZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBuMi5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobjIuc2hhcGVGbGFnICYgNTEyIC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi8pIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmFjdGl2YXRlKG4yLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcsIG9wdGltaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb3VudENvbXBvbmVudChuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbW91bnRDb21wb25lbnQgPSAoaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IChpbml0aWFsVk5vZGUuY29tcG9uZW50ID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2UoaW5pdGlhbFZOb2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKSk7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XG4gICAgICAgICAgICByZWdpc3RlckhNUihpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGluaXRpYWxWTm9kZSk7XG4gICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluamVjdCByZW5kZXJlciBpbnRlcm5hbHMgZm9yIGtlZXBBbGl2ZVxuICAgICAgICBpZiAoaXNLZWVwQWxpdmUoaW5pdGlhbFZOb2RlKSkge1xuICAgICAgICAgICAgaW5zdGFuY2UuY3R4LnJlbmRlcmVyID0gaW50ZXJuYWxzO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlc29sdmUgcHJvcHMgYW5kIHNsb3RzIGZvciBzZXR1cCBjb250ZXh0XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBpbml0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXR1cENvbXBvbmVudChpbnN0YW5jZSk7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzZXR1cCgpIGlzIGFzeW5jLiBUaGlzIGNvbXBvbmVudCByZWxpZXMgb24gYXN5bmMgbG9naWMgdG8gYmUgcmVzb2x2ZWRcbiAgICAgICAgLy8gYmVmb3JlIHByb2NlZWRpbmdcbiAgICAgICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwKSB7XG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5yZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QpO1xuICAgICAgICAgICAgLy8gR2l2ZSBpdCBhIHBsYWNlaG9sZGVyIGlmIHRoaXMgaXMgbm90IGh5ZHJhdGlvblxuICAgICAgICAgICAgLy8gVE9ETyBoYW5kbGUgc2VsZi1kZWZpbmVkIGZhbGxiYWNrXG4gICAgICAgICAgICBpZiAoIWluaXRpYWxWTm9kZS5lbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gKGluc3RhbmNlLnN1YlRyZWUgPSBjcmVhdGVWTm9kZShDb21tZW50KSk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0NvbW1lbnROb2RlKG51bGwsIHBsYWNlaG9sZGVyLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0dXBSZW5kZXJFZmZlY3QoaW5zdGFuY2UsIGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGVDb21wb25lbnQgPSAobjEsIG4yLCBvcHRpbWl6ZWQpID0+IHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSAobjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50KTtcbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZUNvbXBvbmVudChuMSwgbjIsIG9wdGltaXplZCkpIHtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5hc3luY0RlcCAmJlxuICAgICAgICAgICAgICAgICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gYXN5bmMgJiBzdGlsbCBwZW5kaW5nIC0ganVzdCB1cGRhdGUgcHJvcHMgYW5kIHNsb3RzXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIGNvbXBvbmVudCdzIHJlYWN0aXZlIGVmZmVjdCBmb3IgcmVuZGVyIGlzbid0IHNldC11cCB5ZXRcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChuMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbjIsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBub3JtYWwgdXBkYXRlXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UubmV4dCA9IG4yO1xuICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIGNoaWxkIGNvbXBvbmVudCBpcyBhbHNvIHF1ZXVlZCwgcmVtb3ZlIGl0IHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlIHVwZGF0aW5nIHRoZSBzYW1lIGNoaWxkIGNvbXBvbmVudCBpbiB0aGUgc2FtZSBmbHVzaC5cbiAgICAgICAgICAgICAgICBpbnZhbGlkYXRlSm9iKGluc3RhbmNlLnVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgLy8gaW5zdGFuY2UudXBkYXRlIGlzIHRoZSByZWFjdGl2ZSBlZmZlY3QuXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBubyB1cGRhdGUgbmVlZGVkLiBqdXN0IGNvcHkgb3ZlciBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgICAgICAgaW5zdGFuY2Uudm5vZGUgPSBuMjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0dXBSZW5kZXJFZmZlY3QgPSAoaW5zdGFuY2UsIGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudFVwZGF0ZUZuID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpbnN0YW5jZS5pc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdm5vZGVIb29rO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZWwsIHByb3BzIH0gPSBpbml0aWFsVk5vZGU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBibSwgbSwgcGFyZW50IH0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0FzeW5jV3JhcHBlclZOb2RlID0gaXNBc3luY1dyYXBwZXIoaW5pdGlhbFZOb2RlKTtcbiAgICAgICAgICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlTW91bnQgaG9va1xuICAgICAgICAgICAgICAgIGlmIChibSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgc2hhcmVkXzEuaW52b2tlQXJyYXlGbnMpKGJtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZUJlZm9yZU1vdW50XG4gICAgICAgICAgICAgICAgaWYgKCFpc0FzeW5jV3JhcHBlclZOb2RlICYmXG4gICAgICAgICAgICAgICAgICAgICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgaW5pdGlhbFZOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVsICYmIGh5ZHJhdGVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZub2RlIGhhcyBhZG9wdGVkIGhvc3Qgbm9kZSAtIHBlcmZvcm0gaHlkcmF0aW9uIGluc3RlYWQgb2YgbW91bnQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGh5ZHJhdGVTdWJUcmVlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBoeWRyYXRlTm9kZShlbCwgaW5zdGFuY2Uuc3ViVHJlZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3luY1dyYXBwZXJWTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFZOb2RlLnR5cGUuX19hc3luY0xvYWRlcigpLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RlOiB3ZSBhcmUgbW92aW5nIHRoZSByZW5kZXIgY2FsbCBpbnRvIGFuIGFzeW5jIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggbWVhbnMgaXQgd29uJ3QgdHJhY2sgZGVwZW5kZW5jaWVzIC0gYnV0IGl0J3Mgb2sgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBzZXJ2ZXItcmVuZGVyZWQgYXN5bmMgd3JhcHBlciBpcyBhbHJlYWR5IGluIHJlc29sdmVkIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgaXQgd2lsbCBuZXZlciBuZWVkIHRvIGNoYW5nZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICgpID0+ICFpbnN0YW5jZS5pc1VubW91bnRlZCAmJiBoeWRyYXRlU3ViVHJlZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGVTdWJUcmVlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YlRyZWUgPSAoaW5zdGFuY2Uuc3ViVHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgc3ViVHJlZSwgY29udGFpbmVyLCBhbmNob3IsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsVk5vZGUuZWwgPSBzdWJUcmVlLmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QobSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBvblZub2RlTW91bnRlZFxuICAgICAgICAgICAgICAgIGlmICghaXNBc3luY1dyYXBwZXJWTm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjb3BlZEluaXRpYWxWTm9kZSA9IGluaXRpYWxWTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgc2NvcGVkSW5pdGlhbFZOb2RlKSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhY3RpdmF0ZWQgaG9vayBmb3Iga2VlcC1hbGl2ZSByb290cy5cbiAgICAgICAgICAgICAgICAvLyAjMTc0MiBhY3RpdmF0ZWQgaG9vayBtdXN0IGJlIGFjY2Vzc2VkIGFmdGVyIGZpcnN0IHJlbmRlclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBob29rIG1heSBiZSBpbmplY3RlZCBieSBhIGNoaWxkIGtlZXAtYWxpdmVcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbFZOb2RlLnNoYXBlRmxhZyAmIDI1NiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLyB8fFxuICAgICAgICAgICAgICAgICAgICAocGFyZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FzeW5jV3JhcHBlcihwYXJlbnQudm5vZGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQudm5vZGUuc2hhcGVGbGFnICYgMjU2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5hICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChpbnN0YW5jZS5hLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICMyNDU4OiBkZWZlcmVuY2UgbW91bnQtb25seSBvYmplY3QgcGFyYW1ldGVycyB0byBwcmV2ZW50IG1lbWxlYWtzXG4gICAgICAgICAgICAgICAgaW5pdGlhbFZOb2RlID0gY29udGFpbmVyID0gYW5jaG9yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZUNvbXBvbmVudFxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdHJpZ2dlcmVkIGJ5IG11dGF0aW9uIG9mIGNvbXBvbmVudCdzIG93biBzdGF0ZSAobmV4dDogbnVsbClcbiAgICAgICAgICAgICAgICAvLyBPUiBwYXJlbnQgY2FsbGluZyBwcm9jZXNzQ29tcG9uZW50IChuZXh0OiBWTm9kZSlcbiAgICAgICAgICAgICAgICBsZXQgeyBuZXh0LCBidSwgdSwgcGFyZW50LCB2bm9kZSB9ID0gaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgbGV0IG9yaWdpbk5leHQgPSBuZXh0O1xuICAgICAgICAgICAgICAgIGxldCB2bm9kZUhvb2s7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobmV4dCB8fCBpbnN0YW5jZS52bm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIERpc2FsbG93IGNvbXBvbmVudCBlZmZlY3QgcmVjdXJzaW9uIGR1cmluZyBwcmUtbGlmZWN5Y2xlIGhvb2tzLlxuICAgICAgICAgICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0LmVsID0gdm5vZGUuZWw7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbmV4dCwgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSB2bm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlVXBkYXRlIGhvb2tcbiAgICAgICAgICAgICAgICBpZiAoYnUpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHNoYXJlZF8xLmludm9rZUFycmF5Rm5zKShidSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG9uVm5vZGVCZWZvcmVVcGRhdGVcbiAgICAgICAgICAgICAgICBpZiAoKHZub2RlSG9vayA9IG5leHQucHJvcHMgJiYgbmV4dC5wcm9wcy5vblZub2RlQmVmb3JlVXBkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIG5leHQsIHZub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldlRyZWUgPSBpbnN0YW5jZS5zdWJUcmVlO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLnN1YlRyZWUgPSBuZXh0VHJlZTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdGNoKHByZXZUcmVlLCBuZXh0VHJlZSwgXG4gICAgICAgICAgICAgICAgLy8gcGFyZW50IG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIHRlbGVwb3J0XG4gICAgICAgICAgICAgICAgaG9zdFBhcmVudE5vZGUocHJldlRyZWUuZWwpLCBcbiAgICAgICAgICAgICAgICAvLyBhbmNob3IgbWF5IGhhdmUgY2hhbmdlZCBpZiBpdCdzIGluIGEgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICBnZXROZXh0SG9zdE5vZGUocHJldlRyZWUpLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0LmVsID0gbmV4dFRyZWUuZWw7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbk5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VsZi10cmlnZ2VyZWQgdXBkYXRlLiBJbiBjYXNlIG9mIEhPQywgdXBkYXRlIHBhcmVudCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gdm5vZGUgZWwuIEhPQyBpcyBpbmRpY2F0ZWQgYnkgcGFyZW50IGluc3RhbmNlJ3Mgc3ViVHJlZSBwb2ludGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyB0byBjaGlsZCBjb21wb25lbnQncyB2bm9kZVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIG5leHRUcmVlLmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlZCBob29rXG4gICAgICAgICAgICAgICAgaWYgKHUpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KHUsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZVVwZGF0ZWRcbiAgICAgICAgICAgICAgICBpZiAoKHZub2RlSG9vayA9IG5leHQucHJvcHMgJiYgbmV4dC5wcm9wcy5vblZub2RlVXBkYXRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgbmV4dCwgdm5vZGUpLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGNyZWF0ZSByZWFjdGl2ZSBlZmZlY3QgZm9yIHJlbmRlcmluZ1xuICAgICAgICBjb25zdCBlZmZlY3QgPSAoaW5zdGFuY2UuZWZmZWN0ID0gbmV3IHJlYWN0aXZpdHlfMS5SZWFjdGl2ZUVmZmVjdChjb21wb25lbnRVcGRhdGVGbiwgKCkgPT4gcXVldWVKb2IodXBkYXRlKSwgaW5zdGFuY2Uuc2NvcGUgLy8gdHJhY2sgaXQgaW4gY29tcG9uZW50J3MgZWZmZWN0IHNjb3BlXG4gICAgICAgICkpO1xuICAgICAgICBjb25zdCB1cGRhdGUgPSAoaW5zdGFuY2UudXBkYXRlID0gKCkgPT4gZWZmZWN0LnJ1bigpKTtcbiAgICAgICAgdXBkYXRlLmlkID0gaW5zdGFuY2UudWlkO1xuICAgICAgICAvLyBhbGxvd1JlY3Vyc2VcbiAgICAgICAgLy8gIzE4MDEsICMyMDQzIGNvbXBvbmVudCByZW5kZXIgZWZmZWN0cyBzaG91bGQgYWxsb3cgcmVjdXJzaXZlIHVwZGF0ZXNcbiAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIGVmZmVjdC5vblRyYWNrID0gaW5zdGFuY2UucnRjXG4gICAgICAgICAgICAgICAgPyBlID0+ICgwLCBzaGFyZWRfMS5pbnZva2VBcnJheUZucykoaW5zdGFuY2UucnRjLCBlKVxuICAgICAgICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgICAgICAgZWZmZWN0Lm9uVHJpZ2dlciA9IGluc3RhbmNlLnJ0Z1xuICAgICAgICAgICAgICAgID8gZSA9PiAoMCwgc2hhcmVkXzEuaW52b2tlQXJyYXlGbnMpKGluc3RhbmNlLnJ0ZywgZSlcbiAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgIHVwZGF0ZS5vd25lckluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKCk7XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIgPSAoaW5zdGFuY2UsIG5leHRWTm9kZSwgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIG5leHRWTm9kZS5jb21wb25lbnQgPSBpbnN0YW5jZTtcbiAgICAgICAgY29uc3QgcHJldlByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHM7XG4gICAgICAgIGluc3RhbmNlLnZub2RlID0gbmV4dFZOb2RlO1xuICAgICAgICBpbnN0YW5jZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgdXBkYXRlUHJvcHMoaW5zdGFuY2UsIG5leHRWTm9kZS5wcm9wcywgcHJldlByb3BzLCBvcHRpbWl6ZWQpO1xuICAgICAgICB1cGRhdGVTbG90cyhpbnN0YW5jZSwgbmV4dFZOb2RlLmNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xuICAgICAgICAoMCwgcmVhY3Rpdml0eV8xLnBhdXNlVHJhY2tpbmcpKCk7XG4gICAgICAgIC8vIHByb3BzIHVwZGF0ZSBtYXkgaGF2ZSB0cmlnZ2VyZWQgcHJlLWZsdXNoIHdhdGNoZXJzLlxuICAgICAgICAvLyBmbHVzaCB0aGVtIGJlZm9yZSB0aGUgcmVuZGVyIHVwZGF0ZS5cbiAgICAgICAgZmx1c2hQcmVGbHVzaENicygpO1xuICAgICAgICAoMCwgcmVhY3Rpdml0eV8xLnJlc2V0VHJhY2tpbmcpKCk7XG4gICAgfTtcbiAgICBjb25zdCBwYXRjaENoaWxkcmVuID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XG4gICAgICAgIGNvbnN0IGMxID0gbjEgJiYgbjEuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IHByZXZTaGFwZUZsYWcgPSBuMSA/IG4xLnNoYXBlRmxhZyA6IDA7XG4gICAgICAgIGNvbnN0IGMyID0gbjIuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IHsgcGF0Y2hGbGFnLCBzaGFwZUZsYWcgfSA9IG4yO1xuICAgICAgICAvLyBmYXN0IHBhdGhcbiAgICAgICAgaWYgKHBhdGNoRmxhZyA+IDApIHtcbiAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiAxMjggLyogUGF0Y2hGbGFncy5LRVlFRF9GUkFHTUVOVCAqLykge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgY291bGQgYmUgZWl0aGVyIGZ1bGx5LWtleWVkIG9yIG1peGVkIChzb21lIGtleWVkIHNvbWUgbm90KVxuICAgICAgICAgICAgICAgIC8vIHByZXNlbmNlIG9mIHBhdGNoRmxhZyBtZWFucyBjaGlsZHJlbiBhcmUgZ3VhcmFudGVlZCB0byBiZSBhcnJheXNcbiAgICAgICAgICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXRjaEZsYWcgJiAyNTYgLyogUGF0Y2hGbGFncy5VTktFWUVEX0ZSQUdNRU5UICovKSB7XG4gICAgICAgICAgICAgICAgLy8gdW5rZXllZFxuICAgICAgICAgICAgICAgIHBhdGNoVW5rZXllZENoaWxkcmVuKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNoaWxkcmVuIGhhcyAzIHBvc3NpYmlsaXRpZXM6IHRleHQsIGFycmF5IG9yIG5vIGNoaWxkcmVuLlxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgOCAvKiBTaGFwZUZsYWdzLlRFWFRfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgIC8vIHRleHQgY2hpbGRyZW4gZmFzdCBwYXRoXG4gICAgICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMyICE9PSBjMSkge1xuICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIGMyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgMTYgLyogU2hhcGVGbGFncy5BUlJBWV9DSElMRFJFTiAqLykge1xuICAgICAgICAgICAgICAgIC8vIHByZXYgY2hpbGRyZW4gd2FzIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHdvIGFycmF5cywgY2Fubm90IGFzc3VtZSBhbnl0aGluZywgZG8gZnVsbCBkaWZmXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gbmV3IGNoaWxkcmVuLCBqdXN0IHVubW91bnQgb2xkXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcHJldiBjaGlsZHJlbiB3YXMgdGV4dCBPUiBudWxsXG4gICAgICAgICAgICAgICAgLy8gbmV3IGNoaWxkcmVuIGlzIGFycmF5IE9SIG51bGxcbiAgICAgICAgICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDggLyogU2hhcGVGbGFncy5URVhUX0NISUxEUkVOICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbW91bnQgbmV3IGlmIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgbW91bnRDaGlsZHJlbihjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwYXRjaFVua2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICAgICAgYzEgPSBjMSB8fCBzaGFyZWRfMS5FTVBUWV9BUlI7XG4gICAgICAgIGMyID0gYzIgfHwgc2hhcmVkXzEuRU1QVFlfQVJSO1xuICAgICAgICBjb25zdCBvbGRMZW5ndGggPSBjMS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IGMyLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY29tbW9uTGVuZ3RoID0gTWF0aC5taW4ob2xkTGVuZ3RoLCBuZXdMZW5ndGgpO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbW1vbkxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSAoYzJbaV0gPSBvcHRpbWl6ZWRcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKTtcbiAgICAgICAgICAgIHBhdGNoKGMxW2ldLCBuZXh0Q2hpbGQsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkTGVuZ3RoID4gbmV3TGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgb2xkXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUsIGZhbHNlLCBjb21tb25MZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbW91bnQgbmV3XG4gICAgICAgICAgICBtb3VudENoaWxkcmVuKGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBjb21tb25MZW5ndGgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBjYW4gYmUgYWxsLWtleWVkIG9yIG1peGVkXG4gICAgY29uc3QgcGF0Y2hLZXllZENoaWxkcmVuID0gKGMxLCBjMiwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGNvbnN0IGwyID0gYzIubGVuZ3RoO1xuICAgICAgICBsZXQgZTEgPSBjMS5sZW5ndGggLSAxOyAvLyBwcmV2IGVuZGluZyBpbmRleFxuICAgICAgICBsZXQgZTIgPSBsMiAtIDE7IC8vIG5leHQgZW5kaW5nIGluZGV4XG4gICAgICAgIC8vIDEuIHN5bmMgZnJvbSBzdGFydFxuICAgICAgICAvLyAoYSBiKSBjXG4gICAgICAgIC8vIChhIGIpIGQgZVxuICAgICAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XG4gICAgICAgICAgICBjb25zdCBuMSA9IGMxW2ldO1xuICAgICAgICAgICAgY29uc3QgbjIgPSAoYzJbaV0gPSBvcHRpbWl6ZWRcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKTtcbiAgICAgICAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xuICAgICAgICAgICAgICAgIHBhdGNoKG4xLCBuMiwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMi4gc3luYyBmcm9tIGVuZFxuICAgICAgICAvLyBhIChiIGMpXG4gICAgICAgIC8vIGQgZSAoYiBjKVxuICAgICAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XG4gICAgICAgICAgICBjb25zdCBuMSA9IGMxW2UxXTtcbiAgICAgICAgICAgIGNvbnN0IG4yID0gKGMyW2UyXSA9IG9wdGltaXplZFxuICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbZTJdKVxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbZTJdKSk7XG4gICAgICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcbiAgICAgICAgICAgICAgICBwYXRjaChuMSwgbjIsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZTEtLTtcbiAgICAgICAgICAgIGUyLS07XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4gY29tbW9uIHNlcXVlbmNlICsgbW91bnRcbiAgICAgICAgLy8gKGEgYilcbiAgICAgICAgLy8gKGEgYikgY1xuICAgICAgICAvLyBpID0gMiwgZTEgPSAxLCBlMiA9IDJcbiAgICAgICAgLy8gKGEgYilcbiAgICAgICAgLy8gYyAoYSBiKVxuICAgICAgICAvLyBpID0gMCwgZTEgPSAtMSwgZTIgPSAwXG4gICAgICAgIGlmIChpID4gZTEpIHtcbiAgICAgICAgICAgIGlmIChpIDw9IGUyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFBvcyA9IGUyICsgMTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0UG9zIDwgbDIgPyBjMltuZXh0UG9zXS5lbCA6IHBhcmVudEFuY2hvcjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8PSBlMikge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaChudWxsLCAoYzJbaV0gPSBvcHRpbWl6ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSksIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIDQuIGNvbW1vbiBzZXF1ZW5jZSArIHVubW91bnRcbiAgICAgICAgLy8gKGEgYikgY1xuICAgICAgICAvLyAoYSBiKVxuICAgICAgICAvLyBpID0gMiwgZTEgPSAyLCBlMiA9IDFcbiAgICAgICAgLy8gYSAoYiBjKVxuICAgICAgICAvLyAoYiBjKVxuICAgICAgICAvLyBpID0gMCwgZTEgPSAwLCBlMiA9IC0xXG4gICAgICAgIGVsc2UgaWYgKGkgPiBlMikge1xuICAgICAgICAgICAgd2hpbGUgKGkgPD0gZTEpIHtcbiAgICAgICAgICAgICAgICB1bm1vdW50KGMxW2ldLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gNS4gdW5rbm93biBzZXF1ZW5jZVxuICAgICAgICAvLyBbaSAuLi4gZTEgKyAxXTogYSBiIFtjIGQgZV0gZiBnXG4gICAgICAgIC8vIFtpIC4uLiBlMiArIDFdOiBhIGIgW2UgZCBjIGhdIGYgZ1xuICAgICAgICAvLyBpID0gMiwgZTEgPSA0LCBlMiA9IDVcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzMSA9IGk7IC8vIHByZXYgc3RhcnRpbmcgaW5kZXhcbiAgICAgICAgICAgIGNvbnN0IHMyID0gaTsgLy8gbmV4dCBzdGFydGluZyBpbmRleFxuICAgICAgICAgICAgLy8gNS4xIGJ1aWxkIGtleTppbmRleCBtYXAgZm9yIG5ld0NoaWxkcmVuXG4gICAgICAgICAgICBjb25zdCBrZXlUb05ld0luZGV4TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChpID0gczI7IGkgPD0gZTI7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IChjMltpXSA9IG9wdGltaXplZFxuICAgICAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxuICAgICAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGtleVRvTmV3SW5kZXhNYXAuaGFzKG5leHRDaGlsZC5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBEdXBsaWNhdGUga2V5cyBmb3VuZCBkdXJpbmcgdXBkYXRlOmAsIEpTT04uc3RyaW5naWZ5KG5leHRDaGlsZC5rZXkpLCBgTWFrZSBzdXJlIGtleXMgYXJlIHVuaXF1ZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBrZXlUb05ld0luZGV4TWFwLnNldChuZXh0Q2hpbGQua2V5LCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA1LjIgbG9vcCB0aHJvdWdoIG9sZCBjaGlsZHJlbiBsZWZ0IHRvIGJlIHBhdGNoZWQgYW5kIHRyeSB0byBwYXRjaFxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgbm9kZXMgJiByZW1vdmUgbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnRcbiAgICAgICAgICAgIGxldCBqO1xuICAgICAgICAgICAgbGV0IHBhdGNoZWQgPSAwO1xuICAgICAgICAgICAgY29uc3QgdG9CZVBhdGNoZWQgPSBlMiAtIHMyICsgMTtcbiAgICAgICAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gdXNlZCB0byB0cmFjayB3aGV0aGVyIGFueSBub2RlIGhhcyBtb3ZlZFxuICAgICAgICAgICAgbGV0IG1heE5ld0luZGV4U29GYXIgPSAwO1xuICAgICAgICAgICAgLy8gd29ya3MgYXMgTWFwPG5ld0luZGV4LCBvbGRJbmRleD5cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBvbGRJbmRleCBpcyBvZmZzZXQgYnkgKzFcbiAgICAgICAgICAgIC8vIGFuZCBvbGRJbmRleCA9IDAgaXMgYSBzcGVjaWFsIHZhbHVlIGluZGljYXRpbmcgdGhlIG5ldyBub2RlIGhhc1xuICAgICAgICAgICAgLy8gbm8gY29ycmVzcG9uZGluZyBvbGQgbm9kZS5cbiAgICAgICAgICAgIC8vIHVzZWQgZm9yIGRldGVybWluaW5nIGxvbmdlc3Qgc3RhYmxlIHN1YnNlcXVlbmNlXG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleFRvT2xkSW5kZXhNYXAgPSBuZXcgQXJyYXkodG9CZVBhdGNoZWQpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvQmVQYXRjaGVkOyBpKyspXG4gICAgICAgICAgICAgICAgbmV3SW5kZXhUb09sZEluZGV4TWFwW2ldID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IHMxOyBpIDw9IGUxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBjMVtpXTtcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hlZCA+PSB0b0JlUGF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbGwgbmV3IGNoaWxkcmVuIGhhdmUgYmVlbiBwYXRjaGVkIHNvIHRoaXMgY2FuIG9ubHkgYmUgYSByZW1vdmFsXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQocHJldkNoaWxkLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBuZXdJbmRleDtcbiAgICAgICAgICAgICAgICBpZiAocHJldkNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0luZGV4ID0ga2V5VG9OZXdJbmRleE1hcC5nZXQocHJldkNoaWxkLmtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBrZXktbGVzcyBub2RlLCB0cnkgdG8gbG9jYXRlIGEga2V5LWxlc3Mgbm9kZSBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IHMyOyBqIDw9IGUyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdJbmRleFRvT2xkSW5kZXhNYXBbaiAtIHMyXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU2FtZVZOb2RlVHlwZShwcmV2Q2hpbGQsIGMyW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0luZGV4ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV3SW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbbmV3SW5kZXggLSBzMl0gPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4ID49IG1heE5ld0luZGV4U29GYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heE5ld0luZGV4U29GYXIgPSBuZXdJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRjaChwcmV2Q2hpbGQsIGMyW25ld0luZGV4XSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgICAgICBwYXRjaGVkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gNS4zIG1vdmUgYW5kIG1vdW50XG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSBsb25nZXN0IHN0YWJsZSBzdWJzZXF1ZW5jZSBvbmx5IHdoZW4gbm9kZXMgaGF2ZSBtb3ZlZFxuICAgICAgICAgICAgY29uc3QgaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UgPSBtb3ZlZFxuICAgICAgICAgICAgICAgID8gZ2V0U2VxdWVuY2UobmV3SW5kZXhUb09sZEluZGV4TWFwKVxuICAgICAgICAgICAgICAgIDogc2hhcmVkXzEuRU1QVFlfQVJSO1xuICAgICAgICAgICAgaiA9IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAvLyBsb29waW5nIGJhY2t3YXJkcyBzbyB0aGF0IHdlIGNhbiB1c2UgbGFzdCBwYXRjaGVkIG5vZGUgYXMgYW5jaG9yXG4gICAgICAgICAgICBmb3IgKGkgPSB0b0JlUGF0Y2hlZCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gczIgKyBpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IGMyW25leHRJbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dEluZGV4ICsgMSA8IGwyID8gYzJbbmV4dEluZGV4ICsgMV0uZWwgOiBwYXJlbnRBbmNob3I7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtpXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3VudCBuZXdcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgbmV4dENoaWxkLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBpZjpcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gc3RhYmxlIHN1YnNlcXVlbmNlIChlLmcuIGEgcmV2ZXJzZSlcbiAgICAgICAgICAgICAgICAgICAgLy8gT1IgY3VycmVudCBub2RlIGlzIG5vdCBhbW9uZyB0aGUgc3RhYmxlIHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBpICE9PSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZVtqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZShuZXh0Q2hpbGQsIGNvbnRhaW5lciwgYW5jaG9yLCAyIC8qIE1vdmVUeXBlLlJFT1JERVIgKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUsIHBhcmVudFN1c3BlbnNlID0gbnVsbCkgPT4ge1xuICAgICAgICBjb25zdCB7IGVsLCB0eXBlLCB0cmFuc2l0aW9uLCBjaGlsZHJlbiwgc2hhcGVGbGFnIH0gPSB2bm9kZTtcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDYgLyogU2hhcGVGbGFncy5DT01QT05FTlQgKi8pIHtcbiAgICAgICAgICAgIG1vdmUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTaGFwZUZsYWdzLlNVU1BFTlNFICovKSB7XG4gICAgICAgICAgICB2bm9kZS5zdXNwZW5zZS5tb3ZlKGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFNoYXBlRmxhZ3MuVEVMRVBPUlQgKi8pIHtcbiAgICAgICAgICAgIHR5cGUubW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGludGVybmFscyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhvc3RJbnNlcnQodm5vZGUuYW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xuICAgICAgICAgICAgbW92ZVN0YXRpY05vZGUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaW5nbGUgbm9kZXNcbiAgICAgICAgY29uc3QgbmVlZFRyYW5zaXRpb24gPSBtb3ZlVHlwZSAhPT0gMiAvKiBNb3ZlVHlwZS5SRU9SREVSICovICYmXG4gICAgICAgICAgICBzaGFwZUZsYWcgJiAxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqLyAmJlxuICAgICAgICAgICAgdHJhbnNpdGlvbjtcbiAgICAgICAgaWYgKG5lZWRUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAobW92ZVR5cGUgPT09IDAgLyogTW92ZVR5cGUuRU5URVIgKi8pIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICAgICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHRyYW5zaXRpb24uZW50ZXIoZWwpLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxlYXZlLCBkZWxheUxlYXZlLCBhZnRlckxlYXZlIH0gPSB0cmFuc2l0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW92ZSA9ICgpID0+IGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxlYXZlKGVsLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChkZWxheUxlYXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5TGVhdmUoZWwsIHJlbW92ZSwgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdW5tb3VudCA9ICh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgcmVmLCBjaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuLCBzaGFwZUZsYWcsIHBhdGNoRmxhZywgZGlycyB9ID0gdm5vZGU7XG4gICAgICAgIC8vIHVuc2V0IHJlZlxuICAgICAgICBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDI1NiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLykge1xuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5kZWFjdGl2YXRlKHZub2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaG91bGRJbnZva2VEaXJzID0gc2hhcGVGbGFnICYgMSAvKiBTaGFwZUZsYWdzLkVMRU1FTlQgKi8gJiYgZGlycztcbiAgICAgICAgY29uc3Qgc2hvdWxkSW52b2tlVm5vZGVIb29rID0gIWlzQXN5bmNXcmFwcGVyKHZub2RlKTtcbiAgICAgICAgbGV0IHZub2RlSG9vaztcbiAgICAgICAgaWYgKHNob3VsZEludm9rZVZub2RlSG9vayAmJlxuICAgICAgICAgICAgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVVbm1vdW50KSkge1xuICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDYgLyogU2hhcGVGbGFncy5DT01QT05FTlQgKi8pIHtcbiAgICAgICAgICAgIHVubW91bnRDb21wb25lbnQodm5vZGUuY29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTaGFwZUZsYWdzLlNVU1BFTlNFICovKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUuc3VzcGVuc2UudW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRJbnZva2VEaXJzKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlVW5tb3VudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFNoYXBlRmxhZ3MuVEVMRVBPUlQgKi8pIHtcbiAgICAgICAgICAgICAgICB2bm9kZS50eXBlLnJlbW92ZSh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkLCBpbnRlcm5hbHMsIGRvUmVtb3ZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGR5bmFtaWNDaGlsZHJlbiAmJlxuICAgICAgICAgICAgICAgIC8vICMxMTUzOiBmYXN0IHBhdGggc2hvdWxkIG5vdCBiZSB0YWtlbiBmb3Igbm9uLXN0YWJsZSAodi1mb3IpIGZyYWdtZW50c1xuICAgICAgICAgICAgICAgICh0eXBlICE9PSBGcmFnbWVudCB8fFxuICAgICAgICAgICAgICAgICAgICAocGF0Y2hGbGFnID4gMCAmJiBwYXRjaEZsYWcgJiA2NCAvKiBQYXRjaEZsYWdzLlNUQUJMRV9GUkFHTUVOVCAqLykpKSB7XG4gICAgICAgICAgICAgICAgLy8gZmFzdCBwYXRoIGZvciBibG9jayBub2Rlczogb25seSBuZWVkIHRvIHVubW91bnQgZHluYW1pYyBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oZHluYW1pY0NoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgodHlwZSA9PT0gRnJhZ21lbnQgJiZcbiAgICAgICAgICAgICAgICBwYXRjaEZsYWcgJlxuICAgICAgICAgICAgICAgICAgICAoMTI4IC8qIFBhdGNoRmxhZ3MuS0VZRURfRlJBR01FTlQgKi8gfCAyNTYgLyogUGF0Y2hGbGFncy5VTktFWUVEX0ZSQUdNRU5UICovKSkgfHxcbiAgICAgICAgICAgICAgICAoIW9wdGltaXplZCAmJiBzaGFwZUZsYWcgJiAxNiAvKiBTaGFwZUZsYWdzLkFSUkFZX0NISUxEUkVOICovKSkge1xuICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9SZW1vdmUpIHtcbiAgICAgICAgICAgICAgICByZW1vdmUodm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgoc2hvdWxkSW52b2tlVm5vZGVIb29rICYmXG4gICAgICAgICAgICAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZVVubW91bnRlZCkpIHx8XG4gICAgICAgICAgICBzaG91bGRJbnZva2VEaXJzKSB7XG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgICAgICAgICAgICBzaG91bGRJbnZva2VEaXJzICYmXG4gICAgICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ3VubW91bnRlZCcpO1xuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmUgPSB2bm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgZWwsIGFuY2hvciwgdHJhbnNpdGlvbiB9ID0gdm5vZGU7XG4gICAgICAgIGlmICh0eXBlID09PSBGcmFnbWVudCkge1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgIHZub2RlLnBhdGNoRmxhZyA+IDAgJiZcbiAgICAgICAgICAgICAgICB2bm9kZS5wYXRjaEZsYWcgJiAyMDQ4IC8qIFBhdGNoRmxhZ3MuREVWX1JPT1RfRlJBR01FTlQgKi8gJiZcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uICYmXG4gICAgICAgICAgICAgICAgIXRyYW5zaXRpb24ucGVyc2lzdGVkKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBDb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0UmVtb3ZlKGNoaWxkLmVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW92ZUZyYWdtZW50KGVsLCBhbmNob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcbiAgICAgICAgICAgIHJlbW92ZVN0YXRpY05vZGUodm5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBlcmZvcm1SZW1vdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICBob3N0UmVtb3ZlKGVsKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCAmJiB0cmFuc2l0aW9uLmFmdGVyTGVhdmUpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmFmdGVyTGVhdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEgLyogU2hhcGVGbGFncy5FTEVNRU5UICovICYmXG4gICAgICAgICAgICB0cmFuc2l0aW9uICYmXG4gICAgICAgICAgICAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUgfSA9IHRyYW5zaXRpb247XG4gICAgICAgICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiBsZWF2ZShlbCwgcGVyZm9ybVJlbW92ZSk7XG4gICAgICAgICAgICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgICAgICAgICAgICAgIGRlbGF5TGVhdmUodm5vZGUuZWwsIHBlcmZvcm1SZW1vdmUsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZXJmb3JtTGVhdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBlcmZvcm1SZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlRnJhZ21lbnQgPSAoY3VyLCBlbmQpID0+IHtcbiAgICAgICAgLy8gRm9yIGZyYWdtZW50cywgZGlyZWN0bHkgcmVtb3ZlIGFsbCBjb250YWluZWQgRE9NIG5vZGVzLlxuICAgICAgICAvLyAoZnJhZ21lbnQgY2hpbGQgbm9kZXMgY2Fubm90IGhhdmUgdHJhbnNpdGlvbilcbiAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgIHdoaWxlIChjdXIgIT09IGVuZCkge1xuICAgICAgICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhjdXIpO1xuICAgICAgICAgICAgaG9zdFJlbW92ZShjdXIpO1xuICAgICAgICAgICAgY3VyID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBob3N0UmVtb3ZlKGVuZCk7XG4gICAgfTtcbiAgICBjb25zdCB1bm1vdW50Q29tcG9uZW50ID0gKGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpID0+IHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpbnN0YW5jZS50eXBlLl9faG1ySWQpIHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYnVtLCBzY29wZSwgdXBkYXRlLCBzdWJUcmVlLCB1bSB9ID0gaW5zdGFuY2U7XG4gICAgICAgIC8vIGJlZm9yZVVubW91bnQgaG9va1xuICAgICAgICBpZiAoYnVtKSB7XG4gICAgICAgICAgICAoMCwgc2hhcmVkXzEuaW52b2tlQXJyYXlGbnMpKGJ1bSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RvcCBlZmZlY3RzIGluIGNvbXBvbmVudCBzY29wZVxuICAgICAgICBzY29wZS5zdG9wKCk7XG4gICAgICAgIC8vIHVwZGF0ZSBtYXkgYmUgbnVsbCBpZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgYmVmb3JlIGl0cyBhc3luY1xuICAgICAgICAvLyBzZXR1cCBoYXMgcmVzb2x2ZWQuXG4gICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgc2NoZWR1bGVyIHdpbGwgbm8gbG9uZ2VyIGludm9rZSBpdFxuICAgICAgICAgICAgdXBkYXRlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdW5tb3VudChzdWJUcmVlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1bm1vdW50ZWQgaG9va1xuICAgICAgICBpZiAodW0pIHtcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCh1bSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpbnN0YW5jZS5pc1VubW91bnRlZCA9IHRydWU7XG4gICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgLy8gQSBjb21wb25lbnQgd2l0aCBhc3luYyBkZXAgaW5zaWRlIGEgcGVuZGluZyBzdXNwZW5zZSBpcyB1bm1vdW50ZWQgYmVmb3JlXG4gICAgICAgIC8vIGl0cyBhc3luYyBkZXAgcmVzb2x2ZXMuIFRoaXMgc2hvdWxkIHJlbW92ZSB0aGUgZGVwIGZyb20gdGhlIHN1c3BlbnNlLCBhbmRcbiAgICAgICAgLy8gY2F1c2UgdGhlIHN1c3BlbnNlIHRvIHJlc29sdmUgaW1tZWRpYXRlbHkgaWYgdGhhdCB3YXMgdGhlIGxhc3QgZGVwLlxuICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UgJiZcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiZcbiAgICAgICAgICAgICFwYXJlbnRTdXNwZW5zZS5pc1VubW91bnRlZCAmJlxuICAgICAgICAgICAgaW5zdGFuY2UuYXN5bmNEZXAgJiZcbiAgICAgICAgICAgICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkICYmXG4gICAgICAgICAgICBpbnN0YW5jZS5zdXNwZW5zZUlkID09PSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQpIHtcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLmRlcHMtLTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZS5kZXBzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB1bm1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlLCBzdGFydCA9IDApID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHVubW91bnQoY2hpbGRyZW5baV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlLCBvcHRpbWl6ZWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXROZXh0SG9zdE5vZGUgPSB2bm9kZSA9PiB7XG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiA2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UICovKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0TmV4dEhvc3ROb2RlKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNoYXBlRmxhZ3MuU1VTUEVOU0UgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiB2bm9kZS5zdXNwZW5zZS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhvc3ROZXh0U2libGluZygodm5vZGUuYW5jaG9yIHx8IHZub2RlLmVsKSk7XG4gICAgfTtcbiAgICBjb25zdCByZW5kZXIgPSAodm5vZGUsIGNvbnRhaW5lciwgaXNTVkcpID0+IHtcbiAgICAgICAgaWYgKHZub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuX3Zub2RlKSB7XG4gICAgICAgICAgICAgICAgdW5tb3VudChjb250YWluZXIuX3Zub2RlLCBudWxsLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGNoKGNvbnRhaW5lci5fdm5vZGUgfHwgbnVsbCwgdm5vZGUsIGNvbnRhaW5lciwgbnVsbCwgbnVsbCwgbnVsbCwgaXNTVkcpO1xuICAgICAgICB9XG4gICAgICAgIGZsdXNoUHJlRmx1c2hDYnMoKTtcbiAgICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcbiAgICAgICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xuICAgIH07XG4gICAgY29uc3QgaW50ZXJuYWxzID0ge1xuICAgICAgICBwOiBwYXRjaCxcbiAgICAgICAgdW06IHVubW91bnQsXG4gICAgICAgIG06IG1vdmUsXG4gICAgICAgIHI6IHJlbW92ZSxcbiAgICAgICAgbXQ6IG1vdW50Q29tcG9uZW50LFxuICAgICAgICBtYzogbW91bnRDaGlsZHJlbixcbiAgICAgICAgcGM6IHBhdGNoQ2hpbGRyZW4sXG4gICAgICAgIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLFxuICAgICAgICBuOiBnZXROZXh0SG9zdE5vZGUsXG4gICAgICAgIG86IG9wdGlvbnNcbiAgICB9O1xuICAgIGxldCBoeWRyYXRlO1xuICAgIGxldCBoeWRyYXRlTm9kZTtcbiAgICBpZiAoY3JlYXRlSHlkcmF0aW9uRm5zKSB7XG4gICAgICAgIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV0gPSBjcmVhdGVIeWRyYXRpb25GbnMoaW50ZXJuYWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVuZGVyLFxuICAgICAgICBoeWRyYXRlLFxuICAgICAgICBjcmVhdGVBcHA6IGNyZWF0ZUFwcEFQSShyZW5kZXIsIGh5ZHJhdGUpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZVJlY3Vyc2UoeyBlZmZlY3QsIHVwZGF0ZSB9LCBhbGxvd2VkKSB7XG4gICAgZWZmZWN0LmFsbG93UmVjdXJzZSA9IHVwZGF0ZS5hbGxvd1JlY3Vyc2UgPSBhbGxvd2VkO1xufVxuLyoqXG4gKiAjMTE1NlxuICogV2hlbiBhIGNvbXBvbmVudCBpcyBITVItZW5hYmxlZCwgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCBhbGwgc3RhdGljIG5vZGVzXG4gKiBpbnNpZGUgYSBibG9jayBhbHNvIGluaGVyaXQgdGhlIERPTSBlbGVtZW50IGZyb20gdGhlIHByZXZpb3VzIHRyZWUgc28gdGhhdFxuICogSE1SIHVwZGF0ZXMgKHdoaWNoIGFyZSBmdWxsIHVwZGF0ZXMpIGNhbiByZXRyaWV2ZSB0aGUgZWxlbWVudCBmb3IgcGF0Y2hpbmcuXG4gKlxuICogIzIwODBcbiAqIEluc2lkZSBrZXllZCBgdGVtcGxhdGVgIGZyYWdtZW50IHN0YXRpYyBjaGlsZHJlbiwgaWYgYSBmcmFnbWVudCBpcyBtb3ZlZCxcbiAqIHRoZSBjaGlsZHJlbiB3aWxsIGFsd2F5cyBiZSBtb3ZlZC4gVGhlcmVmb3JlLCBpbiBvcmRlciB0byBlbnN1cmUgY29ycmVjdCBtb3ZlXG4gKiBwb3NpdGlvbiwgZWwgc2hvdWxkIGJlIGluaGVyaXRlZCBmcm9tIHByZXZpb3VzIG5vZGVzLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMiwgc2hhbGxvdyA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2gxID0gbjEuY2hpbGRyZW47XG4gICAgY29uc3QgY2gyID0gbjIuY2hpbGRyZW47XG4gICAgaWYgKCgwLCBzaGFyZWRfMS5pc0FycmF5KShjaDEpICYmICgwLCBzaGFyZWRfMS5pc0FycmF5KShjaDIpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2gxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG9ubHkgY2FsbGVkIGluIHRoZSBvcHRpbWl6ZWQgcGF0aCBzbyBhcnJheSBjaGlsZHJlbiBhcmVcbiAgICAgICAgICAgIC8vIGd1YXJhbnRlZWQgdG8gYmUgdm5vZGVzXG4gICAgICAgICAgICBjb25zdCBjMSA9IGNoMVtpXTtcbiAgICAgICAgICAgIGxldCBjMiA9IGNoMltpXTtcbiAgICAgICAgICAgIGlmIChjMi5zaGFwZUZsYWcgJiAxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqLyAmJiAhYzIuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMyLnBhdGNoRmxhZyA8PSAwIHx8IGMyLnBhdGNoRmxhZyA9PT0gMzIgLyogUGF0Y2hGbGFncy5IWURSQVRFX0VWRU5UUyAqLykge1xuICAgICAgICAgICAgICAgICAgICBjMiA9IGNoMltpXSA9IGNsb25lSWZNb3VudGVkKGNoMltpXSk7XG4gICAgICAgICAgICAgICAgICAgIGMyLmVsID0gYzEuZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2hhbGxvdylcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihjMSwgYzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gIzY4NTIgYWxzbyBpbmhlcml0IGZvciB0ZXh0IG5vZGVzXG4gICAgICAgICAgICBpZiAoYzIudHlwZSA9PT0gVGV4dCkge1xuICAgICAgICAgICAgICAgIGMyLmVsID0gYzEuZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbHNvIGluaGVyaXQgZm9yIGNvbW1lbnQgbm9kZXMsIGJ1dCBub3QgcGxhY2Vob2xkZXJzIChlLmcuIHYtaWYgd2hpY2hcbiAgICAgICAgICAgIC8vIHdvdWxkIGhhdmUgcmVjZWl2ZWQgLmVsIGR1cmluZyBibG9jayBwYXRjaClcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgYzIudHlwZSA9PT0gQ29tbWVudCAmJiAhYzIuZWwpIHtcbiAgICAgICAgICAgICAgICBjMi5lbCA9IGMxLmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9uZ2VzdF9pbmNyZWFzaW5nX3N1YnNlcXVlbmNlXG5mdW5jdGlvbiBnZXRTZXF1ZW5jZShhcnIpIHtcbiAgICBjb25zdCBwID0gYXJyLnNsaWNlKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gWzBdO1xuICAgIGxldCBpLCBqLCB1LCB2LCBjO1xuICAgIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyckkgPSBhcnJbaV07XG4gICAgICAgIGlmIChhcnJJICE9PSAwKSB7XG4gICAgICAgICAgICBqID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChhcnJbal0gPCBhcnJJKSB7XG4gICAgICAgICAgICAgICAgcFtpXSA9IGo7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1ID0gMDtcbiAgICAgICAgICAgIHYgPSByZXN1bHQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlICh1IDwgdikge1xuICAgICAgICAgICAgICAgIGMgPSAodSArIHYpID4+IDE7XG4gICAgICAgICAgICAgICAgaWYgKGFycltyZXN1bHRbY11dIDwgYXJySSkge1xuICAgICAgICAgICAgICAgICAgICB1ID0gYyArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2ID0gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJySSA8IGFycltyZXN1bHRbdV1dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbaV0gPSByZXN1bHRbdSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRbdV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHUgPSByZXN1bHQubGVuZ3RoO1xuICAgIHYgPSByZXN1bHRbdSAtIDFdO1xuICAgIHdoaWxlICh1LS0gPiAwKSB7XG4gICAgICAgIHJlc3VsdFt1XSA9IHY7XG4gICAgICAgIHYgPSBwW3ZdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgaXNUZWxlcG9ydCA9ICh0eXBlKSA9PiB0eXBlLl9faXNUZWxlcG9ydDtcbmNvbnN0IGlzVGVsZXBvcnREaXNhYmxlZCA9IChwcm9wcykgPT4gcHJvcHMgJiYgKHByb3BzLmRpc2FibGVkIHx8IHByb3BzLmRpc2FibGVkID09PSAnJyk7XG5jb25zdCBpc1RhcmdldFNWRyA9ICh0YXJnZXQpID0+IHR5cGVvZiBTVkdFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50O1xuY29uc3QgcmVzb2x2ZVRhcmdldCA9IChwcm9wcywgc2VsZWN0KSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0U2VsZWN0b3IgPSBwcm9wcyAmJiBwcm9wcy50bztcbiAgICBpZiAoKDAsIHNoYXJlZF8xLmlzU3RyaW5nKSh0YXJnZXRTZWxlY3RvcikpIHtcbiAgICAgICAgaWYgKCFzZWxlY3QpIHtcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgIHdhcm4oYEN1cnJlbnQgcmVuZGVyZXIgZG9lcyBub3Qgc3VwcG9ydCBzdHJpbmcgdGFyZ2V0IGZvciBUZWxlcG9ydHMuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgKG1pc3NpbmcgcXVlcnlTZWxlY3RvciByZW5kZXJlciBvcHRpb24pYCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHNlbGVjdCh0YXJnZXRTZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBGYWlsZWQgdG8gbG9jYXRlIFRlbGVwb3J0IHRhcmdldCB3aXRoIHNlbGVjdG9yIFwiJHt0YXJnZXRTZWxlY3Rvcn1cIi4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgTm90ZSB0aGUgdGFyZ2V0IGVsZW1lbnQgbXVzdCBleGlzdCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkIC0gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgaS5lLiB0aGUgdGFyZ2V0IGNhbm5vdCBiZSByZW5kZXJlZCBieSB0aGUgY29tcG9uZW50IGl0c2VsZiwgYW5kIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGlkZWFsbHkgc2hvdWxkIGJlIG91dHNpZGUgb2YgdGhlIGVudGlyZSBWdWUgY29tcG9uZW50IHRyZWUuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICF0YXJnZXRTZWxlY3RvciAmJiAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xuICAgICAgICAgICAgd2FybihgSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQ6ICR7dGFyZ2V0U2VsZWN0b3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldFNlbGVjdG9yO1xuICAgIH1cbn07XG5jb25zdCBUZWxlcG9ydEltcGwgPSB7XG4gICAgX19pc1RlbGVwb3J0OiB0cnVlLFxuICAgIHByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBpbnRlcm5hbHMpIHtcbiAgICAgICAgY29uc3QgeyBtYzogbW91bnRDaGlsZHJlbiwgcGM6IHBhdGNoQ2hpbGRyZW4sIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLCBvOiB7IGluc2VydCwgcXVlcnlTZWxlY3RvciwgY3JlYXRlVGV4dCwgY3JlYXRlQ29tbWVudCB9IH0gPSBpbnRlcm5hbHM7XG4gICAgICAgIGNvbnN0IGRpc2FibGVkID0gaXNUZWxlcG9ydERpc2FibGVkKG4yLnByb3BzKTtcbiAgICAgICAgbGV0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuIH0gPSBuMjtcbiAgICAgICAgLy8gIzMzMDJcbiAgICAgICAgLy8gSE1SIHVwZGF0ZWQsIGZvcmNlIGZ1bGwgZGlmZlxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGFuY2hvcnMgaW4gdGhlIG1haW4gdmlld1xuICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSAobjIuZWwgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbW1lbnQoJ3RlbGVwb3J0IHN0YXJ0JylcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZVRleHQoJycpKTtcbiAgICAgICAgICAgIGNvbnN0IG1haW5BbmNob3IgPSAobjIuYW5jaG9yID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVDb21tZW50KCd0ZWxlcG9ydCBlbmQnKVxuICAgICAgICAgICAgICAgIDogY3JlYXRlVGV4dCgnJykpO1xuICAgICAgICAgICAgaW5zZXJ0KHBsYWNlaG9sZGVyLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgICAgICBpbnNlcnQobWFpbkFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQobjIucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IChuMi50YXJnZXRBbmNob3IgPSBjcmVhdGVUZXh0KCcnKSk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0KHRhcmdldEFuY2hvciwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAvLyAjMjY1MiB3ZSBjb3VsZCBiZSB0ZWxlcG9ydGluZyBmcm9tIGEgbm9uLVNWRyB0cmVlIGludG8gYW4gU1ZHIHRyZWVcbiAgICAgICAgICAgICAgICBpc1NWRyA9IGlzU1ZHIHx8IGlzVGFyZ2V0U1ZHKHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gbW91bnQ6JywgdGFyZ2V0LCBgKCR7dHlwZW9mIHRhcmdldH0pYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb3VudCA9IChjb250YWluZXIsIGFuY2hvcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRlbGVwb3J0ICphbHdheXMqIGhhcyBBcnJheSBjaGlsZHJlbi4gVGhpcyBpcyBlbmZvcmNlZCBpbiBib3RoIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvbXBpbGVyIGFuZCB2bm9kZSBjaGlsZHJlbiBub3JtYWxpemF0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBTaGFwZUZsYWdzLkFSUkFZX0NISUxEUkVOICovKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBtb3VudChjb250YWluZXIsIG1haW5BbmNob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgbW91bnQodGFyZ2V0LCB0YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdXBkYXRlIGNvbnRlbnRcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICAgICAgICBjb25zdCBtYWluQW5jaG9yID0gKG4yLmFuY2hvciA9IG4xLmFuY2hvcik7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAobjIudGFyZ2V0ID0gbjEudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IChuMi50YXJnZXRBbmNob3IgPSBuMS50YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgY29uc3Qgd2FzRGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjEucHJvcHMpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudENvbnRhaW5lciA9IHdhc0Rpc2FibGVkID8gY29udGFpbmVyIDogdGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEFuY2hvciA9IHdhc0Rpc2FibGVkID8gbWFpbkFuY2hvciA6IHRhcmdldEFuY2hvcjtcbiAgICAgICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgaXNUYXJnZXRTVkcodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBmYXN0IHBhdGggd2hlbiB0aGUgdGVsZXBvcnQgaGFwcGVucyB0byBiZSBhIGJsb2NrIHJvb3RcbiAgICAgICAgICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4objEuZHluYW1pY0NoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIGN1cnJlbnRDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xuICAgICAgICAgICAgICAgIC8vIGV2ZW4gaW4gYmxvY2sgdHJlZSBtb2RlIHdlIG5lZWQgdG8gbWFrZSBzdXJlIGFsbCByb290LWxldmVsIG5vZGVzXG4gICAgICAgICAgICAgICAgLy8gaW4gdGhlIHRlbGVwb3J0IGluaGVyaXQgcHJldmlvdXMgRE9NIHJlZmVyZW5jZXMgc28gdGhhdCB0aGV5IGNhblxuICAgICAgICAgICAgICAgIC8vIGJlIG1vdmVkIGluIGZ1dHVyZSBwYXRjaGVzLlxuICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcbiAgICAgICAgICAgICAgICBwYXRjaENoaWxkcmVuKG4xLCBuMiwgY3VycmVudENvbnRhaW5lciwgY3VycmVudEFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3YXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbmFibGVkIC0+IGRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgaW50byBtYWluIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICBtb3ZlVGVsZXBvcnQobjIsIGNvbnRhaW5lciwgbWFpbkFuY2hvciwgaW50ZXJuYWxzLCAxIC8qIFRlbGVwb3J0TW92ZVR5cGVzLlRPR0dMRSAqLyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0IGNoYW5nZWRcbiAgICAgICAgICAgICAgICBpZiAoKG4yLnByb3BzICYmIG4yLnByb3BzLnRvKSAhPT0gKG4xLnByb3BzICYmIG4xLnByb3BzLnRvKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0VGFyZ2V0ID0gKG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQobjIucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVUZWxlcG9ydChuMiwgbmV4dFRhcmdldCwgbnVsbCwgaW50ZXJuYWxzLCAwIC8qIFRlbGVwb3J0TW92ZVR5cGVzLlRBUkdFVF9DSEFOR0UgKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gdXBkYXRlOicsIHRhcmdldCwgYCgke3R5cGVvZiB0YXJnZXR9KWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdhc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGVkIC0+IGVuYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBpbnRvIHRlbGVwb3J0IHRhcmdldFxuICAgICAgICAgICAgICAgICAgICBtb3ZlVGVsZXBvcnQobjIsIHRhcmdldCwgdGFyZ2V0QW5jaG9yLCBpbnRlcm5hbHMsIDEgLyogVGVsZXBvcnRNb3ZlVHlwZXMuVE9HR0xFICovKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlQ3NzVmFycyhuMik7XG4gICAgfSxcbiAgICByZW1vdmUodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCwgeyB1bTogdW5tb3VudCwgbzogeyByZW1vdmU6IGhvc3RSZW1vdmUgfSB9LCBkb1JlbW92ZSkge1xuICAgICAgICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4sIGFuY2hvciwgdGFyZ2V0QW5jaG9yLCB0YXJnZXQsIHByb3BzIH0gPSB2bm9kZTtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgaG9zdFJlbW92ZSh0YXJnZXRBbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFuIHVubW91bnRlZCB0ZWxlcG9ydCBzaG91bGQgYWx3YXlzIHJlbW92ZSBpdHMgY2hpbGRyZW4gaWYgbm90IGRpc2FibGVkXG4gICAgICAgIGlmIChkb1JlbW92ZSB8fCAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xuICAgICAgICAgICAgaG9zdFJlbW92ZShhbmNob3IpO1xuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQoY2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUsICEhY2hpbGQuZHluYW1pY0NoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1vdmU6IG1vdmVUZWxlcG9ydCxcbiAgICBoeWRyYXRlOiBoeWRyYXRlVGVsZXBvcnRcbn07XG5mdW5jdGlvbiBtb3ZlVGVsZXBvcnQodm5vZGUsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCB7IG86IHsgaW5zZXJ0IH0sIG06IG1vdmUgfSwgbW92ZVR5cGUgPSAyIC8qIFRlbGVwb3J0TW92ZVR5cGVzLlJFT1JERVIgKi8pIHtcbiAgICAvLyBtb3ZlIHRhcmdldCBhbmNob3IgaWYgdGhpcyBpcyBhIHRhcmdldCBjaGFuZ2UuXG4gICAgaWYgKG1vdmVUeXBlID09PSAwIC8qIFRlbGVwb3J0TW92ZVR5cGVzLlRBUkdFVF9DSEFOR0UgKi8pIHtcbiAgICAgICAgaW5zZXJ0KHZub2RlLnRhcmdldEFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICAgIH1cbiAgICBjb25zdCB7IGVsLCBhbmNob3IsIHNoYXBlRmxhZywgY2hpbGRyZW4sIHByb3BzIH0gPSB2bm9kZTtcbiAgICBjb25zdCBpc1Jlb3JkZXIgPSBtb3ZlVHlwZSA9PT0gMiAvKiBUZWxlcG9ydE1vdmVUeXBlcy5SRU9SREVSICovO1xuICAgIC8vIG1vdmUgbWFpbiB2aWV3IGFuY2hvciBpZiB0aGlzIGlzIGEgcmUtb3JkZXIuXG4gICAgaWYgKGlzUmVvcmRlcikge1xuICAgICAgICBpbnNlcnQoZWwsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcbiAgICB9XG4gICAgLy8gaWYgdGhpcyBpcyBhIHJlLW9yZGVyIGFuZCB0ZWxlcG9ydCBpcyBlbmFibGVkIChjb250ZW50IGlzIGluIHRhcmdldClcbiAgICAvLyBkbyBub3QgbW92ZSBjaGlsZHJlbi4gU28gdGhlIG9wcG9zaXRlIGlzOiBvbmx5IG1vdmUgY2hpbGRyZW4gaWYgdGhpc1xuICAgIC8vIGlzIG5vdCBhIHJlb3JkZXIsIG9yIHRoZSB0ZWxlcG9ydCBpcyBkaXNhYmxlZFxuICAgIGlmICghaXNSZW9yZGVyIHx8IGlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcbiAgICAgICAgLy8gVGVsZXBvcnQgaGFzIGVpdGhlciBBcnJheSBjaGlsZHJlbiBvciBubyBjaGlsZHJlbi5cbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtb3ZlKGNoaWxkcmVuW2ldLCBjb250YWluZXIsIHBhcmVudEFuY2hvciwgMiAvKiBNb3ZlVHlwZS5SRU9SREVSICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBtb3ZlIG1haW4gdmlldyBhbmNob3IgaWYgdGhpcyBpcyBhIHJlLW9yZGVyLlxuICAgIGlmIChpc1Jlb3JkZXIpIHtcbiAgICAgICAgaW5zZXJ0KGFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGh5ZHJhdGVUZWxlcG9ydChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHsgbzogeyBuZXh0U2libGluZywgcGFyZW50Tm9kZSwgcXVlcnlTZWxlY3RvciB9IH0sIGh5ZHJhdGVDaGlsZHJlbikge1xuICAgIGNvbnN0IHRhcmdldCA9ICh2bm9kZS50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KHZub2RlLnByb3BzLCBxdWVyeVNlbGVjdG9yKSk7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgICAvLyBpZiBtdWx0aXBsZSB0ZWxlcG9ydHMgcmVuZGVyZWQgdG8gdGhlIHNhbWUgdGFyZ2V0IGVsZW1lbnQsIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gcGljayB1cCBmcm9tIHdoZXJlIHRoZSBsYXN0IHRlbGVwb3J0IGZpbmlzaGVkIGluc3RlYWQgb2YgdGhlIGZpcnN0IG5vZGVcbiAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRhcmdldC5fbHBhIHx8IHRhcmdldC5maXJzdENoaWxkO1xuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTYgLyogU2hhcGVGbGFncy5BUlJBWV9DSElMRFJFTiAqLykge1xuICAgICAgICAgICAgaWYgKGlzVGVsZXBvcnREaXNhYmxlZCh2bm9kZS5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBoeWRyYXRlQ2hpbGRyZW4obmV4dFNpYmxpbmcobm9kZSksIHZub2RlLCBwYXJlbnROb2RlKG5vZGUpLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZub2RlLmFuY2hvciA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgICAgICAgIC8vIGxvb2thaGVhZCB1bnRpbCB3ZSBmaW5kIHRoZSB0YXJnZXQgYW5jaG9yXG4gICAgICAgICAgICAgICAgLy8gd2UgY2Fubm90IHJlbHkgb24gcmV0dXJuIHZhbHVlIG9mIGh5ZHJhdGVDaGlsZHJlbigpIGJlY2F1c2UgdGhlcmVcbiAgICAgICAgICAgICAgICAvLyBjb3VsZCBiZSBuZXN0ZWQgdGVsZXBvcnRzXG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldEFuY2hvciA9IHRhcmdldE5vZGU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRhcmdldEFuY2hvcikge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRBbmNob3IgPSBuZXh0U2libGluZyh0YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0QW5jaG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRBbmNob3Iubm9kZVR5cGUgPT09IDggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEFuY2hvci5kYXRhID09PSAndGVsZXBvcnQgYW5jaG9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yID0gdGFyZ2V0QW5jaG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Ll9scGEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS50YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaHlkcmF0ZUNoaWxkcmVuKHRhcmdldE5vZGUsIHZub2RlLCB0YXJnZXQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVDc3NWYXJzKHZub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlLmFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS5hbmNob3IpO1xufVxuLy8gRm9yY2UtY2FzdGVkIHB1YmxpYyB0eXBpbmcgZm9yIGggYW5kIFRTWCBwcm9wcyBpbmZlcmVuY2VcbmNvbnN0IFRlbGVwb3J0ID0gVGVsZXBvcnRJbXBsO1xuZXhwb3J0cy5UZWxlcG9ydCA9IFRlbGVwb3J0O1xuZnVuY3Rpb24gdXBkYXRlQ3NzVmFycyh2bm9kZSkge1xuICAgIC8vIHByZXNlbmNlIG9mIC51dCBtZXRob2QgaW5kaWNhdGVzIG93bmVyIGNvbXBvbmVudCB1c2VzIGNzcyB2YXJzLlxuICAgIC8vIGNvZGUgcGF0aCBoZXJlIGNhbiBhc3N1bWUgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICBjb25zdCBjdHggPSB2bm9kZS5jdHg7XG4gICAgaWYgKGN0eCAmJiBjdHgudXQpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB2bm9kZS5jaGlsZHJlblswXS5lbDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IHZub2RlLnRhcmdldEFuY2hvcikge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpXG4gICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdi1vd25lcicsIGN0eC51aWQpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnV0KCk7XG4gICAgfVxufVxuY29uc3QgRnJhZ21lbnQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ0ZyYWdtZW50JyA6IHVuZGVmaW5lZCk7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5jb25zdCBUZXh0ID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdUZXh0JyA6IHVuZGVmaW5lZCk7XG5leHBvcnRzLlRleHQgPSBUZXh0O1xuY29uc3QgQ29tbWVudCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnQ29tbWVudCcgOiB1bmRlZmluZWQpO1xuZXhwb3J0cy5Db21tZW50ID0gQ29tbWVudDtcbmNvbnN0IFN0YXRpYyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnU3RhdGljJyA6IHVuZGVmaW5lZCk7XG5leHBvcnRzLlN0YXRpYyA9IFN0YXRpYztcbi8vIFNpbmNlIHYtaWYgYW5kIHYtZm9yIGFyZSB0aGUgdHdvIHBvc3NpYmxlIHdheXMgbm9kZSBzdHJ1Y3R1cmUgY2FuIGR5bmFtaWNhbGx5XG4vLyBjaGFuZ2UsIG9uY2Ugd2UgY29uc2lkZXIgdi1pZiBicmFuY2hlcyBhbmQgZWFjaCB2LWZvciBmcmFnbWVudCBhIGJsb2NrLCB3ZVxuLy8gY2FuIGRpdmlkZSBhIHRlbXBsYXRlIGludG8gbmVzdGVkIGJsb2NrcywgYW5kIHdpdGhpbiBlYWNoIGJsb2NrIHRoZSBub2RlXG4vLyBzdHJ1Y3R1cmUgd291bGQgYmUgc3RhYmxlLiBUaGlzIGFsbG93cyB1cyB0byBza2lwIG1vc3QgY2hpbGRyZW4gZGlmZmluZ1xuLy8gYW5kIG9ubHkgd29ycnkgYWJvdXQgdGhlIGR5bmFtaWMgbm9kZXMgKGluZGljYXRlZCBieSBwYXRjaCBmbGFncykuXG5jb25zdCBibG9ja1N0YWNrID0gW107XG5sZXQgY3VycmVudEJsb2NrID0gbnVsbDtcbi8qKlxuICogT3BlbiBhIGJsb2NrLlxuICogVGhpcyBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgYGNyZWF0ZUJsb2NrYC4gSXQgY2Fubm90IGJlIHBhcnQgb2YgYGNyZWF0ZUJsb2NrYFxuICogYmVjYXVzZSB0aGUgY2hpbGRyZW4gb2YgdGhlIGJsb2NrIGFyZSBldmFsdWF0ZWQgYmVmb3JlIGBjcmVhdGVCbG9ja2AgaXRzZWxmXG4gKiBpcyBjYWxsZWQuIFRoZSBnZW5lcmF0ZWQgY29kZSB0eXBpY2FsbHkgbG9va3MgbGlrZSB0aGlzOlxuICpcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gKiAgIHJldHVybiAob3BlbkJsb2NrKCksY3JlYXRlQmxvY2soJ2RpdicsIG51bGwsIFsuLi5dKSlcbiAqIH1cbiAqIGBgYFxuICogZGlzYWJsZVRyYWNraW5nIGlzIHRydWUgd2hlbiBjcmVhdGluZyBhIHYtZm9yIGZyYWdtZW50IGJsb2NrLCBzaW5jZSBhIHYtZm9yXG4gKiBmcmFnbWVudCBhbHdheXMgZGlmZnMgaXRzIGNoaWxkcmVuLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG9wZW5CbG9jayhkaXNhYmxlVHJhY2tpbmcgPSBmYWxzZSkge1xuICAgIGJsb2NrU3RhY2sucHVzaCgoY3VycmVudEJsb2NrID0gZGlzYWJsZVRyYWNraW5nID8gbnVsbCA6IFtdKSk7XG59XG5leHBvcnRzLm9wZW5CbG9jayA9IG9wZW5CbG9jaztcbmZ1bmN0aW9uIGNsb3NlQmxvY2soKSB7XG4gICAgYmxvY2tTdGFjay5wb3AoKTtcbiAgICBjdXJyZW50QmxvY2sgPSBibG9ja1N0YWNrW2Jsb2NrU3RhY2subGVuZ3RoIC0gMV0gfHwgbnVsbDtcbn1cbi8vIFdoZXRoZXIgd2Ugc2hvdWxkIGJlIHRyYWNraW5nIGR5bmFtaWMgY2hpbGQgbm9kZXMgaW5zaWRlIGEgYmxvY2suXG4vLyBPbmx5IHRyYWNrcyB3aGVuIHRoaXMgdmFsdWUgaXMgPiAwXG4vLyBXZSBhcmUgbm90IHVzaW5nIGEgc2ltcGxlIGJvb2xlYW4gYmVjYXVzZSB0aGlzIHZhbHVlIG1heSBuZWVkIHRvIGJlXG4vLyBpbmNyZW1lbnRlZC9kZWNyZW1lbnRlZCBieSBuZXN0ZWQgdXNhZ2Ugb2Ygdi1vbmNlIChzZWUgYmVsb3cpXG5sZXQgaXNCbG9ja1RyZWVFbmFibGVkID0gMTtcbi8qKlxuICogQmxvY2sgdHJhY2tpbmcgc29tZXRpbWVzIG5lZWRzIHRvIGJlIGRpc2FibGVkLCBmb3IgZXhhbXBsZSBkdXJpbmcgdGhlXG4gKiBjcmVhdGlvbiBvZiBhIHRyZWUgdGhhdCBuZWVkcyB0byBiZSBjYWNoZWQgYnkgdi1vbmNlLiBUaGUgY29tcGlsZXIgZ2VuZXJhdGVzXG4gKiBjb2RlIGxpa2UgdGhpczpcbiAqXG4gKiBgYGAganNcbiAqIF9jYWNoZVsxXSB8fCAoXG4gKiAgIHNldEJsb2NrVHJhY2tpbmcoLTEpLFxuICogICBfY2FjaGVbMV0gPSBjcmVhdGVWTm9kZSguLi4pLFxuICogICBzZXRCbG9ja1RyYWNraW5nKDEpLFxuICogICBfY2FjaGVbMV1cbiAqIClcbiAqIGBgYFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldEJsb2NrVHJhY2tpbmcodmFsdWUpIHtcbiAgICBpc0Jsb2NrVHJlZUVuYWJsZWQgKz0gdmFsdWU7XG59XG5leHBvcnRzLnNldEJsb2NrVHJhY2tpbmcgPSBzZXRCbG9ja1RyYWNraW5nO1xuZnVuY3Rpb24gc2V0dXBCbG9jayh2bm9kZSkge1xuICAgIC8vIHNhdmUgY3VycmVudCBibG9jayBjaGlsZHJlbiBvbiB0aGUgYmxvY2sgdm5vZGVcbiAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPVxuICAgICAgICBpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwID8gY3VycmVudEJsb2NrIHx8IHNoYXJlZF8xLkVNUFRZX0FSUiA6IG51bGw7XG4gICAgLy8gY2xvc2UgYmxvY2tcbiAgICBjbG9zZUJsb2NrKCk7XG4gICAgLy8gYSBibG9jayBpcyBhbHdheXMgZ29pbmcgdG8gYmUgcGF0Y2hlZCwgc28gdHJhY2sgaXQgYXMgYSBjaGlsZCBvZiBpdHNcbiAgICAvLyBwYXJlbnQgYmxvY2tcbiAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiBjdXJyZW50QmxvY2spIHtcbiAgICAgICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGU7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRCbG9jayh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCBzaGFwZUZsYWcpIHtcbiAgICByZXR1cm4gc2V0dXBCbG9jayhjcmVhdGVCYXNlVk5vZGUodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgc2hhcGVGbGFnLCB0cnVlIC8qIGlzQmxvY2sgKi8pKTtcbn1cbmV4cG9ydHMuY3JlYXRlRWxlbWVudEJsb2NrID0gY3JlYXRlRWxlbWVudEJsb2NrO1xuLyoqXG4gKiBDcmVhdGUgYSBibG9jayByb290IHZub2RlLiBUYWtlcyB0aGUgc2FtZSBleGFjdCBhcmd1bWVudHMgYXMgYGNyZWF0ZVZOb2RlYC5cbiAqIEEgYmxvY2sgcm9vdCBrZWVwcyB0cmFjayBvZiBkeW5hbWljIG5vZGVzIHdpdGhpbiB0aGUgYmxvY2sgaW4gdGhlXG4gKiBgZHluYW1pY0NoaWxkcmVuYCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCbG9jayh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzKSB7XG4gICAgcmV0dXJuIHNldHVwQmxvY2soY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgdHJ1ZSAvKiBpc0Jsb2NrOiBwcmV2ZW50IGEgYmxvY2sgZnJvbSB0cmFja2luZyBpdHNlbGYgKi8pKTtcbn1cbmV4cG9ydHMuY3JlYXRlQmxvY2sgPSBjcmVhdGVCbG9jaztcbmZ1bmN0aW9uIGlzVk5vZGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZS5fX3ZfaXNWTm9kZSA9PT0gdHJ1ZSA6IGZhbHNlO1xufVxuZXhwb3J0cy5pc1ZOb2RlID0gaXNWTm9kZTtcbmZ1bmN0aW9uIGlzU2FtZVZOb2RlVHlwZShuMSwgbjIpIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgIG4yLnNoYXBlRmxhZyAmIDYgLyogU2hhcGVGbGFncy5DT01QT05FTlQgKi8gJiZcbiAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmhhcyhuMi50eXBlKSkge1xuICAgICAgICAvLyAjNzA0MiwgZW5zdXJlIHRoZSB2bm9kZSBiZWluZyB1bm1vdW50ZWQgZHVyaW5nIEhNUlxuICAgICAgICAvLyBiaXR3aXNlIG9wZXJhdGlvbnMgdG8gcmVtb3ZlIGtlZXAgYWxpdmUgZmxhZ3NcbiAgICAgICAgbjEuc2hhcGVGbGFnICY9IH4yNTYgLyogU2hhcGVGbGFncy5DT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi87XG4gICAgICAgIG4yLnNoYXBlRmxhZyAmPSB+NTEyIC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi87XG4gICAgICAgIC8vIEhNUiBvbmx5OiBpZiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIGhvdC11cGRhdGVkLCBmb3JjZSBhIHJlbG9hZC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbjEudHlwZSA9PT0gbjIudHlwZSAmJiBuMS5rZXkgPT09IG4yLmtleTtcbn1cbmxldCB2bm9kZUFyZ3NUcmFuc2Zvcm1lcjtcbi8qKlxuICogSW50ZXJuYWwgQVBJIGZvciByZWdpc3RlcmluZyBhbiBhcmd1bWVudHMgdHJhbnNmb3JtIGZvciBjcmVhdGVWTm9kZVxuICogdXNlZCBmb3IgY3JlYXRpbmcgc3R1YnMgaW4gdGhlIHRlc3QtdXRpbHNcbiAqIEl0IGlzICppbnRlcm5hbCogYnV0IG5lZWRzIHRvIGJlIGV4cG9zZWQgZm9yIHRlc3QtdXRpbHMgdG8gcGljayB1cCBwcm9wZXJcbiAqIHR5cGluZ3NcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtVk5vZGVBcmdzKHRyYW5zZm9ybWVyKSB7XG4gICAgdm5vZGVBcmdzVHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcjtcbn1cbmV4cG9ydHMudHJhbnNmb3JtVk5vZGVBcmdzID0gdHJhbnNmb3JtVk5vZGVBcmdzO1xuY29uc3QgY3JlYXRlVk5vZGVXaXRoQXJnc1RyYW5zZm9ybSA9ICguLi5hcmdzKSA9PiB7XG4gICAgcmV0dXJuIF9jcmVhdGVWTm9kZSguLi4odm5vZGVBcmdzVHJhbnNmb3JtZXJcbiAgICAgICAgPyB2bm9kZUFyZ3NUcmFuc2Zvcm1lcihhcmdzLCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpXG4gICAgICAgIDogYXJncykpO1xufTtcbmNvbnN0IEludGVybmFsT2JqZWN0S2V5ID0gYF9fdkludGVybmFsYDtcbmNvbnN0IG5vcm1hbGl6ZUtleSA9ICh7IGtleSB9KSA9PiBrZXkgIT0gbnVsbCA/IGtleSA6IG51bGw7XG5jb25zdCBub3JtYWxpemVSZWYgPSAoeyByZWYsIHJlZl9rZXksIHJlZl9mb3IgfSkgPT4ge1xuICAgIHJldHVybiAocmVmICE9IG51bGxcbiAgICAgICAgPyAoMCwgc2hhcmVkXzEuaXNTdHJpbmcpKHJlZikgfHwgKDAsIHJlYWN0aXZpdHlfMS5pc1JlZikocmVmKSB8fCAoMCwgc2hhcmVkXzEuaXNGdW5jdGlvbikocmVmKVxuICAgICAgICAgICAgPyB7IGk6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSwgcjogcmVmLCBrOiByZWZfa2V5LCBmOiAhIXJlZl9mb3IgfVxuICAgICAgICAgICAgOiByZWZcbiAgICAgICAgOiBudWxsKTtcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVk5vZGUodHlwZSwgcHJvcHMgPSBudWxsLCBjaGlsZHJlbiA9IG51bGwsIHBhdGNoRmxhZyA9IDAsIGR5bmFtaWNQcm9wcyA9IG51bGwsIHNoYXBlRmxhZyA9IHR5cGUgPT09IEZyYWdtZW50ID8gMCA6IDEgLyogU2hhcGVGbGFncy5FTEVNRU5UICovLCBpc0Jsb2NrTm9kZSA9IGZhbHNlLCBuZWVkRnVsbENoaWxkcmVuTm9ybWFsaXphdGlvbiA9IGZhbHNlKSB7XG4gICAgY29uc3Qgdm5vZGUgPSB7XG4gICAgICAgIF9fdl9pc1ZOb2RlOiB0cnVlLFxuICAgICAgICBfX3Zfc2tpcDogdHJ1ZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIGtleTogcHJvcHMgJiYgbm9ybWFsaXplS2V5KHByb3BzKSxcbiAgICAgICAgcmVmOiBwcm9wcyAmJiBub3JtYWxpemVSZWYocHJvcHMpLFxuICAgICAgICBzY29wZUlkOiBjdXJyZW50U2NvcGVJZCxcbiAgICAgICAgc2xvdFNjb3BlSWRzOiBudWxsLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgY29tcG9uZW50OiBudWxsLFxuICAgICAgICBzdXNwZW5zZTogbnVsbCxcbiAgICAgICAgc3NDb250ZW50OiBudWxsLFxuICAgICAgICBzc0ZhbGxiYWNrOiBudWxsLFxuICAgICAgICBkaXJzOiBudWxsLFxuICAgICAgICB0cmFuc2l0aW9uOiBudWxsLFxuICAgICAgICBlbDogbnVsbCxcbiAgICAgICAgYW5jaG9yOiBudWxsLFxuICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgIHRhcmdldEFuY2hvcjogbnVsbCxcbiAgICAgICAgc3RhdGljQ291bnQ6IDAsXG4gICAgICAgIHNoYXBlRmxhZyxcbiAgICAgICAgcGF0Y2hGbGFnLFxuICAgICAgICBkeW5hbWljUHJvcHMsXG4gICAgICAgIGR5bmFtaWNDaGlsZHJlbjogbnVsbCxcbiAgICAgICAgYXBwQ29udGV4dDogbnVsbCxcbiAgICAgICAgY3R4OiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2VcbiAgICB9O1xuICAgIGlmIChuZWVkRnVsbENoaWxkcmVuTm9ybWFsaXphdGlvbikge1xuICAgICAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4pO1xuICAgICAgICAvLyBub3JtYWxpemUgc3VzcGVuc2UgY2hpbGRyZW5cbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTaGFwZUZsYWdzLlNVU1BFTlNFICovKSB7XG4gICAgICAgICAgICB0eXBlLm5vcm1hbGl6ZSh2bm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgLy8gY29tcGlsZWQgZWxlbWVudCB2bm9kZSAtIGlmIGNoaWxkcmVuIGlzIHBhc3NlZCwgb25seSBwb3NzaWJsZSB0eXBlcyBhcmVcbiAgICAgICAgLy8gc3RyaW5nIG9yIEFycmF5LlxuICAgICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gKDAsIHNoYXJlZF8xLmlzU3RyaW5nKShjaGlsZHJlbilcbiAgICAgICAgICAgID8gOCAvKiBTaGFwZUZsYWdzLlRFWFRfQ0hJTERSRU4gKi9cbiAgICAgICAgICAgIDogMTYgLyogU2hhcGVGbGFncy5BUlJBWV9DSElMRFJFTiAqLztcbiAgICB9XG4gICAgLy8gdmFsaWRhdGUga2V5XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB2bm9kZS5rZXkgIT09IHZub2RlLmtleSkge1xuICAgICAgICB3YXJuKGBWTm9kZSBjcmVhdGVkIHdpdGggaW52YWxpZCBrZXkgKE5hTikuIFZOb2RlIHR5cGU6YCwgdm5vZGUudHlwZSk7XG4gICAgfVxuICAgIC8vIHRyYWNrIHZub2RlIGZvciBibG9jayB0cmVlXG4gICAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiZcbiAgICAgICAgLy8gYXZvaWQgYSBibG9jayBub2RlIGZyb20gdHJhY2tpbmcgaXRzZWxmXG4gICAgICAgICFpc0Jsb2NrTm9kZSAmJlxuICAgICAgICAvLyBoYXMgY3VycmVudCBwYXJlbnQgYmxvY2tcbiAgICAgICAgY3VycmVudEJsb2NrICYmXG4gICAgICAgIC8vIHByZXNlbmNlIG9mIGEgcGF0Y2ggZmxhZyBpbmRpY2F0ZXMgdGhpcyBub2RlIG5lZWRzIHBhdGNoaW5nIG9uIHVwZGF0ZXMuXG4gICAgICAgIC8vIGNvbXBvbmVudCBub2RlcyBhbHNvIHNob3VsZCBhbHdheXMgYmUgcGF0Y2hlZCwgYmVjYXVzZSBldmVuIGlmIHRoZVxuICAgICAgICAvLyBjb21wb25lbnQgZG9lc24ndCBuZWVkIHRvIHVwZGF0ZSwgaXQgbmVlZHMgdG8gcGVyc2lzdCB0aGUgaW5zdGFuY2Ugb24gdG9cbiAgICAgICAgLy8gdGhlIG5leHQgdm5vZGUgc28gdGhhdCBpdCBjYW4gYmUgcHJvcGVybHkgdW5tb3VudGVkIGxhdGVyLlxuICAgICAgICAodm5vZGUucGF0Y2hGbGFnID4gMCB8fCBzaGFwZUZsYWcgJiA2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UICovKSAmJlxuICAgICAgICAvLyB0aGUgRVZFTlRTIGZsYWcgaXMgb25seSBmb3IgaHlkcmF0aW9uIGFuZCBpZiBpdCBpcyB0aGUgb25seSBmbGFnLCB0aGVcbiAgICAgICAgLy8gdm5vZGUgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIGR5bmFtaWMgZHVlIHRvIGhhbmRsZXIgY2FjaGluZy5cbiAgICAgICAgdm5vZGUucGF0Y2hGbGFnICE9PSAzMiAvKiBQYXRjaEZsYWdzLkhZRFJBVEVfRVZFTlRTICovKSB7XG4gICAgICAgIGN1cnJlbnRCbG9jay5wdXNoKHZub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xufVxuZXhwb3J0cy5jcmVhdGVFbGVtZW50Vk5vZGUgPSBjcmVhdGVCYXNlVk5vZGU7XG5jb25zdCBjcmVhdGVWTm9kZSA9ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtIDogX2NyZWF0ZVZOb2RlKTtcbmV4cG9ydHMuY3JlYXRlVk5vZGUgPSBjcmVhdGVWTm9kZTtcbmZ1bmN0aW9uIF9jcmVhdGVWTm9kZSh0eXBlLCBwcm9wcyA9IG51bGwsIGNoaWxkcmVuID0gbnVsbCwgcGF0Y2hGbGFnID0gMCwgZHluYW1pY1Byb3BzID0gbnVsbCwgaXNCbG9ja05vZGUgPSBmYWxzZSkge1xuICAgIGlmICghdHlwZSB8fCB0eXBlID09PSBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UKSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXR5cGUpIHtcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgdm5vZGUgdHlwZSB3aGVuIGNyZWF0aW5nIHZub2RlOiAke3R5cGV9LmApO1xuICAgICAgICB9XG4gICAgICAgIHR5cGUgPSBDb21tZW50O1xuICAgIH1cbiAgICBpZiAoaXNWTm9kZSh0eXBlKSkge1xuICAgICAgICAvLyBjcmVhdGVWTm9kZSByZWNlaXZpbmcgYW4gZXhpc3Rpbmcgdm5vZGUuIFRoaXMgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAgIC8vIDxjb21wb25lbnQgOmlzPVwidm5vZGVcIi8+XG4gICAgICAgIC8vICMyMDc4IG1ha2Ugc3VyZSB0byBtZXJnZSByZWZzIGR1cmluZyB0aGUgY2xvbmUgaW5zdGVhZCBvZiBvdmVyd3JpdGluZyBpdFxuICAgICAgICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKHR5cGUsIHByb3BzLCB0cnVlIC8qIG1lcmdlUmVmOiB0cnVlICovKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBub3JtYWxpemVDaGlsZHJlbihjbG9uZWQsIGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiAhaXNCbG9ja05vZGUgJiYgY3VycmVudEJsb2NrKSB7XG4gICAgICAgICAgICBpZiAoY2xvbmVkLnNoYXBlRmxhZyAmIDYgLyogU2hhcGVGbGFncy5DT01QT05FTlQgKi8pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50QmxvY2tbY3VycmVudEJsb2NrLmluZGV4T2YodHlwZSldID0gY2xvbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJsb2NrLnB1c2goY2xvbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbG9uZWQucGF0Y2hGbGFnIHw9IC0yIC8qIFBhdGNoRmxhZ3MuQkFJTCAqLztcbiAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9XG4gICAgLy8gY2xhc3MgY29tcG9uZW50IG5vcm1hbGl6YXRpb24uXG4gICAgaWYgKGlzQ2xhc3NDb21wb25lbnQodHlwZSkpIHtcbiAgICAgICAgdHlwZSA9IHR5cGUuX192Y2NPcHRzO1xuICAgIH1cbiAgICAvLyBjbGFzcyAmIHN0eWxlIG5vcm1hbGl6YXRpb24uXG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIC8vIGZvciByZWFjdGl2ZSBvciBwcm94eSBvYmplY3RzLCB3ZSBuZWVkIHRvIGNsb25lIGl0IHRvIGVuYWJsZSBtdXRhdGlvbi5cbiAgICAgICAgcHJvcHMgPSBndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpO1xuICAgICAgICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKGtsYXNzICYmICEoMCwgc2hhcmVkXzEuaXNTdHJpbmcpKGtsYXNzKSkge1xuICAgICAgICAgICAgcHJvcHMuY2xhc3MgPSAoMCwgc2hhcmVkXzEubm9ybWFsaXplQ2xhc3MpKGtsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIHNoYXJlZF8xLmlzT2JqZWN0KShzdHlsZSkpIHtcbiAgICAgICAgICAgIC8vIHJlYWN0aXZlIHN0YXRlIG9iamVjdHMgbmVlZCB0byBiZSBjbG9uZWQgc2luY2UgdGhleSBhcmUgbGlrZWx5IHRvIGJlXG4gICAgICAgICAgICAvLyBtdXRhdGVkXG4gICAgICAgICAgICBpZiAoKDAsIHJlYWN0aXZpdHlfMS5pc1Byb3h5KShzdHlsZSkgJiYgISgwLCBzaGFyZWRfMS5pc0FycmF5KShzdHlsZSkpIHtcbiAgICAgICAgICAgICAgICBzdHlsZSA9ICgwLCBzaGFyZWRfMS5leHRlbmQpKHt9LCBzdHlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wcy5zdHlsZSA9ICgwLCBzaGFyZWRfMS5ub3JtYWxpemVTdHlsZSkoc3R5bGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVuY29kZSB0aGUgdm5vZGUgdHlwZSBpbmZvcm1hdGlvbiBpbnRvIGEgYml0bWFwXG4gICAgY29uc3Qgc2hhcGVGbGFnID0gKDAsIHNoYXJlZF8xLmlzU3RyaW5nKSh0eXBlKVxuICAgICAgICA/IDEgLyogU2hhcGVGbGFncy5FTEVNRU5UICovXG4gICAgICAgIDogaXNTdXNwZW5zZSh0eXBlKVxuICAgICAgICAgICAgPyAxMjggLyogU2hhcGVGbGFncy5TVVNQRU5TRSAqL1xuICAgICAgICAgICAgOiBpc1RlbGVwb3J0KHR5cGUpXG4gICAgICAgICAgICAgICAgPyA2NCAvKiBTaGFwZUZsYWdzLlRFTEVQT1JUICovXG4gICAgICAgICAgICAgICAgOiAoMCwgc2hhcmVkXzEuaXNPYmplY3QpKHR5cGUpXG4gICAgICAgICAgICAgICAgICAgID8gNCAvKiBTaGFwZUZsYWdzLlNUQVRFRlVMX0NPTVBPTkVOVCAqL1xuICAgICAgICAgICAgICAgICAgICA6ICgwLCBzaGFyZWRfMS5pc0Z1bmN0aW9uKSh0eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAyIC8qIFNoYXBlRmxhZ3MuRlVOQ1RJT05BTF9DT01QT05FTlQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNoYXBlRmxhZyAmIDQgLyogU2hhcGVGbGFncy5TVEFURUZVTF9DT01QT05FTlQgKi8gJiYgKDAsIHJlYWN0aXZpdHlfMS5pc1Byb3h5KSh0eXBlKSkge1xuICAgICAgICB0eXBlID0gKDAsIHJlYWN0aXZpdHlfMS50b1JhdykodHlwZSk7XG4gICAgICAgIHdhcm4oYFZ1ZSByZWNlaXZlZCBhIENvbXBvbmVudCB3aGljaCB3YXMgbWFkZSBhIHJlYWN0aXZlIG9iamVjdC4gVGhpcyBjYW4gYCArXG4gICAgICAgICAgICBgbGVhZCB0byB1bm5lY2Vzc2FyeSBwZXJmb3JtYW5jZSBvdmVyaGVhZCwgYW5kIHNob3VsZCBiZSBhdm9pZGVkIGJ5IGAgK1xuICAgICAgICAgICAgYG1hcmtpbmcgdGhlIGNvbXBvbmVudCB3aXRoIFxcYG1hcmtSYXdcXGAgb3IgdXNpbmcgXFxgc2hhbGxvd1JlZlxcYCBgICtcbiAgICAgICAgICAgIGBpbnN0ZWFkIG9mIFxcYHJlZlxcYC5gLCBgXFxuQ29tcG9uZW50IHRoYXQgd2FzIG1hZGUgcmVhY3RpdmU6IGAsIHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQmFzZVZOb2RlKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIHNoYXBlRmxhZywgaXNCbG9ja05vZGUsIHRydWUpO1xufVxuZnVuY3Rpb24gZ3VhcmRSZWFjdGl2ZVByb3BzKHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuICgwLCByZWFjdGl2aXR5XzEuaXNQcm94eSkocHJvcHMpIHx8IEludGVybmFsT2JqZWN0S2V5IGluIHByb3BzXG4gICAgICAgID8gKDAsIHNoYXJlZF8xLmV4dGVuZCkoe30sIHByb3BzKVxuICAgICAgICA6IHByb3BzO1xufVxuZXhwb3J0cy5ndWFyZFJlYWN0aXZlUHJvcHMgPSBndWFyZFJlYWN0aXZlUHJvcHM7XG5mdW5jdGlvbiBjbG9uZVZOb2RlKHZub2RlLCBleHRyYVByb3BzLCBtZXJnZVJlZiA9IGZhbHNlKSB7XG4gICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IE5PVCB1c2luZyBzcHJlYWQgb3IgZXh0ZW5kIHRvIGF2b2lkIHRoZSBydW50aW1lXG4gICAgLy8ga2V5IGVudW1lcmF0aW9uIGNvc3QuXG4gICAgY29uc3QgeyBwcm9wcywgcmVmLCBwYXRjaEZsYWcsIGNoaWxkcmVuIH0gPSB2bm9kZTtcbiAgICBjb25zdCBtZXJnZWRQcm9wcyA9IGV4dHJhUHJvcHMgPyBtZXJnZVByb3BzKHByb3BzIHx8IHt9LCBleHRyYVByb3BzKSA6IHByb3BzO1xuICAgIGNvbnN0IGNsb25lZCA9IHtcbiAgICAgICAgX192X2lzVk5vZGU6IHRydWUsXG4gICAgICAgIF9fdl9za2lwOiB0cnVlLFxuICAgICAgICB0eXBlOiB2bm9kZS50eXBlLFxuICAgICAgICBwcm9wczogbWVyZ2VkUHJvcHMsXG4gICAgICAgIGtleTogbWVyZ2VkUHJvcHMgJiYgbm9ybWFsaXplS2V5KG1lcmdlZFByb3BzKSxcbiAgICAgICAgcmVmOiBleHRyYVByb3BzICYmIGV4dHJhUHJvcHMucmVmXG4gICAgICAgICAgICA/IC8vICMyMDc4IGluIHRoZSBjYXNlIG9mIDxjb21wb25lbnQgOmlzPVwidm5vZGVcIiByZWY9XCJleHRyYVwiLz5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdm5vZGUgaXRzZWxmIGFscmVhZHkgaGFzIGEgcmVmLCBjbG9uZVZOb2RlIHdpbGwgbmVlZCB0byBtZXJnZVxuICAgICAgICAgICAgICAgIC8vIHRoZSByZWZzIHNvIHRoZSBzaW5nbGUgdm5vZGUgY2FuIGJlIHNldCBvbiBtdWx0aXBsZSByZWZzXG4gICAgICAgICAgICAgICAgbWVyZ2VSZWYgJiYgcmVmXG4gICAgICAgICAgICAgICAgICAgID8gKDAsIHNoYXJlZF8xLmlzQXJyYXkpKHJlZilcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVmLmNvbmNhdChub3JtYWxpemVSZWYoZXh0cmFQcm9wcykpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtyZWYsIG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKV1cbiAgICAgICAgICAgICAgICAgICAgOiBub3JtYWxpemVSZWYoZXh0cmFQcm9wcylcbiAgICAgICAgICAgIDogcmVmLFxuICAgICAgICBzY29wZUlkOiB2bm9kZS5zY29wZUlkLFxuICAgICAgICBzbG90U2NvcGVJZHM6IHZub2RlLnNsb3RTY29wZUlkcyxcbiAgICAgICAgY2hpbGRyZW46IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBwYXRjaEZsYWcgPT09IC0xIC8qIFBhdGNoRmxhZ3MuSE9JU1RFRCAqLyAmJiAoMCwgc2hhcmVkXzEuaXNBcnJheSkoY2hpbGRyZW4pXG4gICAgICAgICAgICA/IGNoaWxkcmVuLm1hcChkZWVwQ2xvbmVWTm9kZSlcbiAgICAgICAgICAgIDogY2hpbGRyZW4sXG4gICAgICAgIHRhcmdldDogdm5vZGUudGFyZ2V0LFxuICAgICAgICB0YXJnZXRBbmNob3I6IHZub2RlLnRhcmdldEFuY2hvcixcbiAgICAgICAgc3RhdGljQ291bnQ6IHZub2RlLnN0YXRpY0NvdW50LFxuICAgICAgICBzaGFwZUZsYWc6IHZub2RlLnNoYXBlRmxhZyxcbiAgICAgICAgLy8gaWYgdGhlIHZub2RlIGlzIGNsb25lZCB3aXRoIGV4dHJhIHByb3BzLCB3ZSBjYW4gbm8gbG9uZ2VyIGFzc3VtZSBpdHNcbiAgICAgICAgLy8gZXhpc3RpbmcgcGF0Y2ggZmxhZyB0byBiZSByZWxpYWJsZSBhbmQgbmVlZCB0byBhZGQgdGhlIEZVTExfUFJPUFMgZmxhZy5cbiAgICAgICAgLy8gbm90ZTogcHJlc2VydmUgZmxhZyBmb3IgZnJhZ21lbnRzIHNpbmNlIHRoZXkgdXNlIHRoZSBmbGFnIGZvciBjaGlsZHJlblxuICAgICAgICAvLyBmYXN0IHBhdGhzIG9ubHkuXG4gICAgICAgIHBhdGNoRmxhZzogZXh0cmFQcm9wcyAmJiB2bm9kZS50eXBlICE9PSBGcmFnbWVudFxuICAgICAgICAgICAgPyBwYXRjaEZsYWcgPT09IC0xIC8vIGhvaXN0ZWQgbm9kZVxuICAgICAgICAgICAgICAgID8gMTYgLyogUGF0Y2hGbGFncy5GVUxMX1BST1BTICovXG4gICAgICAgICAgICAgICAgOiBwYXRjaEZsYWcgfCAxNiAvKiBQYXRjaEZsYWdzLkZVTExfUFJPUFMgKi9cbiAgICAgICAgICAgIDogcGF0Y2hGbGFnLFxuICAgICAgICBkeW5hbWljUHJvcHM6IHZub2RlLmR5bmFtaWNQcm9wcyxcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuOiB2bm9kZS5keW5hbWljQ2hpbGRyZW4sXG4gICAgICAgIGFwcENvbnRleHQ6IHZub2RlLmFwcENvbnRleHQsXG4gICAgICAgIGRpcnM6IHZub2RlLmRpcnMsXG4gICAgICAgIHRyYW5zaXRpb246IHZub2RlLnRyYW5zaXRpb24sXG4gICAgICAgIC8vIFRoZXNlIHNob3VsZCB0ZWNobmljYWxseSBvbmx5IGJlIG5vbi1udWxsIG9uIG1vdW50ZWQgVk5vZGVzLiBIb3dldmVyLFxuICAgICAgICAvLyB0aGV5ICpzaG91bGQqIGJlIGNvcGllZCBmb3Iga2VwdC1hbGl2ZSB2bm9kZXMuIFNvIHdlIGp1c3QgYWx3YXlzIGNvcHlcbiAgICAgICAgLy8gdGhlbSBzaW5jZSB0aGVtIGJlaW5nIG5vbi1udWxsIGR1cmluZyBhIG1vdW50IGRvZXNuJ3QgYWZmZWN0IHRoZSBsb2dpYyBhc1xuICAgICAgICAvLyB0aGV5IHdpbGwgc2ltcGx5IGJlIG92ZXJ3cml0dGVuLlxuICAgICAgICBjb21wb25lbnQ6IHZub2RlLmNvbXBvbmVudCxcbiAgICAgICAgc3VzcGVuc2U6IHZub2RlLnN1c3BlbnNlLFxuICAgICAgICBzc0NvbnRlbnQ6IHZub2RlLnNzQ29udGVudCAmJiBjbG9uZVZOb2RlKHZub2RlLnNzQ29udGVudCksXG4gICAgICAgIHNzRmFsbGJhY2s6IHZub2RlLnNzRmFsbGJhY2sgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0ZhbGxiYWNrKSxcbiAgICAgICAgZWw6IHZub2RlLmVsLFxuICAgICAgICBhbmNob3I6IHZub2RlLmFuY2hvcixcbiAgICAgICAgY3R4OiB2bm9kZS5jdHgsXG4gICAgICAgIGNlOiB2bm9kZS5jZVxuICAgIH07XG4gICAgcmV0dXJuIGNsb25lZDtcbn1cbmV4cG9ydHMuY2xvbmVWTm9kZSA9IGNsb25lVk5vZGU7XG4vKipcbiAqIERldiBvbmx5LCBmb3IgSE1SIG9mIGhvaXN0ZWQgdm5vZGVzIHJldXNlZCBpbiB2LWZvclxuICogaHR0cHM6Ly9naXRodWIuY29tL3ZpdGVqcy92aXRlL2lzc3Vlcy8yMDIyXG4gKi9cbmZ1bmN0aW9uIGRlZXBDbG9uZVZOb2RlKHZub2RlKSB7XG4gICAgY29uc3QgY2xvbmVkID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgaWYgKCgwLCBzaGFyZWRfMS5pc0FycmF5KSh2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgY2xvbmVkLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZDtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlKHRleHQgPSAnICcsIGZsYWcgPSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIHRleHQsIGZsYWcpO1xufVxuZXhwb3J0cy5jcmVhdGVUZXh0Vk5vZGUgPSBjcmVhdGVUZXh0Vk5vZGU7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1ZOb2RlKGNvbnRlbnQsIG51bWJlck9mTm9kZXMpIHtcbiAgICAvLyBBIHN0YXRpYyB2bm9kZSBjYW4gY29udGFpbiBtdWx0aXBsZSBzdHJpbmdpZmllZCBlbGVtZW50cywgYW5kIHRoZSBudW1iZXJcbiAgICAvLyBvZiBlbGVtZW50cyBpcyBuZWNlc3NhcnkgZm9yIGh5ZHJhdGlvbi5cbiAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKFN0YXRpYywgbnVsbCwgY29udGVudCk7XG4gICAgdm5vZGUuc3RhdGljQ291bnQgPSBudW1iZXJPZk5vZGVzO1xuICAgIHJldHVybiB2bm9kZTtcbn1cbmV4cG9ydHMuY3JlYXRlU3RhdGljVk5vZGUgPSBjcmVhdGVTdGF0aWNWTm9kZTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29tbWVudFZOb2RlKHRleHQgPSAnJywgXG4vLyB3aGVuIHVzZWQgYXMgdGhlIHYtZWxzZSBicmFuY2gsIHRoZSBjb21tZW50IG5vZGUgbXVzdCBiZSBjcmVhdGVkIGFzIGFcbi8vIGJsb2NrIHRvIGVuc3VyZSBjb3JyZWN0IHVwZGF0ZXMuXG5hc0Jsb2NrID0gZmFsc2UpIHtcbiAgICByZXR1cm4gYXNCbG9ja1xuICAgICAgICA/IChvcGVuQmxvY2soKSwgY3JlYXRlQmxvY2soQ29tbWVudCwgbnVsbCwgdGV4dCkpXG4gICAgICAgIDogY3JlYXRlVk5vZGUoQ29tbWVudCwgbnVsbCwgdGV4dCk7XG59XG5leHBvcnRzLmNyZWF0ZUNvbW1lbnRWTm9kZSA9IGNyZWF0ZUNvbW1lbnRWTm9kZTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVZOb2RlKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09IG51bGwgfHwgdHlwZW9mIGNoaWxkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgLy8gZW1wdHkgcGxhY2Vob2xkZXJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgc2hhcmVkXzEuaXNBcnJheSkoY2hpbGQpKSB7XG4gICAgICAgIC8vIGZyYWdtZW50XG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShGcmFnbWVudCwgbnVsbCwgXG4gICAgICAgIC8vICMzNjY2LCBhdm9pZCByZWZlcmVuY2UgcG9sbHV0aW9uIHdoZW4gcmV1c2luZyB2bm9kZVxuICAgICAgICBjaGlsZC5zbGljZSgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBhbHJlYWR5IHZub2RlLCB0aGlzIHNob3VsZCBiZSB0aGUgbW9zdCBjb21tb24gc2luY2UgY29tcGlsZWQgdGVtcGxhdGVzXG4gICAgICAgIC8vIGFsd2F5cyBwcm9kdWNlIGFsbC12bm9kZSBjaGlsZHJlbiBhcnJheXNcbiAgICAgICAgcmV0dXJuIGNsb25lSWZNb3VudGVkKGNoaWxkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHN0cmluZ3MgYW5kIG51bWJlcnNcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIFN0cmluZyhjaGlsZCkpO1xuICAgIH1cbn1cbi8vIG9wdGltaXplZCBub3JtYWxpemF0aW9uIGZvciB0ZW1wbGF0ZS1jb21waWxlZCByZW5kZXIgZm5zXG5mdW5jdGlvbiBjbG9uZUlmTW91bnRlZChjaGlsZCkge1xuICAgIHJldHVybiAoY2hpbGQuZWwgPT09IG51bGwgJiYgY2hpbGQucGF0Y2hGbGFnICE9PSAtMSAvKiBQYXRjaEZsYWdzLkhPSVNURUQgKi8pIHx8XG4gICAgICAgIGNoaWxkLm1lbW9cbiAgICAgICAgPyBjaGlsZFxuICAgICAgICA6IGNsb25lVk5vZGUoY2hpbGQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKSB7XG4gICAgbGV0IHR5cGUgPSAwO1xuICAgIGNvbnN0IHsgc2hhcGVGbGFnIH0gPSB2bm9kZTtcbiAgICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBzaGFyZWRfMS5pc0FycmF5KShjaGlsZHJlbikpIHtcbiAgICAgICAgdHlwZSA9IDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmICgxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqLyB8IDY0IC8qIFNoYXBlRmxhZ3MuVEVMRVBPUlQgKi8pKSB7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgc2xvdCB0byBwbGFpbiBjaGlsZHJlbiBmb3IgcGxhaW4gZWxlbWVudCBhbmQgVGVsZXBvcnRcbiAgICAgICAgICAgIGNvbnN0IHNsb3QgPSBjaGlsZHJlbi5kZWZhdWx0O1xuICAgICAgICAgICAgaWYgKHNsb3QpIHtcbiAgICAgICAgICAgICAgICAvLyBfYyBtYXJrZXIgaXMgYWRkZWQgYnkgd2l0aEN0eCgpIGluZGljYXRpbmcgdGhpcyBpcyBhIGNvbXBpbGVkIHNsb3RcbiAgICAgICAgICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gZmFsc2UpO1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBzbG90KCkpO1xuICAgICAgICAgICAgICAgIHNsb3QuX2MgJiYgKHNsb3QuX2QgPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR5cGUgPSAzMiAvKiBTaGFwZUZsYWdzLlNMT1RTX0NISUxEUkVOICovO1xuICAgICAgICAgICAgY29uc3Qgc2xvdEZsYWcgPSBjaGlsZHJlbi5fO1xuICAgICAgICAgICAgaWYgKCFzbG90RmxhZyAmJiAhKEludGVybmFsT2JqZWN0S2V5IGluIGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLl9jdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzbG90RmxhZyA9PT0gMyAvKiBTbG90RmxhZ3MuRk9SV0FSREVEICovICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIC8vIGEgY2hpbGQgY29tcG9uZW50IHJlY2VpdmVzIGZvcndhcmRlZCBzbG90cyBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICAgICAgICAgICAgLy8gaXRzIHNsb3QgdHlwZSBpcyBkZXRlcm1pbmVkIGJ5IGl0cyBwYXJlbnQncyBzbG90IHR5cGUuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5zbG90cy5fID09PSAxIC8qIFNsb3RGbGFncy5TVEFCTEUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uXyA9IDEgLyogU2xvdEZsYWdzLlNUQUJMRSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLl8gPSAyIC8qIFNsb3RGbGFncy5EWU5BTUlDICovO1xuICAgICAgICAgICAgICAgICAgICB2bm9kZS5wYXRjaEZsYWcgfD0gMTAyNCAvKiBQYXRjaEZsYWdzLkRZTkFNSUNfU0xPVFMgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBzaGFyZWRfMS5pc0Z1bmN0aW9uKShjaGlsZHJlbikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSB7IGRlZmF1bHQ6IGNoaWxkcmVuLCBfY3R4OiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfTtcbiAgICAgICAgdHlwZSA9IDMyIC8qIFNoYXBlRmxhZ3MuU0xPVFNfQ0hJTERSRU4gKi87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGlsZHJlbiA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgICAgIC8vIGZvcmNlIHRlbGVwb3J0IGNoaWxkcmVuIHRvIGFycmF5IHNvIGl0IGNhbiBiZSBtb3ZlZCBhcm91bmRcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFNoYXBlRmxhZ3MuVEVMRVBPUlQgKi8pIHtcbiAgICAgICAgICAgIHR5cGUgPSAxNiAvKiBTaGFwZUZsYWdzLkFSUkFZX0NISUxEUkVOICovO1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0eXBlID0gOCAvKiBTaGFwZUZsYWdzLlRFWFRfQ0hJTERSRU4gKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgdm5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB2bm9kZS5zaGFwZUZsYWcgfD0gdHlwZTtcbn1cbmZ1bmN0aW9uIG1lcmdlUHJvcHMoLi4uYXJncykge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0b01lcmdlID0gYXJnc1tpXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdG9NZXJnZSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgIGlmIChyZXQuY2xhc3MgIT09IHRvTWVyZ2UuY2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LmNsYXNzID0gKDAsIHNoYXJlZF8xLm5vcm1hbGl6ZUNsYXNzKShbcmV0LmNsYXNzLCB0b01lcmdlLmNsYXNzXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0LnN0eWxlID0gKDAsIHNoYXJlZF8xLm5vcm1hbGl6ZVN0eWxlKShbcmV0LnN0eWxlLCB0b01lcmdlLnN0eWxlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoMCwgc2hhcmVkXzEuaXNPbikoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gcmV0W2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgaW5jb21pbmcgPSB0b01lcmdlW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGluY29taW5nICYmXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nICE9PSBpbmNvbWluZyAmJlxuICAgICAgICAgICAgICAgICAgICAhKCgwLCBzaGFyZWRfMS5pc0FycmF5KShleGlzdGluZykgJiYgZXhpc3RpbmcuaW5jbHVkZXMoaW5jb21pbmcpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXRba2V5XSA9IGV4aXN0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaW5jb21pbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGluY29taW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXRba2V5XSA9IHRvTWVyZ2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuZXhwb3J0cy5tZXJnZVByb3BzID0gbWVyZ2VQcm9wcztcbmZ1bmN0aW9uIGludm9rZVZOb2RlSG9vayhob29rLCBpbnN0YW5jZSwgdm5vZGUsIHByZXZWTm9kZSA9IG51bGwpIHtcbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgNyAvKiBFcnJvckNvZGVzLlZOT0RFX0hPT0sgKi8sIFtcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIHByZXZWTm9kZVxuICAgIF0pO1xufVxuY29uc3QgZW1wdHlBcHBDb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xubGV0IHVpZCA9IDA7XG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZSh2bm9kZSwgcGFyZW50LCBzdXNwZW5zZSkge1xuICAgIGNvbnN0IHR5cGUgPSB2bm9kZS50eXBlO1xuICAgIC8vIGluaGVyaXQgcGFyZW50IGFwcCBjb250ZXh0IC0gb3IgLSBpZiByb290LCBhZG9wdCBmcm9tIHJvb3Qgdm5vZGVcbiAgICBjb25zdCBhcHBDb250ZXh0ID0gKHBhcmVudCA/IHBhcmVudC5hcHBDb250ZXh0IDogdm5vZGUuYXBwQ29udGV4dCkgfHwgZW1wdHlBcHBDb250ZXh0O1xuICAgIGNvbnN0IGluc3RhbmNlID0ge1xuICAgICAgICB1aWQ6IHVpZCsrLFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBhcHBDb250ZXh0LFxuICAgICAgICByb290OiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICBzdWJUcmVlOiBudWxsLFxuICAgICAgICBlZmZlY3Q6IG51bGwsXG4gICAgICAgIHVwZGF0ZTogbnVsbCxcbiAgICAgICAgc2NvcGU6IG5ldyByZWFjdGl2aXR5XzEuRWZmZWN0U2NvcGUodHJ1ZSAvKiBkZXRhY2hlZCAqLyksXG4gICAgICAgIHJlbmRlcjogbnVsbCxcbiAgICAgICAgcHJveHk6IG51bGwsXG4gICAgICAgIGV4cG9zZWQ6IG51bGwsXG4gICAgICAgIGV4cG9zZVByb3h5OiBudWxsLFxuICAgICAgICB3aXRoUHJveHk6IG51bGwsXG4gICAgICAgIHByb3ZpZGVzOiBwYXJlbnQgPyBwYXJlbnQucHJvdmlkZXMgOiBPYmplY3QuY3JlYXRlKGFwcENvbnRleHQucHJvdmlkZXMpLFxuICAgICAgICBhY2Nlc3NDYWNoZTogbnVsbCxcbiAgICAgICAgcmVuZGVyQ2FjaGU6IFtdLFxuICAgICAgICAvLyBsb2NhbCByZXNvbHZlZCBhc3NldHNcbiAgICAgICAgY29tcG9uZW50czogbnVsbCxcbiAgICAgICAgZGlyZWN0aXZlczogbnVsbCxcbiAgICAgICAgLy8gcmVzb2x2ZWQgcHJvcHMgYW5kIGVtaXRzIG9wdGlvbnNcbiAgICAgICAgcHJvcHNPcHRpb25zOiBub3JtYWxpemVQcm9wc09wdGlvbnModHlwZSwgYXBwQ29udGV4dCksXG4gICAgICAgIGVtaXRzT3B0aW9uczogbm9ybWFsaXplRW1pdHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxuICAgICAgICAvLyBlbWl0XG4gICAgICAgIGVtaXQ6IG51bGwsXG4gICAgICAgIGVtaXR0ZWQ6IG51bGwsXG4gICAgICAgIC8vIHByb3BzIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgcHJvcHNEZWZhdWx0czogc2hhcmVkXzEuRU1QVFlfT0JKLFxuICAgICAgICAvLyBpbmhlcml0QXR0cnNcbiAgICAgICAgaW5oZXJpdEF0dHJzOiB0eXBlLmluaGVyaXRBdHRycyxcbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgY3R4OiBzaGFyZWRfMS5FTVBUWV9PQkosXG4gICAgICAgIGRhdGE6IHNoYXJlZF8xLkVNUFRZX09CSixcbiAgICAgICAgcHJvcHM6IHNoYXJlZF8xLkVNUFRZX09CSixcbiAgICAgICAgYXR0cnM6IHNoYXJlZF8xLkVNUFRZX09CSixcbiAgICAgICAgc2xvdHM6IHNoYXJlZF8xLkVNUFRZX09CSixcbiAgICAgICAgcmVmczogc2hhcmVkXzEuRU1QVFlfT0JKLFxuICAgICAgICBzZXR1cFN0YXRlOiBzaGFyZWRfMS5FTVBUWV9PQkosXG4gICAgICAgIHNldHVwQ29udGV4dDogbnVsbCxcbiAgICAgICAgLy8gc3VzcGVuc2UgcmVsYXRlZFxuICAgICAgICBzdXNwZW5zZSxcbiAgICAgICAgc3VzcGVuc2VJZDogc3VzcGVuc2UgPyBzdXNwZW5zZS5wZW5kaW5nSWQgOiAwLFxuICAgICAgICBhc3luY0RlcDogbnVsbCxcbiAgICAgICAgYXN5bmNSZXNvbHZlZDogZmFsc2UsXG4gICAgICAgIC8vIGxpZmVjeWNsZSBob29rc1xuICAgICAgICAvLyBub3QgdXNpbmcgZW51bXMgaGVyZSBiZWNhdXNlIGl0IHJlc3VsdHMgaW4gY29tcHV0ZWQgcHJvcGVydGllc1xuICAgICAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgICAgICBpc1VubW91bnRlZDogZmFsc2UsXG4gICAgICAgIGlzRGVhY3RpdmF0ZWQ6IGZhbHNlLFxuICAgICAgICBiYzogbnVsbCxcbiAgICAgICAgYzogbnVsbCxcbiAgICAgICAgYm06IG51bGwsXG4gICAgICAgIG06IG51bGwsXG4gICAgICAgIGJ1OiBudWxsLFxuICAgICAgICB1OiBudWxsLFxuICAgICAgICB1bTogbnVsbCxcbiAgICAgICAgYnVtOiBudWxsLFxuICAgICAgICBkYTogbnVsbCxcbiAgICAgICAgYTogbnVsbCxcbiAgICAgICAgcnRnOiBudWxsLFxuICAgICAgICBydGM6IG51bGwsXG4gICAgICAgIGVjOiBudWxsLFxuICAgICAgICBzcDogbnVsbFxuICAgIH07XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICBpbnN0YW5jZS5jdHggPSBjcmVhdGVEZXZSZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLmN0eCA9IHsgXzogaW5zdGFuY2UgfTtcbiAgICB9XG4gICAgaW5zdGFuY2Uucm9vdCA9IHBhcmVudCA/IHBhcmVudC5yb290IDogaW5zdGFuY2U7XG4gICAgaW5zdGFuY2UuZW1pdCA9IGVtaXQuYmluZChudWxsLCBpbnN0YW5jZSk7XG4gICAgLy8gYXBwbHkgY3VzdG9tIGVsZW1lbnQgc3BlY2lhbCBoYW5kbGluZ1xuICAgIGlmICh2bm9kZS5jZSkge1xuICAgICAgICB2bm9kZS5jZShpbnN0YW5jZSk7XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cbmxldCBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xuY29uc3QgZ2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbmV4cG9ydHMuZ2V0Q3VycmVudEluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlO1xuY29uc3Qgc2V0Q3VycmVudEluc3RhbmNlID0gKGluc3RhbmNlKSA9PiB7XG4gICAgY3VycmVudEluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgaW5zdGFuY2Uuc2NvcGUub24oKTtcbn07XG5jb25zdCB1bnNldEN1cnJlbnRJbnN0YW5jZSA9ICgpID0+IHtcbiAgICBjdXJyZW50SW5zdGFuY2UgJiYgY3VycmVudEluc3RhbmNlLnNjb3BlLm9mZigpO1xuICAgIGN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XG59O1xuY29uc3QgaXNCdWlsdEluVGFnID0gLyojX19QVVJFX18qLyAoMCwgc2hhcmVkXzEubWFrZU1hcCkoJ3Nsb3QsY29tcG9uZW50Jyk7XG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgY29uZmlnKSB7XG4gICAgY29uc3QgYXBwSXNOYXRpdmVUYWcgPSBjb25maWcuaXNOYXRpdmVUYWcgfHwgc2hhcmVkXzEuTk87XG4gICAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBhcHBJc05hdGl2ZVRhZyhuYW1lKSkge1xuICAgICAgICB3YXJuKCdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50IGlkOiAnICsgbmFtZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNoYXBlRmxhZ3MuU1RBVEVGVUxfQ09NUE9ORU5UICovO1xufVxubGV0IGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0dXBDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSID0gZmFsc2UpIHtcbiAgICBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBpc1NTUjtcbiAgICBjb25zdCB7IHByb3BzLCBjaGlsZHJlbiB9ID0gaW5zdGFuY2Uudm5vZGU7XG4gICAgY29uc3QgaXNTdGF0ZWZ1bCA9IGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpO1xuICAgIGluaXRQcm9wcyhpbnN0YW5jZSwgcHJvcHMsIGlzU3RhdGVmdWwsIGlzU1NSKTtcbiAgICBpbml0U2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcbiAgICBjb25zdCBzZXR1cFJlc3VsdCA9IGlzU3RhdGVmdWxcbiAgICAgICAgPyBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUilcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgaXNJblNTUkNvbXBvbmVudFNldHVwID0gZmFsc2U7XG4gICAgcmV0dXJuIHNldHVwUmVzdWx0O1xufVxuZnVuY3Rpb24gc2V0dXBTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGlmIChDb21wb25lbnQubmFtZSkge1xuICAgICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKENvbXBvbmVudC5uYW1lLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENvbXBvbmVudC5jb21wb25lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKENvbXBvbmVudC5jb21wb25lbnRzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZXNbaV0sIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoQ29tcG9uZW50LmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmRpcmVjdGl2ZXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENvbXBvbmVudC5jb21waWxlck9wdGlvbnMgJiYgaXNSdW50aW1lT25seSgpKSB7XG4gICAgICAgICAgICB3YXJuKGBcImNvbXBpbGVyT3B0aW9uc1wiIGlzIG9ubHkgc3VwcG9ydGVkIHdoZW4gdXNpbmcgYSBidWlsZCBvZiBWdWUgdGhhdCBgICtcbiAgICAgICAgICAgICAgICBgaW5jbHVkZXMgdGhlIHJ1bnRpbWUgY29tcGlsZXIuIFNpbmNlIHlvdSBhcmUgdXNpbmcgYSBydW50aW1lLW9ubHkgYCArXG4gICAgICAgICAgICAgICAgYGJ1aWxkLCB0aGUgb3B0aW9ucyBzaG91bGQgYmUgcGFzc2VkIHZpYSB5b3VyIGJ1aWxkIHRvb2wgY29uZmlnIGluc3RlYWQuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gMC4gY3JlYXRlIHJlbmRlciBwcm94eSBwcm9wZXJ0eSBhY2Nlc3MgY2FjaGVcbiAgICBpbnN0YW5jZS5hY2Nlc3NDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgLy8gMS4gY3JlYXRlIHB1YmxpYyBpbnN0YW5jZSAvIHJlbmRlciBwcm94eVxuICAgIC8vIGFsc28gbWFyayBpdCByYXcgc28gaXQncyBuZXZlciBvYnNlcnZlZFxuICAgIGluc3RhbmNlLnByb3h5ID0gKDAsIHJlYWN0aXZpdHlfMS5tYXJrUmF3KShuZXcgUHJveHkoaW5zdGFuY2UuY3R4LCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMpKTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcbiAgICB9XG4gICAgLy8gMi4gY2FsbCBzZXR1cCgpXG4gICAgY29uc3QgeyBzZXR1cCB9ID0gQ29tcG9uZW50O1xuICAgIGlmIChzZXR1cCkge1xuICAgICAgICBjb25zdCBzZXR1cENvbnRleHQgPSAoaW5zdGFuY2Uuc2V0dXBDb250ZXh0ID1cbiAgICAgICAgICAgIHNldHVwLmxlbmd0aCA+IDEgPyBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIDogbnVsbCk7XG4gICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgICgwLCByZWFjdGl2aXR5XzEucGF1c2VUcmFja2luZykoKTtcbiAgICAgICAgY29uc3Qgc2V0dXBSZXN1bHQgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoc2V0dXAsIGluc3RhbmNlLCAwIC8qIEVycm9yQ29kZXMuU0VUVVBfRlVOQ1RJT04gKi8sIFsocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAoMCwgcmVhY3Rpdml0eV8xLnNoYWxsb3dSZWFkb25seSkoaW5zdGFuY2UucHJvcHMpIDogaW5zdGFuY2UucHJvcHMsIHNldHVwQ29udGV4dF0pO1xuICAgICAgICAoMCwgcmVhY3Rpdml0eV8xLnJlc2V0VHJhY2tpbmcpKCk7XG4gICAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICAgIGlmICgoMCwgc2hhcmVkXzEuaXNQcm9taXNlKShzZXR1cFJlc3VsdCkpIHtcbiAgICAgICAgICAgIHNldHVwUmVzdWx0LnRoZW4odW5zZXRDdXJyZW50SW5zdGFuY2UsIHVuc2V0Q3VycmVudEluc3RhbmNlKTtcbiAgICAgICAgICAgIGlmIChpc1NTUikge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgcHJvbWlzZSBzbyBzZXJ2ZXItcmVuZGVyZXIgY2FuIHdhaXQgb24gaXRcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dXBSZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHJlc29sdmVkUmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCByZXNvbHZlZFJlc3VsdCwgaXNTU1IpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgaW5zdGFuY2UsIDAgLyogRXJyb3JDb2Rlcy5TRVRVUF9GVU5DVElPTiAqLyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhc3luYyBzZXR1cCByZXR1cm5lZCBQcm9taXNlLlxuICAgICAgICAgICAgICAgIC8vIGJhaWwgaGVyZSBhbmQgd2FpdCBmb3IgcmUtZW50cnkuXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuYXN5bmNEZXAgPSBzZXR1cFJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpbnN0YW5jZS5zdXNwZW5zZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gKF9hID0gQ29tcG9uZW50Lm5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdBbm9ueW1vdXMnO1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgPCR7bmFtZX0+OiBzZXR1cCBmdW5jdGlvbiByZXR1cm5lZCBhIHByb21pc2UsIGJ1dCBubyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGA8U3VzcGVuc2U+IGJvdW5kYXJ5IHdhcyBmb3VuZCBpbiB0aGUgcGFyZW50IGNvbXBvbmVudCB0cmVlLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBBIGNvbXBvbmVudCB3aXRoIGFzeW5jIHNldHVwKCkgbXVzdCBiZSBuZXN0ZWQgaW4gYSA8U3VzcGVuc2U+IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGluIG9yZGVyIHRvIGJlIHJlbmRlcmVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBzZXR1cFJlc3VsdCwgaXNTU1IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBzZXR1cFJlc3VsdCwgaXNTU1IpIHtcbiAgICBpZiAoKDAsIHNoYXJlZF8xLmlzRnVuY3Rpb24pKHNldHVwUmVzdWx0KSkge1xuICAgICAgICAvLyBzZXR1cCByZXR1cm5lZCBhbiBpbmxpbmUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpbnN0YW5jZS50eXBlLl9fc3NySW5saW5lUmVuZGVyKSB7XG4gICAgICAgICAgICAvLyB3aGVuIHRoZSBmdW5jdGlvbidzIG5hbWUgaXMgYHNzclJlbmRlcmAgKGNvbXBpbGVkIGJ5IFNGQyBpbmxpbmUgbW9kZSksXG4gICAgICAgICAgICAvLyBzZXQgaXQgYXMgc3NyUmVuZGVyIGluc3RlYWQuXG4gICAgICAgICAgICBpbnN0YW5jZS5zc3JSZW5kZXIgPSBzZXR1cFJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnJlbmRlciA9IHNldHVwUmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCBzaGFyZWRfMS5pc09iamVjdCkoc2V0dXBSZXN1bHQpKSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNWTm9kZShzZXR1cFJlc3VsdCkpIHtcbiAgICAgICAgICAgIHdhcm4oYHNldHVwKCkgc2hvdWxkIG5vdCByZXR1cm4gVk5vZGVzIGRpcmVjdGx5IC0gYCArXG4gICAgICAgICAgICAgICAgYHJldHVybiBhIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldHVwIHJldHVybmVkIGJpbmRpbmdzLlxuICAgICAgICAvLyBhc3N1bWluZyBhIHJlbmRlciBmdW5jdGlvbiBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGlzIHByZXNlbnQuXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5kZXZ0b29sc1Jhd1NldHVwU3RhdGUgPSBzZXR1cFJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5zZXR1cFN0YXRlID0gKDAsIHJlYWN0aXZpdHlfMS5wcm94eVJlZnMpKHNldHVwUmVzdWx0KTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNldHVwUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2Fybihgc2V0dXAoKSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC4gUmVjZWl2ZWQ6ICR7c2V0dXBSZXN1bHQgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2Ygc2V0dXBSZXN1bHR9YCk7XG4gICAgfVxuICAgIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XG59XG5sZXQgY29tcGlsZTtcbmxldCBpbnN0YWxsV2l0aFByb3h5O1xuLyoqXG4gKiBGb3IgcnVudGltZS1kb20gdG8gcmVnaXN0ZXIgdGhlIGNvbXBpbGVyLlxuICogTm90ZSB0aGUgZXhwb3J0ZWQgbWV0aG9kIHVzZXMgYW55IHRvIGF2b2lkIGQudHMgcmVseWluZyBvbiB0aGUgY29tcGlsZXIgdHlwZXMuXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyKF9jb21waWxlKSB7XG4gICAgY29tcGlsZSA9IF9jb21waWxlO1xuICAgIGluc3RhbGxXaXRoUHJveHkgPSBpID0+IHtcbiAgICAgICAgaWYgKGkucmVuZGVyLl9yYykge1xuICAgICAgICAgICAgaS53aXRoUHJveHkgPSBuZXcgUHJveHkoaS5jdHgsIFJ1bnRpbWVDb21waWxlZFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy5yZWdpc3RlclJ1bnRpbWVDb21waWxlciA9IHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyO1xuLy8gZGV2IG9ubHlcbmNvbnN0IGlzUnVudGltZU9ubHkgPSAoKSA9PiAhY29tcGlsZTtcbmV4cG9ydHMuaXNSdW50aW1lT25seSA9IGlzUnVudGltZU9ubHk7XG5mdW5jdGlvbiBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IsIHNraXBPcHRpb25zKSB7XG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgICAvLyB0ZW1wbGF0ZSAvIHJlbmRlciBmdW5jdGlvbiBub3JtYWxpemF0aW9uXG4gICAgLy8gY291bGQgYmUgYWxyZWFkeSBzZXQgd2hlbiByZXR1cm5lZCBmcm9tIHNldHVwKClcbiAgICBpZiAoIWluc3RhbmNlLnJlbmRlcikge1xuICAgICAgICAvLyBvbmx5IGRvIG9uLXRoZS1mbHkgY29tcGlsZSBpZiBub3QgaW4gU1NSIC0gU1NSIG9uLXRoZS1mbHkgY29tcGlsYXRpb25cbiAgICAgICAgLy8gaXMgZG9uZSBieSBzZXJ2ZXItcmVuZGVyZXJcbiAgICAgICAgaWYgKCFpc1NTUiAmJiBjb21waWxlICYmICFDb21wb25lbnQucmVuZGVyKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IENvbXBvbmVudC50ZW1wbGF0ZSB8fFxuICAgICAgICAgICAgICAgIHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKS50ZW1wbGF0ZTtcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGlzQ3VzdG9tRWxlbWVudCwgY29tcGlsZXJPcHRpb25zIH0gPSBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRlbGltaXRlcnMsIGNvbXBpbGVyT3B0aW9uczogY29tcG9uZW50Q29tcGlsZXJPcHRpb25zIH0gPSBDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZmluYWxDb21waWxlck9wdGlvbnMgPSAoMCwgc2hhcmVkXzEuZXh0ZW5kKSgoMCwgc2hhcmVkXzEuZXh0ZW5kKSh7XG4gICAgICAgICAgICAgICAgICAgIGlzQ3VzdG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyc1xuICAgICAgICAgICAgICAgIH0sIGNvbXBpbGVyT3B0aW9ucyksIGNvbXBvbmVudENvbXBpbGVyT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnJlbmRlciA9IGNvbXBpbGUodGVtcGxhdGUsIGZpbmFsQ29tcGlsZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBjb21waWxlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLnJlbmRlciA9IChDb21wb25lbnQucmVuZGVyIHx8IHNoYXJlZF8xLk5PT1ApO1xuICAgICAgICAvLyBmb3IgcnVudGltZS1jb21waWxlZCByZW5kZXIgZnVuY3Rpb25zIHVzaW5nIGB3aXRoYCBibG9ja3MsIHRoZSByZW5kZXJcbiAgICAgICAgLy8gcHJveHkgdXNlZCBuZWVkcyBhIGRpZmZlcmVudCBgaGFzYCBoYW5kbGVyIHdoaWNoIGlzIG1vcmUgcGVyZm9ybWFudCBhbmRcbiAgICAgICAgLy8gYWxzbyBvbmx5IGFsbG93cyBhIHdoaXRlbGlzdCBvZiBnbG9iYWxzIHRvIGZhbGx0aHJvdWdoLlxuICAgICAgICBpZiAoaW5zdGFsbFdpdGhQcm94eSkge1xuICAgICAgICAgICAgaW5zdGFsbFdpdGhQcm94eShpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc3VwcG9ydCBmb3IgMi54IG9wdGlvbnNcbiAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhKGZhbHNlKSkge1xuICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICAoMCwgcmVhY3Rpdml0eV8xLnBhdXNlVHJhY2tpbmcpKCk7XG4gICAgICAgIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSk7XG4gICAgICAgICgwLCByZWFjdGl2aXR5XzEucmVzZXRUcmFja2luZykoKTtcbiAgICAgICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICB9XG4gICAgLy8gd2FybiBtaXNzaW5nIHRlbXBsYXRlL3JlbmRlclxuICAgIC8vIHRoZSBydW50aW1lIGNvbXBpbGF0aW9uIG9mIHRlbXBsYXRlIGluIFNTUiBpcyBkb25lIGJ5IHNlcnZlci1yZW5kZXJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFDb21wb25lbnQucmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gc2hhcmVkXzEuTk9PUCAmJiAhaXNTU1IpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghY29tcGlsZSAmJiBDb21wb25lbnQudGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBwcm92aWRlZCB0ZW1wbGF0ZSBvcHRpb24gYnV0IGAgK1xuICAgICAgICAgICAgICAgIGBydW50aW1lIGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBWdWUuYCArXG4gICAgICAgICAgICAgICAgKGAgQ29uZmlndXJlIHlvdXIgYnVuZGxlciB0byBhbGlhcyBcInZ1ZVwiIHRvIFwidnVlL2Rpc3QvdnVlLmVzbS1idW5kbGVyLmpzXCIuYCkgLyogc2hvdWxkIG5vdCBoYXBwZW4gKi8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IGlzIG1pc3NpbmcgdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uLmApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQXR0cnNQcm94eShpbnN0YW5jZSkge1xuICAgIHJldHVybiBuZXcgUHJveHkoaW5zdGFuY2UuYXR0cnMsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgICAgICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgICAgICAgICAgICAgKDAsIHJlYWN0aXZpdHlfMS50cmFjaykoaW5zdGFuY2UsIFwiZ2V0XCIgLyogVHJhY2tPcFR5cGVzLkdFVCAqLywgJyRhdHRycycpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQoKSB7XG4gICAgICAgICAgICAgICAgd2Fybihgc2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LmApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWxldGVQcm9wZXJ0eSgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBzZXR1cENvbnRleHQuYXR0cnMgaXMgcmVhZG9ubHkuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICAgICAgICAgICAgKDAsIHJlYWN0aXZpdHlfMS50cmFjaykoaW5zdGFuY2UsIFwiZ2V0XCIgLyogVHJhY2tPcFR5cGVzLkdFVCAqLywgJyRhdHRycycpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBleHBvc2UgPSBleHBvc2VkID0+IHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlLmV4cG9zZWQpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBleHBvc2UoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZSBwZXIgc2V0dXAoKS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHBvc2VkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgZXhwb3NlZFR5cGUgPSB0eXBlb2YgZXhwb3NlZDtcbiAgICAgICAgICAgICAgICBpZiAoZXhwb3NlZFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgc2hhcmVkXzEuaXNBcnJheSkoZXhwb3NlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9zZWRUeXBlID0gJ2FycmF5JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgoMCwgcmVhY3Rpdml0eV8xLmlzUmVmKShleHBvc2VkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3NlZFR5cGUgPSAncmVmJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhwb3NlZFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYGV4cG9zZSgpIHNob3VsZCBiZSBwYXNzZWQgYSBwbGFpbiBvYmplY3QsIHJlY2VpdmVkICR7ZXhwb3NlZFR5cGV9LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5leHBvc2VkID0gZXhwb3NlZCB8fCB7fTtcbiAgICB9O1xuICAgIGxldCBhdHRycztcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIC8vIFdlIHVzZSBnZXR0ZXJzIGluIGRldiBpbiBjYXNlIGxpYnMgbGlrZSB0ZXN0LXV0aWxzIG92ZXJ3cml0ZSBpbnN0YW5jZVxuICAgICAgICAvLyBwcm9wZXJ0aWVzIChvdmVyd3JpdGVzIHNob3VsZCBub3QgYmUgZG9uZSBpbiBwcm9kKVxuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBnZXQgYXR0cnMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJzIHx8IChhdHRycyA9IGNyZWF0ZUF0dHJzUHJveHkoaW5zdGFuY2UpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgc2xvdHMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCByZWFjdGl2aXR5XzEuc2hhbGxvd1JlYWRvbmx5KShpbnN0YW5jZS5zbG90cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGVtaXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChldmVudCwgLi4uYXJncykgPT4gaW5zdGFuY2UuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXhwb3NlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldCBhdHRycygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0cnMgfHwgKGF0dHJzID0gY3JlYXRlQXR0cnNQcm94eShpbnN0YW5jZSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNsb3RzOiBpbnN0YW5jZS5zbG90cyxcbiAgICAgICAgICAgIGVtaXQ6IGluc3RhbmNlLmVtaXQsXG4gICAgICAgICAgICBleHBvc2VcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRFeHBvc2VQcm94eShpbnN0YW5jZSkge1xuICAgIGlmIChpbnN0YW5jZS5leHBvc2VkKSB7XG4gICAgICAgIHJldHVybiAoaW5zdGFuY2UuZXhwb3NlUHJveHkgfHxcbiAgICAgICAgICAgIChpbnN0YW5jZS5leHBvc2VQcm94eSA9IG5ldyBQcm94eSgoMCwgcmVhY3Rpdml0eV8xLnByb3h5UmVmcykoKDAsIHJlYWN0aXZpdHlfMS5tYXJrUmF3KShpbnN0YW5jZS5leHBvc2VkKSksIHtcbiAgICAgICAgICAgICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgaW4gcHVibGljUHJvcGVydGllc01hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XShpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhhcyh0YXJnZXQsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5IGluIHRhcmdldCB8fCBrZXkgaW4gcHVibGljUHJvcGVydGllc01hcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSkpO1xuICAgIH1cbn1cbmNvbnN0IGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG5jb25zdCBjbGFzc2lmeSA9IChzdHIpID0+IHN0ci5yZXBsYWNlKGNsYXNzaWZ5UkUsIGMgPT4gYy50b1VwcGVyQ2FzZSgpKS5yZXBsYWNlKC9bLV9dL2csICcnKTtcbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50LCBpbmNsdWRlSW5mZXJyZWQgPSB0cnVlKSB7XG4gICAgcmV0dXJuICgwLCBzaGFyZWRfMS5pc0Z1bmN0aW9uKShDb21wb25lbnQpXG4gICAgICAgID8gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lXG4gICAgICAgIDogQ29tcG9uZW50Lm5hbWUgfHwgKGluY2x1ZGVJbmZlcnJlZCAmJiBDb21wb25lbnQuX19uYW1lKTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBDb21wb25lbnQsIGlzUm9vdCA9IGZhbHNlKSB7XG4gICAgbGV0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCk7XG4gICAgaWYgKCFuYW1lICYmIENvbXBvbmVudC5fX2ZpbGUpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBDb21wb25lbnQuX19maWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLlxcdyskLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbmFtZSA9IG1hdGNoWzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbmFtZSAmJiBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wYXJlbnQpIHtcbiAgICAgICAgLy8gdHJ5IHRvIGluZmVyIHRoZSBuYW1lIGJhc2VkIG9uIHJldmVyc2UgcmVzb2x1dGlvblxuICAgICAgICBjb25zdCBpbmZlckZyb21SZWdpc3RyeSA9IChyZWdpc3RyeSkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVnaXN0cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVnaXN0cnlba2V5XSA9PT0gQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBuYW1lID1cbiAgICAgICAgICAgIGluZmVyRnJvbVJlZ2lzdHJ5KGluc3RhbmNlLmNvbXBvbmVudHMgfHxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5wYXJlbnQudHlwZS5jb21wb25lbnRzKSB8fCBpbmZlckZyb21SZWdpc3RyeShpbnN0YW5jZS5hcHBDb250ZXh0LmNvbXBvbmVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZSA/IGNsYXNzaWZ5KG5hbWUpIDogaXNSb290ID8gYEFwcGAgOiBgQW5vbnltb3VzYDtcbn1cbmZ1bmN0aW9uIGlzQ2xhc3NDb21wb25lbnQodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHNoYXJlZF8xLmlzRnVuY3Rpb24pKHZhbHVlKSAmJiAnX192Y2NPcHRzJyBpbiB2YWx1ZTtcbn1cbmNvbnN0IGNvbXB1dGVkID0gKChnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucykgPT4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gKDAsIHJlYWN0aXZpdHlfMS5jb21wdXRlZCkoZ2V0dGVyT3JPcHRpb25zLCBkZWJ1Z09wdGlvbnMsIGlzSW5TU1JDb21wb25lbnRTZXR1cCk7XG59KTtcbmV4cG9ydHMuY29tcHV0ZWQgPSBjb21wdXRlZDtcbi8vIGRldiBvbmx5XG5jb25zdCB3YXJuUnVudGltZVVzYWdlID0gKG1ldGhvZCkgPT4gd2FybihgJHttZXRob2R9KCkgaXMgYSBjb21waWxlci1oaW50IGhlbHBlciB0aGF0IGlzIG9ubHkgdXNhYmxlIGluc2lkZSBgICtcbiAgICBgPHNjcmlwdCBzZXR1cD4gb2YgYSBzaW5nbGUgZmlsZSBjb21wb25lbnQuIEl0cyBhcmd1bWVudHMgc2hvdWxkIGJlIGAgK1xuICAgIGBjb21waWxlZCBhd2F5IGFuZCBwYXNzaW5nIGl0IGF0IHJ1bnRpbWUgaGFzIG5vIGVmZmVjdC5gKTtcbi8vIGltcGxlbWVudGF0aW9uXG5mdW5jdGlvbiBkZWZpbmVQcm9wcygpIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZVByb3BzYCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5kZWZpbmVQcm9wcyA9IGRlZmluZVByb3BzO1xuLy8gaW1wbGVtZW50YXRpb25cbmZ1bmN0aW9uIGRlZmluZUVtaXRzKCkge1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lRW1pdHNgKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLmRlZmluZUVtaXRzID0gZGVmaW5lRW1pdHM7XG4vKipcbiAqIFZ1ZSBgPHNjcmlwdCBzZXR1cD5gIGNvbXBpbGVyIG1hY3JvIGZvciBkZWNsYXJpbmcgYSBjb21wb25lbnQncyBleHBvc2VkXG4gKiBpbnN0YW5jZSBwcm9wZXJ0aWVzIHdoZW4gaXQgaXMgYWNjZXNzZWQgYnkgYSBwYXJlbnQgY29tcG9uZW50IHZpYSB0ZW1wbGF0ZVxuICogcmVmcy5cbiAqXG4gKiBgPHNjcmlwdCBzZXR1cD5gIGNvbXBvbmVudHMgYXJlIGNsb3NlZCBieSBkZWZhdWx0IC0gaS5lLiB2YXJpYWJsZXMgaW5zaWRlXG4gKiB0aGUgYDxzY3JpcHQgc2V0dXA+YCBzY29wZSBpcyBub3QgZXhwb3NlZCB0byBwYXJlbnQgdW5sZXNzIGV4cGxpY2l0bHkgZXhwb3NlZFxuICogdmlhIGBkZWZpbmVFeHBvc2VgLlxuICpcbiAqIFRoaXMgaXMgb25seSB1c2FibGUgaW5zaWRlIGA8c2NyaXB0IHNldHVwPmAsIGlzIGNvbXBpbGVkIGF3YXkgaW4gdGhlXG4gKiBvdXRwdXQgYW5kIHNob3VsZCAqKm5vdCoqIGJlIGFjdHVhbGx5IGNhbGxlZCBhdCBydW50aW1lLlxuICovXG5mdW5jdGlvbiBkZWZpbmVFeHBvc2UoZXhwb3NlZCkge1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lRXhwb3NlYCk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZpbmVFeHBvc2UgPSBkZWZpbmVFeHBvc2U7XG4vKipcbiAqIFZ1ZSBgPHNjcmlwdCBzZXR1cD5gIGNvbXBpbGVyIG1hY3JvIGZvciBwcm92aWRpbmcgcHJvcHMgZGVmYXVsdCB2YWx1ZXMgd2hlblxuICogdXNpbmcgdHlwZS1iYXNlZCBgZGVmaW5lUHJvcHNgIGRlY2xhcmF0aW9uLlxuICpcbiAqIEV4YW1wbGUgdXNhZ2U6XG4gKiBgYGB0c1xuICogd2l0aERlZmF1bHRzKGRlZmluZVByb3BzPHtcbiAqICAgc2l6ZT86IG51bWJlclxuICogICBsYWJlbHM/OiBzdHJpbmdbXVxuICogfT4oKSwge1xuICogICBzaXplOiAzLFxuICogICBsYWJlbHM6ICgpID0+IFsnZGVmYXVsdCBsYWJlbCddXG4gKiB9KVxuICogYGBgXG4gKlxuICogVGhpcyBpcyBvbmx5IHVzYWJsZSBpbnNpZGUgYDxzY3JpcHQgc2V0dXA+YCwgaXMgY29tcGlsZWQgYXdheSBpbiB0aGUgb3V0cHV0XG4gKiBhbmQgc2hvdWxkICoqbm90KiogYmUgYWN0dWFsbHkgY2FsbGVkIGF0IHJ1bnRpbWUuXG4gKi9cbmZ1bmN0aW9uIHdpdGhEZWZhdWx0cyhwcm9wcywgZGVmYXVsdHMpIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIHdhcm5SdW50aW1lVXNhZ2UoYHdpdGhEZWZhdWx0c2ApO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMud2l0aERlZmF1bHRzID0gd2l0aERlZmF1bHRzO1xuZnVuY3Rpb24gdXNlU2xvdHMoKSB7XG4gICAgcmV0dXJuIGdldENvbnRleHQoKS5zbG90cztcbn1cbmV4cG9ydHMudXNlU2xvdHMgPSB1c2VTbG90cztcbmZ1bmN0aW9uIHVzZUF0dHJzKCkge1xuICAgIHJldHVybiBnZXRDb250ZXh0KCkuYXR0cnM7XG59XG5leHBvcnRzLnVzZUF0dHJzID0gdXNlQXR0cnM7XG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICAgIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpKSB7XG4gICAgICAgIHdhcm4oYHVzZUNvbnRleHQoKSBjYWxsZWQgd2l0aG91dCBhY3RpdmUgaW5zdGFuY2UuYCk7XG4gICAgfVxuICAgIHJldHVybiBpLnNldHVwQ29udGV4dCB8fCAoaS5zZXR1cENvbnRleHQgPSBjcmVhdGVTZXR1cENvbnRleHQoaSkpO1xufVxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyBkZWZhdWx0IGRlY2xhcmF0aW9ucy4gSW1wb3J0ZWQgYnkgY29tcGlsZWQgY29kZVxuICogb25seS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRzKHJhdywgZGVmYXVsdHMpIHtcbiAgICBjb25zdCBwcm9wcyA9ICgwLCBzaGFyZWRfMS5pc0FycmF5KShyYXcpXG4gICAgICAgID8gcmF3LnJlZHVjZSgobm9ybWFsaXplZCwgcCkgPT4gKChub3JtYWxpemVkW3BdID0ge30pLCBub3JtYWxpemVkKSwge30pXG4gICAgICAgIDogcmF3O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgICAgIGNvbnN0IG9wdCA9IHByb3BzW2tleV07XG4gICAgICAgIGlmIChvcHQpIHtcbiAgICAgICAgICAgIGlmICgoMCwgc2hhcmVkXzEuaXNBcnJheSkob3B0KSB8fCAoMCwgc2hhcmVkXzEuaXNGdW5jdGlvbikob3B0KSkge1xuICAgICAgICAgICAgICAgIHByb3BzW2tleV0gPSB7IHR5cGU6IG9wdCwgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0LmRlZmF1bHQgPSBkZWZhdWx0c1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHsgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgd2FybihgcHJvcHMgZGVmYXVsdCBrZXkgXCIke2tleX1cIiBoYXMgbm8gY29ycmVzcG9uZGluZyBkZWNsYXJhdGlvbi5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcHM7XG59XG5leHBvcnRzLm1lcmdlRGVmYXVsdHMgPSBtZXJnZURlZmF1bHRzO1xuLyoqXG4gKiBVc2VkIHRvIGNyZWF0ZSBhIHByb3h5IGZvciB0aGUgcmVzdCBlbGVtZW50IHdoZW4gZGVzdHJ1Y3R1cmluZyBwcm9wcyB3aXRoXG4gKiBkZWZpbmVQcm9wcygpLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb3BzUmVzdFByb3h5KHByb3BzLCBleGNsdWRlZEtleXMpIHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICBpZiAoIWV4Y2x1ZGVkS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmV0LCBrZXksIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gcHJvcHNba2V5XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbmV4cG9ydHMuY3JlYXRlUHJvcHNSZXN0UHJveHkgPSBjcmVhdGVQcm9wc1Jlc3RQcm94eTtcbi8qKlxuICogYDxzY3JpcHQgc2V0dXA+YCBoZWxwZXIgZm9yIHBlcnNpc3RpbmcgdGhlIGN1cnJlbnQgaW5zdGFuY2UgY29udGV4dCBvdmVyXG4gKiBhc3luYy9hd2FpdCBmbG93cy5cbiAqXG4gKiBgQHZ1ZS9jb21waWxlci1zZmNgIGNvbnZlcnRzIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IHggPSBhd2FpdCBmb28oKVxuICogYGBgXG4gKlxuICogaW50bzpcbiAqXG4gKiBgYGB0c1xuICogbGV0IF9fdGVtcCwgX19yZXN0b3JlXG4gKiBjb25zdCB4ID0gKChbX190ZW1wLCBfX3Jlc3RvcmVdID0gd2l0aEFzeW5jQ29udGV4dCgoKSA9PiBmb28oKSkpLF9fdGVtcD1hd2FpdCBfX3RlbXAsX19yZXN0b3JlKCksX190ZW1wKVxuICogYGBgXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gd2l0aEFzeW5jQ29udGV4dChnZXRBd2FpdGFibGUpIHtcbiAgICBjb25zdCBjdHggPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjdHgpIHtcbiAgICAgICAgd2Fybihgd2l0aEFzeW5jQ29udGV4dCBjYWxsZWQgd2l0aG91dCBhY3RpdmUgY3VycmVudCBpbnN0YW5jZS4gYCArXG4gICAgICAgICAgICBgVGhpcyBpcyBsaWtlbHkgYSBidWcuYCk7XG4gICAgfVxuICAgIGxldCBhd2FpdGFibGUgPSBnZXRBd2FpdGFibGUoKTtcbiAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGlmICgoMCwgc2hhcmVkXzEuaXNQcm9taXNlKShhd2FpdGFibGUpKSB7XG4gICAgICAgIGF3YWl0YWJsZSA9IGF3YWl0YWJsZS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShjdHgpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBbYXdhaXRhYmxlLCAoKSA9PiBzZXRDdXJyZW50SW5zdGFuY2UoY3R4KV07XG59XG5leHBvcnRzLndpdGhBc3luY0NvbnRleHQgPSB3aXRoQXN5bmNDb250ZXh0O1xuLy8gQWN0dWFsIGltcGxlbWVudGF0aW9uXG5mdW5jdGlvbiBoKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pIHtcbiAgICBjb25zdCBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gMikge1xuICAgICAgICBpZiAoKDAsIHNoYXJlZF8xLmlzT2JqZWN0KShwcm9wc09yQ2hpbGRyZW4pICYmICEoMCwgc2hhcmVkXzEuaXNBcnJheSkocHJvcHNPckNoaWxkcmVuKSkge1xuICAgICAgICAgICAgLy8gc2luZ2xlIHZub2RlIHdpdGhvdXQgcHJvcHNcbiAgICAgICAgICAgIGlmIChpc1ZOb2RlKHByb3BzT3JDaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbnVsbCwgW3Byb3BzT3JDaGlsZHJlbl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJvcHMgd2l0aG91dCBjaGlsZHJlblxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzT3JDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBvbWl0IHByb3BzXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbnVsbCwgcHJvcHNPckNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGwgPiAzKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobCA9PT0gMyAmJiBpc1ZOb2RlKGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBbY2hpbGRyZW5dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKTtcbiAgICB9XG59XG5leHBvcnRzLmggPSBoO1xuY29uc3Qgc3NyQ29udGV4dEtleSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgc3NyQ29udGV4dGAgOiBgYCk7XG5leHBvcnRzLnNzckNvbnRleHRLZXkgPSBzc3JDb250ZXh0S2V5O1xuY29uc3QgdXNlU1NSQ29udGV4dCA9ICgpID0+IHtcbiAgICB7XG4gICAgICAgIGNvbnN0IGN0eCA9IGluamVjdChzc3JDb250ZXh0S2V5KTtcbiAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgIHdhcm4oYFNlcnZlciByZW5kZXJpbmcgY29udGV4dCBub3QgcHJvdmlkZWQuIE1ha2Ugc3VyZSB0byBvbmx5IGNhbGwgYCArXG4gICAgICAgICAgICAgICAgICAgIGB1c2VTU1JDb250ZXh0KCkgY29uZGl0aW9uYWxseSBpbiB0aGUgc2VydmVyIGJ1aWxkLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdHg7XG4gICAgfVxufTtcbmV4cG9ydHMudXNlU1NSQ29udGV4dCA9IHVzZVNTUkNvbnRleHQ7XG5mdW5jdGlvbiBpc1NoYWxsb3codmFsdWUpIHtcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNTaGFsbG93XCIgLyogUmVhY3RpdmVGbGFncy5JU19TSEFMTE9XICovXSk7XG59XG5mdW5jdGlvbiBpbml0Q3VzdG9tRm9ybWF0dGVyKCkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xuICAgIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdnVlU3R5bGUgPSB7IHN0eWxlOiAnY29sb3I6IzNiYTc3NicgfTtcbiAgICBjb25zdCBudW1iZXJTdHlsZSA9IHsgc3R5bGU6ICdjb2xvcjojMGIxYmM5JyB9O1xuICAgIGNvbnN0IHN0cmluZ1N0eWxlID0geyBzdHlsZTogJ2NvbG9yOiNiNjJlMjQnIH07XG4gICAgY29uc3Qga2V5d29yZFN0eWxlID0geyBzdHlsZTogJ2NvbG9yOiM5ZDI4OGMnIH07XG4gICAgLy8gY3VzdG9tIGZvcm1hdHRlciBmb3IgQ2hyb21lXG4gICAgLy8gaHR0cHM6Ly93d3cubWF0dHpldW5lcnQuY29tLzIwMTYvMDIvMTkvY3VzdG9tLWNocm9tZS1kZXZ0b29scy1vYmplY3QtZm9ybWF0dGVycy5odG1sXG4gICAgY29uc3QgZm9ybWF0dGVyID0ge1xuICAgICAgICBoZWFkZXIob2JqKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGFsc28gZm9ybWF0IENvbXBvbmVudFB1YmxpY0luc3RhbmNlICYgY3R4LnNsb3RzL2F0dHJzIGluIHNldHVwXG4gICAgICAgICAgICBpZiAoISgwLCBzaGFyZWRfMS5pc09iamVjdCkob2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai5fX2lzVnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnZGl2JywgdnVlU3R5bGUsIGBWdWVJbnN0YW5jZWBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKDAsIHJlYWN0aXZpdHlfMS5pc1JlZikob2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAgWydzcGFuJywgdnVlU3R5bGUsIGdlblJlZkZsYWcob2JqKV0sXG4gICAgICAgICAgICAgICAgICAgICc8JyxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0VmFsdWUob2JqLnZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgYD5gXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCgwLCByZWFjdGl2aXR5XzEuaXNSZWFjdGl2ZSkob2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAgWydzcGFuJywgdnVlU3R5bGUsIGlzU2hhbGxvdyhvYmopID8gJ1NoYWxsb3dSZWFjdGl2ZScgOiAnUmVhY3RpdmUnXSxcbiAgICAgICAgICAgICAgICAgICAgJzwnLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxuICAgICAgICAgICAgICAgICAgICBgPiR7KDAsIHJlYWN0aXZpdHlfMS5pc1JlYWRvbmx5KShvYmopID8gYCAocmVhZG9ubHkpYCA6IGBgfWBcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKDAsIHJlYWN0aXZpdHlfMS5pc1JlYWRvbmx5KShvYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICBbJ3NwYW4nLCB2dWVTdHlsZSwgaXNTaGFsbG93KG9iaikgPyAnU2hhbGxvd1JlYWRvbmx5JyA6ICdSZWFkb25seSddLFxuICAgICAgICAgICAgICAgICAgICAnPCcsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFZhbHVlKG9iaiksXG4gICAgICAgICAgICAgICAgICAgICc+J1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzQm9keShvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgb2JqLl9faXNWdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGJvZHkob2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqICYmIG9iai5fX2lzVnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICAuLi5mb3JtYXRJbnN0YW5jZShvYmouJClcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBmb3JtYXRJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgICAgICBjb25zdCBibG9ja3MgPSBbXTtcbiAgICAgICAgaWYgKGluc3RhbmNlLnR5cGUucHJvcHMgJiYgaW5zdGFuY2UucHJvcHMpIHtcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ3Byb3BzJywgKDAsIHJlYWN0aXZpdHlfMS50b1JhdykoaW5zdGFuY2UucHJvcHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3RhbmNlLnNldHVwU3RhdGUgIT09IHNoYXJlZF8xLkVNUFRZX09CSikge1xuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnc2V0dXAnLCBpbnN0YW5jZS5zZXR1cFN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3RhbmNlLmRhdGEgIT09IHNoYXJlZF8xLkVNUFRZX09CSikge1xuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnZGF0YScsICgwLCByZWFjdGl2aXR5XzEudG9SYXcpKGluc3RhbmNlLmRhdGEpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgJ2NvbXB1dGVkJyk7XG4gICAgICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnY29tcHV0ZWQnLCBjb21wdXRlZCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluamVjdGVkID0gZXh0cmFjdEtleXMoaW5zdGFuY2UsICdpbmplY3QnKTtcbiAgICAgICAgaWYgKGluamVjdGVkKSB7XG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdpbmplY3RlZCcsIGluamVjdGVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2tzLnB1c2goW1xuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToga2V5d29yZFN0eWxlLnN0eWxlICsgJztvcGFjaXR5OjAuNjYnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnJCAoaW50ZXJuYWwpOiAnXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgWydvYmplY3QnLCB7IG9iamVjdDogaW5zdGFuY2UgfV1cbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiBibG9ja3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlQmxvY2sodHlwZSwgdGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldCA9ICgwLCBzaGFyZWRfMS5leHRlbmQpKHt9LCB0YXJnZXQpO1xuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHRhcmdldCkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywge31dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgIHsgc3R5bGU6ICdsaW5lLWhlaWdodDoxLjI1ZW07bWFyZ2luLWJvdHRvbTowLjZlbScgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnY29sb3I6IzQ3NjU4MidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3BhZGRpbmctbGVmdDoxLjI1ZW0nXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAuLi5PYmplY3Qua2V5cyh0YXJnZXQpLm1hcChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFsnc3BhbicsIGtleXdvcmRTdHlsZSwga2V5ICsgJzogJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZSh0YXJnZXRba2V5XSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodiwgYXNSYXcgPSB0cnVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCBudW1iZXJTdHlsZSwgdl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywgc3RyaW5nU3R5bGUsIEpTT04uc3RyaW5naWZ5KHYpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywga2V5d29yZFN0eWxlLCB2XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwgc2hhcmVkXzEuaXNPYmplY3QpKHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gWydvYmplY3QnLCB7IG9iamVjdDogYXNSYXcgPyAoMCwgcmVhY3Rpdml0eV8xLnRvUmF3KSh2KSA6IHYgfV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywgc3RyaW5nU3R5bGUsIFN0cmluZyh2KV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZXh0cmFjdEtleXMoaW5zdGFuY2UsIHR5cGUpIHtcbiAgICAgICAgY29uc3QgQ29tcCA9IGluc3RhbmNlLnR5cGU7XG4gICAgICAgIGlmICgoMCwgc2hhcmVkXzEuaXNGdW5jdGlvbikoQ29tcCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHRyYWN0ZWQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UuY3R4KSB7XG4gICAgICAgICAgICBpZiAoaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSkge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RlZFtrZXldID0gaW5zdGFuY2UuY3R4W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4dHJhY3RlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBDb21wW3R5cGVdO1xuICAgICAgICBpZiAoKCgwLCBzaGFyZWRfMS5pc0FycmF5KShvcHRzKSAmJiBvcHRzLmluY2x1ZGVzKGtleSkpIHx8XG4gICAgICAgICAgICAoKDAsIHNoYXJlZF8xLmlzT2JqZWN0KShvcHRzKSAmJiBrZXkgaW4gb3B0cykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChDb21wLmV4dGVuZHMgJiYgaXNLZXlPZlR5cGUoQ29tcC5leHRlbmRzLCBrZXksIHR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQ29tcC5taXhpbnMgJiYgQ29tcC5taXhpbnMuc29tZShtID0+IGlzS2V5T2ZUeXBlKG0sIGtleSwgdHlwZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZW5SZWZGbGFnKHYpIHtcbiAgICAgICAgaWYgKGlzU2hhbGxvdyh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIGBTaGFsbG93UmVmYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodi5lZmZlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBgQ29tcHV0ZWRSZWZgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgUmVmYDtcbiAgICB9XG4gICAgaWYgKHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMpIHtcbiAgICAgICAgd2luZG93LmRldnRvb2xzRm9ybWF0dGVycy5wdXNoKGZvcm1hdHRlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzID0gW2Zvcm1hdHRlcl07XG4gICAgfVxufVxuZXhwb3J0cy5pbml0Q3VzdG9tRm9ybWF0dGVyID0gaW5pdEN1c3RvbUZvcm1hdHRlcjtcbmZ1bmN0aW9uIHdpdGhNZW1vKG1lbW8sIHJlbmRlciwgY2FjaGUsIGluZGV4KSB7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbaW5kZXhdO1xuICAgIGlmIChjYWNoZWQgJiYgaXNNZW1vU2FtZShjYWNoZWQsIG1lbW8pKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHJlbmRlcigpO1xuICAgIC8vIHNoYWxsb3cgY2xvbmVcbiAgICByZXQubWVtbyA9IG1lbW8uc2xpY2UoKTtcbiAgICByZXR1cm4gKGNhY2hlW2luZGV4XSA9IHJldCk7XG59XG5leHBvcnRzLndpdGhNZW1vID0gd2l0aE1lbW87XG5mdW5jdGlvbiBpc01lbW9TYW1lKGNhY2hlZCwgbWVtbykge1xuICAgIGNvbnN0IHByZXYgPSBjYWNoZWQubWVtbztcbiAgICBpZiAocHJldi5sZW5ndGggIT0gbWVtby5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCgwLCBzaGFyZWRfMS5oYXNDaGFuZ2VkKShwcmV2W2ldLCBtZW1vW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB0byBsZXQgcGFyZW50IGJsb2NrIHRyYWNrIGl0IHdoZW4gcmV0dXJuaW5nIGNhY2hlZFxuICAgIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmIGN1cnJlbnRCbG9jaykge1xuICAgICAgICBjdXJyZW50QmxvY2sucHVzaChjYWNoZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuaXNNZW1vU2FtZSA9IGlzTWVtb1NhbWU7XG4vLyBDb3JlIEFQSSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNvbnN0IHZlcnNpb24gPSBcIjMuMi40N1wiO1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmNvbnN0IF9zc3JVdGlscyA9IHtcbiAgICBjcmVhdGVDb21wb25lbnRJbnN0YW5jZSxcbiAgICBzZXR1cENvbXBvbmVudCxcbiAgICByZW5kZXJDb21wb25lbnRSb290LFxuICAgIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSxcbiAgICBpc1ZOb2RlLFxuICAgIG5vcm1hbGl6ZVZOb2RlXG59O1xuLyoqXG4gKiBTU1IgdXRpbHMgZm9yIFxcQHZ1ZS9zZXJ2ZXItcmVuZGVyZXIuIE9ubHkgZXhwb3NlZCBpbiBzc3ItcG9zc2libGUgYnVpbGRzLlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IHNzclV0aWxzID0gKF9zc3JVdGlscyk7XG5leHBvcnRzLnNzclV0aWxzID0gc3NyVXRpbHM7XG4vKipcbiAqIEBpbnRlcm5hbCBvbmx5IGV4cG9zZWQgaW4gY29tcGF0IGJ1aWxkc1xuICovXG5jb25zdCByZXNvbHZlRmlsdGVyID0gbnVsbDtcbmV4cG9ydHMucmVzb2x2ZUZpbHRlciA9IHJlc29sdmVGaWx0ZXI7XG4vKipcbiAqIEBpbnRlcm5hbCBvbmx5IGV4cG9zZWQgaW4gY29tcGF0IGJ1aWxkcy5cbiAqL1xuY29uc3QgY29tcGF0VXRpbHMgPSAobnVsbCk7XG5leHBvcnRzLmNvbXBhdFV0aWxzID0gY29tcGF0VXRpbHM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js\n");

/***/ }),

/***/ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.withModifiers = exports.withKeys = exports.vShow = exports.vModelText = exports.vModelSelect = exports.vModelRadio = exports.vModelDynamic = exports.vModelCheckbox = exports.useCssVars = exports.useCssModule = exports.render = exports.initDirectivesForSSR = exports.hydrate = exports.defineSSRCustomElement = exports.defineCustomElement = exports.createSSRApp = exports.createApp = exports.VueElement = exports.TransitionGroup = exports.Transition = void 0;\nconst runtime_core_1 = __webpack_require__(/*! @vue/runtime-core */ \"./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js\");\n__exportStar(__webpack_require__(/*! @vue/runtime-core */ \"./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js\"), exports);\nconst shared_1 = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/shared/dist/shared.esm-bundler.js\");\nconst svgNS = 'http://www.w3.org/2000/svg';\nconst doc = typeof document !== 'undefined' ? document : null;\nconst templateContainer = doc && /*#__PURE__*/doc.createElement('template');\nconst nodeOps = {\n  insert: (child, parent, anchor) => {\n    parent.insertBefore(child, anchor || null);\n  },\n  remove: child => {\n    const parent = child.parentNode;\n    if (parent) {\n      parent.removeChild(child);\n    }\n  },\n  createElement: (tag, isSVG, is, props) => {\n    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? {\n      is\n    } : undefined);\n    if (tag === 'select' && props && props.multiple != null) {\n      el.setAttribute('multiple', props.multiple);\n    }\n    return el;\n  },\n  createText: text => doc.createTextNode(text),\n  createComment: text => doc.createComment(text),\n  setText: (node, text) => {\n    node.nodeValue = text;\n  },\n  setElementText: (el, text) => {\n    el.textContent = text;\n  },\n  parentNode: node => node.parentNode,\n  nextSibling: node => node.nextSibling,\n  querySelector: selector => doc.querySelector(selector),\n  setScopeId(el, id) {\n    el.setAttribute(id, '');\n  },\n  // __UNSAFE__\n  // Reason: innerHTML.\n  // Static content here can only come from compiled templates.\n  // As long as the user only uses trusted templates, this is safe.\n  insertStaticContent(content, parent, anchor, isSVG, start, end) {\n    // <parent> before | first ... last | anchor </parent>\n    const before = anchor ? anchor.previousSibling : parent.lastChild;\n    // #5308 can only take cached path if:\n    // - has a single root node\n    // - nextSibling info is still available\n    if (start && (start === end || start.nextSibling)) {\n      // cached\n      while (true) {\n        parent.insertBefore(start.cloneNode(true), anchor);\n        if (start === end || !(start = start.nextSibling)) break;\n      }\n    } else {\n      // fresh insert\n      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;\n      const template = templateContainer.content;\n      if (isSVG) {\n        // remove outer svg wrapper\n        const wrapper = template.firstChild;\n        while (wrapper.firstChild) {\n          template.appendChild(wrapper.firstChild);\n        }\n        template.removeChild(wrapper);\n      }\n      parent.insertBefore(template, anchor);\n    }\n    return [\n    // first\n    before ? before.nextSibling : parent.firstChild,\n    // last\n    anchor ? anchor.previousSibling : parent.lastChild];\n  }\n};\n// compiler should normalize class + :class bindings on the same element\n// into a single binding ['staticClass', dynamic]\nfunction patchClass(el, value, isSVG) {\n  // directly setting className should be faster than setAttribute in theory\n  // if this is an element during a transition, take the temporary transition\n  // classes into account.\n  const transitionClasses = el._vtc;\n  if (transitionClasses) {\n    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(' ');\n  }\n  if (value == null) {\n    el.removeAttribute('class');\n  } else if (isSVG) {\n    el.setAttribute('class', value);\n  } else {\n    el.className = value;\n  }\n}\nfunction patchStyle(el, prev, next) {\n  const style = el.style;\n  const isCssString = (0, shared_1.isString)(next);\n  if (next && !isCssString) {\n    if (prev && !(0, shared_1.isString)(prev)) {\n      for (const key in prev) {\n        if (next[key] == null) {\n          setStyle(style, key, '');\n        }\n      }\n    }\n    for (const key in next) {\n      setStyle(style, key, next[key]);\n    }\n  } else {\n    const currentDisplay = style.display;\n    if (isCssString) {\n      if (prev !== next) {\n        style.cssText = next;\n      }\n    } else if (prev) {\n      el.removeAttribute('style');\n    }\n    // indicates that the `display` of the element is controlled by `v-show`,\n    // so we always keep the current `display` value regardless of the `style`\n    // value, thus handing over control to `v-show`.\n    if ('_vod' in el) {\n      style.display = currentDisplay;\n    }\n  }\n}\nconst semicolonRE = /[^\\\\];\\s*$/;\nconst importantRE = /\\s*!important$/;\nfunction setStyle(style, name, val) {\n  if ((0, shared_1.isArray)(val)) {\n    val.forEach(v => setStyle(style, name, v));\n  } else {\n    if (val == null) val = '';\n    if (true) {\n      if (semicolonRE.test(val)) {\n        (0, runtime_core_1.warn)(`Unexpected semicolon at the end of '${name}' style value: '${val}'`);\n      }\n    }\n    if (name.startsWith('--')) {\n      // custom property definition\n      style.setProperty(name, val);\n    } else {\n      const prefixed = autoPrefix(style, name);\n      if (importantRE.test(val)) {\n        // !important\n        style.setProperty((0, shared_1.hyphenate)(prefixed), val.replace(importantRE, ''), 'important');\n      } else {\n        style[prefixed] = val;\n      }\n    }\n  }\n}\nconst prefixes = ['Webkit', 'Moz', 'ms'];\nconst prefixCache = {};\nfunction autoPrefix(style, rawName) {\n  const cached = prefixCache[rawName];\n  if (cached) {\n    return cached;\n  }\n  let name = (0, runtime_core_1.camelize)(rawName);\n  if (name !== 'filter' && name in style) {\n    return prefixCache[rawName] = name;\n  }\n  name = (0, shared_1.capitalize)(name);\n  for (let i = 0; i < prefixes.length; i++) {\n    const prefixed = prefixes[i] + name;\n    if (prefixed in style) {\n      return prefixCache[rawName] = prefixed;\n    }\n  }\n  return rawName;\n}\nconst xlinkNS = 'http://www.w3.org/1999/xlink';\nfunction patchAttr(el, key, value, isSVG, instance) {\n  if (isSVG && key.startsWith('xlink:')) {\n    if (value == null) {\n      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    // note we are only checking boolean attributes that don't have a\n    // corresponding dom prop of the same name here.\n    const isBoolean = (0, shared_1.isSpecialBooleanAttr)(key);\n    if (value == null || isBoolean && !(0, shared_1.includeBooleanAttr)(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, isBoolean ? '' : value);\n    }\n  }\n}\n// __UNSAFE__\n// functions. The user is responsible for using them with only trusted content.\nfunction patchDOMProp(el, key, value,\n// the following args are passed only due to potential innerHTML/textContent\n// overriding existing VNodes, in which case the old tree must be properly\n// unmounted.\nprevChildren, parentComponent, parentSuspense, unmountChildren) {\n  if (key === 'innerHTML' || key === 'textContent') {\n    if (prevChildren) {\n      unmountChildren(prevChildren, parentComponent, parentSuspense);\n    }\n    el[key] = value == null ? '' : value;\n    return;\n  }\n  if (key === 'value' && el.tagName !== 'PROGRESS' &&\n  // custom elements may use _value internally\n  !el.tagName.includes('-')) {\n    // store value as _value as well since\n    // non-string values will be stringified.\n    el._value = value;\n    const newValue = value == null ? '' : value;\n    if (el.value !== newValue ||\n    // #4956: always set for OPTION elements because its value falls back to\n    // textContent if no value attribute is present. And setting .value for\n    // OPTION has no side effect\n    el.tagName === 'OPTION') {\n      el.value = newValue;\n    }\n    if (value == null) {\n      el.removeAttribute(key);\n    }\n    return;\n  }\n  let needRemove = false;\n  if (value === '' || value == null) {\n    const type = typeof el[key];\n    if (type === 'boolean') {\n      // e.g. <select multiple> compiles to { multiple: '' }\n      value = (0, shared_1.includeBooleanAttr)(value);\n    } else if (value == null && type === 'string') {\n      // e.g. <div :id=\"null\">\n      value = '';\n      needRemove = true;\n    } else if (type === 'number') {\n      // e.g. <img :width=\"null\">\n      value = 0;\n      needRemove = true;\n    }\n  }\n  // some properties perform value validation and throw,\n  // some properties has getter, no setter, will error in 'use strict'\n  // eg. <select :type=\"null\"></select> <select :willValidate=\"null\"></select>\n  try {\n    el[key] = value;\n  } catch (e) {\n    // do not warn if value is auto-coerced from nullish values\n    if ( true && !needRemove) {\n      (0, runtime_core_1.warn)(`Failed setting prop \"${key}\" on <${el.tagName.toLowerCase()}>: ` + `value ${value} is invalid.`, e);\n    }\n  }\n  needRemove && el.removeAttribute(key);\n}\nfunction addEventListener(el, event, handler, options) {\n  el.addEventListener(event, handler, options);\n}\nfunction removeEventListener(el, event, handler, options) {\n  el.removeEventListener(event, handler, options);\n}\nfunction patchEvent(el, rawName, prevValue, nextValue) {\n  let instance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  // vei = vue event invokers\n  const invokers = el._vei || (el._vei = {});\n  const existingInvoker = invokers[rawName];\n  if (nextValue && existingInvoker) {\n    // patch\n    existingInvoker.value = nextValue;\n  } else {\n    const [name, options] = parseName(rawName);\n    if (nextValue) {\n      // add\n      const invoker = invokers[rawName] = createInvoker(nextValue, instance);\n      addEventListener(el, name, invoker, options);\n    } else if (existingInvoker) {\n      // remove\n      removeEventListener(el, name, existingInvoker, options);\n      invokers[rawName] = undefined;\n    }\n  }\n}\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/;\nfunction parseName(name) {\n  let options;\n  if (optionsModifierRE.test(name)) {\n    options = {};\n    let m;\n    while (m = name.match(optionsModifierRE)) {\n      name = name.slice(0, name.length - m[0].length);\n      options[m[0].toLowerCase()] = true;\n    }\n  }\n  const event = name[2] === ':' ? name.slice(3) : (0, shared_1.hyphenate)(name.slice(2));\n  return [event, options];\n}\n// To avoid the overhead of repeatedly calling Date.now(), we cache\n// and use the same timestamp for all event listeners attached in the same tick.\nlet cachedNow = 0;\nconst p = /*#__PURE__*/Promise.resolve();\nconst getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());\nfunction createInvoker(initialValue, instance) {\n  const invoker = e => {\n    // async edge case vuejs/vue#6566\n    // inner click event triggers patch, event handler\n    // attached to outer element during patch, and triggered again. This\n    // happens because browsers fire microtask ticks between event propagation.\n    // this no longer happens for templates in Vue 3, but could still be\n    // theoretically possible for hand-written render functions.\n    // the solution: we save the timestamp when a handler is attached,\n    // and also attach the timestamp to any event that was handled by vue\n    // for the first time (to avoid inconsistent event timestamp implementations\n    // or events fired from iframes, e.g. #2513)\n    // The handler would only fire if the event passed to it was fired\n    // AFTER it was attached.\n    if (!e._vts) {\n      e._vts = Date.now();\n    } else if (e._vts <= invoker.attached) {\n      return;\n    }\n    (0, runtime_core_1.callWithAsyncErrorHandling)(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* ErrorCodes.NATIVE_EVENT_HANDLER */, [e]);\n  };\n  invoker.value = initialValue;\n  invoker.attached = getNow();\n  return invoker;\n}\nfunction patchStopImmediatePropagation(e, value) {\n  if ((0, shared_1.isArray)(value)) {\n    const originalStop = e.stopImmediatePropagation;\n    e.stopImmediatePropagation = () => {\n      originalStop.call(e);\n      e._stopped = true;\n    };\n    return value.map(fn => e => !e._stopped && fn && fn(e));\n  } else {\n    return value;\n  }\n}\nconst nativeOnRE = /^on[a-z]/;\nconst patchProp = function (el, key, prevValue, nextValue) {\n  let isSVG = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let prevChildren = arguments.length > 5 ? arguments[5] : undefined;\n  let parentComponent = arguments.length > 6 ? arguments[6] : undefined;\n  let parentSuspense = arguments.length > 7 ? arguments[7] : undefined;\n  let unmountChildren = arguments.length > 8 ? arguments[8] : undefined;\n  if (key === 'class') {\n    patchClass(el, nextValue, isSVG);\n  } else if (key === 'style') {\n    patchStyle(el, prevValue, nextValue);\n  } else if ((0, shared_1.isOn)(key)) {\n    // ignore v-model listeners\n    if (!(0, shared_1.isModelListener)(key)) {\n      patchEvent(el, key, prevValue, nextValue, parentComponent);\n    }\n  } else if (key[0] === '.' ? (key = key.slice(1), true) : key[0] === '^' ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {\n    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);\n  } else {\n    // special case for <input v-model type=\"checkbox\"> with\n    // :true-value & :false-value\n    // store value as dom properties since non-string values will be\n    // stringified.\n    if (key === 'true-value') {\n      el._trueValue = nextValue;\n    } else if (key === 'false-value') {\n      el._falseValue = nextValue;\n    }\n    patchAttr(el, key, nextValue, isSVG);\n  }\n};\nfunction shouldSetAsProp(el, key, value, isSVG) {\n  if (isSVG) {\n    // most keys must be set as attribute on svg elements to work\n    // ...except innerHTML & textContent\n    if (key === 'innerHTML' || key === 'textContent') {\n      return true;\n    }\n    // or native onclick with function values\n    if (key in el && nativeOnRE.test(key) && (0, shared_1.isFunction)(value)) {\n      return true;\n    }\n    return false;\n  }\n  // these are enumerated attrs, however their corresponding DOM properties\n  // are actually booleans - this leads to setting it with a string \"false\"\n  // value leading it to be coerced to `true`, so we need to always treat\n  // them as attributes.\n  // Note that `contentEditable` doesn't have this problem: its DOM\n  // property is also enumerated string values.\n  if (key === 'spellcheck' || key === 'draggable' || key === 'translate') {\n    return false;\n  }\n  // #1787, #2840 form property on form elements is readonly and must be set as\n  // attribute.\n  if (key === 'form') {\n    return false;\n  }\n  // #1526 <input list> must be set as attribute\n  if (key === 'list' && el.tagName === 'INPUT') {\n    return false;\n  }\n  // #2766 <textarea type> must be set as attribute\n  if (key === 'type' && el.tagName === 'TEXTAREA') {\n    return false;\n  }\n  // native onclick with string value, must be set as attribute\n  if (nativeOnRE.test(key) && (0, shared_1.isString)(value)) {\n    return false;\n  }\n  return key in el;\n}\nfunction defineCustomElement(options, hydrate) {\n  const Comp = (0, runtime_core_1.defineComponent)(options);\n  class VueCustomElement extends VueElement {\n    constructor(initialProps) {\n      super(Comp, initialProps, hydrate);\n    }\n  }\n  VueCustomElement.def = Comp;\n  return VueCustomElement;\n}\nexports.defineCustomElement = defineCustomElement;\nconst defineSSRCustomElement = options => {\n  // @ts-ignore\n  return defineCustomElement(options, hydrate);\n};\nexports.defineSSRCustomElement = defineSSRCustomElement;\nconst BaseClass = typeof HTMLElement !== 'undefined' ? HTMLElement : class {};\nclass VueElement extends BaseClass {\n  constructor(_def) {\n    let _props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let hydrate = arguments.length > 2 ? arguments[2] : undefined;\n    super();\n    this._def = _def;\n    this._props = _props;\n    /**\n     * @internal\n     */\n    this._instance = null;\n    this._connected = false;\n    this._resolved = false;\n    this._numberProps = null;\n    if (this.shadowRoot && hydrate) {\n      hydrate(this._createVNode(), this.shadowRoot);\n    } else {\n      if ( true && this.shadowRoot) {\n        (0, runtime_core_1.warn)(`Custom element has pre-rendered declarative shadow root but is not ` + `defined as hydratable. Use \\`defineSSRCustomElement\\`.`);\n      }\n      this.attachShadow({\n        mode: 'open'\n      });\n      if (!this._def.__asyncLoader) {\n        // for sync component defs we can immediately resolve props\n        this._resolveProps(this._def);\n      }\n    }\n  }\n  connectedCallback() {\n    this._connected = true;\n    if (!this._instance) {\n      if (this._resolved) {\n        this._update();\n      } else {\n        this._resolveDef();\n      }\n    }\n  }\n  disconnectedCallback() {\n    this._connected = false;\n    (0, runtime_core_1.nextTick)(() => {\n      if (!this._connected) {\n        render(null, this.shadowRoot);\n        this._instance = null;\n      }\n    });\n  }\n  /**\n   * resolve inner component definition (handle possible async component)\n   */\n  _resolveDef() {\n    var _this = this;\n    this._resolved = true;\n    // set initial attrs\n    for (let i = 0; i < this.attributes.length; i++) {\n      this._setAttr(this.attributes[i].name);\n    }\n    // watch future attr changes\n    new MutationObserver(mutations => {\n      for (const m of mutations) {\n        this._setAttr(m.attributeName);\n      }\n    }).observe(this, {\n      attributes: true\n    });\n    const resolve = function (def) {\n      let isAsync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      const {\n        props,\n        styles\n      } = def;\n      // cast Number-type props set before resolve\n      let numberProps;\n      if (props && !(0, shared_1.isArray)(props)) {\n        for (const key in props) {\n          const opt = props[key];\n          if (opt === Number || opt && opt.type === Number) {\n            if (key in _this._props) {\n              _this._props[key] = (0, shared_1.toNumber)(_this._props[key]);\n            }\n            (numberProps || (numberProps = Object.create(null)))[(0, shared_1.camelize)(key)] = true;\n          }\n        }\n      }\n      _this._numberProps = numberProps;\n      if (isAsync) {\n        // defining getter/setters on prototype\n        // for sync defs, this already happened in the constructor\n        _this._resolveProps(def);\n      }\n      // apply CSS\n      _this._applyStyles(styles);\n      // initial render\n      _this._update();\n    };\n    const asyncDef = this._def.__asyncLoader;\n    if (asyncDef) {\n      asyncDef().then(def => resolve(def, true));\n    } else {\n      resolve(this._def);\n    }\n  }\n  _resolveProps(def) {\n    const {\n      props\n    } = def;\n    const declaredPropKeys = (0, shared_1.isArray)(props) ? props : Object.keys(props || {});\n    // check if there are props set pre-upgrade or connect\n    for (const key of Object.keys(this)) {\n      if (key[0] !== '_' && declaredPropKeys.includes(key)) {\n        this._setProp(key, this[key], true, false);\n      }\n    }\n    // defining getter/setters on prototype\n    for (const key of declaredPropKeys.map(shared_1.camelize)) {\n      Object.defineProperty(this, key, {\n        get() {\n          return this._getProp(key);\n        },\n        set(val) {\n          this._setProp(key, val);\n        }\n      });\n    }\n  }\n  _setAttr(key) {\n    let value = this.getAttribute(key);\n    const camelKey = (0, shared_1.camelize)(key);\n    if (this._numberProps && this._numberProps[camelKey]) {\n      value = (0, shared_1.toNumber)(value);\n    }\n    this._setProp(camelKey, value, false);\n  }\n  /**\n   * @internal\n   */\n  _getProp(key) {\n    return this._props[key];\n  }\n  /**\n   * @internal\n   */\n  _setProp(key, val) {\n    let shouldReflect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let shouldUpdate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    if (val !== this._props[key]) {\n      this._props[key] = val;\n      if (shouldUpdate && this._instance) {\n        this._update();\n      }\n      // reflect\n      if (shouldReflect) {\n        if (val === true) {\n          this.setAttribute((0, shared_1.hyphenate)(key), '');\n        } else if (typeof val === 'string' || typeof val === 'number') {\n          this.setAttribute((0, shared_1.hyphenate)(key), val + '');\n        } else if (!val) {\n          this.removeAttribute((0, shared_1.hyphenate)(key));\n        }\n      }\n    }\n  }\n  _update() {\n    render(this._createVNode(), this.shadowRoot);\n  }\n  _createVNode() {\n    const vnode = (0, runtime_core_1.createVNode)(this._def, (0, shared_1.extend)({}, this._props));\n    if (!this._instance) {\n      vnode.ce = instance => {\n        this._instance = instance;\n        instance.isCE = true;\n        // HMR\n        if (true) {\n          instance.ceReload = newStyles => {\n            // always reset styles\n            if (this._styles) {\n              this._styles.forEach(s => this.shadowRoot.removeChild(s));\n              this._styles.length = 0;\n            }\n            this._applyStyles(newStyles);\n            this._instance = null;\n            this._update();\n          };\n        }\n        const dispatch = (event, args) => {\n          this.dispatchEvent(new CustomEvent(event, {\n            detail: args\n          }));\n        };\n        // intercept emit\n        instance.emit = function (event) {\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n          // dispatch both the raw and hyphenated versions of an event\n          // to match Vue behavior\n          dispatch(event, args);\n          if ((0, shared_1.hyphenate)(event) !== event) {\n            dispatch((0, shared_1.hyphenate)(event), args);\n          }\n        };\n        // locate nearest Vue custom element parent for provide/inject\n        let parent = this;\n        while (parent = parent && (parent.parentNode || parent.host)) {\n          if (parent instanceof VueElement) {\n            instance.parent = parent._instance;\n            instance.provides = parent._instance.provides;\n            break;\n          }\n        }\n      };\n    }\n    return vnode;\n  }\n  _applyStyles(styles) {\n    if (styles) {\n      styles.forEach(css => {\n        const s = document.createElement('style');\n        s.textContent = css;\n        this.shadowRoot.appendChild(s);\n        // record for HMR\n        if (true) {\n          (this._styles || (this._styles = [])).push(s);\n        }\n      });\n    }\n  }\n}\nexports.VueElement = VueElement;\nfunction useCssModule() {\n  let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '$style';\n  /* istanbul ignore else */\n  {\n    const instance = (0, runtime_core_1.getCurrentInstance)();\n    if (!instance) {\n       true && (0, runtime_core_1.warn)(`useCssModule must be called inside setup()`);\n      return shared_1.EMPTY_OBJ;\n    }\n    const modules = instance.type.__cssModules;\n    if (!modules) {\n       true && (0, runtime_core_1.warn)(`Current instance does not have CSS modules injected.`);\n      return shared_1.EMPTY_OBJ;\n    }\n    const mod = modules[name];\n    if (!mod) {\n       true && (0, runtime_core_1.warn)(`Current instance does not have CSS module named \"${name}\".`);\n      return shared_1.EMPTY_OBJ;\n    }\n    return mod;\n  }\n}\nexports.useCssModule = useCssModule;\n/**\n * Runtime helper for SFC's CSS variable injection feature.\n * @private\n */\nfunction useCssVars(getter) {\n  const instance = (0, runtime_core_1.getCurrentInstance)();\n  /* istanbul ignore next */\n  if (!instance) {\n     true && (0, runtime_core_1.warn)(`useCssVars is called without current active component instance.`);\n    return;\n  }\n  const updateTeleports = instance.ut = function () {\n    let vars = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getter(instance.proxy);\n    Array.from(document.querySelectorAll(`[data-v-owner=\"${instance.uid}\"]`)).forEach(node => setVarsOnNode(node, vars));\n  };\n  const setVars = () => {\n    const vars = getter(instance.proxy);\n    setVarsOnVNode(instance.subTree, vars);\n    updateTeleports(vars);\n  };\n  (0, runtime_core_1.watchPostEffect)(setVars);\n  (0, runtime_core_1.onMounted)(() => {\n    const ob = new MutationObserver(setVars);\n    ob.observe(instance.subTree.el.parentNode, {\n      childList: true\n    });\n    (0, runtime_core_1.onUnmounted)(() => ob.disconnect());\n  });\n}\nexports.useCssVars = useCssVars;\nfunction setVarsOnVNode(vnode, vars) {\n  if (vnode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n    const suspense = vnode.suspense;\n    vnode = suspense.activeBranch;\n    if (suspense.pendingBranch && !suspense.isHydrating) {\n      suspense.effects.push(() => {\n        setVarsOnVNode(suspense.activeBranch, vars);\n      });\n    }\n  }\n  // drill down HOCs until it's a non-component vnode\n  while (vnode.component) {\n    vnode = vnode.component.subTree;\n  }\n  if (vnode.shapeFlag & 1 /* ShapeFlags.ELEMENT */ && vnode.el) {\n    setVarsOnNode(vnode.el, vars);\n  } else if (vnode.type === runtime_core_1.Fragment) {\n    vnode.children.forEach(c => setVarsOnVNode(c, vars));\n  } else if (vnode.type === runtime_core_1.Static) {\n    let {\n      el,\n      anchor\n    } = vnode;\n    while (el) {\n      setVarsOnNode(el, vars);\n      if (el === anchor) break;\n      el = el.nextSibling;\n    }\n  }\n}\nfunction setVarsOnNode(el, vars) {\n  if (el.nodeType === 1) {\n    const style = el.style;\n    for (const key in vars) {\n      style.setProperty(`--${key}`, vars[key]);\n    }\n  }\n}\nconst TRANSITION = 'transition';\nconst ANIMATION = 'animation';\n// DOM Transition is a higher-order-component based on the platform-agnostic\n// base Transition component, with DOM-specific logic.\nconst Transition = (props, _ref) => {\n  let {\n    slots\n  } = _ref;\n  return (0, runtime_core_1.h)(runtime_core_1.BaseTransition, resolveTransitionProps(props), slots);\n};\nexports.Transition = Transition;\nTransition.displayName = 'Transition';\nconst DOMTransitionPropsValidators = {\n  name: String,\n  type: String,\n  css: {\n    type: Boolean,\n    default: true\n  },\n  duration: [String, Number, Object],\n  enterFromClass: String,\n  enterActiveClass: String,\n  enterToClass: String,\n  appearFromClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  leaveFromClass: String,\n  leaveActiveClass: String,\n  leaveToClass: String\n};\nconst TransitionPropsValidators = Transition.props = /*#__PURE__*/(0, shared_1.extend)({}, runtime_core_1.BaseTransition.props, DOMTransitionPropsValidators);\n/**\n * #3227 Incoming hooks may be merged into arrays when wrapping Transition\n * with custom HOCs.\n */\nconst callHook = function (hook) {\n  let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  if ((0, shared_1.isArray)(hook)) {\n    hook.forEach(h => h(...args));\n  } else if (hook) {\n    hook(...args);\n  }\n};\n/**\n * Check if a hook expects a callback (2nd arg), which means the user\n * intends to explicitly control the end of the transition.\n */\nconst hasExplicitCallback = hook => {\n  return hook ? (0, shared_1.isArray)(hook) ? hook.some(h => h.length > 1) : hook.length > 1 : false;\n};\nfunction resolveTransitionProps(rawProps) {\n  const baseProps = {};\n  for (const key in rawProps) {\n    if (!(key in DOMTransitionPropsValidators)) {\n      baseProps[key] = rawProps[key];\n    }\n  }\n  if (rawProps.css === false) {\n    return baseProps;\n  }\n  const {\n    name = 'v',\n    type,\n    duration,\n    enterFromClass = `${name}-enter-from`,\n    enterActiveClass = `${name}-enter-active`,\n    enterToClass = `${name}-enter-to`,\n    appearFromClass = enterFromClass,\n    appearActiveClass = enterActiveClass,\n    appearToClass = enterToClass,\n    leaveFromClass = `${name}-leave-from`,\n    leaveActiveClass = `${name}-leave-active`,\n    leaveToClass = `${name}-leave-to`\n  } = rawProps;\n  const durations = normalizeDuration(duration);\n  const enterDuration = durations && durations[0];\n  const leaveDuration = durations && durations[1];\n  const {\n    onBeforeEnter,\n    onEnter,\n    onEnterCancelled,\n    onLeave,\n    onLeaveCancelled,\n    onBeforeAppear = onBeforeEnter,\n    onAppear = onEnter,\n    onAppearCancelled = onEnterCancelled\n  } = baseProps;\n  const finishEnter = (el, isAppear, done) => {\n    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);\n    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);\n    done && done();\n  };\n  const finishLeave = (el, done) => {\n    el._isLeaving = false;\n    removeTransitionClass(el, leaveFromClass);\n    removeTransitionClass(el, leaveToClass);\n    removeTransitionClass(el, leaveActiveClass);\n    done && done();\n  };\n  const makeEnterHook = isAppear => {\n    return (el, done) => {\n      const hook = isAppear ? onAppear : onEnter;\n      const resolve = () => finishEnter(el, isAppear, done);\n      callHook(hook, [el, resolve]);\n      nextFrame(() => {\n        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);\n        addTransitionClass(el, isAppear ? appearToClass : enterToClass);\n        if (!hasExplicitCallback(hook)) {\n          whenTransitionEnds(el, type, enterDuration, resolve);\n        }\n      });\n    };\n  };\n  return (0, shared_1.extend)(baseProps, {\n    onBeforeEnter(el) {\n      callHook(onBeforeEnter, [el]);\n      addTransitionClass(el, enterFromClass);\n      addTransitionClass(el, enterActiveClass);\n    },\n    onBeforeAppear(el) {\n      callHook(onBeforeAppear, [el]);\n      addTransitionClass(el, appearFromClass);\n      addTransitionClass(el, appearActiveClass);\n    },\n    onEnter: makeEnterHook(false),\n    onAppear: makeEnterHook(true),\n    onLeave(el, done) {\n      el._isLeaving = true;\n      const resolve = () => finishLeave(el, done);\n      addTransitionClass(el, leaveFromClass);\n      // force reflow so *-leave-from classes immediately take effect (#2593)\n      forceReflow();\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(() => {\n        if (!el._isLeaving) {\n          // cancelled\n          return;\n        }\n        removeTransitionClass(el, leaveFromClass);\n        addTransitionClass(el, leaveToClass);\n        if (!hasExplicitCallback(onLeave)) {\n          whenTransitionEnds(el, type, leaveDuration, resolve);\n        }\n      });\n      callHook(onLeave, [el, resolve]);\n    },\n    onEnterCancelled(el) {\n      finishEnter(el, false);\n      callHook(onEnterCancelled, [el]);\n    },\n    onAppearCancelled(el) {\n      finishEnter(el, true);\n      callHook(onAppearCancelled, [el]);\n    },\n    onLeaveCancelled(el) {\n      finishLeave(el);\n      callHook(onLeaveCancelled, [el]);\n    }\n  });\n}\nfunction normalizeDuration(duration) {\n  if (duration == null) {\n    return null;\n  } else if ((0, shared_1.isObject)(duration)) {\n    return [NumberOf(duration.enter), NumberOf(duration.leave)];\n  } else {\n    const n = NumberOf(duration);\n    return [n, n];\n  }\n}\nfunction NumberOf(val) {\n  const res = (0, shared_1.toNumber)(val);\n  if (true) {\n    (0, runtime_core_1.assertNumber)(res, '<transition> explicit duration');\n  }\n  return res;\n}\nfunction addTransitionClass(el, cls) {\n  cls.split(/\\s+/).forEach(c => c && el.classList.add(c));\n  (el._vtc || (el._vtc = new Set())).add(cls);\n}\nfunction removeTransitionClass(el, cls) {\n  cls.split(/\\s+/).forEach(c => c && el.classList.remove(c));\n  const {\n    _vtc\n  } = el;\n  if (_vtc) {\n    _vtc.delete(cls);\n    if (!_vtc.size) {\n      el._vtc = undefined;\n    }\n  }\n}\nfunction nextFrame(cb) {\n  requestAnimationFrame(() => {\n    requestAnimationFrame(cb);\n  });\n}\nlet endId = 0;\nfunction whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {\n  const id = el._endId = ++endId;\n  const resolveIfNotStale = () => {\n    if (id === el._endId) {\n      resolve();\n    }\n  };\n  if (explicitTimeout) {\n    return setTimeout(resolveIfNotStale, explicitTimeout);\n  }\n  const {\n    type,\n    timeout,\n    propCount\n  } = getTransitionInfo(el, expectedType);\n  if (!type) {\n    return resolve();\n  }\n  const endEvent = type + 'end';\n  let ended = 0;\n  const end = () => {\n    el.removeEventListener(endEvent, onEnd);\n    resolveIfNotStale();\n  };\n  const onEnd = e => {\n    if (e.target === el && ++ended >= propCount) {\n      end();\n    }\n  };\n  setTimeout(() => {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(endEvent, onEnd);\n}\nfunction getTransitionInfo(el, expectedType) {\n  const styles = window.getComputedStyle(el);\n  // JSDOM may return undefined for transition properties\n  const getStyleProperties = key => (styles[key] || '').split(', ');\n  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);\n  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);\n  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);\n  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);\n  const animationTimeout = getTimeout(animationDelays, animationDurations);\n  let type = null;\n  let timeout = 0;\n  let propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n  }\n  const hasTransform = type === TRANSITION && /\\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());\n  return {\n    type,\n    timeout,\n    propCount,\n    hasTransform\n  };\n}\nfunction getTimeout(delays, durations) {\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));\n}\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer\n// numbers in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down\n// (i.e. acting as a floor function) causing unexpected behaviors\nfunction toMs(s) {\n  return Number(s.slice(0, -1).replace(',', '.')) * 1000;\n}\n// synchronously force layout to put elements into a certain state\nfunction forceReflow() {\n  return document.body.offsetHeight;\n}\nconst positionMap = new WeakMap();\nconst newPositionMap = new WeakMap();\nconst TransitionGroupImpl = {\n  name: 'TransitionGroup',\n  props: /*#__PURE__*/(0, shared_1.extend)({}, TransitionPropsValidators, {\n    tag: String,\n    moveClass: String\n  }),\n  setup(props, _ref2) {\n    let {\n      slots\n    } = _ref2;\n    const instance = (0, runtime_core_1.getCurrentInstance)();\n    const state = (0, runtime_core_1.useTransitionState)();\n    let prevChildren;\n    let children;\n    (0, runtime_core_1.onUpdated)(() => {\n      // children is guaranteed to exist after initial render\n      if (!prevChildren.length) {\n        return;\n      }\n      const moveClass = props.moveClass || `${props.name || 'v'}-move`;\n      if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {\n        return;\n      }\n      // we divide the work into three loops to avoid mixing DOM reads and writes\n      // in each iteration - which helps prevent layout thrashing.\n      prevChildren.forEach(callPendingCbs);\n      prevChildren.forEach(recordPosition);\n      const movedChildren = prevChildren.filter(applyTranslation);\n      // force reflow to put everything in position\n      forceReflow();\n      movedChildren.forEach(c => {\n        const el = c.el;\n        const style = el.style;\n        addTransitionClass(el, moveClass);\n        style.transform = style.webkitTransform = style.transitionDuration = '';\n        const cb = el._moveCb = e => {\n          if (e && e.target !== el) {\n            return;\n          }\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener('transitionend', cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        };\n        el.addEventListener('transitionend', cb);\n      });\n    });\n    return () => {\n      const rawProps = (0, runtime_core_1.toRaw)(props);\n      const cssTransitionProps = resolveTransitionProps(rawProps);\n      let tag = rawProps.tag || runtime_core_1.Fragment;\n      prevChildren = children;\n      children = slots.default ? (0, runtime_core_1.getTransitionRawChildren)(slots.default()) : [];\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        if (child.key != null) {\n          (0, runtime_core_1.setTransitionHooks)(child, (0, runtime_core_1.resolveTransitionHooks)(child, cssTransitionProps, state, instance));\n        } else if (true) {\n          (0, runtime_core_1.warn)(`<TransitionGroup> children must be keyed.`);\n        }\n      }\n      if (prevChildren) {\n        for (let i = 0; i < prevChildren.length; i++) {\n          const child = prevChildren[i];\n          (0, runtime_core_1.setTransitionHooks)(child, (0, runtime_core_1.resolveTransitionHooks)(child, cssTransitionProps, state, instance));\n          positionMap.set(child, child.el.getBoundingClientRect());\n        }\n      }\n      return (0, runtime_core_1.createVNode)(tag, null, children);\n    };\n  }\n};\n/**\n * TransitionGroup does not support \"mode\" so we need to remove it from the\n * props declarations, but direct delete operation is considered a side effect\n * and will make the entire transition feature non-tree-shakeable, so we do it\n * in a function and mark the function's invocation as pure.\n */\nconst removeMode = props => delete props.mode;\n/*#__PURE__*/\nremoveMode(TransitionGroupImpl.props);\nconst TransitionGroup = TransitionGroupImpl;\nexports.TransitionGroup = TransitionGroup;\nfunction callPendingCbs(c) {\n  const el = c.el;\n  if (el._moveCb) {\n    el._moveCb();\n  }\n  if (el._enterCb) {\n    el._enterCb();\n  }\n}\nfunction recordPosition(c) {\n  newPositionMap.set(c, c.el.getBoundingClientRect());\n}\nfunction applyTranslation(c) {\n  const oldPos = positionMap.get(c);\n  const newPos = newPositionMap.get(c);\n  const dx = oldPos.left - newPos.left;\n  const dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    const s = c.el.style;\n    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;\n    s.transitionDuration = '0s';\n    return c;\n  }\n}\nfunction hasCSSTransform(el, root, moveClass) {\n  // Detect whether an element with the move class applied has\n  // CSS transitions. Since the element may be inside an entering\n  // transition at this very moment, we make a clone of it and remove\n  // all other transition classes applied to ensure only the move class\n  // is applied.\n  const clone = el.cloneNode();\n  if (el._vtc) {\n    el._vtc.forEach(cls => {\n      cls.split(/\\s+/).forEach(c => c && clone.classList.remove(c));\n    });\n  }\n  moveClass.split(/\\s+/).forEach(c => c && clone.classList.add(c));\n  clone.style.display = 'none';\n  const container = root.nodeType === 1 ? root : root.parentNode;\n  container.appendChild(clone);\n  const {\n    hasTransform\n  } = getTransitionInfo(clone);\n  container.removeChild(clone);\n  return hasTransform;\n}\nconst getModelAssigner = vnode => {\n  const fn = vnode.props['onUpdate:modelValue'] || false;\n  return (0, shared_1.isArray)(fn) ? value => (0, shared_1.invokeArrayFns)(fn, value) : fn;\n};\nfunction onCompositionStart(e) {\n  e.target.composing = true;\n}\nfunction onCompositionEnd(e) {\n  const target = e.target;\n  if (target.composing) {\n    target.composing = false;\n    target.dispatchEvent(new Event('input'));\n  }\n}\n// We are exporting the v-model runtime directly as vnode hooks so that it can\n// be tree-shaken in case v-model is never used.\nconst vModelText = {\n  created(el, _ref3, vnode) {\n    let {\n      modifiers: {\n        lazy,\n        trim,\n        number\n      }\n    } = _ref3;\n    el._assign = getModelAssigner(vnode);\n    const castToNumber = number || vnode.props && vnode.props.type === 'number';\n    addEventListener(el, lazy ? 'change' : 'input', e => {\n      if (e.target.composing) return;\n      let domValue = el.value;\n      if (trim) {\n        domValue = domValue.trim();\n      }\n      if (castToNumber) {\n        domValue = (0, shared_1.looseToNumber)(domValue);\n      }\n      el._assign(domValue);\n    });\n    if (trim) {\n      addEventListener(el, 'change', () => {\n        el.value = el.value.trim();\n      });\n    }\n    if (!lazy) {\n      addEventListener(el, 'compositionstart', onCompositionStart);\n      addEventListener(el, 'compositionend', onCompositionEnd);\n      // Safari < 10.2 & UIWebView doesn't fire compositionend when\n      // switching focus before confirming composition choice\n      // this also fixes the issue where some browsers e.g. iOS Chrome\n      // fires \"change\" instead of \"input\" on autocomplete.\n      addEventListener(el, 'change', onCompositionEnd);\n    }\n  },\n  // set value on mounted so it's after min/max for type=\"range\"\n  mounted(el, _ref4) {\n    let {\n      value\n    } = _ref4;\n    el.value = value == null ? '' : value;\n  },\n  beforeUpdate(el, _ref5, vnode) {\n    let {\n      value,\n      modifiers: {\n        lazy,\n        trim,\n        number\n      }\n    } = _ref5;\n    el._assign = getModelAssigner(vnode);\n    // avoid clearing unresolved text. #2302\n    if (el.composing) return;\n    if (document.activeElement === el && el.type !== 'range') {\n      if (lazy) {\n        return;\n      }\n      if (trim && el.value.trim() === value) {\n        return;\n      }\n      if ((number || el.type === 'number') && (0, shared_1.looseToNumber)(el.value) === value) {\n        return;\n      }\n    }\n    const newValue = value == null ? '' : value;\n    if (el.value !== newValue) {\n      el.value = newValue;\n    }\n  }\n};\nexports.vModelText = vModelText;\nconst vModelCheckbox = {\n  // #4096 array checkboxes need to be deep traversed\n  deep: true,\n  created(el, _, vnode) {\n    el._assign = getModelAssigner(vnode);\n    addEventListener(el, 'change', () => {\n      const modelValue = el._modelValue;\n      const elementValue = getValue(el);\n      const checked = el.checked;\n      const assign = el._assign;\n      if ((0, shared_1.isArray)(modelValue)) {\n        const index = (0, shared_1.looseIndexOf)(modelValue, elementValue);\n        const found = index !== -1;\n        if (checked && !found) {\n          assign(modelValue.concat(elementValue));\n        } else if (!checked && found) {\n          const filtered = [...modelValue];\n          filtered.splice(index, 1);\n          assign(filtered);\n        }\n      } else if ((0, shared_1.isSet)(modelValue)) {\n        const cloned = new Set(modelValue);\n        if (checked) {\n          cloned.add(elementValue);\n        } else {\n          cloned.delete(elementValue);\n        }\n        assign(cloned);\n      } else {\n        assign(getCheckboxValue(el, checked));\n      }\n    });\n  },\n  // set initial checked on mount to wait for true-value/false-value\n  mounted: setChecked,\n  beforeUpdate(el, binding, vnode) {\n    el._assign = getModelAssigner(vnode);\n    setChecked(el, binding, vnode);\n  }\n};\nexports.vModelCheckbox = vModelCheckbox;\nfunction setChecked(el, _ref6, vnode) {\n  let {\n    value,\n    oldValue\n  } = _ref6;\n  el._modelValue = value;\n  if ((0, shared_1.isArray)(value)) {\n    el.checked = (0, shared_1.looseIndexOf)(value, vnode.props.value) > -1;\n  } else if ((0, shared_1.isSet)(value)) {\n    el.checked = value.has(vnode.props.value);\n  } else if (value !== oldValue) {\n    el.checked = (0, shared_1.looseEqual)(value, getCheckboxValue(el, true));\n  }\n}\nconst vModelRadio = {\n  created(el, _ref7, vnode) {\n    let {\n      value\n    } = _ref7;\n    el.checked = (0, shared_1.looseEqual)(value, vnode.props.value);\n    el._assign = getModelAssigner(vnode);\n    addEventListener(el, 'change', () => {\n      el._assign(getValue(el));\n    });\n  },\n  beforeUpdate(el, _ref8, vnode) {\n    let {\n      value,\n      oldValue\n    } = _ref8;\n    el._assign = getModelAssigner(vnode);\n    if (value !== oldValue) {\n      el.checked = (0, shared_1.looseEqual)(value, vnode.props.value);\n    }\n  }\n};\nexports.vModelRadio = vModelRadio;\nconst vModelSelect = {\n  // <select multiple> value need to be deep traversed\n  deep: true,\n  created(el, _ref9, vnode) {\n    let {\n      value,\n      modifiers: {\n        number\n      }\n    } = _ref9;\n    const isSetModel = (0, shared_1.isSet)(value);\n    addEventListener(el, 'change', () => {\n      const selectedVal = Array.prototype.filter.call(el.options, o => o.selected).map(o => number ? (0, shared_1.looseToNumber)(getValue(o)) : getValue(o));\n      el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);\n    });\n    el._assign = getModelAssigner(vnode);\n  },\n  // set value in mounted & updated because <select> relies on its children\n  // <option>s.\n  mounted(el, _ref10) {\n    let {\n      value\n    } = _ref10;\n    setSelected(el, value);\n  },\n  beforeUpdate(el, _binding, vnode) {\n    el._assign = getModelAssigner(vnode);\n  },\n  updated(el, _ref11) {\n    let {\n      value\n    } = _ref11;\n    setSelected(el, value);\n  }\n};\nexports.vModelSelect = vModelSelect;\nfunction setSelected(el, value) {\n  const isMultiple = el.multiple;\n  if (isMultiple && !(0, shared_1.isArray)(value) && !(0, shared_1.isSet)(value)) {\n     true && (0, runtime_core_1.warn)(`<select multiple v-model> expects an Array or Set value for its binding, ` + `but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);\n    return;\n  }\n  for (let i = 0, l = el.options.length; i < l; i++) {\n    const option = el.options[i];\n    const optionValue = getValue(option);\n    if (isMultiple) {\n      if ((0, shared_1.isArray)(value)) {\n        option.selected = (0, shared_1.looseIndexOf)(value, optionValue) > -1;\n      } else {\n        option.selected = value.has(optionValue);\n      }\n    } else {\n      if ((0, shared_1.looseEqual)(getValue(option), value)) {\n        if (el.selectedIndex !== i) el.selectedIndex = i;\n        return;\n      }\n    }\n  }\n  if (!isMultiple && el.selectedIndex !== -1) {\n    el.selectedIndex = -1;\n  }\n}\n// retrieve raw value set via :value bindings\nfunction getValue(el) {\n  return '_value' in el ? el._value : el.value;\n}\n// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings\nfunction getCheckboxValue(el, checked) {\n  const key = checked ? '_trueValue' : '_falseValue';\n  return key in el ? el[key] : checked;\n}\nconst vModelDynamic = {\n  created(el, binding, vnode) {\n    callModelHook(el, binding, vnode, null, 'created');\n  },\n  mounted(el, binding, vnode) {\n    callModelHook(el, binding, vnode, null, 'mounted');\n  },\n  beforeUpdate(el, binding, vnode, prevVNode) {\n    callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');\n  },\n  updated(el, binding, vnode, prevVNode) {\n    callModelHook(el, binding, vnode, prevVNode, 'updated');\n  }\n};\nexports.vModelDynamic = vModelDynamic;\nfunction resolveDynamicModel(tagName, type) {\n  switch (tagName) {\n    case 'SELECT':\n      return vModelSelect;\n    case 'TEXTAREA':\n      return vModelText;\n    default:\n      switch (type) {\n        case 'checkbox':\n          return vModelCheckbox;\n        case 'radio':\n          return vModelRadio;\n        default:\n          return vModelText;\n      }\n  }\n}\nfunction callModelHook(el, binding, vnode, prevVNode, hook) {\n  const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);\n  const fn = modelToUse[hook];\n  fn && fn(el, binding, vnode, prevVNode);\n}\n// SSR vnode transforms, only used when user includes client-oriented render\n// function in SSR\nfunction initVModelForSSR() {\n  vModelText.getSSRProps = _ref12 => {\n    let {\n      value\n    } = _ref12;\n    return {\n      value\n    };\n  };\n  vModelRadio.getSSRProps = (_ref13, vnode) => {\n    let {\n      value\n    } = _ref13;\n    if (vnode.props && (0, shared_1.looseEqual)(vnode.props.value, value)) {\n      return {\n        checked: true\n      };\n    }\n  };\n  vModelCheckbox.getSSRProps = (_ref14, vnode) => {\n    let {\n      value\n    } = _ref14;\n    if ((0, shared_1.isArray)(value)) {\n      if (vnode.props && (0, shared_1.looseIndexOf)(value, vnode.props.value) > -1) {\n        return {\n          checked: true\n        };\n      }\n    } else if ((0, shared_1.isSet)(value)) {\n      if (vnode.props && value.has(vnode.props.value)) {\n        return {\n          checked: true\n        };\n      }\n    } else if (value) {\n      return {\n        checked: true\n      };\n    }\n  };\n  vModelDynamic.getSSRProps = (binding, vnode) => {\n    if (typeof vnode.type !== 'string') {\n      return;\n    }\n    const modelToUse = resolveDynamicModel(\n    // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase\n    vnode.type.toUpperCase(), vnode.props && vnode.props.type);\n    if (modelToUse.getSSRProps) {\n      return modelToUse.getSSRProps(binding, vnode);\n    }\n  };\n}\nconst systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];\nconst modifierGuards = {\n  stop: e => e.stopPropagation(),\n  prevent: e => e.preventDefault(),\n  self: e => e.target !== e.currentTarget,\n  ctrl: e => !e.ctrlKey,\n  shift: e => !e.shiftKey,\n  alt: e => !e.altKey,\n  meta: e => !e.metaKey,\n  left: e => 'button' in e && e.button !== 0,\n  middle: e => 'button' in e && e.button !== 1,\n  right: e => 'button' in e && e.button !== 2,\n  exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))\n};\n/**\n * @private\n */\nconst withModifiers = (fn, modifiers) => {\n  return function (event) {\n    for (let i = 0; i < modifiers.length; i++) {\n      const guard = modifierGuards[modifiers[i]];\n      if (guard && guard(event, modifiers)) return;\n    }\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    return fn(event, ...args);\n  };\n};\nexports.withModifiers = withModifiers;\n// Kept for 2.x compat.\n// Note: IE11 compat for `spacebar` and `del` is removed for now.\nconst keyNames = {\n  esc: 'escape',\n  space: ' ',\n  up: 'arrow-up',\n  left: 'arrow-left',\n  right: 'arrow-right',\n  down: 'arrow-down',\n  delete: 'backspace'\n};\n/**\n * @private\n */\nconst withKeys = (fn, modifiers) => {\n  return event => {\n    if (!('key' in event)) {\n      return;\n    }\n    const eventKey = (0, shared_1.hyphenate)(event.key);\n    if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {\n      return fn(event);\n    }\n  };\n};\nexports.withKeys = withKeys;\nconst vShow = {\n  beforeMount(el, _ref15, _ref16) {\n    let {\n      value\n    } = _ref15;\n    let {\n      transition\n    } = _ref16;\n    el._vod = el.style.display === 'none' ? '' : el.style.display;\n    if (transition && value) {\n      transition.beforeEnter(el);\n    } else {\n      setDisplay(el, value);\n    }\n  },\n  mounted(el, _ref17, _ref18) {\n    let {\n      value\n    } = _ref17;\n    let {\n      transition\n    } = _ref18;\n    if (transition && value) {\n      transition.enter(el);\n    }\n  },\n  updated(el, _ref19, _ref20) {\n    let {\n      value,\n      oldValue\n    } = _ref19;\n    let {\n      transition\n    } = _ref20;\n    if (!value === !oldValue) return;\n    if (transition) {\n      if (value) {\n        transition.beforeEnter(el);\n        setDisplay(el, true);\n        transition.enter(el);\n      } else {\n        transition.leave(el, () => {\n          setDisplay(el, false);\n        });\n      }\n    } else {\n      setDisplay(el, value);\n    }\n  },\n  beforeUnmount(el, _ref21) {\n    let {\n      value\n    } = _ref21;\n    setDisplay(el, value);\n  }\n};\nexports.vShow = vShow;\nfunction setDisplay(el, value) {\n  el.style.display = value ? el._vod : 'none';\n}\n// SSR vnode transforms, only used when user includes client-oriented render\n// function in SSR\nfunction initVShowForSSR() {\n  vShow.getSSRProps = _ref22 => {\n    let {\n      value\n    } = _ref22;\n    if (!value) {\n      return {\n        style: {\n          display: 'none'\n        }\n      };\n    }\n  };\n}\nconst rendererOptions = /*#__PURE__*/(0, shared_1.extend)({\n  patchProp\n}, nodeOps);\n// lazy create the renderer - this makes core renderer logic tree-shakable\n// in case the user only imports reactivity utilities from Vue.\nlet renderer;\nlet enabledHydration = false;\nfunction ensureRenderer() {\n  return renderer || (renderer = (0, runtime_core_1.createRenderer)(rendererOptions));\n}\nfunction ensureHydrationRenderer() {\n  renderer = enabledHydration ? renderer : (0, runtime_core_1.createHydrationRenderer)(rendererOptions);\n  enabledHydration = true;\n  return renderer;\n}\n// use explicit type casts here to avoid import() calls in rolled-up d.ts\nconst render = function () {\n  ensureRenderer().render(...arguments);\n};\nexports.render = render;\nconst hydrate = function () {\n  ensureHydrationRenderer().hydrate(...arguments);\n};\nexports.hydrate = hydrate;\nconst createApp = function () {\n  const app = ensureRenderer().createApp(...arguments);\n  if (true) {\n    injectNativeTagCheck(app);\n    injectCompilerOptionsCheck(app);\n  }\n  const {\n    mount\n  } = app;\n  app.mount = containerOrSelector => {\n    const container = normalizeContainer(containerOrSelector);\n    if (!container) return;\n    const component = app._component;\n    if (!(0, shared_1.isFunction)(component) && !component.render && !component.template) {\n      // __UNSAFE__\n      // Reason: potential execution of JS expressions in in-DOM template.\n      // The user must make sure the in-DOM template is trusted. If it's\n      // rendered by the server, the template should not contain any user data.\n      component.template = container.innerHTML;\n    }\n    // clear content before mounting\n    container.innerHTML = '';\n    const proxy = mount(container, false, container instanceof SVGElement);\n    if (container instanceof Element) {\n      container.removeAttribute('v-cloak');\n      container.setAttribute('data-v-app', '');\n    }\n    return proxy;\n  };\n  return app;\n};\nexports.createApp = createApp;\nconst createSSRApp = function () {\n  const app = ensureHydrationRenderer().createApp(...arguments);\n  if (true) {\n    injectNativeTagCheck(app);\n    injectCompilerOptionsCheck(app);\n  }\n  const {\n    mount\n  } = app;\n  app.mount = containerOrSelector => {\n    const container = normalizeContainer(containerOrSelector);\n    if (container) {\n      return mount(container, true, container instanceof SVGElement);\n    }\n  };\n  return app;\n};\nexports.createSSRApp = createSSRApp;\nfunction injectNativeTagCheck(app) {\n  // Inject `isNativeTag`\n  // this is used for component name validation (dev only)\n  Object.defineProperty(app.config, 'isNativeTag', {\n    value: tag => (0, shared_1.isHTMLTag)(tag) || (0, shared_1.isSVGTag)(tag),\n    writable: false\n  });\n}\n// dev only\nfunction injectCompilerOptionsCheck(app) {\n  if ((0, runtime_core_1.isRuntimeOnly)()) {\n    const isCustomElement = app.config.isCustomElement;\n    Object.defineProperty(app.config, 'isCustomElement', {\n      get() {\n        return isCustomElement;\n      },\n      set() {\n        (0, runtime_core_1.warn)(`The \\`isCustomElement\\` config option is deprecated. Use ` + `\\`compilerOptions.isCustomElement\\` instead.`);\n      }\n    });\n    const compilerOptions = app.config.compilerOptions;\n    const msg = `The \\`compilerOptions\\` config option is only respected when using ` + `a build of Vue.js that includes the runtime compiler (aka \"full build\"). ` + `Since you are using the runtime-only build, \\`compilerOptions\\` ` + `must be passed to \\`@vue/compiler-dom\\` in the build setup instead.\\n` + `- For vue-loader: pass it via vue-loader's \\`compilerOptions\\` loader option.\\n` + `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\\n` + `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;\n    Object.defineProperty(app.config, 'compilerOptions', {\n      get() {\n        (0, runtime_core_1.warn)(msg);\n        return compilerOptions;\n      },\n      set() {\n        (0, runtime_core_1.warn)(msg);\n      }\n    });\n  }\n}\nfunction normalizeContainer(container) {\n  if ((0, shared_1.isString)(container)) {\n    const res = document.querySelector(container);\n    if ( true && !res) {\n      (0, runtime_core_1.warn)(`Failed to mount app: mount target selector \"${container}\" returned null.`);\n    }\n    return res;\n  }\n  if ( true && window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === 'closed') {\n    (0, runtime_core_1.warn)(`mounting on a ShadowRoot with \\`{mode: \"closed\"}\\` may lead to unpredictable bugs`);\n  }\n  return container;\n}\nlet ssrDirectiveInitialized = false;\n/**\n * @internal\n */\nconst initDirectivesForSSR = () => {\n  if (!ssrDirectiveInitialized) {\n    ssrDirectiveInitialized = true;\n    initVModelForSSR();\n    initVShowForSSR();\n  }\n};\nexports.initDirectivesForSSR = initDirectivesForSSR;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWRvbS9kaXN0L3J1bnRpbWUtZG9tLmVzbS1idW5kbGVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU1BO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBTEE7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFiLy4vbm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1kb20vZGlzdC9ydW50aW1lLWRvbS5lc20tYnVuZGxlci5qcz84MzBmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndpdGhNb2RpZmllcnMgPSBleHBvcnRzLndpdGhLZXlzID0gZXhwb3J0cy52U2hvdyA9IGV4cG9ydHMudk1vZGVsVGV4dCA9IGV4cG9ydHMudk1vZGVsU2VsZWN0ID0gZXhwb3J0cy52TW9kZWxSYWRpbyA9IGV4cG9ydHMudk1vZGVsRHluYW1pYyA9IGV4cG9ydHMudk1vZGVsQ2hlY2tib3ggPSBleHBvcnRzLnVzZUNzc1ZhcnMgPSBleHBvcnRzLnVzZUNzc01vZHVsZSA9IGV4cG9ydHMucmVuZGVyID0gZXhwb3J0cy5pbml0RGlyZWN0aXZlc0ZvclNTUiA9IGV4cG9ydHMuaHlkcmF0ZSA9IGV4cG9ydHMuZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCA9IGV4cG9ydHMuZGVmaW5lQ3VzdG9tRWxlbWVudCA9IGV4cG9ydHMuY3JlYXRlU1NSQXBwID0gZXhwb3J0cy5jcmVhdGVBcHAgPSBleHBvcnRzLlZ1ZUVsZW1lbnQgPSBleHBvcnRzLlRyYW5zaXRpb25Hcm91cCA9IGV4cG9ydHMuVHJhbnNpdGlvbiA9IHZvaWQgMDtcbmNvbnN0IHJ1bnRpbWVfY29yZV8xID0gcmVxdWlyZShcIkB2dWUvcnVudGltZS1jb3JlXCIpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCJAdnVlL3J1bnRpbWUtY29yZVwiKSwgZXhwb3J0cyk7XG5jb25zdCBzaGFyZWRfMSA9IHJlcXVpcmUoXCJAdnVlL3NoYXJlZFwiKTtcbmNvbnN0IHN2Z05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbmNvbnN0IGRvYyA9ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiBudWxsKTtcbmNvbnN0IHRlbXBsYXRlQ29udGFpbmVyID0gZG9jICYmIC8qI19fUFVSRV9fKi8gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG5jb25zdCBub2RlT3BzID0ge1xuICAgIGluc2VydDogKGNoaWxkLCBwYXJlbnQsIGFuY2hvcikgPT4ge1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBhbmNob3IgfHwgbnVsbCk7XG4gICAgfSxcbiAgICByZW1vdmU6IGNoaWxkID0+IHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gY2hpbGQucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlRWxlbWVudDogKHRhZywgaXNTVkcsIGlzLCBwcm9wcykgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IGlzU1ZHXG4gICAgICAgICAgICA/IGRvYy5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIHRhZylcbiAgICAgICAgICAgIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCBpcyA/IHsgaXMgfSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICh0YWcgPT09ICdzZWxlY3QnICYmIHByb3BzICYmIHByb3BzLm11bHRpcGxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCBwcm9wcy5tdWx0aXBsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH0sXG4gICAgY3JlYXRlVGV4dDogdGV4dCA9PiBkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCksXG4gICAgY3JlYXRlQ29tbWVudDogdGV4dCA9PiBkb2MuY3JlYXRlQ29tbWVudCh0ZXh0KSxcbiAgICBzZXRUZXh0OiAobm9kZSwgdGV4dCkgPT4ge1xuICAgICAgICBub2RlLm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgfSxcbiAgICBzZXRFbGVtZW50VGV4dDogKGVsLCB0ZXh0KSA9PiB7XG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICB9LFxuICAgIHBhcmVudE5vZGU6IG5vZGUgPT4gbm9kZS5wYXJlbnROb2RlLFxuICAgIG5leHRTaWJsaW5nOiBub2RlID0+IG5vZGUubmV4dFNpYmxpbmcsXG4gICAgcXVlcnlTZWxlY3Rvcjogc2VsZWN0b3IgPT4gZG9jLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpLFxuICAgIHNldFNjb3BlSWQoZWwsIGlkKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShpZCwgJycpO1xuICAgIH0sXG4gICAgLy8gX19VTlNBRkVfX1xuICAgIC8vIFJlYXNvbjogaW5uZXJIVE1MLlxuICAgIC8vIFN0YXRpYyBjb250ZW50IGhlcmUgY2FuIG9ubHkgY29tZSBmcm9tIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgICAvLyBBcyBsb25nIGFzIHRoZSB1c2VyIG9ubHkgdXNlcyB0cnVzdGVkIHRlbXBsYXRlcywgdGhpcyBpcyBzYWZlLlxuICAgIGluc2VydFN0YXRpY0NvbnRlbnQoY29udGVudCwgcGFyZW50LCBhbmNob3IsIGlzU1ZHLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIC8vIDxwYXJlbnQ+IGJlZm9yZSB8IGZpcnN0IC4uLiBsYXN0IHwgYW5jaG9yIDwvcGFyZW50PlxuICAgICAgICBjb25zdCBiZWZvcmUgPSBhbmNob3IgPyBhbmNob3IucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Lmxhc3RDaGlsZDtcbiAgICAgICAgLy8gIzUzMDggY2FuIG9ubHkgdGFrZSBjYWNoZWQgcGF0aCBpZjpcbiAgICAgICAgLy8gLSBoYXMgYSBzaW5nbGUgcm9vdCBub2RlXG4gICAgICAgIC8vIC0gbmV4dFNpYmxpbmcgaW5mbyBpcyBzdGlsbCBhdmFpbGFibGVcbiAgICAgICAgaWYgKHN0YXJ0ICYmIChzdGFydCA9PT0gZW5kIHx8IHN0YXJ0Lm5leHRTaWJsaW5nKSkge1xuICAgICAgICAgICAgLy8gY2FjaGVkXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoc3RhcnQuY2xvbmVOb2RlKHRydWUpLCBhbmNob3IpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PT0gZW5kIHx8ICEoc3RhcnQgPSBzdGFydC5uZXh0U2libGluZykpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZnJlc2ggaW5zZXJ0XG4gICAgICAgICAgICB0ZW1wbGF0ZUNvbnRhaW5lci5pbm5lckhUTUwgPSBpc1NWRyA/IGA8c3ZnPiR7Y29udGVudH08L3N2Zz5gIDogY29udGVudDtcbiAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVDb250YWluZXIuY29udGVudDtcbiAgICAgICAgICAgIGlmIChpc1NWRykge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBvdXRlciBzdmcgd3JhcHBlclxuICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0ZW1wbGF0ZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIHdoaWxlICh3cmFwcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUuYXBwZW5kQ2hpbGQod3JhcHBlci5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGVtcGxhdGUucmVtb3ZlQ2hpbGQod3JhcHBlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRlbXBsYXRlLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAvLyBmaXJzdFxuICAgICAgICAgICAgYmVmb3JlID8gYmVmb3JlLm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAvLyBsYXN0XG4gICAgICAgICAgICBhbmNob3IgPyBhbmNob3IucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Lmxhc3RDaGlsZFxuICAgICAgICBdO1xuICAgIH1cbn07XG4vLyBjb21waWxlciBzaG91bGQgbm9ybWFsaXplIGNsYXNzICsgOmNsYXNzIGJpbmRpbmdzIG9uIHRoZSBzYW1lIGVsZW1lbnRcbi8vIGludG8gYSBzaW5nbGUgYmluZGluZyBbJ3N0YXRpY0NsYXNzJywgZHluYW1pY11cbmZ1bmN0aW9uIHBhdGNoQ2xhc3MoZWwsIHZhbHVlLCBpc1NWRykge1xuICAgIC8vIGRpcmVjdGx5IHNldHRpbmcgY2xhc3NOYW1lIHNob3VsZCBiZSBmYXN0ZXIgdGhhbiBzZXRBdHRyaWJ1dGUgaW4gdGhlb3J5XG4gICAgLy8gaWYgdGhpcyBpcyBhbiBlbGVtZW50IGR1cmluZyBhIHRyYW5zaXRpb24sIHRha2UgdGhlIHRlbXBvcmFyeSB0cmFuc2l0aW9uXG4gICAgLy8gY2xhc3NlcyBpbnRvIGFjY291bnQuXG4gICAgY29uc3QgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdnRjO1xuICAgIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA/IFt2YWx1ZSwgLi4udHJhbnNpdGlvbkNsYXNzZXNdIDogWy4uLnRyYW5zaXRpb25DbGFzc2VzXSkuam9pbignICcpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU1ZHKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbC5jbGFzc05hbWUgPSB2YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXRjaFN0eWxlKGVsLCBwcmV2LCBuZXh0KSB7XG4gICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICBjb25zdCBpc0Nzc1N0cmluZyA9ICgwLCBzaGFyZWRfMS5pc1N0cmluZykobmV4dCk7XG4gICAgaWYgKG5leHQgJiYgIWlzQ3NzU3RyaW5nKSB7XG4gICAgICAgIGlmIChwcmV2ICYmICEoMCwgc2hhcmVkXzEuaXNTdHJpbmcpKHByZXYpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xuICAgICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgbmV4dFtrZXldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgY3VycmVudERpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuICAgICAgICBpZiAoaXNDc3NTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChwcmV2ICE9PSBuZXh0KSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuY3NzVGV4dCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJldikge1xuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluZGljYXRlcyB0aGF0IHRoZSBgZGlzcGxheWAgb2YgdGhlIGVsZW1lbnQgaXMgY29udHJvbGxlZCBieSBgdi1zaG93YCxcbiAgICAgICAgLy8gc28gd2UgYWx3YXlzIGtlZXAgdGhlIGN1cnJlbnQgYGRpc3BsYXlgIHZhbHVlIHJlZ2FyZGxlc3Mgb2YgdGhlIGBzdHlsZWBcbiAgICAgICAgLy8gdmFsdWUsIHRodXMgaGFuZGluZyBvdmVyIGNvbnRyb2wgdG8gYHYtc2hvd2AuXG4gICAgICAgIGlmICgnX3ZvZCcgaW4gZWwpIHtcbiAgICAgICAgICAgIHN0eWxlLmRpc3BsYXkgPSBjdXJyZW50RGlzcGxheTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IHNlbWljb2xvblJFID0gL1teXFxcXF07XFxzKiQvO1xuY29uc3QgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbmZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlLCBuYW1lLCB2YWwpIHtcbiAgICBpZiAoKDAsIHNoYXJlZF8xLmlzQXJyYXkpKHZhbCkpIHtcbiAgICAgICAgdmFsLmZvckVhY2godiA9PiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKVxuICAgICAgICAgICAgdmFsID0gJyc7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIGlmIChzZW1pY29sb25SRS50ZXN0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICAoMCwgcnVudGltZV9jb3JlXzEud2FybikoYFVuZXhwZWN0ZWQgc2VtaWNvbG9uIGF0IHRoZSBlbmQgb2YgJyR7bmFtZX0nIHN0eWxlIHZhbHVlOiAnJHt2YWx9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJy0tJykpIHtcbiAgICAgICAgICAgIC8vIGN1c3RvbSBwcm9wZXJ0eSBkZWZpbml0aW9uXG4gICAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ZWQgPSBhdXRvUHJlZml4KHN0eWxlLCBuYW1lKTtcbiAgICAgICAgICAgIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICAvLyAhaW1wb3J0YW50XG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoKDAsIHNoYXJlZF8xLmh5cGhlbmF0ZSkocHJlZml4ZWQpLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHlsZVtwcmVmaXhlZF0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuY29uc3QgcHJlZml4Q2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGF1dG9QcmVmaXgoc3R5bGUsIHJhd05hbWUpIHtcbiAgICBjb25zdCBjYWNoZWQgPSBwcmVmaXhDYWNoZVtyYXdOYW1lXTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGxldCBuYW1lID0gKDAsIHJ1bnRpbWVfY29yZV8xLmNhbWVsaXplKShyYXdOYW1lKTtcbiAgICBpZiAobmFtZSAhPT0gJ2ZpbHRlcicgJiYgbmFtZSBpbiBzdHlsZSkge1xuICAgICAgICByZXR1cm4gKHByZWZpeENhY2hlW3Jhd05hbWVdID0gbmFtZSk7XG4gICAgfVxuICAgIG5hbWUgPSAoMCwgc2hhcmVkXzEuY2FwaXRhbGl6ZSkobmFtZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgbmFtZTtcbiAgICAgICAgaWYgKHByZWZpeGVkIGluIHN0eWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHByZWZpeENhY2hlW3Jhd05hbWVdID0gcHJlZml4ZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYXdOYW1lO1xufVxuY29uc3QgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcbmZ1bmN0aW9uIHBhdGNoQXR0cihlbCwga2V5LCB2YWx1ZSwgaXNTVkcsIGluc3RhbmNlKSB7XG4gICAgaWYgKGlzU1ZHICYmIGtleS5zdGFydHNXaXRoKCd4bGluazonKSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywga2V5LnNsaWNlKDYsIGtleS5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBub3RlIHdlIGFyZSBvbmx5IGNoZWNraW5nIGJvb2xlYW4gYXR0cmlidXRlcyB0aGF0IGRvbid0IGhhdmUgYVxuICAgICAgICAvLyBjb3JyZXNwb25kaW5nIGRvbSBwcm9wIG9mIHRoZSBzYW1lIG5hbWUgaGVyZS5cbiAgICAgICAgY29uc3QgaXNCb29sZWFuID0gKDAsIHNoYXJlZF8xLmlzU3BlY2lhbEJvb2xlYW5BdHRyKShrZXkpO1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCAoaXNCb29sZWFuICYmICEoMCwgc2hhcmVkXzEuaW5jbHVkZUJvb2xlYW5BdHRyKSh2YWx1ZSkpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzQm9vbGVhbiA/ICcnIDogdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gX19VTlNBRkVfX1xuLy8gZnVuY3Rpb25zLiBUaGUgdXNlciBpcyByZXNwb25zaWJsZSBmb3IgdXNpbmcgdGhlbSB3aXRoIG9ubHkgdHJ1c3RlZCBjb250ZW50LlxuZnVuY3Rpb24gcGF0Y2hET01Qcm9wKGVsLCBrZXksIHZhbHVlLCBcbi8vIHRoZSBmb2xsb3dpbmcgYXJncyBhcmUgcGFzc2VkIG9ubHkgZHVlIHRvIHBvdGVudGlhbCBpbm5lckhUTUwvdGV4dENvbnRlbnRcbi8vIG92ZXJyaWRpbmcgZXhpc3RpbmcgVk5vZGVzLCBpbiB3aGljaCBjYXNlIHRoZSBvbGQgdHJlZSBtdXN0IGJlIHByb3Blcmx5XG4vLyB1bm1vdW50ZWQuXG5wcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbikge1xuICAgIGlmIChrZXkgPT09ICdpbm5lckhUTUwnIHx8IGtleSA9PT0gJ3RleHRDb250ZW50Jykge1xuICAgICAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbFtrZXldID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJyAmJlxuICAgICAgICBlbC50YWdOYW1lICE9PSAnUFJPR1JFU1MnICYmXG4gICAgICAgIC8vIGN1c3RvbSBlbGVtZW50cyBtYXkgdXNlIF92YWx1ZSBpbnRlcm5hbGx5XG4gICAgICAgICFlbC50YWdOYW1lLmluY2x1ZGVzKCctJykpIHtcbiAgICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZC5cbiAgICAgICAgZWwuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG4gICAgICAgIGlmIChlbC52YWx1ZSAhPT0gbmV3VmFsdWUgfHxcbiAgICAgICAgICAgIC8vICM0OTU2OiBhbHdheXMgc2V0IGZvciBPUFRJT04gZWxlbWVudHMgYmVjYXVzZSBpdHMgdmFsdWUgZmFsbHMgYmFjayB0b1xuICAgICAgICAgICAgLy8gdGV4dENvbnRlbnQgaWYgbm8gdmFsdWUgYXR0cmlidXRlIGlzIHByZXNlbnQuIEFuZCBzZXR0aW5nIC52YWx1ZSBmb3JcbiAgICAgICAgICAgIC8vIE9QVElPTiBoYXMgbm8gc2lkZSBlZmZlY3RcbiAgICAgICAgICAgIGVsLnRhZ05hbWUgPT09ICdPUFRJT04nKSB7XG4gICAgICAgICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBuZWVkUmVtb3ZlID0gZmFsc2U7XG4gICAgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgZWxba2V5XTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgLy8gZS5nLiA8c2VsZWN0IG11bHRpcGxlPiBjb21waWxlcyB0byB7IG11bHRpcGxlOiAnJyB9XG4gICAgICAgICAgICB2YWx1ZSA9ICgwLCBzaGFyZWRfMS5pbmNsdWRlQm9vbGVhbkF0dHIpKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSBudWxsICYmIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBlLmcuIDxkaXYgOmlkPVwibnVsbFwiPlxuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIG5lZWRSZW1vdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBlLmcuIDxpbWcgOndpZHRoPVwibnVsbFwiPlxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICAgICAgbmVlZFJlbW92ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc29tZSBwcm9wZXJ0aWVzIHBlcmZvcm0gdmFsdWUgdmFsaWRhdGlvbiBhbmQgdGhyb3csXG4gICAgLy8gc29tZSBwcm9wZXJ0aWVzIGhhcyBnZXR0ZXIsIG5vIHNldHRlciwgd2lsbCBlcnJvciBpbiAndXNlIHN0cmljdCdcbiAgICAvLyBlZy4gPHNlbGVjdCA6dHlwZT1cIm51bGxcIj48L3NlbGVjdD4gPHNlbGVjdCA6d2lsbFZhbGlkYXRlPVwibnVsbFwiPjwvc2VsZWN0PlxuICAgIHRyeSB7XG4gICAgICAgIGVsW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gZG8gbm90IHdhcm4gaWYgdmFsdWUgaXMgYXV0by1jb2VyY2VkIGZyb20gbnVsbGlzaCB2YWx1ZXNcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhbmVlZFJlbW92ZSkge1xuICAgICAgICAgICAgKDAsIHJ1bnRpbWVfY29yZV8xLndhcm4pKGBGYWlsZWQgc2V0dGluZyBwcm9wIFwiJHtrZXl9XCIgb24gPCR7ZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpfT46IGAgK1xuICAgICAgICAgICAgICAgIGB2YWx1ZSAke3ZhbHVlfSBpcyBpbnZhbGlkLmAsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5lZWRSZW1vdmUgJiYgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG59XG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGVsLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHBhdGNoRXZlbnQoZWwsIHJhd05hbWUsIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBpbnN0YW5jZSA9IG51bGwpIHtcbiAgICAvLyB2ZWkgPSB2dWUgZXZlbnQgaW52b2tlcnNcbiAgICBjb25zdCBpbnZva2VycyA9IGVsLl92ZWkgfHwgKGVsLl92ZWkgPSB7fSk7XG4gICAgY29uc3QgZXhpc3RpbmdJbnZva2VyID0gaW52b2tlcnNbcmF3TmFtZV07XG4gICAgaWYgKG5leHRWYWx1ZSAmJiBleGlzdGluZ0ludm9rZXIpIHtcbiAgICAgICAgLy8gcGF0Y2hcbiAgICAgICAgZXhpc3RpbmdJbnZva2VyLnZhbHVlID0gbmV4dFZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgW25hbWUsIG9wdGlvbnNdID0gcGFyc2VOYW1lKHJhd05hbWUpO1xuICAgICAgICBpZiAobmV4dFZhbHVlKSB7XG4gICAgICAgICAgICAvLyBhZGRcbiAgICAgICAgICAgIGNvbnN0IGludm9rZXIgPSAoaW52b2tlcnNbcmF3TmFtZV0gPSBjcmVhdGVJbnZva2VyKG5leHRWYWx1ZSwgaW5zdGFuY2UpKTtcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGludm9rZXIsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4aXN0aW5nSW52b2tlcikge1xuICAgICAgICAgICAgLy8gcmVtb3ZlXG4gICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBuYW1lLCBleGlzdGluZ0ludm9rZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaW52b2tlcnNbcmF3TmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBvcHRpb25zTW9kaWZpZXJSRSA9IC8oPzpPbmNlfFBhc3NpdmV8Q2FwdHVyZSkkLztcbmZ1bmN0aW9uIHBhcnNlTmFtZShuYW1lKSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnNNb2RpZmllclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICBsZXQgbTtcbiAgICAgICAgd2hpbGUgKChtID0gbmFtZS5tYXRjaChvcHRpb25zTW9kaWZpZXJSRSkpKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCBuYW1lLmxlbmd0aCAtIG1bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIG9wdGlvbnNbbVswXS50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXZlbnQgPSBuYW1lWzJdID09PSAnOicgPyBuYW1lLnNsaWNlKDMpIDogKDAsIHNoYXJlZF8xLmh5cGhlbmF0ZSkobmFtZS5zbGljZSgyKSk7XG4gICAgcmV0dXJuIFtldmVudCwgb3B0aW9uc107XG59XG4vLyBUbyBhdm9pZCB0aGUgb3ZlcmhlYWQgb2YgcmVwZWF0ZWRseSBjYWxsaW5nIERhdGUubm93KCksIHdlIGNhY2hlXG4vLyBhbmQgdXNlIHRoZSBzYW1lIHRpbWVzdGFtcCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVycyBhdHRhY2hlZCBpbiB0aGUgc2FtZSB0aWNrLlxubGV0IGNhY2hlZE5vdyA9IDA7XG5jb25zdCBwID0gLyojX19QVVJFX18qLyBQcm9taXNlLnJlc29sdmUoKTtcbmNvbnN0IGdldE5vdyA9ICgpID0+IGNhY2hlZE5vdyB8fCAocC50aGVuKCgpID0+IChjYWNoZWROb3cgPSAwKSksIChjYWNoZWROb3cgPSBEYXRlLm5vdygpKSk7XG5mdW5jdGlvbiBjcmVhdGVJbnZva2VyKGluaXRpYWxWYWx1ZSwgaW5zdGFuY2UpIHtcbiAgICBjb25zdCBpbnZva2VyID0gKGUpID0+IHtcbiAgICAgICAgLy8gYXN5bmMgZWRnZSBjYXNlIHZ1ZWpzL3Z1ZSM2NTY2XG4gICAgICAgIC8vIGlubmVyIGNsaWNrIGV2ZW50IHRyaWdnZXJzIHBhdGNoLCBldmVudCBoYW5kbGVyXG4gICAgICAgIC8vIGF0dGFjaGVkIHRvIG91dGVyIGVsZW1lbnQgZHVyaW5nIHBhdGNoLCBhbmQgdHJpZ2dlcmVkIGFnYWluLiBUaGlzXG4gICAgICAgIC8vIGhhcHBlbnMgYmVjYXVzZSBicm93c2VycyBmaXJlIG1pY3JvdGFzayB0aWNrcyBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgICAgICAvLyB0aGlzIG5vIGxvbmdlciBoYXBwZW5zIGZvciB0ZW1wbGF0ZXMgaW4gVnVlIDMsIGJ1dCBjb3VsZCBzdGlsbCBiZVxuICAgICAgICAvLyB0aGVvcmV0aWNhbGx5IHBvc3NpYmxlIGZvciBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgICAgICAgLy8gdGhlIHNvbHV0aW9uOiB3ZSBzYXZlIHRoZSB0aW1lc3RhbXAgd2hlbiBhIGhhbmRsZXIgaXMgYXR0YWNoZWQsXG4gICAgICAgIC8vIGFuZCBhbHNvIGF0dGFjaCB0aGUgdGltZXN0YW1wIHRvIGFueSBldmVudCB0aGF0IHdhcyBoYW5kbGVkIGJ5IHZ1ZVxuICAgICAgICAvLyBmb3IgdGhlIGZpcnN0IHRpbWUgKHRvIGF2b2lkIGluY29uc2lzdGVudCBldmVudCB0aW1lc3RhbXAgaW1wbGVtZW50YXRpb25zXG4gICAgICAgIC8vIG9yIGV2ZW50cyBmaXJlZCBmcm9tIGlmcmFtZXMsIGUuZy4gIzI1MTMpXG4gICAgICAgIC8vIFRoZSBoYW5kbGVyIHdvdWxkIG9ubHkgZmlyZSBpZiB0aGUgZXZlbnQgcGFzc2VkIHRvIGl0IHdhcyBmaXJlZFxuICAgICAgICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXG4gICAgICAgIGlmICghZS5fdnRzKSB7XG4gICAgICAgICAgICBlLl92dHMgPSBEYXRlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGUuX3Z0cyA8PSBpbnZva2VyLmF0dGFjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHJ1bnRpbWVfY29yZV8xLmNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKShwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCBpbnZva2VyLnZhbHVlKSwgaW5zdGFuY2UsIDUgLyogRXJyb3JDb2Rlcy5OQVRJVkVfRVZFTlRfSEFORExFUiAqLywgW2VdKTtcbiAgICB9O1xuICAgIGludm9rZXIudmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgaW52b2tlci5hdHRhY2hlZCA9IGdldE5vdygpO1xuICAgIHJldHVybiBpbnZva2VyO1xufVxuZnVuY3Rpb24gcGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgdmFsdWUpIHtcbiAgICBpZiAoKDAsIHNoYXJlZF8xLmlzQXJyYXkpKHZhbHVlKSkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbFN0b3AgPSBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICBvcmlnaW5hbFN0b3AuY2FsbChlKTtcbiAgICAgICAgICAgIGUuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZuID0+IChlKSA9PiAhZS5fc3RvcHBlZCAmJiBmbiAmJiBmbihlKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuY29uc3QgbmF0aXZlT25SRSA9IC9eb25bYS16XS87XG5jb25zdCBwYXRjaFByb3AgPSAoZWwsIGtleSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIGlzU1ZHID0gZmFsc2UsIHByZXZDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKSA9PiB7XG4gICAgaWYgKGtleSA9PT0gJ2NsYXNzJykge1xuICAgICAgICBwYXRjaENsYXNzKGVsLCBuZXh0VmFsdWUsIGlzU1ZHKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgIHBhdGNoU3R5bGUoZWwsIHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHNoYXJlZF8xLmlzT24pKGtleSkpIHtcbiAgICAgICAgLy8gaWdub3JlIHYtbW9kZWwgbGlzdGVuZXJzXG4gICAgICAgIGlmICghKDAsIHNoYXJlZF8xLmlzTW9kZWxMaXN0ZW5lcikoa2V5KSkge1xuICAgICAgICAgICAgcGF0Y2hFdmVudChlbCwga2V5LCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChrZXlbMF0gPT09ICcuJ1xuICAgICAgICA/ICgoa2V5ID0ga2V5LnNsaWNlKDEpKSwgdHJ1ZSlcbiAgICAgICAgOiBrZXlbMF0gPT09ICdeJ1xuICAgICAgICAgICAgPyAoKGtleSA9IGtleS5zbGljZSgxKSksIGZhbHNlKVxuICAgICAgICAgICAgOiBzaG91bGRTZXRBc1Byb3AoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRykpIHtcbiAgICAgICAgcGF0Y2hET01Qcm9wKGVsLCBrZXksIG5leHRWYWx1ZSwgcHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciA8aW5wdXQgdi1tb2RlbCB0eXBlPVwiY2hlY2tib3hcIj4gd2l0aFxuICAgICAgICAvLyA6dHJ1ZS12YWx1ZSAmIDpmYWxzZS12YWx1ZVxuICAgICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBkb20gcHJvcGVydGllcyBzaW5jZSBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlXG4gICAgICAgIC8vIHN0cmluZ2lmaWVkLlxuICAgICAgICBpZiAoa2V5ID09PSAndHJ1ZS12YWx1ZScpIHtcbiAgICAgICAgICAgIGVsLl90cnVlVmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnZmFsc2UtdmFsdWUnKSB7XG4gICAgICAgICAgICBlbC5fZmFsc2VWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBwYXRjaEF0dHIoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRyk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIHNob3VsZFNldEFzUHJvcChlbCwga2V5LCB2YWx1ZSwgaXNTVkcpIHtcbiAgICBpZiAoaXNTVkcpIHtcbiAgICAgICAgLy8gbW9zdCBrZXlzIG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZSBvbiBzdmcgZWxlbWVudHMgdG8gd29ya1xuICAgICAgICAvLyAuLi5leGNlcHQgaW5uZXJIVE1MICYgdGV4dENvbnRlbnRcbiAgICAgICAgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgfHwga2V5ID09PSAndGV4dENvbnRlbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvciBuYXRpdmUgb25jbGljayB3aXRoIGZ1bmN0aW9uIHZhbHVlc1xuICAgICAgICBpZiAoa2V5IGluIGVsICYmIG5hdGl2ZU9uUkUudGVzdChrZXkpICYmICgwLCBzaGFyZWRfMS5pc0Z1bmN0aW9uKSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gdGhlc2UgYXJlIGVudW1lcmF0ZWQgYXR0cnMsIGhvd2V2ZXIgdGhlaXIgY29ycmVzcG9uZGluZyBET00gcHJvcGVydGllc1xuICAgIC8vIGFyZSBhY3R1YWxseSBib29sZWFucyAtIHRoaXMgbGVhZHMgdG8gc2V0dGluZyBpdCB3aXRoIGEgc3RyaW5nIFwiZmFsc2VcIlxuICAgIC8vIHZhbHVlIGxlYWRpbmcgaXQgdG8gYmUgY29lcmNlZCB0byBgdHJ1ZWAsIHNvIHdlIG5lZWQgdG8gYWx3YXlzIHRyZWF0XG4gICAgLy8gdGhlbSBhcyBhdHRyaWJ1dGVzLlxuICAgIC8vIE5vdGUgdGhhdCBgY29udGVudEVkaXRhYmxlYCBkb2Vzbid0IGhhdmUgdGhpcyBwcm9ibGVtOiBpdHMgRE9NXG4gICAgLy8gcHJvcGVydHkgaXMgYWxzbyBlbnVtZXJhdGVkIHN0cmluZyB2YWx1ZXMuXG4gICAgaWYgKGtleSA9PT0gJ3NwZWxsY2hlY2snIHx8IGtleSA9PT0gJ2RyYWdnYWJsZScgfHwga2V5ID09PSAndHJhbnNsYXRlJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vICMxNzg3LCAjMjg0MCBmb3JtIHByb3BlcnR5IG9uIGZvcm0gZWxlbWVudHMgaXMgcmVhZG9ubHkgYW5kIG11c3QgYmUgc2V0IGFzXG4gICAgLy8gYXR0cmlidXRlLlxuICAgIGlmIChrZXkgPT09ICdmb3JtJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vICMxNTI2IDxpbnB1dCBsaXN0PiBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGVcbiAgICBpZiAoa2V5ID09PSAnbGlzdCcgJiYgZWwudGFnTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vICMyNzY2IDx0ZXh0YXJlYSB0eXBlPiBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGVcbiAgICBpZiAoa2V5ID09PSAndHlwZScgJiYgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIG5hdGl2ZSBvbmNsaWNrIHdpdGggc3RyaW5nIHZhbHVlLCBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGVcbiAgICBpZiAobmF0aXZlT25SRS50ZXN0KGtleSkgJiYgKDAsIHNoYXJlZF8xLmlzU3RyaW5nKSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4ga2V5IGluIGVsO1xufVxuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudChvcHRpb25zLCBoeWRyYXRlKSB7XG4gICAgY29uc3QgQ29tcCA9ICgwLCBydW50aW1lX2NvcmVfMS5kZWZpbmVDb21wb25lbnQpKG9wdGlvbnMpO1xuICAgIGNsYXNzIFZ1ZUN1c3RvbUVsZW1lbnQgZXh0ZW5kcyBWdWVFbGVtZW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5pdGlhbFByb3BzKSB7XG4gICAgICAgICAgICBzdXBlcihDb21wLCBpbml0aWFsUHJvcHMsIGh5ZHJhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFZ1ZUN1c3RvbUVsZW1lbnQuZGVmID0gQ29tcDtcbiAgICByZXR1cm4gVnVlQ3VzdG9tRWxlbWVudDtcbn1cbmV4cG9ydHMuZGVmaW5lQ3VzdG9tRWxlbWVudCA9IGRlZmluZUN1c3RvbUVsZW1lbnQ7XG5jb25zdCBkZWZpbmVTU1JDdXN0b21FbGVtZW50ID0gKChvcHRpb25zKSA9PiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBkZWZpbmVDdXN0b21FbGVtZW50KG9wdGlvbnMsIGh5ZHJhdGUpO1xufSk7XG5leHBvcnRzLmRlZmluZVNTUkN1c3RvbUVsZW1lbnQgPSBkZWZpbmVTU1JDdXN0b21FbGVtZW50O1xuY29uc3QgQmFzZUNsYXNzID0gKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBIVE1MRWxlbWVudCA6IGNsYXNzIHtcbn0pO1xuY2xhc3MgVnVlRWxlbWVudCBleHRlbmRzIEJhc2VDbGFzcyB7XG4gICAgY29uc3RydWN0b3IoX2RlZiwgX3Byb3BzID0ge30sIGh5ZHJhdGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fZGVmID0gX2RlZjtcbiAgICAgICAgdGhpcy5fcHJvcHMgPSBfcHJvcHM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX251bWJlclByb3BzID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93Um9vdCAmJiBoeWRyYXRlKSB7XG4gICAgICAgICAgICBoeWRyYXRlKHRoaXMuX2NyZWF0ZVZOb2RlKCksIHRoaXMuc2hhZG93Um9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgICAgICgwLCBydW50aW1lX2NvcmVfMS53YXJuKShgQ3VzdG9tIGVsZW1lbnQgaGFzIHByZS1yZW5kZXJlZCBkZWNsYXJhdGl2ZSBzaGFkb3cgcm9vdCBidXQgaXMgbm90IGAgK1xuICAgICAgICAgICAgICAgICAgICBgZGVmaW5lZCBhcyBoeWRyYXRhYmxlLiBVc2UgXFxgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudFxcYC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kZWYuX19hc3luY0xvYWRlcikge1xuICAgICAgICAgICAgICAgIC8vIGZvciBzeW5jIGNvbXBvbmVudCBkZWZzIHdlIGNhbiBpbW1lZGlhdGVseSByZXNvbHZlIHByb3BzXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZVByb3BzKHRoaXMuX2RlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZURlZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgKDAsIHJ1bnRpbWVfY29yZV8xLm5leHRUaWNrKSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHJlbmRlcihudWxsLCB0aGlzLnNoYWRvd1Jvb3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJlc29sdmUgaW5uZXIgY29tcG9uZW50IGRlZmluaXRpb24gKGhhbmRsZSBwb3NzaWJsZSBhc3luYyBjb21wb25lbnQpXG4gICAgICovXG4gICAgX3Jlc29sdmVEZWYoKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgLy8gc2V0IGluaXRpYWwgYXR0cnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEF0dHIodGhpcy5hdHRyaWJ1dGVzW2ldLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdhdGNoIGZ1dHVyZSBhdHRyIGNoYW5nZXNcbiAgICAgICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbSBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRBdHRyKG0uYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLm9ic2VydmUodGhpcywgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCByZXNvbHZlID0gKGRlZiwgaXNBc3luYyA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBzdHlsZXMgfSA9IGRlZjtcbiAgICAgICAgICAgIC8vIGNhc3QgTnVtYmVyLXR5cGUgcHJvcHMgc2V0IGJlZm9yZSByZXNvbHZlXG4gICAgICAgICAgICBsZXQgbnVtYmVyUHJvcHM7XG4gICAgICAgICAgICBpZiAocHJvcHMgJiYgISgwLCBzaGFyZWRfMS5pc0FycmF5KShwcm9wcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSBwcm9wc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0ID09PSBOdW1iZXIgfHwgKG9wdCAmJiBvcHQudHlwZSA9PT0gTnVtYmVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9wcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BzW2tleV0gPSAoMCwgc2hhcmVkXzEudG9OdW1iZXIpKHRoaXMuX3Byb3BzW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKG51bWJlclByb3BzIHx8IChudW1iZXJQcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCkpKVsoMCwgc2hhcmVkXzEuY2FtZWxpemUpKGtleSldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX251bWJlclByb3BzID0gbnVtYmVyUHJvcHM7XG4gICAgICAgICAgICBpZiAoaXNBc3luYykge1xuICAgICAgICAgICAgICAgIC8vIGRlZmluaW5nIGdldHRlci9zZXR0ZXJzIG9uIHByb3RvdHlwZVxuICAgICAgICAgICAgICAgIC8vIGZvciBzeW5jIGRlZnMsIHRoaXMgYWxyZWFkeSBoYXBwZW5lZCBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlUHJvcHMoZGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFwcGx5IENTU1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlTdHlsZXMoc3R5bGVzKTtcbiAgICAgICAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXN5bmNEZWYgPSB0aGlzLl9kZWYuX19hc3luY0xvYWRlcjtcbiAgICAgICAgaWYgKGFzeW5jRGVmKSB7XG4gICAgICAgICAgICBhc3luY0RlZigpLnRoZW4oZGVmID0+IHJlc29sdmUoZGVmLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMuX2RlZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3Jlc29sdmVQcm9wcyhkZWYpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gZGVmO1xuICAgICAgICBjb25zdCBkZWNsYXJlZFByb3BLZXlzID0gKDAsIHNoYXJlZF8xLmlzQXJyYXkpKHByb3BzKSA/IHByb3BzIDogT2JqZWN0LmtleXMocHJvcHMgfHwge30pO1xuICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgcHJvcHMgc2V0IHByZS11cGdyYWRlIG9yIGNvbm5lY3RcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcykpIHtcbiAgICAgICAgICAgIGlmIChrZXlbMF0gIT09ICdfJyAmJiBkZWNsYXJlZFByb3BLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wKGtleSwgdGhpc1trZXldLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVmaW5pbmcgZ2V0dGVyL3NldHRlcnMgb24gcHJvdG90eXBlXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGRlY2xhcmVkUHJvcEtleXMubWFwKHNoYXJlZF8xLmNhbWVsaXplKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByb3Aoa2V5KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldCh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UHJvcChrZXksIHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3NldEF0dHIoa2V5KSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgICAgIGNvbnN0IGNhbWVsS2V5ID0gKDAsIHNoYXJlZF8xLmNhbWVsaXplKShrZXkpO1xuICAgICAgICBpZiAodGhpcy5fbnVtYmVyUHJvcHMgJiYgdGhpcy5fbnVtYmVyUHJvcHNbY2FtZWxLZXldKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICgwLCBzaGFyZWRfMS50b051bWJlcikodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldFByb3AoY2FtZWxLZXksIHZhbHVlLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9nZXRQcm9wKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcHNba2V5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3NldFByb3Aoa2V5LCB2YWwsIHNob3VsZFJlZmxlY3QgPSB0cnVlLCBzaG91bGRVcGRhdGUgPSB0cnVlKSB7XG4gICAgICAgIGlmICh2YWwgIT09IHRoaXMuX3Byb3BzW2tleV0pIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb3BzW2tleV0gPSB2YWw7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlICYmIHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZWZsZWN0XG4gICAgICAgICAgICBpZiAoc2hvdWxkUmVmbGVjdCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoKDAsIHNoYXJlZF8xLmh5cGhlbmF0ZSkoa2V5KSwgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgoMCwgc2hhcmVkXzEuaHlwaGVuYXRlKShrZXkpLCB2YWwgKyAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoKDAsIHNoYXJlZF8xLmh5cGhlbmF0ZSkoa2V5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF91cGRhdGUoKSB7XG4gICAgICAgIHJlbmRlcih0aGlzLl9jcmVhdGVWTm9kZSgpLCB0aGlzLnNoYWRvd1Jvb3QpO1xuICAgIH1cbiAgICBfY3JlYXRlVk5vZGUoKSB7XG4gICAgICAgIGNvbnN0IHZub2RlID0gKDAsIHJ1bnRpbWVfY29yZV8xLmNyZWF0ZVZOb2RlKSh0aGlzLl9kZWYsICgwLCBzaGFyZWRfMS5leHRlbmQpKHt9LCB0aGlzLl9wcm9wcykpO1xuICAgICAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICB2bm9kZS5jZSA9IGluc3RhbmNlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmlzQ0UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIEhNUlxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuY2VSZWxvYWQgPSBuZXdTdHlsZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWx3YXlzIHJlc2V0IHN0eWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0eWxlcy5mb3JFYWNoKHMgPT4gdGhpcy5zaGFkb3dSb290LnJlbW92ZUNoaWxkKHMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHlsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5U3R5bGVzKG5ld1N0eWxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzcGF0Y2ggPSAoZXZlbnQsIGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChldmVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiBhcmdzXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIGludGVyY2VwdCBlbWl0XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZW1pdCA9IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBkaXNwYXRjaCBib3RoIHRoZSByYXcgYW5kIGh5cGhlbmF0ZWQgdmVyc2lvbnMgb2YgYW4gZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gbWF0Y2ggVnVlIGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKGV2ZW50LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBzaGFyZWRfMS5oeXBoZW5hdGUpKGV2ZW50KSAhPT0gZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCgwLCBzaGFyZWRfMS5oeXBoZW5hdGUpKGV2ZW50KSwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIGxvY2F0ZSBuZWFyZXN0IFZ1ZSBjdXN0b20gZWxlbWVudCBwYXJlbnQgZm9yIHByb3ZpZGUvaW5qZWN0XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChwYXJlbnQgPVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgJiYgKHBhcmVudC5wYXJlbnROb2RlIHx8IHBhcmVudC5ob3N0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIFZ1ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnBhcmVudCA9IHBhcmVudC5faW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5wcm92aWRlcyA9IHBhcmVudC5faW5zdGFuY2UucHJvdmlkZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZub2RlO1xuICAgIH1cbiAgICBfYXBwbHlTdHlsZXMoc3R5bGVzKSB7XG4gICAgICAgIGlmIChzdHlsZXMpIHtcbiAgICAgICAgICAgIHN0eWxlcy5mb3JFYWNoKGNzcyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICAgICAgcy50ZXh0Q29udGVudCA9IGNzcztcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQocyk7XG4gICAgICAgICAgICAgICAgLy8gcmVjb3JkIGZvciBITVJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLl9zdHlsZXMgfHwgKHRoaXMuX3N0eWxlcyA9IFtdKSkucHVzaChzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVnVlRWxlbWVudCA9IFZ1ZUVsZW1lbnQ7XG5mdW5jdGlvbiB1c2VDc3NNb2R1bGUobmFtZSA9ICckc3R5bGUnKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gKDAsIHJ1bnRpbWVfY29yZV8xLmdldEN1cnJlbnRJbnN0YW5jZSkoKTtcbiAgICAgICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICgwLCBydW50aW1lX2NvcmVfMS53YXJuKShgdXNlQ3NzTW9kdWxlIG11c3QgYmUgY2FsbGVkIGluc2lkZSBzZXR1cCgpYCk7XG4gICAgICAgICAgICByZXR1cm4gc2hhcmVkXzEuRU1QVFlfT0JKO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZHVsZXMgPSBpbnN0YW5jZS50eXBlLl9fY3NzTW9kdWxlcztcbiAgICAgICAgaWYgKCFtb2R1bGVzKSB7XG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgKDAsIHJ1bnRpbWVfY29yZV8xLndhcm4pKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZXMgaW5qZWN0ZWQuYCk7XG4gICAgICAgICAgICByZXR1cm4gc2hhcmVkXzEuRU1QVFlfT0JKO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZCA9IG1vZHVsZXNbbmFtZV07XG4gICAgICAgIGlmICghbW9kKSB7XG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICAoMCwgcnVudGltZV9jb3JlXzEud2FybikoYEN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBDU1MgbW9kdWxlIG5hbWVkIFwiJHtuYW1lfVwiLmApO1xuICAgICAgICAgICAgcmV0dXJuIHNoYXJlZF8xLkVNUFRZX09CSjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kO1xuICAgIH1cbn1cbmV4cG9ydHMudXNlQ3NzTW9kdWxlID0gdXNlQ3NzTW9kdWxlO1xuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgU0ZDJ3MgQ1NTIHZhcmlhYmxlIGluamVjdGlvbiBmZWF0dXJlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdXNlQ3NzVmFycyhnZXR0ZXIpIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9ICgwLCBydW50aW1lX2NvcmVfMS5nZXRDdXJyZW50SW5zdGFuY2UpKCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgKDAsIHJ1bnRpbWVfY29yZV8xLndhcm4pKGB1c2VDc3NWYXJzIGlzIGNhbGxlZCB3aXRob3V0IGN1cnJlbnQgYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZS5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVUZWxlcG9ydHMgPSAoaW5zdGFuY2UudXQgPSAodmFycyA9IGdldHRlcihpbnN0YW5jZS5wcm94eSkpID0+IHtcbiAgICAgICAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS12LW93bmVyPVwiJHtpbnN0YW5jZS51aWR9XCJdYCkpLmZvckVhY2gobm9kZSA9PiBzZXRWYXJzT25Ob2RlKG5vZGUsIHZhcnMpKTtcbiAgICB9KTtcbiAgICBjb25zdCBzZXRWYXJzID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB2YXJzID0gZ2V0dGVyKGluc3RhbmNlLnByb3h5KTtcbiAgICAgICAgc2V0VmFyc09uVk5vZGUoaW5zdGFuY2Uuc3ViVHJlZSwgdmFycyk7XG4gICAgICAgIHVwZGF0ZVRlbGVwb3J0cyh2YXJzKTtcbiAgICB9O1xuICAgICgwLCBydW50aW1lX2NvcmVfMS53YXRjaFBvc3RFZmZlY3QpKHNldFZhcnMpO1xuICAgICgwLCBydW50aW1lX2NvcmVfMS5vbk1vdW50ZWQpKCgpID0+IHtcbiAgICAgICAgY29uc3Qgb2IgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihzZXRWYXJzKTtcbiAgICAgICAgb2Iub2JzZXJ2ZShpbnN0YW5jZS5zdWJUcmVlLmVsLnBhcmVudE5vZGUsIHsgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgICAgICAoMCwgcnVudGltZV9jb3JlXzEub25Vbm1vdW50ZWQpKCgpID0+IG9iLmRpc2Nvbm5lY3QoKSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnVzZUNzc1ZhcnMgPSB1c2VDc3NWYXJzO1xuZnVuY3Rpb24gc2V0VmFyc09uVk5vZGUodm5vZGUsIHZhcnMpIHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNoYXBlRmxhZ3MuU1VTUEVOU0UgKi8pIHtcbiAgICAgICAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZTtcbiAgICAgICAgdm5vZGUgPSBzdXNwZW5zZS5hY3RpdmVCcmFuY2g7XG4gICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmICFzdXNwZW5zZS5pc0h5ZHJhdGluZykge1xuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRWYXJzT25WTm9kZShzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIHZhcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZHJpbGwgZG93biBIT0NzIHVudGlsIGl0J3MgYSBub24tY29tcG9uZW50IHZub2RlXG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudCkge1xuICAgICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudC5zdWJUcmVlO1xuICAgIH1cbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAvKiBTaGFwZUZsYWdzLkVMRU1FTlQgKi8gJiYgdm5vZGUuZWwpIHtcbiAgICAgICAgc2V0VmFyc09uTm9kZSh2bm9kZS5lbCwgdmFycyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZub2RlLnR5cGUgPT09IHJ1bnRpbWVfY29yZV8xLkZyYWdtZW50KSB7XG4gICAgICAgIHZub2RlLmNoaWxkcmVuLmZvckVhY2goYyA9PiBzZXRWYXJzT25WTm9kZShjLCB2YXJzKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZub2RlLnR5cGUgPT09IHJ1bnRpbWVfY29yZV8xLlN0YXRpYykge1xuICAgICAgICBsZXQgeyBlbCwgYW5jaG9yIH0gPSB2bm9kZTtcbiAgICAgICAgd2hpbGUgKGVsKSB7XG4gICAgICAgICAgICBzZXRWYXJzT25Ob2RlKGVsLCB2YXJzKTtcbiAgICAgICAgICAgIGlmIChlbCA9PT0gYW5jaG9yKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZWwgPSBlbC5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNldFZhcnNPbk5vZGUoZWwsIHZhcnMpIHtcbiAgICBpZiAoZWwubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFycykge1xuICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoYC0tJHtrZXl9YCwgdmFyc1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG5jb25zdCBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcbi8vIERPTSBUcmFuc2l0aW9uIGlzIGEgaGlnaGVyLW9yZGVyLWNvbXBvbmVudCBiYXNlZCBvbiB0aGUgcGxhdGZvcm0tYWdub3N0aWNcbi8vIGJhc2UgVHJhbnNpdGlvbiBjb21wb25lbnQsIHdpdGggRE9NLXNwZWNpZmljIGxvZ2ljLlxuY29uc3QgVHJhbnNpdGlvbiA9IChwcm9wcywgeyBzbG90cyB9KSA9PiAoMCwgcnVudGltZV9jb3JlXzEuaCkocnVudGltZV9jb3JlXzEuQmFzZVRyYW5zaXRpb24sIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocHJvcHMpLCBzbG90cyk7XG5leHBvcnRzLlRyYW5zaXRpb24gPSBUcmFuc2l0aW9uO1xuVHJhbnNpdGlvbi5kaXNwbGF5TmFtZSA9ICdUcmFuc2l0aW9uJztcbmNvbnN0IERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSB7XG4gICAgbmFtZTogU3RyaW5nLFxuICAgIHR5cGU6IFN0cmluZyxcbiAgICBjc3M6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgZHVyYXRpb246IFtTdHJpbmcsIE51bWJlciwgT2JqZWN0XSxcbiAgICBlbnRlckZyb21DbGFzczogU3RyaW5nLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgICBhcHBlYXJGcm9tQ2xhc3M6IFN0cmluZyxcbiAgICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgICBsZWF2ZUZyb21DbGFzczogU3RyaW5nLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBsZWF2ZVRvQ2xhc3M6IFN0cmluZ1xufTtcbmNvbnN0IFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMgPSAoVHJhbnNpdGlvbi5wcm9wcyA9XG4gICAgLyojX19QVVJFX18qLyAoMCwgc2hhcmVkXzEuZXh0ZW5kKSh7fSwgcnVudGltZV9jb3JlXzEuQmFzZVRyYW5zaXRpb24ucHJvcHMsIERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMpKTtcbi8qKlxuICogIzMyMjcgSW5jb21pbmcgaG9va3MgbWF5IGJlIG1lcmdlZCBpbnRvIGFycmF5cyB3aGVuIHdyYXBwaW5nIFRyYW5zaXRpb25cbiAqIHdpdGggY3VzdG9tIEhPQ3MuXG4gKi9cbmNvbnN0IGNhbGxIb29rID0gKGhvb2ssIGFyZ3MgPSBbXSkgPT4ge1xuICAgIGlmICgoMCwgc2hhcmVkXzEuaXNBcnJheSkoaG9vaykpIHtcbiAgICAgICAgaG9vay5mb3JFYWNoKGggPT4gaCguLi5hcmdzKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhvb2spIHtcbiAgICAgICAgaG9vayguLi5hcmdzKTtcbiAgICB9XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIGhvb2sgZXhwZWN0cyBhIGNhbGxiYWNrICgybmQgYXJnKSwgd2hpY2ggbWVhbnMgdGhlIHVzZXJcbiAqIGludGVuZHMgdG8gZXhwbGljaXRseSBjb250cm9sIHRoZSBlbmQgb2YgdGhlIHRyYW5zaXRpb24uXG4gKi9cbmNvbnN0IGhhc0V4cGxpY2l0Q2FsbGJhY2sgPSAoaG9vaykgPT4ge1xuICAgIHJldHVybiBob29rXG4gICAgICAgID8gKDAsIHNoYXJlZF8xLmlzQXJyYXkpKGhvb2spXG4gICAgICAgICAgICA/IGhvb2suc29tZShoID0+IGgubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIDogaG9vay5sZW5ndGggPiAxXG4gICAgICAgIDogZmFsc2U7XG59O1xuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcykge1xuICAgIGNvbnN0IGJhc2VQcm9wcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd1Byb3BzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzKSkge1xuICAgICAgICAgICAgYmFzZVByb3BzW2tleV0gPSByYXdQcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyYXdQcm9wcy5jc3MgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBiYXNlUHJvcHM7XG4gICAgfVxuICAgIGNvbnN0IHsgbmFtZSA9ICd2JywgdHlwZSwgZHVyYXRpb24sIGVudGVyRnJvbUNsYXNzID0gYCR7bmFtZX0tZW50ZXItZnJvbWAsIGVudGVyQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci1hY3RpdmVgLCBlbnRlclRvQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci10b2AsIGFwcGVhckZyb21DbGFzcyA9IGVudGVyRnJvbUNsYXNzLCBhcHBlYXJBY3RpdmVDbGFzcyA9IGVudGVyQWN0aXZlQ2xhc3MsIGFwcGVhclRvQ2xhc3MgPSBlbnRlclRvQ2xhc3MsIGxlYXZlRnJvbUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtZnJvbWAsIGxlYXZlQWN0aXZlQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS1hY3RpdmVgLCBsZWF2ZVRvQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS10b2AgfSA9IHJhd1Byb3BzO1xuICAgIGNvbnN0IGR1cmF0aW9ucyA9IG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICBjb25zdCBlbnRlckR1cmF0aW9uID0gZHVyYXRpb25zICYmIGR1cmF0aW9uc1swXTtcbiAgICBjb25zdCBsZWF2ZUR1cmF0aW9uID0gZHVyYXRpb25zICYmIGR1cmF0aW9uc1sxXTtcbiAgICBjb25zdCB7IG9uQmVmb3JlRW50ZXIsIG9uRW50ZXIsIG9uRW50ZXJDYW5jZWxsZWQsIG9uTGVhdmUsIG9uTGVhdmVDYW5jZWxsZWQsIG9uQmVmb3JlQXBwZWFyID0gb25CZWZvcmVFbnRlciwgb25BcHBlYXIgPSBvbkVudGVyLCBvbkFwcGVhckNhbmNlbGxlZCA9IG9uRW50ZXJDYW5jZWxsZWQgfSA9IGJhc2VQcm9wcztcbiAgICBjb25zdCBmaW5pc2hFbnRlciA9IChlbCwgaXNBcHBlYXIsIGRvbmUpID0+IHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyQWN0aXZlQ2xhc3MgOiBlbnRlckFjdGl2ZUNsYXNzKTtcbiAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgfTtcbiAgICBjb25zdCBmaW5pc2hMZWF2ZSA9IChlbCwgZG9uZSkgPT4ge1xuICAgICAgICBlbC5faXNMZWF2aW5nID0gZmFsc2U7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgIH07XG4gICAgY29uc3QgbWFrZUVudGVySG9vayA9IChpc0FwcGVhcikgPT4ge1xuICAgICAgICByZXR1cm4gKGVsLCBkb25lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBob29rID0gaXNBcHBlYXIgPyBvbkFwcGVhciA6IG9uRW50ZXI7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlID0gKCkgPT4gZmluaXNoRW50ZXIoZWwsIGlzQXBwZWFyLCBkb25lKTtcbiAgICAgICAgICAgIGNhbGxIb29rKGhvb2ssIFtlbCwgcmVzb2x2ZV0pO1xuICAgICAgICAgICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyRnJvbUNsYXNzIDogZW50ZXJGcm9tQ2xhc3MpO1xuICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2soaG9vaykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBlbnRlckR1cmF0aW9uLCByZXNvbHZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiAoMCwgc2hhcmVkXzEuZXh0ZW5kKShiYXNlUHJvcHMsIHtcbiAgICAgICAgb25CZWZvcmVFbnRlcihlbCkge1xuICAgICAgICAgICAgY2FsbEhvb2sob25CZWZvcmVFbnRlciwgW2VsXSk7XG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyRnJvbUNsYXNzKTtcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgZW50ZXJBY3RpdmVDbGFzcyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQmVmb3JlQXBwZWFyKGVsKSB7XG4gICAgICAgICAgICBjYWxsSG9vayhvbkJlZm9yZUFwcGVhciwgW2VsXSk7XG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFwcGVhckZyb21DbGFzcyk7XG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFwcGVhckFjdGl2ZUNsYXNzKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FbnRlcjogbWFrZUVudGVySG9vayhmYWxzZSksXG4gICAgICAgIG9uQXBwZWFyOiBtYWtlRW50ZXJIb29rKHRydWUpLFxuICAgICAgICBvbkxlYXZlKGVsLCBkb25lKSB7XG4gICAgICAgICAgICBlbC5faXNMZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmUgPSAoKSA9PiBmaW5pc2hMZWF2ZShlbCwgZG9uZSk7XG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcbiAgICAgICAgICAgIC8vIGZvcmNlIHJlZmxvdyBzbyAqLWxlYXZlLWZyb20gY2xhc3NlcyBpbW1lZGlhdGVseSB0YWtlIGVmZmVjdCAoIzI1OTMpXG4gICAgICAgICAgICBmb3JjZVJlZmxvdygpO1xuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbC5faXNMZWF2aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbmNlbGxlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xuICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2sob25MZWF2ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBsZWF2ZUR1cmF0aW9uLCByZXNvbHZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmUsIFtlbCwgcmVzb2x2ZV0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkVudGVyQ2FuY2VsbGVkKGVsKSB7XG4gICAgICAgICAgICBmaW5pc2hFbnRlcihlbCwgZmFsc2UpO1xuICAgICAgICAgICAgY2FsbEhvb2sob25FbnRlckNhbmNlbGxlZCwgW2VsXSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQXBwZWFyQ2FuY2VsbGVkKGVsKSB7XG4gICAgICAgICAgICBmaW5pc2hFbnRlcihlbCwgdHJ1ZSk7XG4gICAgICAgICAgICBjYWxsSG9vayhvbkFwcGVhckNhbmNlbGxlZCwgW2VsXSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTGVhdmVDYW5jZWxsZWQoZWwpIHtcbiAgICAgICAgICAgIGZpbmlzaExlYXZlKGVsKTtcbiAgICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVEdXJhdGlvbihkdXJhdGlvbikge1xuICAgIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgc2hhcmVkXzEuaXNPYmplY3QpKGR1cmF0aW9uKSkge1xuICAgICAgICByZXR1cm4gW051bWJlck9mKGR1cmF0aW9uLmVudGVyKSwgTnVtYmVyT2YoZHVyYXRpb24ubGVhdmUpXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG4gPSBOdW1iZXJPZihkdXJhdGlvbik7XG4gICAgICAgIHJldHVybiBbbiwgbl07XG4gICAgfVxufVxuZnVuY3Rpb24gTnVtYmVyT2YodmFsKSB7XG4gICAgY29uc3QgcmVzID0gKDAsIHNoYXJlZF8xLnRvTnVtYmVyKSh2YWwpO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgKDAsIHJ1bnRpbWVfY29yZV8xLmFzc2VydE51bWJlcikocmVzLCAnPHRyYW5zaXRpb24+IGV4cGxpY2l0IGR1cmF0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xuICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGVsLmNsYXNzTGlzdC5hZGQoYykpO1xuICAgIChlbC5fdnRjIHx8XG4gICAgICAgIChlbC5fdnRjID0gbmV3IFNldCgpKSkuYWRkKGNscyk7XG59XG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xuICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGVsLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xuICAgIGNvbnN0IHsgX3Z0YyB9ID0gZWw7XG4gICAgaWYgKF92dGMpIHtcbiAgICAgICAgX3Z0Yy5kZWxldGUoY2xzKTtcbiAgICAgICAgaWYgKCFfdnRjLnNpemUpIHtcbiAgICAgICAgICAgIGVsLl92dGMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBuZXh0RnJhbWUoY2IpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpO1xuICAgIH0pO1xufVxubGV0IGVuZElkID0gMDtcbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgZXhwZWN0ZWRUeXBlLCBleHBsaWNpdFRpbWVvdXQsIHJlc29sdmUpIHtcbiAgICBjb25zdCBpZCA9IChlbC5fZW5kSWQgPSArK2VuZElkKTtcbiAgICBjb25zdCByZXNvbHZlSWZOb3RTdGFsZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKGlkID09PSBlbC5fZW5kSWQpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKGV4cGxpY2l0VGltZW91dCkge1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlSWZOb3RTdGFsZSwgZXhwbGljaXRUaW1lb3V0KTtcbiAgICB9XG4gICAgY29uc3QgeyB0eXBlLCB0aW1lb3V0LCBwcm9wQ291bnQgfSA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICAgIGlmICghdHlwZSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBlbmRFdmVudCA9IHR5cGUgKyAnZW5kJztcbiAgICBsZXQgZW5kZWQgPSAwO1xuICAgIGNvbnN0IGVuZCA9ICgpID0+IHtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgb25FbmQpO1xuICAgICAgICByZXNvbHZlSWZOb3RTdGFsZSgpO1xuICAgIH07XG4gICAgY29uc3Qgb25FbmQgPSAoZSkgPT4ge1xuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGVsICYmICsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgICAgICBlbmQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgICAgICAgZW5kKCk7XG4gICAgICAgIH1cbiAgICB9LCB0aW1lb3V0ICsgMSk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgb25FbmQpO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSkge1xuICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gICAgY29uc3QgZ2V0U3R5bGVQcm9wZXJ0aWVzID0gKGtleSkgPT4gKHN0eWxlc1trZXldIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke1RSQU5TSVRJT059RGVsYXlgKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke1RSQU5TSVRJT059RHVyYXRpb25gKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gICAgY29uc3QgYW5pbWF0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke0FOSU1BVElPTn1EZWxheWApO1xuICAgIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9ucyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtBTklNQVRJT059RHVyYXRpb25gKTtcbiAgICBjb25zdCBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG4gICAgbGV0IHR5cGUgPSBudWxsO1xuICAgIGxldCB0aW1lb3V0ID0gMDtcbiAgICBsZXQgcHJvcENvdW50ID0gMDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgICAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICAgICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgICAgICB0eXBlID1cbiAgICAgICAgICAgIHRpbWVvdXQgPiAwXG4gICAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgICAgICAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgICAgICAgICAgICAgIDogQU5JTUFUSU9OXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICAgICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgICAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgICAgICA6IDA7XG4gICAgfVxuICAgIGNvbnN0IGhhc1RyYW5zZm9ybSA9IHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICAgICAgL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLy50ZXN0KGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfVByb3BlcnR5YCkudG9TdHJpbmcoKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdGltZW91dCxcbiAgICAgICAgcHJvcENvdW50LFxuICAgICAgICBoYXNUcmFuc2Zvcm1cbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0VGltZW91dChkZWxheXMsIGR1cmF0aW9ucykge1xuICAgIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgICAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1heCguLi5kdXJhdGlvbnMubWFwKChkLCBpKSA9PiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pKSk7XG59XG4vLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlclxuLy8gbnVtYmVycyBpbiBhIGxvY2FsZS1kZXBlbmRlbnQgd2F5LCB1c2luZyBhIGNvbW1hIGluc3RlYWQgb2YgYSBkb3QuXG4vLyBJZiBjb21tYSBpcyBub3QgcmVwbGFjZWQgd2l0aCBhIGRvdCwgdGhlIGlucHV0IHdpbGwgYmUgcm91bmRlZCBkb3duXG4vLyAoaS5lLiBhY3RpbmcgYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xuZnVuY3Rpb24gdG9NcyhzKSB7XG4gICAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKS5yZXBsYWNlKCcsJywgJy4nKSkgKiAxMDAwO1xufVxuLy8gc3luY2hyb25vdXNseSBmb3JjZSBsYXlvdXQgdG8gcHV0IGVsZW1lbnRzIGludG8gYSBjZXJ0YWluIHN0YXRlXG5mdW5jdGlvbiBmb3JjZVJlZmxvdygpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG59XG5jb25zdCBwb3NpdGlvbk1hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBuZXdQb3NpdGlvbk1hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBUcmFuc2l0aW9uR3JvdXBJbXBsID0ge1xuICAgIG5hbWU6ICdUcmFuc2l0aW9uR3JvdXAnLFxuICAgIHByb3BzOiAvKiNfX1BVUkVfXyovICgwLCBzaGFyZWRfMS5leHRlbmQpKHt9LCBUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCB7XG4gICAgICAgIHRhZzogU3RyaW5nLFxuICAgICAgICBtb3ZlQ2xhc3M6IFN0cmluZ1xuICAgIH0pLFxuICAgIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSAoMCwgcnVudGltZV9jb3JlXzEuZ2V0Q3VycmVudEluc3RhbmNlKSgpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9ICgwLCBydW50aW1lX2NvcmVfMS51c2VUcmFuc2l0aW9uU3RhdGUpKCk7XG4gICAgICAgIGxldCBwcmV2Q2hpbGRyZW47XG4gICAgICAgIGxldCBjaGlsZHJlbjtcbiAgICAgICAgKDAsIHJ1bnRpbWVfY29yZV8xLm9uVXBkYXRlZCkoKCkgPT4ge1xuICAgICAgICAgICAgLy8gY2hpbGRyZW4gaXMgZ3VhcmFudGVlZCB0byBleGlzdCBhZnRlciBpbml0aWFsIHJlbmRlclxuICAgICAgICAgICAgaWYgKCFwcmV2Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW92ZUNsYXNzID0gcHJvcHMubW92ZUNsYXNzIHx8IGAke3Byb3BzLm5hbWUgfHwgJ3YnfS1tb3ZlYDtcbiAgICAgICAgICAgIGlmICghaGFzQ1NTVHJhbnNmb3JtKHByZXZDaGlsZHJlblswXS5lbCwgaW5zdGFuY2Uudm5vZGUuZWwsIG1vdmVDbGFzcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAgICAgICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgICAgICAgICAgcHJldkNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgICAgICAgICAgcHJldkNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgICAgICAgICAgY29uc3QgbW92ZWRDaGlsZHJlbiA9IHByZXZDaGlsZHJlbi5maWx0ZXIoYXBwbHlUcmFuc2xhdGlvbik7XG4gICAgICAgICAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAgICAgICAgIGZvcmNlUmVmbG93KCk7XG4gICAgICAgICAgICBtb3ZlZENoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWwgPSBjLmVsO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IHN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gKGVsLl9tb3ZlQ2IgPSAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgY2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgY2IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmF3UHJvcHMgPSAoMCwgcnVudGltZV9jb3JlXzEudG9SYXcpKHByb3BzKTtcbiAgICAgICAgICAgIGNvbnN0IGNzc1RyYW5zaXRpb25Qcm9wcyA9IHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocmF3UHJvcHMpO1xuICAgICAgICAgICAgbGV0IHRhZyA9IHJhd1Byb3BzLnRhZyB8fCBydW50aW1lX2NvcmVfMS5GcmFnbWVudDtcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ID8gKDAsIHJ1bnRpbWVfY29yZV8xLmdldFRyYW5zaXRpb25SYXdDaGlsZHJlbikoc2xvdHMuZGVmYXVsdCgpKSA6IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBydW50aW1lX2NvcmVfMS5zZXRUcmFuc2l0aW9uSG9va3MpKGNoaWxkLCAoMCwgcnVudGltZV9jb3JlXzEucmVzb2x2ZVRyYW5zaXRpb25Ib29rcykoY2hpbGQsIGNzc1RyYW5zaXRpb25Qcm9wcywgc3RhdGUsIGluc3RhbmNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgcnVudGltZV9jb3JlXzEud2FybikoYDxUcmFuc2l0aW9uR3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gcHJldkNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICAoMCwgcnVudGltZV9jb3JlXzEuc2V0VHJhbnNpdGlvbkhvb2tzKShjaGlsZCwgKDAsIHJ1bnRpbWVfY29yZV8xLnJlc29sdmVUcmFuc2l0aW9uSG9va3MpKGNoaWxkLCBjc3NUcmFuc2l0aW9uUHJvcHMsIHN0YXRlLCBpbnN0YW5jZSkpO1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoY2hpbGQsIGNoaWxkLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIHJ1bnRpbWVfY29yZV8xLmNyZWF0ZVZOb2RlKSh0YWcsIG51bGwsIGNoaWxkcmVuKTtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuLyoqXG4gKiBUcmFuc2l0aW9uR3JvdXAgZG9lcyBub3Qgc3VwcG9ydCBcIm1vZGVcIiBzbyB3ZSBuZWVkIHRvIHJlbW92ZSBpdCBmcm9tIHRoZVxuICogcHJvcHMgZGVjbGFyYXRpb25zLCBidXQgZGlyZWN0IGRlbGV0ZSBvcGVyYXRpb24gaXMgY29uc2lkZXJlZCBhIHNpZGUgZWZmZWN0XG4gKiBhbmQgd2lsbCBtYWtlIHRoZSBlbnRpcmUgdHJhbnNpdGlvbiBmZWF0dXJlIG5vbi10cmVlLXNoYWtlYWJsZSwgc28gd2UgZG8gaXRcbiAqIGluIGEgZnVuY3Rpb24gYW5kIG1hcmsgdGhlIGZ1bmN0aW9uJ3MgaW52b2NhdGlvbiBhcyBwdXJlLlxuICovXG5jb25zdCByZW1vdmVNb2RlID0gKHByb3BzKSA9PiBkZWxldGUgcHJvcHMubW9kZTtcbi8qI19fUFVSRV9fKi8gcmVtb3ZlTW9kZShUcmFuc2l0aW9uR3JvdXBJbXBsLnByb3BzKTtcbmNvbnN0IFRyYW5zaXRpb25Hcm91cCA9IFRyYW5zaXRpb25Hcm91cEltcGw7XG5leHBvcnRzLlRyYW5zaXRpb25Hcm91cCA9IFRyYW5zaXRpb25Hcm91cDtcbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzKGMpIHtcbiAgICBjb25zdCBlbCA9IGMuZWw7XG4gICAgaWYgKGVsLl9tb3ZlQ2IpIHtcbiAgICAgICAgZWwuX21vdmVDYigpO1xuICAgIH1cbiAgICBpZiAoZWwuX2VudGVyQ2IpIHtcbiAgICAgICAgZWwuX2VudGVyQ2IoKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbihjKSB7XG4gICAgbmV3UG9zaXRpb25NYXAuc2V0KGMsIGMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xufVxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbihjKSB7XG4gICAgY29uc3Qgb2xkUG9zID0gcG9zaXRpb25NYXAuZ2V0KGMpO1xuICAgIGNvbnN0IG5ld1BvcyA9IG5ld1Bvc2l0aW9uTWFwLmdldChjKTtcbiAgICBjb25zdCBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gICAgY29uc3QgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgICBpZiAoZHggfHwgZHkpIHtcbiAgICAgICAgY29uc3QgcyA9IGMuZWwuc3R5bGU7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy53ZWJraXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZHh9cHgsJHtkeX1weClgO1xuICAgICAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0NTU1RyYW5zZm9ybShlbCwgcm9vdCwgbW92ZUNsYXNzKSB7XG4gICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgY29uc3QgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICBpZiAoZWwuX3Z0Yykge1xuICAgICAgICBlbC5fdnRjLmZvckVhY2goY2xzID0+IHtcbiAgICAgICAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbW92ZUNsYXNzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChjID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LmFkZChjKSk7XG4gICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBjb25zdCBjb250YWluZXIgPSAocm9vdC5ub2RlVHlwZSA9PT0gMSA/IHJvb3QgOiByb290LnBhcmVudE5vZGUpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgY29uc3QgeyBoYXNUcmFuc2Zvcm0gfSA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgIHJldHVybiBoYXNUcmFuc2Zvcm07XG59XG5jb25zdCBnZXRNb2RlbEFzc2lnbmVyID0gKHZub2RlKSA9PiB7XG4gICAgY29uc3QgZm4gPSB2bm9kZS5wcm9wc1snb25VcGRhdGU6bW9kZWxWYWx1ZSddIHx8XG4gICAgICAgIChmYWxzZSk7XG4gICAgcmV0dXJuICgwLCBzaGFyZWRfMS5pc0FycmF5KShmbikgPyB2YWx1ZSA9PiAoMCwgc2hhcmVkXzEuaW52b2tlQXJyYXlGbnMpKGZuLCB2YWx1ZSkgOiBmbjtcbn07XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQoZSkge1xuICAgIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kKGUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICBpZiAodGFyZ2V0LmNvbXBvc2luZykge1xuICAgICAgICB0YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnKSk7XG4gICAgfVxufVxuLy8gV2UgYXJlIGV4cG9ydGluZyB0aGUgdi1tb2RlbCBydW50aW1lIGRpcmVjdGx5IGFzIHZub2RlIGhvb2tzIHNvIHRoYXQgaXQgY2FuXG4vLyBiZSB0cmVlLXNoYWtlbiBpbiBjYXNlIHYtbW9kZWwgaXMgbmV2ZXIgdXNlZC5cbmNvbnN0IHZNb2RlbFRleHQgPSB7XG4gICAgY3JlYXRlZChlbCwgeyBtb2RpZmllcnM6IHsgbGF6eSwgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgICAgICBjb25zdCBjYXN0VG9OdW1iZXIgPSBudW1iZXIgfHwgKHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGUgPT09ICdudW1iZXInKTtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbGF6eSA/ICdjaGFuZ2UnIDogJ2lucHV0JywgZSA9PiB7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQuY29tcG9zaW5nKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBkb21WYWx1ZSA9IGVsLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRyaW0pIHtcbiAgICAgICAgICAgICAgICBkb21WYWx1ZSA9IGRvbVZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYXN0VG9OdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBkb21WYWx1ZSA9ICgwLCBzaGFyZWRfMS5sb29zZVRvTnVtYmVyKShkb21WYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbC5fYXNzaWduKGRvbVZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0cmltKSB7XG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGVsLnZhbHVlID0gZWwudmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYXp5KSB7XG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cbiAgICAgICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvLyBzZXQgdmFsdWUgb24gbW91bnRlZCBzbyBpdCdzIGFmdGVyIG1pbi9tYXggZm9yIHR5cGU9XCJyYW5nZVwiXG4gICAgbW91bnRlZChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgICAgIGVsLnZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG4gICAgfSxcbiAgICBiZWZvcmVVcGRhdGUoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBsYXp5LCB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgICAgIC8vIGF2b2lkIGNsZWFyaW5nIHVucmVzb2x2ZWQgdGV4dC4gIzIzMDJcbiAgICAgICAgaWYgKGVsLmNvbXBvc2luZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsICYmIGVsLnR5cGUgIT09ICdyYW5nZScpIHtcbiAgICAgICAgICAgIGlmIChsYXp5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyaW0gJiYgZWwudmFsdWUudHJpbSgpID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobnVtYmVyIHx8IGVsLnR5cGUgPT09ICdudW1iZXInKSAmJlxuICAgICAgICAgICAgICAgICgwLCBzaGFyZWRfMS5sb29zZVRvTnVtYmVyKShlbC52YWx1ZSkgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG4gICAgICAgIGlmIChlbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGVsLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0cy52TW9kZWxUZXh0ID0gdk1vZGVsVGV4dDtcbmNvbnN0IHZNb2RlbENoZWNrYm94ID0ge1xuICAgIC8vICM0MDk2IGFycmF5IGNoZWNrYm94ZXMgbmVlZCB0byBiZSBkZWVwIHRyYXZlcnNlZFxuICAgIGRlZXA6IHRydWUsXG4gICAgY3JlYXRlZChlbCwgXywgdm5vZGUpIHtcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9kZWxWYWx1ZSA9IGVsLl9tb2RlbFZhbHVlO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudFZhbHVlID0gZ2V0VmFsdWUoZWwpO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IGVsLmNoZWNrZWQ7XG4gICAgICAgICAgICBjb25zdCBhc3NpZ24gPSBlbC5fYXNzaWduO1xuICAgICAgICAgICAgaWYgKCgwLCBzaGFyZWRfMS5pc0FycmF5KShtb2RlbFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gKDAsIHNoYXJlZF8xLmxvb3NlSW5kZXhPZikobW9kZWxWYWx1ZSwgZWxlbWVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZCA9IGluZGV4ICE9PSAtMTtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZCAmJiAhZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduKG1vZGVsVmFsdWUuY29uY2F0KGVsZW1lbnRWYWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY2hlY2tlZCAmJiBmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IFsuLi5tb2RlbFZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduKGZpbHRlcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoMCwgc2hhcmVkXzEuaXNTZXQpKG1vZGVsVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvbmVkID0gbmV3IFNldChtb2RlbFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBjbG9uZWQuYWRkKGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjbG9uZWQuZGVsZXRlKGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzc2lnbihjbG9uZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNzaWduKGdldENoZWNrYm94VmFsdWUoZWwsIGNoZWNrZWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBzZXQgaW5pdGlhbCBjaGVja2VkIG9uIG1vdW50IHRvIHdhaXQgZm9yIHRydWUtdmFsdWUvZmFsc2UtdmFsdWVcbiAgICBtb3VudGVkOiBzZXRDaGVja2VkLFxuICAgIGJlZm9yZVVwZGF0ZShlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgICAgICBzZXRDaGVja2VkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgfVxufTtcbmV4cG9ydHMudk1vZGVsQ2hlY2tib3ggPSB2TW9kZWxDaGVja2JveDtcbmZ1bmN0aW9uIHNldENoZWNrZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XG4gICAgZWwuX21vZGVsVmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAoKDAsIHNoYXJlZF8xLmlzQXJyYXkpKHZhbHVlKSkge1xuICAgICAgICBlbC5jaGVja2VkID0gKDAsIHNoYXJlZF8xLmxvb3NlSW5kZXhPZikodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgc2hhcmVkXzEuaXNTZXQpKHZhbHVlKSkge1xuICAgICAgICBlbC5jaGVja2VkID0gdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSAoMCwgc2hhcmVkXzEubG9vc2VFcXVhbCkodmFsdWUsIGdldENoZWNrYm94VmFsdWUoZWwsIHRydWUpKTtcbiAgICB9XG59XG5jb25zdCB2TW9kZWxSYWRpbyA9IHtcbiAgICBjcmVhdGVkKGVsLCB7IHZhbHVlIH0sIHZub2RlKSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSAoMCwgc2hhcmVkXzEubG9vc2VFcXVhbCkodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKTtcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgZWwuX2Fzc2lnbihnZXRWYWx1ZShlbCkpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgdm5vZGUpIHtcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICAgICAgICBlbC5jaGVja2VkID0gKDAsIHNoYXJlZF8xLmxvb3NlRXF1YWwpKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0cy52TW9kZWxSYWRpbyA9IHZNb2RlbFJhZGlvO1xuY29uc3Qgdk1vZGVsU2VsZWN0ID0ge1xuICAgIC8vIDxzZWxlY3QgbXVsdGlwbGU+IHZhbHVlIG5lZWQgdG8gYmUgZGVlcCB0cmF2ZXJzZWRcbiAgICBkZWVwOiB0cnVlLFxuICAgIGNyZWF0ZWQoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgICAgICBjb25zdCBpc1NldE1vZGVsID0gKDAsIHNoYXJlZF8xLmlzU2V0KSh2YWx1ZSk7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZFZhbCA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXJcbiAgICAgICAgICAgICAgICAuY2FsbChlbC5vcHRpb25zLCAobykgPT4gby5zZWxlY3RlZClcbiAgICAgICAgICAgICAgICAubWFwKChvKSA9PiBudW1iZXIgPyAoMCwgc2hhcmVkXzEubG9vc2VUb051bWJlcikoZ2V0VmFsdWUobykpIDogZ2V0VmFsdWUobykpO1xuICAgICAgICAgICAgZWwuX2Fzc2lnbihlbC5tdWx0aXBsZVxuICAgICAgICAgICAgICAgID8gaXNTZXRNb2RlbFxuICAgICAgICAgICAgICAgICAgICA/IG5ldyBTZXQoc2VsZWN0ZWRWYWwpXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZWN0ZWRWYWxcbiAgICAgICAgICAgICAgICA6IHNlbGVjdGVkVmFsWzBdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICB9LFxuICAgIC8vIHNldCB2YWx1ZSBpbiBtb3VudGVkICYgdXBkYXRlZCBiZWNhdXNlIDxzZWxlY3Q+IHJlbGllcyBvbiBpdHMgY2hpbGRyZW5cbiAgICAvLyA8b3B0aW9uPnMuXG4gICAgbW91bnRlZChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBiZWZvcmVVcGRhdGUoZWwsIF9iaW5kaW5nLCB2bm9kZSkge1xuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgfSxcbiAgICB1cGRhdGVkKGVsLCB7IHZhbHVlIH0pIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKTtcbiAgICB9XG59O1xuZXhwb3J0cy52TW9kZWxTZWxlY3QgPSB2TW9kZWxTZWxlY3Q7XG5mdW5jdGlvbiBzZXRTZWxlY3RlZChlbCwgdmFsdWUpIHtcbiAgICBjb25zdCBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gICAgaWYgKGlzTXVsdGlwbGUgJiYgISgwLCBzaGFyZWRfMS5pc0FycmF5KSh2YWx1ZSkgJiYgISgwLCBzaGFyZWRfMS5pc1NldCkodmFsdWUpKSB7XG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgKDAsIHJ1bnRpbWVfY29yZV8xLndhcm4pKGA8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw+IGV4cGVjdHMgYW4gQXJyYXkgb3IgU2V0IHZhbHVlIGZvciBpdHMgYmluZGluZywgYCArXG4gICAgICAgICAgICAgICAgYGJ1dCBnb3QgJHtPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKX0uYCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb25zdCBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgICAgICBjb25zdCBvcHRpb25WYWx1ZSA9IGdldFZhbHVlKG9wdGlvbik7XG4gICAgICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICAgICAgICBpZiAoKDAsIHNoYXJlZF8xLmlzQXJyYXkpKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9ICgwLCBzaGFyZWRfMS5sb29zZUluZGV4T2YpKHZhbHVlLCBvcHRpb25WYWx1ZSkgPiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmhhcyhvcHRpb25WYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKDAsIHNoYXJlZF8xLmxvb3NlRXF1YWwpKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKVxuICAgICAgICAgICAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc011bHRpcGxlICYmIGVsLnNlbGVjdGVkSW5kZXggIT09IC0xKSB7XG4gICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICB9XG59XG4vLyByZXRyaWV2ZSByYXcgdmFsdWUgc2V0IHZpYSA6dmFsdWUgYmluZGluZ3NcbmZ1bmN0aW9uIGdldFZhbHVlKGVsKSB7XG4gICAgcmV0dXJuICdfdmFsdWUnIGluIGVsID8gZWwuX3ZhbHVlIDogZWwudmFsdWU7XG59XG4vLyByZXRyaWV2ZSByYXcgdmFsdWUgZm9yIHRydWUtdmFsdWUgYW5kIGZhbHNlLXZhbHVlIHNldCB2aWEgOnRydWUtdmFsdWUgb3IgOmZhbHNlLXZhbHVlIGJpbmRpbmdzXG5mdW5jdGlvbiBnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSB7XG4gICAgY29uc3Qga2V5ID0gY2hlY2tlZCA/ICdfdHJ1ZVZhbHVlJyA6ICdfZmFsc2VWYWx1ZSc7XG4gICAgcmV0dXJuIGtleSBpbiBlbCA/IGVsW2tleV0gOiBjaGVja2VkO1xufVxuY29uc3Qgdk1vZGVsRHluYW1pYyA9IHtcbiAgICBjcmVhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgICAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgbnVsbCwgJ2NyZWF0ZWQnKTtcbiAgICB9LFxuICAgIG1vdW50ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCAnbW91bnRlZCcpO1xuICAgIH0sXG4gICAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XG4gICAgICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9LFxuICAgIHVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG59O1xuZXhwb3J0cy52TW9kZWxEeW5hbWljID0gdk1vZGVsRHluYW1pYztcbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljTW9kZWwodGFnTmFtZSwgdHlwZSkge1xuICAgIHN3aXRjaCAodGFnTmFtZSkge1xuICAgICAgICBjYXNlICdTRUxFQ1QnOlxuICAgICAgICAgICAgcmV0dXJuIHZNb2RlbFNlbGVjdDtcbiAgICAgICAgY2FzZSAnVEVYVEFSRUEnOlxuICAgICAgICAgICAgcmV0dXJuIHZNb2RlbFRleHQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2TW9kZWxDaGVja2JveDtcbiAgICAgICAgICAgICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2TW9kZWxSYWRpbztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdk1vZGVsVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBob29rKSB7XG4gICAgY29uc3QgbW9kZWxUb1VzZSA9IHJlc29sdmVEeW5hbWljTW9kZWwoZWwudGFnTmFtZSwgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZSk7XG4gICAgY29uc3QgZm4gPSBtb2RlbFRvVXNlW2hvb2tdO1xuICAgIGZuICYmIGZuKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKTtcbn1cbi8vIFNTUiB2bm9kZSB0cmFuc2Zvcm1zLCBvbmx5IHVzZWQgd2hlbiB1c2VyIGluY2x1ZGVzIGNsaWVudC1vcmllbnRlZCByZW5kZXJcbi8vIGZ1bmN0aW9uIGluIFNTUlxuZnVuY3Rpb24gaW5pdFZNb2RlbEZvclNTUigpIHtcbiAgICB2TW9kZWxUZXh0LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSkgPT4gKHsgdmFsdWUgfSk7XG4gICAgdk1vZGVsUmFkaW8uZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9LCB2bm9kZSkgPT4ge1xuICAgICAgICBpZiAodm5vZGUucHJvcHMgJiYgKDAsIHNoYXJlZF8xLmxvb3NlRXF1YWwpKHZub2RlLnByb3BzLnZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdk1vZGVsQ2hlY2tib3guZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9LCB2bm9kZSkgPT4ge1xuICAgICAgICBpZiAoKDAsIHNoYXJlZF8xLmlzQXJyYXkpKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHZub2RlLnByb3BzICYmICgwLCBzaGFyZWRfMS5sb29zZUluZGV4T2YpKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwgc2hhcmVkXzEuaXNTZXQpKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHZub2RlLnByb3BzICYmIHZhbHVlLmhhcyh2bm9kZS5wcm9wcy52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdk1vZGVsRHluYW1pYy5nZXRTU1JQcm9wcyA9IChiaW5kaW5nLCB2bm9kZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZub2RlLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWxUb1VzZSA9IHJlc29sdmVEeW5hbWljTW9kZWwoXG4gICAgICAgIC8vIHJlc29sdmVEeW5hbWljTW9kZWwgZXhwZWN0cyBhbiB1cHBlcmNhc2UgdGFnIG5hbWUsIGJ1dCB2bm9kZS50eXBlIGlzIGxvd2VyY2FzZVxuICAgICAgICB2bm9kZS50eXBlLnRvVXBwZXJDYXNlKCksIHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGUpO1xuICAgICAgICBpZiAobW9kZWxUb1VzZS5nZXRTU1JQcm9wcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsVG9Vc2UuZ2V0U1NSUHJvcHMoYmluZGluZywgdm5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IHN5c3RlbU1vZGlmaWVycyA9IFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddO1xuY29uc3QgbW9kaWZpZXJHdWFyZHMgPSB7XG4gICAgc3RvcDogZSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpLFxuICAgIHByZXZlbnQ6IGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpLFxuICAgIHNlbGY6IGUgPT4gZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldCxcbiAgICBjdHJsOiBlID0+ICFlLmN0cmxLZXksXG4gICAgc2hpZnQ6IGUgPT4gIWUuc2hpZnRLZXksXG4gICAgYWx0OiBlID0+ICFlLmFsdEtleSxcbiAgICBtZXRhOiBlID0+ICFlLm1ldGFLZXksXG4gICAgbGVmdDogZSA9PiAnYnV0dG9uJyBpbiBlICYmIGUuYnV0dG9uICE9PSAwLFxuICAgIG1pZGRsZTogZSA9PiAnYnV0dG9uJyBpbiBlICYmIGUuYnV0dG9uICE9PSAxLFxuICAgIHJpZ2h0OiBlID0+ICdidXR0b24nIGluIGUgJiYgZS5idXR0b24gIT09IDIsXG4gICAgZXhhY3Q6IChlLCBtb2RpZmllcnMpID0+IHN5c3RlbU1vZGlmaWVycy5zb21lKG0gPT4gZVtgJHttfUtleWBdICYmICFtb2RpZmllcnMuaW5jbHVkZXMobSkpXG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB3aXRoTW9kaWZpZXJzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcbiAgICByZXR1cm4gKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kaWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBndWFyZCA9IG1vZGlmaWVyR3VhcmRzW21vZGlmaWVyc1tpXV07XG4gICAgICAgICAgICBpZiAoZ3VhcmQgJiYgZ3VhcmQoZXZlbnQsIG1vZGlmaWVycykpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbihldmVudCwgLi4uYXJncyk7XG4gICAgfTtcbn07XG5leHBvcnRzLndpdGhNb2RpZmllcnMgPSB3aXRoTW9kaWZpZXJzO1xuLy8gS2VwdCBmb3IgMi54IGNvbXBhdC5cbi8vIE5vdGU6IElFMTEgY29tcGF0IGZvciBgc3BhY2ViYXJgIGFuZCBgZGVsYCBpcyByZW1vdmVkIGZvciBub3cuXG5jb25zdCBrZXlOYW1lcyA9IHtcbiAgICBlc2M6ICdlc2NhcGUnLFxuICAgIHNwYWNlOiAnICcsXG4gICAgdXA6ICdhcnJvdy11cCcsXG4gICAgbGVmdDogJ2Fycm93LWxlZnQnLFxuICAgIHJpZ2h0OiAnYXJyb3ctcmlnaHQnLFxuICAgIGRvd246ICdhcnJvdy1kb3duJyxcbiAgICBkZWxldGU6ICdiYWNrc3BhY2UnXG59O1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB3aXRoS2V5cyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoISgna2V5JyBpbiBldmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudEtleSA9ICgwLCBzaGFyZWRfMS5oeXBoZW5hdGUpKGV2ZW50LmtleSk7XG4gICAgICAgIGlmIChtb2RpZmllcnMuc29tZShrID0+IGsgPT09IGV2ZW50S2V5IHx8IGtleU5hbWVzW2tdID09PSBldmVudEtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmbihldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmV4cG9ydHMud2l0aEtleXMgPSB3aXRoS2V5cztcbmNvbnN0IHZTaG93ID0ge1xuICAgIGJlZm9yZU1vdW50KGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XG4gICAgICAgIGVsLl92b2QgPSBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xuICAgICAgICBpZiAodHJhbnNpdGlvbiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgdHJhbnNpdGlvbi5lbnRlcihlbCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHVwZGF0ZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XG4gICAgICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgICAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5sZWF2ZShlbCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXREaXNwbGF5KGVsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJlZm9yZVVubW91bnQoZWwsIHsgdmFsdWUgfSkge1xuICAgICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XG4gICAgfVxufTtcbmV4cG9ydHMudlNob3cgPSB2U2hvdztcbmZ1bmN0aW9uIHNldERpc3BsYXkoZWwsIHZhbHVlKSB7XG4gICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX3ZvZCA6ICdub25lJztcbn1cbi8vIFNTUiB2bm9kZSB0cmFuc2Zvcm1zLCBvbmx5IHVzZWQgd2hlbiB1c2VyIGluY2x1ZGVzIGNsaWVudC1vcmllbnRlZCByZW5kZXJcbi8vIGZ1bmN0aW9uIGluIFNTUlxuZnVuY3Rpb24gaW5pdFZTaG93Rm9yU1NSKCkge1xuICAgIHZTaG93LmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSkgPT4ge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdHlsZTogeyBkaXNwbGF5OiAnbm9uZScgfSB9O1xuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IC8qI19fUFVSRV9fKi8gKDAsIHNoYXJlZF8xLmV4dGVuZCkoeyBwYXRjaFByb3AgfSwgbm9kZU9wcyk7XG4vLyBsYXp5IGNyZWF0ZSB0aGUgcmVuZGVyZXIgLSB0aGlzIG1ha2VzIGNvcmUgcmVuZGVyZXIgbG9naWMgdHJlZS1zaGFrYWJsZVxuLy8gaW4gY2FzZSB0aGUgdXNlciBvbmx5IGltcG9ydHMgcmVhY3Rpdml0eSB1dGlsaXRpZXMgZnJvbSBWdWUuXG5sZXQgcmVuZGVyZXI7XG5sZXQgZW5hYmxlZEh5ZHJhdGlvbiA9IGZhbHNlO1xuZnVuY3Rpb24gZW5zdXJlUmVuZGVyZXIoKSB7XG4gICAgcmV0dXJuIChyZW5kZXJlciB8fFxuICAgICAgICAocmVuZGVyZXIgPSAoMCwgcnVudGltZV9jb3JlXzEuY3JlYXRlUmVuZGVyZXIpKHJlbmRlcmVyT3B0aW9ucykpKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkge1xuICAgIHJlbmRlcmVyID0gZW5hYmxlZEh5ZHJhdGlvblxuICAgICAgICA/IHJlbmRlcmVyXG4gICAgICAgIDogKDAsIHJ1bnRpbWVfY29yZV8xLmNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKShyZW5kZXJlck9wdGlvbnMpO1xuICAgIGVuYWJsZWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHJldHVybiByZW5kZXJlcjtcbn1cbi8vIHVzZSBleHBsaWNpdCB0eXBlIGNhc3RzIGhlcmUgdG8gYXZvaWQgaW1wb3J0KCkgY2FsbHMgaW4gcm9sbGVkLXVwIGQudHNcbmNvbnN0IHJlbmRlciA9ICgoLi4uYXJncykgPT4ge1xuICAgIGVuc3VyZVJlbmRlcmVyKCkucmVuZGVyKC4uLmFyZ3MpO1xufSk7XG5leHBvcnRzLnJlbmRlciA9IHJlbmRlcjtcbmNvbnN0IGh5ZHJhdGUgPSAoKC4uLmFyZ3MpID0+IHtcbiAgICBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmh5ZHJhdGUoLi4uYXJncyk7XG59KTtcbmV4cG9ydHMuaHlkcmF0ZSA9IGh5ZHJhdGU7XG5jb25zdCBjcmVhdGVBcHAgPSAoKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBhcHAgPSBlbnN1cmVSZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XG4gICAgICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XG4gICAgfVxuICAgIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcbiAgICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyT3JTZWxlY3Rvcik7XG4gICAgICAgIGlmICghY29udGFpbmVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBhcHAuX2NvbXBvbmVudDtcbiAgICAgICAgaWYgKCEoMCwgc2hhcmVkXzEuaXNGdW5jdGlvbikoY29tcG9uZW50KSAmJiAhY29tcG9uZW50LnJlbmRlciAmJiAhY29tcG9uZW50LnRlbXBsYXRlKSB7XG4gICAgICAgICAgICAvLyBfX1VOU0FGRV9fXG4gICAgICAgICAgICAvLyBSZWFzb246IHBvdGVudGlhbCBleGVjdXRpb24gb2YgSlMgZXhwcmVzc2lvbnMgaW4gaW4tRE9NIHRlbXBsYXRlLlxuICAgICAgICAgICAgLy8gVGhlIHVzZXIgbXVzdCBtYWtlIHN1cmUgdGhlIGluLURPTSB0ZW1wbGF0ZSBpcyB0cnVzdGVkLiBJZiBpdCdzXG4gICAgICAgICAgICAvLyByZW5kZXJlZCBieSB0aGUgc2VydmVyLCB0aGUgdGVtcGxhdGUgc2hvdWxkIG5vdCBjb250YWluIGFueSB1c2VyIGRhdGEuXG4gICAgICAgICAgICBjb21wb25lbnQudGVtcGxhdGUgPSBjb250YWluZXIuaW5uZXJIVE1MO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNsZWFyIGNvbnRlbnQgYmVmb3JlIG1vdW50aW5nXG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgY29uc3QgcHJveHkgPSBtb3VudChjb250YWluZXIsIGZhbHNlLCBjb250YWluZXIgaW5zdGFuY2VvZiBTVkdFbGVtZW50KTtcbiAgICAgICAgaWYgKGNvbnRhaW5lciBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ3YtY2xvYWsnKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2RhdGEtdi1hcHAnLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3h5O1xuICAgIH07XG4gICAgcmV0dXJuIGFwcDtcbn0pO1xuZXhwb3J0cy5jcmVhdGVBcHAgPSBjcmVhdGVBcHA7XG5jb25zdCBjcmVhdGVTU1JBcHAgPSAoKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBhcHAgPSBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XG4gICAgICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XG4gICAgfVxuICAgIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcbiAgICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyT3JTZWxlY3Rvcik7XG4gICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBtb3VudChjb250YWluZXIsIHRydWUsIGNvbnRhaW5lciBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYXBwO1xufSk7XG5leHBvcnRzLmNyZWF0ZVNTUkFwcCA9IGNyZWF0ZVNTUkFwcDtcbmZ1bmN0aW9uIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCkge1xuICAgIC8vIEluamVjdCBgaXNOYXRpdmVUYWdgXG4gICAgLy8gdGhpcyBpcyB1c2VkIGZvciBjb21wb25lbnQgbmFtZSB2YWxpZGF0aW9uIChkZXYgb25seSlcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgJ2lzTmF0aXZlVGFnJywge1xuICAgICAgICB2YWx1ZTogKHRhZykgPT4gKDAsIHNoYXJlZF8xLmlzSFRNTFRhZykodGFnKSB8fCAoMCwgc2hhcmVkXzEuaXNTVkdUYWcpKHRhZyksXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0pO1xufVxuLy8gZGV2IG9ubHlcbmZ1bmN0aW9uIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCkge1xuICAgIGlmICgoMCwgcnVudGltZV9jb3JlXzEuaXNSdW50aW1lT25seSkoKSkge1xuICAgICAgICBjb25zdCBpc0N1c3RvbUVsZW1lbnQgPSBhcHAuY29uZmlnLmlzQ3VzdG9tRWxlbWVudDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsICdpc0N1c3RvbUVsZW1lbnQnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzQ3VzdG9tRWxlbWVudDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQoKSB7XG4gICAgICAgICAgICAgICAgKDAsIHJ1bnRpbWVfY29yZV8xLndhcm4pKGBUaGUgXFxgaXNDdXN0b21FbGVtZW50XFxgIGNvbmZpZyBvcHRpb24gaXMgZGVwcmVjYXRlZC4gVXNlIGAgK1xuICAgICAgICAgICAgICAgICAgICBgXFxgY29tcGlsZXJPcHRpb25zLmlzQ3VzdG9tRWxlbWVudFxcYCBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY29tcGlsZXJPcHRpb25zID0gYXBwLmNvbmZpZy5jb21waWxlck9wdGlvbnM7XG4gICAgICAgIGNvbnN0IG1zZyA9IGBUaGUgXFxgY29tcGlsZXJPcHRpb25zXFxgIGNvbmZpZyBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyBgICtcbiAgICAgICAgICAgIGBhIGJ1aWxkIG9mIFZ1ZS5qcyB0aGF0IGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyIChha2EgXCJmdWxsIGJ1aWxkXCIpLiBgICtcbiAgICAgICAgICAgIGBTaW5jZSB5b3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQsIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBgICtcbiAgICAgICAgICAgIGBtdXN0IGJlIHBhc3NlZCB0byBcXGBAdnVlL2NvbXBpbGVyLWRvbVxcYCBpbiB0aGUgYnVpbGQgc2V0dXAgaW5zdGVhZC5cXG5gICtcbiAgICAgICAgICAgIGAtIEZvciB2dWUtbG9hZGVyOiBwYXNzIGl0IHZpYSB2dWUtbG9hZGVyJ3MgXFxgY29tcGlsZXJPcHRpb25zXFxgIGxvYWRlciBvcHRpb24uXFxuYCArXG4gICAgICAgICAgICBgLSBGb3IgdnVlLWNsaTogc2VlIGh0dHBzOi8vY2xpLnZ1ZWpzLm9yZy9ndWlkZS93ZWJwYWNrLmh0bWwjbW9kaWZ5aW5nLW9wdGlvbnMtb2YtYS1sb2FkZXJcXG5gICtcbiAgICAgICAgICAgIGAtIEZvciB2aXRlOiBwYXNzIGl0IHZpYSBAdml0ZWpzL3BsdWdpbi12dWUgb3B0aW9ucy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS90cmVlL21haW4vcGFja2FnZXMvcGx1Z2luLXZ1ZSNleGFtcGxlLWZvci1wYXNzaW5nLW9wdGlvbnMtdG8tdnVlY29tcGlsZXItZG9tYDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsICdjb21waWxlck9wdGlvbnMnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgKDAsIHJ1bnRpbWVfY29yZV8xLndhcm4pKG1zZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVyT3B0aW9ucztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQoKSB7XG4gICAgICAgICAgICAgICAgKDAsIHJ1bnRpbWVfY29yZV8xLndhcm4pKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICBpZiAoKDAsIHNoYXJlZF8xLmlzU3RyaW5nKShjb250YWluZXIpKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhcmVzKSB7XG4gICAgICAgICAgICAoMCwgcnVudGltZV9jb3JlXzEud2FybikoYEZhaWxlZCB0byBtb3VudCBhcHA6IG1vdW50IHRhcmdldCBzZWxlY3RvciBcIiR7Y29udGFpbmVyfVwiIHJldHVybmVkIG51bGwuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICB3aW5kb3cuU2hhZG93Um9vdCAmJlxuICAgICAgICBjb250YWluZXIgaW5zdGFuY2VvZiB3aW5kb3cuU2hhZG93Um9vdCAmJlxuICAgICAgICBjb250YWluZXIubW9kZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgKDAsIHJ1bnRpbWVfY29yZV8xLndhcm4pKGBtb3VudGluZyBvbiBhIFNoYWRvd1Jvb3Qgd2l0aCBcXGB7bW9kZTogXCJjbG9zZWRcIn1cXGAgbWF5IGxlYWQgdG8gdW5wcmVkaWN0YWJsZSBidWdzYCk7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXI7XG59XG5sZXQgc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IGluaXREaXJlY3RpdmVzRm9yU1NSID0gKCkgPT4ge1xuICAgIGlmICghc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICBpbml0Vk1vZGVsRm9yU1NSKCk7XG4gICAgICAgIGluaXRWU2hvd0ZvclNTUigpO1xuICAgIH1cbn07XG5leHBvcnRzLmluaXREaXJlY3RpdmVzRm9yU1NSID0gaW5pdERpcmVjdGl2ZXNGb3JTU1I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js\n");

/***/ }),

/***/ "./node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.normalizeProps = exports.normalizeClass = exports.makeMap = exports.looseToNumber = exports.looseIndexOf = exports.looseEqual = exports.isVoidTag = exports.isSymbol = exports.isString = exports.isSpecialBooleanAttr = exports.isSet = exports.isSVGTag = exports.isSSRSafeAttrName = exports.isReservedProp = exports.isRegExp = exports.isPromise = exports.isPlainObject = exports.isOn = exports.isObject = exports.isModelListener = exports.isMap = exports.isKnownSvgAttr = exports.isKnownHtmlAttr = exports.isIntegerKey = exports.isHTMLTag = exports.isGloballyWhitelisted = exports.isFunction = exports.isDate = exports.isBuiltInDirective = exports.isBooleanAttr = exports.isArray = exports.invokeArrayFns = exports.includeBooleanAttr = exports.hyphenate = exports.hasOwn = exports.hasChanged = exports.getGlobalThis = exports.generateCodeFrame = exports.genPropsAccessExp = exports.extend = exports.escapeHtmlComment = exports.escapeHtml = exports.def = exports.capitalize = exports.camelize = exports.PatchFlagNames = exports.NOOP = exports.NO = exports.EMPTY_OBJ = exports.EMPTY_ARR = void 0;\nexports.toTypeString = exports.toRawType = exports.toNumber = exports.toHandlerKey = exports.toDisplayString = exports.stringifyStyle = exports.slotFlagsText = exports.remove = exports.propsToAttrMap = exports.parseStringStyle = exports.objectToString = exports.normalizeStyle = void 0;\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n * IMPORTANT: all calls of this function must be prefixed with\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n * So that rollup can tree-shake them if necessary.\n */\nfunction makeMap(str, expectsLowerCase) {\n  const map = Object.create(null);\n  const list = str.split(',');\n  for (let i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\n}\nexports.makeMap = makeMap;\n/**\n * dev only flag -> name mapping\n */\nconst PatchFlagNames = {\n  [1 /* PatchFlags.TEXT */]: `TEXT`,\n  [2 /* PatchFlags.CLASS */]: `CLASS`,\n  [4 /* PatchFlags.STYLE */]: `STYLE`,\n  [8 /* PatchFlags.PROPS */]: `PROPS`,\n  [16 /* PatchFlags.FULL_PROPS */]: `FULL_PROPS`,\n  [32 /* PatchFlags.HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\n  [64 /* PatchFlags.STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\n  [128 /* PatchFlags.KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\n  [256 /* PatchFlags.UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\n  [512 /* PatchFlags.NEED_PATCH */]: `NEED_PATCH`,\n  [1024 /* PatchFlags.DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\n  [2048 /* PatchFlags.DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\n  [-1 /* PatchFlags.HOISTED */]: `HOISTED`,\n  [-2 /* PatchFlags.BAIL */]: `BAIL`\n};\nexports.PatchFlagNames = PatchFlagNames;\n/**\n * Dev only\n */\nconst slotFlagsText = {\n  [1 /* SlotFlags.STABLE */]: 'STABLE',\n  [2 /* SlotFlags.DYNAMIC */]: 'DYNAMIC',\n  [3 /* SlotFlags.FORWARDED */]: 'FORWARDED'\n};\nexports.slotFlagsText = slotFlagsText;\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' + 'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' + 'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';\nconst isGloballyWhitelisted = /*#__PURE__*/makeMap(GLOBALS_WHITE_LISTED);\nexports.isGloballyWhitelisted = isGloballyWhitelisted;\nconst range = 2;\nfunction generateCodeFrame(source) {\n  let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : source.length;\n  // Split the content into individual lines but capture the newline sequence\n  // that separated each line. This is important because the actual sequence is\n  // needed to properly take into account the full line length for offset\n  // comparison\n  let lines = source.split(/(\\r?\\n)/);\n  // Separate the lines and newline sequences into separate arrays for easier referencing\n  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n  lines = lines.filter((_, idx) => idx % 2 === 0);\n  let count = 0;\n  const res = [];\n  for (let i = 0; i < lines.length; i++) {\n    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);\n    if (count >= start) {\n      for (let j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) continue;\n        const line = j + 1;\n        res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\n        const lineLength = lines[j].length;\n        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;\n        if (j === i) {\n          // push underline\n          const pad = start - (count - (lineLength + newLineSeqLength));\n          const length = Math.max(1, end > count ? lineLength - pad : end - start);\n          res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\n        } else if (j > i) {\n          if (end > count) {\n            const length = Math.max(Math.min(end - count, lineLength), 1);\n            res.push(`   |  ` + '^'.repeat(length));\n          }\n          count += lineLength + newLineSeqLength;\n        }\n      }\n      break;\n    }\n  }\n  return res.join('\\n');\n}\nexports.generateCodeFrame = generateCodeFrame;\nfunction normalizeStyle(value) {\n  if (isArray(value)) {\n    const res = {};\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i];\n      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);\n      if (normalized) {\n        for (const key in normalized) {\n          res[key] = normalized[key];\n        }\n      }\n    }\n    return res;\n  } else if (isString(value)) {\n    return value;\n  } else if (isObject(value)) {\n    return value;\n  }\n}\nexports.normalizeStyle = normalizeStyle;\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*.*?\\*\\//gs;\nfunction parseStringStyle(cssText) {\n  const ret = {};\n  cssText.replace(styleCommentRE, '').split(listDelimiterRE).forEach(item => {\n    if (item) {\n      const tmp = item.split(propertyDelimiterRE);\n      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return ret;\n}\nexports.parseStringStyle = parseStringStyle;\nfunction stringifyStyle(styles) {\n  let ret = '';\n  if (!styles || isString(styles)) {\n    return ret;\n  }\n  for (const key in styles) {\n    const value = styles[key];\n    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n    if (isString(value) || typeof value === 'number') {\n      // only render valid values\n      ret += `${normalizedKey}:${value};`;\n    }\n  }\n  return ret;\n}\nexports.stringifyStyle = stringifyStyle;\nfunction normalizeClass(value) {\n  let res = '';\n  if (isString(value)) {\n    res = value;\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const normalized = normalizeClass(value[i]);\n      if (normalized) {\n        res += normalized + ' ';\n      }\n    }\n  } else if (isObject(value)) {\n    for (const name in value) {\n      if (value[name]) {\n        res += name + ' ';\n      }\n    }\n  }\n  return res.trim();\n}\nexports.normalizeClass = normalizeClass;\nfunction normalizeProps(props) {\n  if (!props) return null;\n  let {\n    class: klass,\n    style\n  } = props;\n  if (klass && !isString(klass)) {\n    props.class = normalizeClass(klass);\n  }\n  if (style) {\n    props.style = normalizeStyle(style);\n  }\n  return props;\n}\nexports.normalizeProps = normalizeProps;\n// These tag configs are shared between compiler-dom and runtime-dom, so they\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\nconst HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' + 'header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' + 'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' + 'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' + 'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' + 'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' + 'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' + 'option,output,progress,select,textarea,details,dialog,menu,' + 'summary,template,blockquote,iframe,tfoot';\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\nconst SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' + 'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' + 'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' + 'feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' + 'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' + 'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' + 'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' + 'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' + 'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' + 'text,textPath,title,tspan,unknown,use,view';\nconst VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isHTMLTag = /*#__PURE__*/makeMap(HTML_TAGS);\nexports.isHTMLTag = isHTMLTag;\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isSVGTag = /*#__PURE__*/makeMap(SVG_TAGS);\nexports.isSVGTag = isSVGTag;\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isVoidTag = /*#__PURE__*/makeMap(VOID_TAGS);\nexports.isVoidTag = isVoidTag;\n/**\n * On the client we only need to offer special cases for boolean attributes that\n * have different names from their corresponding dom properties:\n * - itemscope -> N/A\n * - allowfullscreen -> allowFullscreen\n * - formnovalidate -> formNoValidate\n * - ismap -> isMap\n * - nomodule -> noModule\n * - novalidate -> noValidate\n * - readonly -> readOnly\n */\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /*#__PURE__*/makeMap(specialBooleanAttrs);\nexports.isSpecialBooleanAttr = isSpecialBooleanAttr;\n/**\n * The full list is needed during SSR to produce the correct initial markup.\n */\nconst isBooleanAttr = /*#__PURE__*/makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` + `loop,open,required,reversed,scoped,seamless,` + `checked,muted,multiple,selected`);\nexports.isBooleanAttr = isBooleanAttr;\n/**\n * Boolean attributes should be included if the value is truthy or ''.\n * e.g. `<select multiple>` compiles to `{ multiple: '' }`\n */\nfunction includeBooleanAttr(value) {\n  return !!value || value === '';\n}\nexports.includeBooleanAttr = includeBooleanAttr;\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n  if (attrValidationCache.hasOwnProperty(name)) {\n    return attrValidationCache[name];\n  }\n  const isUnsafe = unsafeAttrCharRE.test(name);\n  if (isUnsafe) {\n    console.error(`unsafe attribute name: ${name}`);\n  }\n  return attrValidationCache[name] = !isUnsafe;\n}\nexports.isSSRSafeAttrName = isSSRSafeAttrName;\nconst propsToAttrMap = {\n  acceptCharset: 'accept-charset',\n  className: 'class',\n  htmlFor: 'for',\n  httpEquiv: 'http-equiv'\n};\nexports.propsToAttrMap = propsToAttrMap;\n/**\n * Known attributes, this is used for stringification of runtime static nodes\n * so that we don't stringify bindings that cannot be set from HTML.\n * Don't also forget to allow `data-*` and `aria-*`!\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n */\nconst isKnownHtmlAttr = /*#__PURE__*/makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` + `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` + `border,buffered,capture,challenge,charset,checked,cite,class,code,` + `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` + `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` + `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` + `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` + `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` + `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` + `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` + `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` + `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` + `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` + `start,step,style,summary,tabindex,target,title,translate,type,usemap,` + `value,width,wrap`);\nexports.isKnownHtmlAttr = isKnownHtmlAttr;\n/**\n * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute\n */\nconst isKnownSvgAttr = /*#__PURE__*/makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` + `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` + `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` + `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` + `color-interpolation-filters,color-profile,color-rendering,` + `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` + `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` + `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` + `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` + `font-family,font-size,font-size-adjust,font-stretch,font-style,` + `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` + `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` + `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` + `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` + `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` + `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` + `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` + `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` + `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` + `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` + `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` + `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` + `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` + `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` + `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` + `specularConstant,specularExponent,speed,spreadMethod,startOffset,` + `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` + `strikethrough-position,strikethrough-thickness,string,stroke,` + `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` + `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` + `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` + `text-decoration,text-rendering,textLength,to,transform,transform-origin,` + `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` + `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` + `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` + `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` + `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` + `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` + `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);\nexports.isKnownSvgAttr = isKnownSvgAttr;\nconst escapeRE = /[\"'&<>]/;\nfunction escapeHtml(string) {\n  const str = '' + string;\n  const match = escapeRE.exec(str);\n  if (!match) {\n    return str;\n  }\n  let html = '';\n  let escaped;\n  let index;\n  let lastIndex = 0;\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34:\n        // \"\n        escaped = '&quot;';\n        break;\n      case 38:\n        // &\n        escaped = '&amp;';\n        break;\n      case 39:\n        // '\n        escaped = '&#39;';\n        break;\n      case 60:\n        // <\n        escaped = '&lt;';\n        break;\n      case 62:\n        // >\n        escaped = '&gt;';\n        break;\n      default:\n        continue;\n    }\n    if (lastIndex !== index) {\n      html += str.slice(lastIndex, index);\n    }\n    lastIndex = index + 1;\n    html += escaped;\n  }\n  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\nexports.escapeHtml = escapeHtml;\n// https://www.w3.org/TR/html52/syntax.html#comments\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n  return src.replace(commentStripRE, '');\n}\nexports.escapeHtmlComment = escapeHtmlComment;\nfunction looseCompareArrays(a, b) {\n  if (a.length !== b.length) return false;\n  let equal = true;\n  for (let i = 0; equal && i < a.length; i++) {\n    equal = looseEqual(a[i], b[i]);\n  }\n  return equal;\n}\nfunction looseEqual(a, b) {\n  if (a === b) return true;\n  let aValidType = isDate(a);\n  let bValidType = isDate(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n  }\n  aValidType = isSymbol(a);\n  bValidType = isSymbol(b);\n  if (aValidType || bValidType) {\n    return a === b;\n  }\n  aValidType = isArray(a);\n  bValidType = isArray(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n  }\n  aValidType = isObject(a);\n  bValidType = isObject(b);\n  if (aValidType || bValidType) {\n    /* istanbul ignore if: this if will probably never be called */\n    if (!aValidType || !bValidType) {\n      return false;\n    }\n    const aKeysCount = Object.keys(a).length;\n    const bKeysCount = Object.keys(b).length;\n    if (aKeysCount !== bKeysCount) {\n      return false;\n    }\n    for (const key in a) {\n      const aHasKey = a.hasOwnProperty(key);\n      const bHasKey = b.hasOwnProperty(key);\n      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n  }\n  return String(a) === String(b);\n}\nexports.looseEqual = looseEqual;\nfunction looseIndexOf(arr, val) {\n  return arr.findIndex(item => looseEqual(item, val));\n}\nexports.looseIndexOf = looseIndexOf;\n/**\n * For converting {{ interpolation }} values to displayed strings.\n * @private\n */\nconst toDisplayString = val => {\n  return isString(val) ? val : val == null ? '' : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);\n};\nexports.toDisplayString = toDisplayString;\nconst replacer = (_key, val) => {\n  // can't use isRef here since @vue/shared has no deps\n  if (val && val.__v_isRef) {\n    return replacer(_key, val.value);\n  } else if (isMap(val)) {\n    return {\n      [`Map(${val.size})`]: [...val.entries()].reduce((entries, _ref) => {\n        let [key, val] = _ref;\n        entries[`${key} =>`] = val;\n        return entries;\n      }, {})\n    };\n  } else if (isSet(val)) {\n    return {\n      [`Set(${val.size})`]: [...val.values()]\n    };\n  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n    return String(val);\n  }\n  return val;\n};\nconst EMPTY_OBJ =  true ? Object.freeze({}) : 0;\nexports.EMPTY_OBJ = EMPTY_OBJ;\nconst EMPTY_ARR =  true ? Object.freeze([]) : 0;\nexports.EMPTY_ARR = EMPTY_ARR;\nconst NOOP = () => {};\nexports.NOOP = NOOP;\n/**\n * Always return false.\n */\nconst NO = () => false;\nexports.NO = NO;\nconst onRE = /^on[^a-z]/;\nconst isOn = key => onRE.test(key);\nexports.isOn = isOn;\nconst isModelListener = key => key.startsWith('onUpdate:');\nexports.isModelListener = isModelListener;\nconst extend = Object.assign;\nexports.extend = extend;\nconst remove = (arr, el) => {\n  const i = arr.indexOf(el);\n  if (i > -1) {\n    arr.splice(i, 1);\n  }\n};\nexports.remove = remove;\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nexports.hasOwn = hasOwn;\nconst isArray = Array.isArray;\nexports.isArray = isArray;\nconst isMap = val => toTypeString(val) === '[object Map]';\nexports.isMap = isMap;\nconst isSet = val => toTypeString(val) === '[object Set]';\nexports.isSet = isSet;\nconst isDate = val => toTypeString(val) === '[object Date]';\nexports.isDate = isDate;\nconst isRegExp = val => toTypeString(val) === '[object RegExp]';\nexports.isRegExp = isRegExp;\nconst isFunction = val => typeof val === 'function';\nexports.isFunction = isFunction;\nconst isString = val => typeof val === 'string';\nexports.isString = isString;\nconst isSymbol = val => typeof val === 'symbol';\nexports.isSymbol = isSymbol;\nconst isObject = val => val !== null && typeof val === 'object';\nexports.isObject = isObject;\nconst isPromise = val => {\n  return isObject(val) && isFunction(val.then) && isFunction(val.catch);\n};\nexports.isPromise = isPromise;\nconst objectToString = Object.prototype.toString;\nexports.objectToString = objectToString;\nconst toTypeString = value => objectToString.call(value);\nexports.toTypeString = toTypeString;\nconst toRawType = value => {\n  // extract \"RawType\" from strings like \"[object RawType]\"\n  return toTypeString(value).slice(8, -1);\n};\nexports.toRawType = toRawType;\nconst isPlainObject = val => toTypeString(val) === '[object Object]';\nexports.isPlainObject = isPlainObject;\nconst isIntegerKey = key => isString(key) && key !== 'NaN' && key[0] !== '-' && '' + parseInt(key, 10) === key;\nexports.isIntegerKey = isIntegerKey;\nconst isReservedProp = /*#__PURE__*/makeMap(\n// the leading comma is intentional so empty string \"\" is also included\n',key,ref,ref_for,ref_key,' + 'onVnodeBeforeMount,onVnodeMounted,' + 'onVnodeBeforeUpdate,onVnodeUpdated,' + 'onVnodeBeforeUnmount,onVnodeUnmounted');\nexports.isReservedProp = isReservedProp;\nconst isBuiltInDirective = /*#__PURE__*/makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');\nexports.isBuiltInDirective = isBuiltInDirective;\nconst cacheStringFunction = fn => {\n  const cache = Object.create(null);\n  return str => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n};\nconst camelizeRE = /-(\\w)/g;\n/**\n * @private\n */\nconst camelize = cacheStringFunction(str => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : '');\n});\nexports.camelize = camelize;\nconst hyphenateRE = /\\B([A-Z])/g;\n/**\n * @private\n */\nconst hyphenate = cacheStringFunction(str => str.replace(hyphenateRE, '-$1').toLowerCase());\nexports.hyphenate = hyphenate;\n/**\n * @private\n */\nconst capitalize = cacheStringFunction(str => str.charAt(0).toUpperCase() + str.slice(1));\nexports.capitalize = capitalize;\n/**\n * @private\n */\nconst toHandlerKey = cacheStringFunction(str => str ? `on${capitalize(str)}` : ``);\nexports.toHandlerKey = toHandlerKey;\n// compare whether a value has changed, accounting for NaN.\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nexports.hasChanged = hasChanged;\nconst invokeArrayFns = (fns, arg) => {\n  for (let i = 0; i < fns.length; i++) {\n    fns[i](arg);\n  }\n};\nexports.invokeArrayFns = invokeArrayFns;\nconst def = (obj, key, value) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    value\n  });\n};\nexports.def = def;\n/**\n * \"123-foo\" will be parsed to 123\n * This is used for the .number modifier in v-model\n */\nconst looseToNumber = val => {\n  const n = parseFloat(val);\n  return isNaN(n) ? val : n;\n};\nexports.looseToNumber = looseToNumber;\n/**\n * Only conerces number-like strings\n * \"123-foo\" will be returned as-is\n */\nconst toNumber = val => {\n  const n = isString(val) ? Number(val) : NaN;\n  return isNaN(n) ? val : n;\n};\nexports.toNumber = toNumber;\nlet _globalThis;\nconst getGlobalThis = () => {\n  return _globalThis || (_globalThis = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : {});\n};\nexports.getGlobalThis = getGlobalThis;\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;\n}\nexports.genPropsAccessExp = genPropsAccessExp;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYWIvLi9ub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanM/OWZmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubm9ybWFsaXplUHJvcHMgPSBleHBvcnRzLm5vcm1hbGl6ZUNsYXNzID0gZXhwb3J0cy5tYWtlTWFwID0gZXhwb3J0cy5sb29zZVRvTnVtYmVyID0gZXhwb3J0cy5sb29zZUluZGV4T2YgPSBleHBvcnRzLmxvb3NlRXF1YWwgPSBleHBvcnRzLmlzVm9pZFRhZyA9IGV4cG9ydHMuaXNTeW1ib2wgPSBleHBvcnRzLmlzU3RyaW5nID0gZXhwb3J0cy5pc1NwZWNpYWxCb29sZWFuQXR0ciA9IGV4cG9ydHMuaXNTZXQgPSBleHBvcnRzLmlzU1ZHVGFnID0gZXhwb3J0cy5pc1NTUlNhZmVBdHRyTmFtZSA9IGV4cG9ydHMuaXNSZXNlcnZlZFByb3AgPSBleHBvcnRzLmlzUmVnRXhwID0gZXhwb3J0cy5pc1Byb21pc2UgPSBleHBvcnRzLmlzUGxhaW5PYmplY3QgPSBleHBvcnRzLmlzT24gPSBleHBvcnRzLmlzT2JqZWN0ID0gZXhwb3J0cy5pc01vZGVsTGlzdGVuZXIgPSBleHBvcnRzLmlzTWFwID0gZXhwb3J0cy5pc0tub3duU3ZnQXR0ciA9IGV4cG9ydHMuaXNLbm93bkh0bWxBdHRyID0gZXhwb3J0cy5pc0ludGVnZXJLZXkgPSBleHBvcnRzLmlzSFRNTFRhZyA9IGV4cG9ydHMuaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gZXhwb3J0cy5pc0Z1bmN0aW9uID0gZXhwb3J0cy5pc0RhdGUgPSBleHBvcnRzLmlzQnVpbHRJbkRpcmVjdGl2ZSA9IGV4cG9ydHMuaXNCb29sZWFuQXR0ciA9IGV4cG9ydHMuaXNBcnJheSA9IGV4cG9ydHMuaW52b2tlQXJyYXlGbnMgPSBleHBvcnRzLmluY2x1ZGVCb29sZWFuQXR0ciA9IGV4cG9ydHMuaHlwaGVuYXRlID0gZXhwb3J0cy5oYXNPd24gPSBleHBvcnRzLmhhc0NoYW5nZWQgPSBleHBvcnRzLmdldEdsb2JhbFRoaXMgPSBleHBvcnRzLmdlbmVyYXRlQ29kZUZyYW1lID0gZXhwb3J0cy5nZW5Qcm9wc0FjY2Vzc0V4cCA9IGV4cG9ydHMuZXh0ZW5kID0gZXhwb3J0cy5lc2NhcGVIdG1sQ29tbWVudCA9IGV4cG9ydHMuZXNjYXBlSHRtbCA9IGV4cG9ydHMuZGVmID0gZXhwb3J0cy5jYXBpdGFsaXplID0gZXhwb3J0cy5jYW1lbGl6ZSA9IGV4cG9ydHMuUGF0Y2hGbGFnTmFtZXMgPSBleHBvcnRzLk5PT1AgPSBleHBvcnRzLk5PID0gZXhwb3J0cy5FTVBUWV9PQkogPSBleHBvcnRzLkVNUFRZX0FSUiA9IHZvaWQgMDtcbmV4cG9ydHMudG9UeXBlU3RyaW5nID0gZXhwb3J0cy50b1Jhd1R5cGUgPSBleHBvcnRzLnRvTnVtYmVyID0gZXhwb3J0cy50b0hhbmRsZXJLZXkgPSBleHBvcnRzLnRvRGlzcGxheVN0cmluZyA9IGV4cG9ydHMuc3RyaW5naWZ5U3R5bGUgPSBleHBvcnRzLnNsb3RGbGFnc1RleHQgPSBleHBvcnRzLnJlbW92ZSA9IGV4cG9ydHMucHJvcHNUb0F0dHJNYXAgPSBleHBvcnRzLnBhcnNlU3RyaW5nU3R5bGUgPSBleHBvcnRzLm9iamVjdFRvU3RyaW5nID0gZXhwb3J0cy5ub3JtYWxpemVTdHlsZSA9IHZvaWQgMDtcbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqIElNUE9SVEFOVDogYWxsIGNhbGxzIG9mIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBwcmVmaXhlZCB3aXRoXG4gKiBcXC9cXCojXFxfXFxfUFVSRVxcX1xcX1xcKlxcL1xuICogU28gdGhhdCByb2xsdXAgY2FuIHRyZWUtc2hha2UgdGhlbSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAoc3RyLCBleHBlY3RzTG93ZXJDYXNlKSB7XG4gICAgY29uc3QgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBleHBlY3RzTG93ZXJDYXNlID8gdmFsID0+ICEhbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXSA6IHZhbCA9PiAhIW1hcFt2YWxdO1xufVxuZXhwb3J0cy5tYWtlTWFwID0gbWFrZU1hcDtcbi8qKlxuICogZGV2IG9ubHkgZmxhZyAtPiBuYW1lIG1hcHBpbmdcbiAqL1xuY29uc3QgUGF0Y2hGbGFnTmFtZXMgPSB7XG4gICAgWzEgLyogUGF0Y2hGbGFncy5URVhUICovXTogYFRFWFRgLFxuICAgIFsyIC8qIFBhdGNoRmxhZ3MuQ0xBU1MgKi9dOiBgQ0xBU1NgLFxuICAgIFs0IC8qIFBhdGNoRmxhZ3MuU1RZTEUgKi9dOiBgU1RZTEVgLFxuICAgIFs4IC8qIFBhdGNoRmxhZ3MuUFJPUFMgKi9dOiBgUFJPUFNgLFxuICAgIFsxNiAvKiBQYXRjaEZsYWdzLkZVTExfUFJPUFMgKi9dOiBgRlVMTF9QUk9QU2AsXG4gICAgWzMyIC8qIFBhdGNoRmxhZ3MuSFlEUkFURV9FVkVOVFMgKi9dOiBgSFlEUkFURV9FVkVOVFNgLFxuICAgIFs2NCAvKiBQYXRjaEZsYWdzLlNUQUJMRV9GUkFHTUVOVCAqL106IGBTVEFCTEVfRlJBR01FTlRgLFxuICAgIFsxMjggLyogUGF0Y2hGbGFncy5LRVlFRF9GUkFHTUVOVCAqL106IGBLRVlFRF9GUkFHTUVOVGAsXG4gICAgWzI1NiAvKiBQYXRjaEZsYWdzLlVOS0VZRURfRlJBR01FTlQgKi9dOiBgVU5LRVlFRF9GUkFHTUVOVGAsXG4gICAgWzUxMiAvKiBQYXRjaEZsYWdzLk5FRURfUEFUQ0ggKi9dOiBgTkVFRF9QQVRDSGAsXG4gICAgWzEwMjQgLyogUGF0Y2hGbGFncy5EWU5BTUlDX1NMT1RTICovXTogYERZTkFNSUNfU0xPVFNgLFxuICAgIFsyMDQ4IC8qIFBhdGNoRmxhZ3MuREVWX1JPT1RfRlJBR01FTlQgKi9dOiBgREVWX1JPT1RfRlJBR01FTlRgLFxuICAgIFstMSAvKiBQYXRjaEZsYWdzLkhPSVNURUQgKi9dOiBgSE9JU1RFRGAsXG4gICAgWy0yIC8qIFBhdGNoRmxhZ3MuQkFJTCAqL106IGBCQUlMYFxufTtcbmV4cG9ydHMuUGF0Y2hGbGFnTmFtZXMgPSBQYXRjaEZsYWdOYW1lcztcbi8qKlxuICogRGV2IG9ubHlcbiAqL1xuY29uc3Qgc2xvdEZsYWdzVGV4dCA9IHtcbiAgICBbMSAvKiBTbG90RmxhZ3MuU1RBQkxFICovXTogJ1NUQUJMRScsXG4gICAgWzIgLyogU2xvdEZsYWdzLkRZTkFNSUMgKi9dOiAnRFlOQU1JQycsXG4gICAgWzMgLyogU2xvdEZsYWdzLkZPUldBUkRFRCAqL106ICdGT1JXQVJERUQnXG59O1xuZXhwb3J0cy5zbG90RmxhZ3NUZXh0ID0gc2xvdEZsYWdzVGV4dDtcbmNvbnN0IEdMT0JBTFNfV0hJVEVfTElTVEVEID0gJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4scGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksJyArXG4gICAgJ2RlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LE1hdGgsTnVtYmVyLERhdGUsQXJyYXksJyArXG4gICAgJ09iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsQmlnSW50JztcbmNvbnN0IGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChHTE9CQUxTX1dISVRFX0xJU1RFRCk7XG5leHBvcnRzLmlzR2xvYmFsbHlXaGl0ZWxpc3RlZCA9IGlzR2xvYmFsbHlXaGl0ZWxpc3RlZDtcbmNvbnN0IHJhbmdlID0gMjtcbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lKHNvdXJjZSwgc3RhcnQgPSAwLCBlbmQgPSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgLy8gU3BsaXQgdGhlIGNvbnRlbnQgaW50byBpbmRpdmlkdWFsIGxpbmVzIGJ1dCBjYXB0dXJlIHRoZSBuZXdsaW5lIHNlcXVlbmNlXG4gICAgLy8gdGhhdCBzZXBhcmF0ZWQgZWFjaCBsaW5lLiBUaGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHRoZSBhY3R1YWwgc2VxdWVuY2UgaXNcbiAgICAvLyBuZWVkZWQgdG8gcHJvcGVybHkgdGFrZSBpbnRvIGFjY291bnQgdGhlIGZ1bGwgbGluZSBsZW5ndGggZm9yIG9mZnNldFxuICAgIC8vIGNvbXBhcmlzb25cbiAgICBsZXQgbGluZXMgPSBzb3VyY2Uuc3BsaXQoLyhcXHI/XFxuKS8pO1xuICAgIC8vIFNlcGFyYXRlIHRoZSBsaW5lcyBhbmQgbmV3bGluZSBzZXF1ZW5jZXMgaW50byBzZXBhcmF0ZSBhcnJheXMgZm9yIGVhc2llciByZWZlcmVuY2luZ1xuICAgIGNvbnN0IG5ld2xpbmVTZXF1ZW5jZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMSk7XG4gICAgbGluZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMCk7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvdW50ICs9XG4gICAgICAgICAgICBsaW5lc1tpXS5sZW5ndGggK1xuICAgICAgICAgICAgICAgICgobmV3bGluZVNlcXVlbmNlc1tpXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2ldLmxlbmd0aCkgfHwgMCk7XG4gICAgICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGogKyAxO1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAke2xpbmV9JHsnICcucmVwZWF0KE1hdGgubWF4KDMgLSBTdHJpbmcobGluZSkubGVuZ3RoLCAwKSl9fCAgJHtsaW5lc1tqXX1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmVTZXFMZW5ndGggPSAobmV3bGluZVNlcXVlbmNlc1tqXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2pdLmxlbmd0aCkgfHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoIHVuZGVybGluZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWQgPSBzdGFydCAtIChjb3VudCAtIChsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heCgxLCBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgJyAnLnJlcGVhdChwYWQpICsgJ14nLnJlcGVhdChsZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaiA+IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyAnXicucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXMuam9pbignXFxuJyk7XG59XG5leHBvcnRzLmdlbmVyYXRlQ29kZUZyYW1lID0gZ2VuZXJhdGVDb2RlRnJhbWU7XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZSh2YWx1ZSkge1xuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCByZXMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGlzU3RyaW5nKGl0ZW0pXG4gICAgICAgICAgICAgICAgPyBwYXJzZVN0cmluZ1N0eWxlKGl0ZW0pXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVTdHlsZShpdGVtKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbm9ybWFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZWRba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLm5vcm1hbGl6ZVN0eWxlID0gbm9ybWFsaXplU3R5bGU7XG5jb25zdCBsaXN0RGVsaW1pdGVyUkUgPSAvOyg/IVteKF0qXFwpKS9nO1xuY29uc3QgcHJvcGVydHlEZWxpbWl0ZXJSRSA9IC86KFteXSspLztcbmNvbnN0IHN0eWxlQ29tbWVudFJFID0gL1xcL1xcKi4qP1xcKlxcLy9ncztcbmZ1bmN0aW9uIHBhcnNlU3RyaW5nU3R5bGUoY3NzVGV4dCkge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIGNzc1RleHRcbiAgICAgICAgLnJlcGxhY2Uoc3R5bGVDb21tZW50UkUsICcnKVxuICAgICAgICAuc3BsaXQobGlzdERlbGltaXRlclJFKVxuICAgICAgICAuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXJSRSk7XG4gICAgICAgICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmV0W3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xufVxuZXhwb3J0cy5wYXJzZVN0cmluZ1N0eWxlID0gcGFyc2VTdHJpbmdTdHlsZTtcbmZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlKHN0eWxlcykge1xuICAgIGxldCByZXQgPSAnJztcbiAgICBpZiAoIXN0eWxlcyB8fCBpc1N0cmluZyhzdHlsZXMpKSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHN0eWxlcykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0eWxlc1trZXldO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0ga2V5LnN0YXJ0c1dpdGgoYC0tYCkgPyBrZXkgOiBoeXBoZW5hdGUoa2V5KTtcbiAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBvbmx5IHJlbmRlciB2YWxpZCB2YWx1ZXNcbiAgICAgICAgICAgIHJldCArPSBgJHtub3JtYWxpemVkS2V5fToke3ZhbHVlfTtgO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5leHBvcnRzLnN0cmluZ2lmeVN0eWxlID0gc3RyaW5naWZ5U3R5bGU7XG5mdW5jdGlvbiBub3JtYWxpemVDbGFzcyh2YWx1ZSkge1xuICAgIGxldCByZXMgPSAnJztcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJlcyA9IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplQ2xhc3ModmFsdWVbaV0pO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICByZXMgKz0gbm9ybWFsaXplZCArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZXMgKz0gbmFtZSArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLnRyaW0oKTtcbn1cbmV4cG9ydHMubm9ybWFsaXplQ2xhc3MgPSBub3JtYWxpemVDbGFzcztcbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzKHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XG4gICAgaWYgKGtsYXNzICYmICFpc1N0cmluZyhrbGFzcykpIHtcbiAgICAgICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XG4gICAgfVxuICAgIGlmIChzdHlsZSkge1xuICAgICAgICBwcm9wcy5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BzO1xufVxuZXhwb3J0cy5ub3JtYWxpemVQcm9wcyA9IG5vcm1hbGl6ZVByb3BzO1xuLy8gVGhlc2UgdGFnIGNvbmZpZ3MgYXJlIHNoYXJlZCBiZXR3ZWVuIGNvbXBpbGVyLWRvbSBhbmQgcnVudGltZS1kb20sIHNvIHRoZXlcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudFxuY29uc3QgSFRNTF9UQUdTID0gJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsJyArXG4gICAgJ2hlYWRlcixoZ3JvdXAsaDEsaDIsaDMsaDQsaDUsaDYsbmF2LHNlY3Rpb24sZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sJyArXG4gICAgJ2ZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLGEsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLCcgK1xuICAgICdkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnVieSxzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCwnICtcbiAgICAndGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSwnICtcbiAgICAnY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLGNhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLCcgK1xuICAgICd0aCx0cixidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsJyArXG4gICAgJ29wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsJyArXG4gICAgJ3N1bW1hcnksdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnO1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0VsZW1lbnRcbmNvbnN0IFNWR19UQUdTID0gJ3N2ZyxhbmltYXRlLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxjaXJjbGUsY2xpcFBhdGgsY29sb3ItcHJvZmlsZSwnICtcbiAgICAnZGVmcyxkZXNjLGRpc2NhcmQsZWxsaXBzZSxmZUJsZW5kLGZlQ29sb3JNYXRyaXgsZmVDb21wb25lbnRUcmFuc2ZlciwnICtcbiAgICAnZmVDb21wb3NpdGUsZmVDb252b2x2ZU1hdHJpeCxmZURpZmZ1c2VMaWdodGluZyxmZURpc3BsYWNlbWVudE1hcCwnICtcbiAgICAnZmVEaXN0YW50TGlnaHQsZmVEcm9wU2hhZG93LGZlRmxvb2QsZmVGdW5jQSxmZUZ1bmNCLGZlRnVuY0csZmVGdW5jUiwnICtcbiAgICAnZmVHYXVzc2lhbkJsdXIsZmVJbWFnZSxmZU1lcmdlLGZlTWVyZ2VOb2RlLGZlTW9ycGhvbG9neSxmZU9mZnNldCwnICtcbiAgICAnZmVQb2ludExpZ2h0LGZlU3BlY3VsYXJMaWdodGluZyxmZVNwb3RMaWdodCxmZVRpbGUsZmVUdXJidWxlbmNlLGZpbHRlciwnICtcbiAgICAnZm9yZWlnbk9iamVjdCxnLGhhdGNoLGhhdGNocGF0aCxpbWFnZSxsaW5lLGxpbmVhckdyYWRpZW50LG1hcmtlcixtYXNrLCcgK1xuICAgICdtZXNoLG1lc2hncmFkaWVudCxtZXNocGF0Y2gsbWVzaHJvdyxtZXRhZGF0YSxtcGF0aCxwYXRoLHBhdHRlcm4sJyArXG4gICAgJ3BvbHlnb24scG9seWxpbmUscmFkaWFsR3JhZGllbnQscmVjdCxzZXQsc29saWRjb2xvcixzdG9wLHN3aXRjaCxzeW1ib2wsJyArXG4gICAgJ3RleHQsdGV4dFBhdGgsdGl0bGUsdHNwYW4sdW5rbm93bix1c2Usdmlldyc7XG5jb25zdCBWT0lEX1RBR1MgPSAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxocixpbWcsaW5wdXQsbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInO1xuLyoqXG4gKiBDb21waWxlciBvbmx5LlxuICogRG8gTk9UIHVzZSBpbiBydW50aW1lIGNvZGUgcGF0aHMgdW5sZXNzIGJlaGluZCBgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpYCBmbGFnLlxuICovXG5jb25zdCBpc0hUTUxUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoSFRNTF9UQUdTKTtcbmV4cG9ydHMuaXNIVE1MVGFnID0gaXNIVE1MVGFnO1xuLyoqXG4gKiBDb21waWxlciBvbmx5LlxuICogRG8gTk9UIHVzZSBpbiBydW50aW1lIGNvZGUgcGF0aHMgdW5sZXNzIGJlaGluZCBgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpYCBmbGFnLlxuICovXG5jb25zdCBpc1NWR1RhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChTVkdfVEFHUyk7XG5leHBvcnRzLmlzU1ZHVGFnID0gaXNTVkdUYWc7XG4vKipcbiAqIENvbXBpbGVyIG9ubHkuXG4gKiBEbyBOT1QgdXNlIGluIHJ1bnRpbWUgY29kZSBwYXRocyB1bmxlc3MgYmVoaW5kIGAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylgIGZsYWcuXG4gKi9cbmNvbnN0IGlzVm9pZFRhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChWT0lEX1RBR1MpO1xuZXhwb3J0cy5pc1ZvaWRUYWcgPSBpc1ZvaWRUYWc7XG4vKipcbiAqIE9uIHRoZSBjbGllbnQgd2Ugb25seSBuZWVkIHRvIG9mZmVyIHNwZWNpYWwgY2FzZXMgZm9yIGJvb2xlYW4gYXR0cmlidXRlcyB0aGF0XG4gKiBoYXZlIGRpZmZlcmVudCBuYW1lcyBmcm9tIHRoZWlyIGNvcnJlc3BvbmRpbmcgZG9tIHByb3BlcnRpZXM6XG4gKiAtIGl0ZW1zY29wZSAtPiBOL0FcbiAqIC0gYWxsb3dmdWxsc2NyZWVuIC0+IGFsbG93RnVsbHNjcmVlblxuICogLSBmb3Jtbm92YWxpZGF0ZSAtPiBmb3JtTm9WYWxpZGF0ZVxuICogLSBpc21hcCAtPiBpc01hcFxuICogLSBub21vZHVsZSAtPiBub01vZHVsZVxuICogLSBub3ZhbGlkYXRlIC0+IG5vVmFsaWRhdGVcbiAqIC0gcmVhZG9ubHkgLT4gcmVhZE9ubHlcbiAqL1xuY29uc3Qgc3BlY2lhbEJvb2xlYW5BdHRycyA9IGBpdGVtc2NvcGUsYWxsb3dmdWxsc2NyZWVuLGZvcm1ub3ZhbGlkYXRlLGlzbWFwLG5vbW9kdWxlLG5vdmFsaWRhdGUscmVhZG9ubHlgO1xuY29uc3QgaXNTcGVjaWFsQm9vbGVhbkF0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyk7XG5leHBvcnRzLmlzU3BlY2lhbEJvb2xlYW5BdHRyID0gaXNTcGVjaWFsQm9vbGVhbkF0dHI7XG4vKipcbiAqIFRoZSBmdWxsIGxpc3QgaXMgbmVlZGVkIGR1cmluZyBTU1IgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBpbml0aWFsIG1hcmt1cC5cbiAqL1xuY29uc3QgaXNCb29sZWFuQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzICtcbiAgICBgLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjb250cm9scyxkZWZhdWx0LGRlZmVyLGRpc2FibGVkLGhpZGRlbixgICtcbiAgICBgbG9vcCxvcGVuLHJlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxgICtcbiAgICBgY2hlY2tlZCxtdXRlZCxtdWx0aXBsZSxzZWxlY3RlZGApO1xuZXhwb3J0cy5pc0Jvb2xlYW5BdHRyID0gaXNCb29sZWFuQXR0cjtcbi8qKlxuICogQm9vbGVhbiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBpbmNsdWRlZCBpZiB0aGUgdmFsdWUgaXMgdHJ1dGh5IG9yICcnLlxuICogZS5nLiBgPHNlbGVjdCBtdWx0aXBsZT5gIGNvbXBpbGVzIHRvIGB7IG11bHRpcGxlOiAnJyB9YFxuICovXG5mdW5jdGlvbiBpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSB8fCB2YWx1ZSA9PT0gJyc7XG59XG5leHBvcnRzLmluY2x1ZGVCb29sZWFuQXR0ciA9IGluY2x1ZGVCb29sZWFuQXR0cjtcbmNvbnN0IHVuc2FmZUF0dHJDaGFyUkUgPSAvWz4vPVwiJ1xcdTAwMDlcXHUwMDBhXFx1MDAwY1xcdTAwMjBdLztcbmNvbnN0IGF0dHJWYWxpZGF0aW9uQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzU1NSU2FmZUF0dHJOYW1lKG5hbWUpIHtcbiAgICBpZiAoYXR0clZhbGlkYXRpb25DYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXTtcbiAgICB9XG4gICAgY29uc3QgaXNVbnNhZmUgPSB1bnNhZmVBdHRyQ2hhclJFLnRlc3QobmFtZSk7XG4gICAgaWYgKGlzVW5zYWZlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYHVuc2FmZSBhdHRyaWJ1dGUgbmFtZTogJHtuYW1lfWApO1xuICAgIH1cbiAgICByZXR1cm4gKGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV0gPSAhaXNVbnNhZmUpO1xufVxuZXhwb3J0cy5pc1NTUlNhZmVBdHRyTmFtZSA9IGlzU1NSU2FmZUF0dHJOYW1lO1xuY29uc3QgcHJvcHNUb0F0dHJNYXAgPSB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbn07XG5leHBvcnRzLnByb3BzVG9BdHRyTWFwID0gcHJvcHNUb0F0dHJNYXA7XG4vKipcbiAqIEtub3duIGF0dHJpYnV0ZXMsIHRoaXMgaXMgdXNlZCBmb3Igc3RyaW5naWZpY2F0aW9uIG9mIHJ1bnRpbWUgc3RhdGljIG5vZGVzXG4gKiBzbyB0aGF0IHdlIGRvbid0IHN0cmluZ2lmeSBiaW5kaW5ncyB0aGF0IGNhbm5vdCBiZSBzZXQgZnJvbSBIVE1MLlxuICogRG9uJ3QgYWxzbyBmb3JnZXQgdG8gYWxsb3cgYGRhdGEtKmAgYW5kIGBhcmlhLSpgIVxuICogR2VuZXJhdGVkIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9BdHRyaWJ1dGVzXG4gKi9cbmNvbnN0IGlzS25vd25IdG1sQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgYWNjZXB0LGFjY2VwdC1jaGFyc2V0LGFjY2Vzc2tleSxhY3Rpb24sYWxpZ24sYWxsb3csYWx0LGFzeW5jLGAgK1xuICAgIGBhdXRvY2FwaXRhbGl6ZSxhdXRvY29tcGxldGUsYXV0b2ZvY3VzLGF1dG9wbGF5LGJhY2tncm91bmQsYmdjb2xvcixgICtcbiAgICBgYm9yZGVyLGJ1ZmZlcmVkLGNhcHR1cmUsY2hhbGxlbmdlLGNoYXJzZXQsY2hlY2tlZCxjaXRlLGNsYXNzLGNvZGUsYCArXG4gICAgYGNvZGViYXNlLGNvbG9yLGNvbHMsY29sc3Bhbixjb250ZW50LGNvbnRlbnRlZGl0YWJsZSxjb250ZXh0bWVudSxjb250cm9scyxgICtcbiAgICBgY29vcmRzLGNyb3Nzb3JpZ2luLGNzcCxkYXRhLGRhdGV0aW1lLGRlY29kaW5nLGRlZmF1bHQsZGVmZXIsZGlyLGRpcm5hbWUsYCArXG4gICAgYGRpc2FibGVkLGRvd25sb2FkLGRyYWdnYWJsZSxkcm9wem9uZSxlbmN0eXBlLGVudGVya2V5aGludCxmb3IsZm9ybSxgICtcbiAgICBgZm9ybWFjdGlvbixmb3JtZW5jdHlwZSxmb3JtbWV0aG9kLGZvcm1ub3ZhbGlkYXRlLGZvcm10YXJnZXQsaGVhZGVycyxgICtcbiAgICBgaGVpZ2h0LGhpZGRlbixoaWdoLGhyZWYsaHJlZmxhbmcsaHR0cC1lcXVpdixpY29uLGlkLGltcG9ydGFuY2UsaW50ZWdyaXR5LGAgK1xuICAgIGBpc21hcCxpdGVtcHJvcCxrZXl0eXBlLGtpbmQsbGFiZWwsbGFuZyxsYW5ndWFnZSxsb2FkaW5nLGxpc3QsbG9vcCxsb3csYCArXG4gICAgYG1hbmlmZXN0LG1heCxtYXhsZW5ndGgsbWlubGVuZ3RoLG1lZGlhLG1pbixtdWx0aXBsZSxtdXRlZCxuYW1lLG5vdmFsaWRhdGUsYCArXG4gICAgYG9wZW4sb3B0aW11bSxwYXR0ZXJuLHBpbmcscGxhY2Vob2xkZXIscG9zdGVyLHByZWxvYWQscmFkaW9ncm91cCxyZWFkb25seSxgICtcbiAgICBgcmVmZXJyZXJwb2xpY3kscmVsLHJlcXVpcmVkLHJldmVyc2VkLHJvd3Mscm93c3BhbixzYW5kYm94LHNjb3BlLHNjb3BlZCxgICtcbiAgICBgc2VsZWN0ZWQsc2hhcGUsc2l6ZSxzaXplcyxzbG90LHNwYW4sc3BlbGxjaGVjayxzcmMsc3JjZG9jLHNyY2xhbmcsc3Jjc2V0LGAgK1xuICAgIGBzdGFydCxzdGVwLHN0eWxlLHN1bW1hcnksdGFiaW5kZXgsdGFyZ2V0LHRpdGxlLHRyYW5zbGF0ZSx0eXBlLHVzZW1hcCxgICtcbiAgICBgdmFsdWUsd2lkdGgsd3JhcGApO1xuZXhwb3J0cy5pc0tub3duSHRtbEF0dHIgPSBpc0tub3duSHRtbEF0dHI7XG4vKipcbiAqIEdlbmVyYXRlZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGVcbiAqL1xuY29uc3QgaXNLbm93blN2Z0F0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYHhtbG5zLGFjY2VudC1oZWlnaHQsYWNjdW11bGF0ZSxhZGRpdGl2ZSxhbGlnbm1lbnQtYmFzZWxpbmUsYWxwaGFiZXRpYyxhbXBsaXR1ZGUsYCArXG4gICAgYGFyYWJpYy1mb3JtLGFzY2VudCxhdHRyaWJ1dGVOYW1lLGF0dHJpYnV0ZVR5cGUsYXppbXV0aCxiYXNlRnJlcXVlbmN5LGAgK1xuICAgIGBiYXNlbGluZS1zaGlmdCxiYXNlUHJvZmlsZSxiYm94LGJlZ2luLGJpYXMsYnksY2FsY01vZGUsY2FwLWhlaWdodCxjbGFzcyxgICtcbiAgICBgY2xpcCxjbGlwUGF0aFVuaXRzLGNsaXAtcGF0aCxjbGlwLXJ1bGUsY29sb3IsY29sb3ItaW50ZXJwb2xhdGlvbixgICtcbiAgICBgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzLGNvbG9yLXByb2ZpbGUsY29sb3ItcmVuZGVyaW5nLGAgK1xuICAgIGBjb250ZW50U2NyaXB0VHlwZSxjb250ZW50U3R5bGVUeXBlLGNyb3Nzb3JpZ2luLGN1cnNvcixjeCxjeSxkLGRlY2VsZXJhdGUsYCArXG4gICAgYGRlc2NlbnQsZGlmZnVzZUNvbnN0YW50LGRpcmVjdGlvbixkaXNwbGF5LGRpdmlzb3IsZG9taW5hbnQtYmFzZWxpbmUsZHVyLGR4LGAgK1xuICAgIGBkeSxlZGdlTW9kZSxlbGV2YXRpb24sZW5hYmxlLWJhY2tncm91bmQsZW5kLGV4cG9uZW50LGZpbGwsZmlsbC1vcGFjaXR5LGAgK1xuICAgIGBmaWxsLXJ1bGUsZmlsdGVyLGZpbHRlclJlcyxmaWx0ZXJVbml0cyxmbG9vZC1jb2xvcixmbG9vZC1vcGFjaXR5LGAgK1xuICAgIGBmb250LWZhbWlseSxmb250LXNpemUsZm9udC1zaXplLWFkanVzdCxmb250LXN0cmV0Y2gsZm9udC1zdHlsZSxgICtcbiAgICBgZm9udC12YXJpYW50LGZvbnQtd2VpZ2h0LGZvcm1hdCxmcm9tLGZyLGZ4LGZ5LGcxLGcyLGdseXBoLW5hbWUsYCArXG4gICAgYGdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwsZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwsZ2x5cGhSZWYsYCArXG4gICAgYGdyYWRpZW50VHJhbnNmb3JtLGdyYWRpZW50VW5pdHMsaGFuZ2luZyxoZWlnaHQsaHJlZixocmVmbGFuZyxob3Jpei1hZHYteCxgICtcbiAgICBgaG9yaXotb3JpZ2luLXgsaWQsaWRlb2dyYXBoaWMsaW1hZ2UtcmVuZGVyaW5nLGluLGluMixpbnRlcmNlcHQsayxrMSxrMixrMyxgICtcbiAgICBgazQsa2VybmVsTWF0cml4LGtlcm5lbFVuaXRMZW5ndGgsa2VybmluZyxrZXlQb2ludHMsa2V5U3BsaW5lcyxrZXlUaW1lcyxgICtcbiAgICBgbGFuZyxsZW5ndGhBZGp1c3QsbGV0dGVyLXNwYWNpbmcsbGlnaHRpbmctY29sb3IsbGltaXRpbmdDb25lQW5nbGUsbG9jYWwsYCArXG4gICAgYG1hcmtlci1lbmQsbWFya2VyLW1pZCxtYXJrZXItc3RhcnQsbWFya2VySGVpZ2h0LG1hcmtlclVuaXRzLG1hcmtlcldpZHRoLGAgK1xuICAgIGBtYXNrLG1hc2tDb250ZW50VW5pdHMsbWFza1VuaXRzLG1hdGhlbWF0aWNhbCxtYXgsbWVkaWEsbWV0aG9kLG1pbixtb2RlLGAgK1xuICAgIGBuYW1lLG51bU9jdGF2ZXMsb2Zmc2V0LG9wYWNpdHksb3BlcmF0b3Isb3JkZXIsb3JpZW50LG9yaWVudGF0aW9uLG9yaWdpbixgICtcbiAgICBgb3ZlcmZsb3csb3ZlcmxpbmUtcG9zaXRpb24sb3ZlcmxpbmUtdGhpY2tuZXNzLHBhbm9zZS0xLHBhaW50LW9yZGVyLHBhdGgsYCArXG4gICAgYHBhdGhMZW5ndGgscGF0dGVybkNvbnRlbnRVbml0cyxwYXR0ZXJuVHJhbnNmb3JtLHBhdHRlcm5Vbml0cyxwaW5nLGAgK1xuICAgIGBwb2ludGVyLWV2ZW50cyxwb2ludHMscG9pbnRzQXRYLHBvaW50c0F0WSxwb2ludHNBdFoscHJlc2VydmVBbHBoYSxgICtcbiAgICBgcHJlc2VydmVBc3BlY3RSYXRpbyxwcmltaXRpdmVVbml0cyxyLHJhZGl1cyxyZWZlcnJlclBvbGljeSxyZWZYLHJlZlkscmVsLGAgK1xuICAgIGByZW5kZXJpbmctaW50ZW50LHJlcGVhdENvdW50LHJlcGVhdER1cixyZXF1aXJlZEV4dGVuc2lvbnMscmVxdWlyZWRGZWF0dXJlcyxgICtcbiAgICBgcmVzdGFydCxyZXN1bHQscm90YXRlLHJ4LHJ5LHNjYWxlLHNlZWQsc2hhcGUtcmVuZGVyaW5nLHNsb3BlLHNwYWNpbmcsYCArXG4gICAgYHNwZWN1bGFyQ29uc3RhbnQsc3BlY3VsYXJFeHBvbmVudCxzcGVlZCxzcHJlYWRNZXRob2Qsc3RhcnRPZmZzZXQsYCArXG4gICAgYHN0ZERldmlhdGlvbixzdGVtaCxzdGVtdixzdGl0Y2hUaWxlcyxzdG9wLWNvbG9yLHN0b3Atb3BhY2l0eSxgICtcbiAgICBgc3RyaWtldGhyb3VnaC1wb3NpdGlvbixzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyxzdHJpbmcsc3Ryb2tlLGAgK1xuICAgIGBzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LHN0cm9rZS1saW5lY2FwLHN0cm9rZS1saW5lam9pbixgICtcbiAgICBgc3Ryb2tlLW1pdGVybGltaXQsc3Ryb2tlLW9wYWNpdHksc3Ryb2tlLXdpZHRoLHN0eWxlLHN1cmZhY2VTY2FsZSxgICtcbiAgICBgc3lzdGVtTGFuZ3VhZ2UsdGFiaW5kZXgsdGFibGVWYWx1ZXMsdGFyZ2V0LHRhcmdldFgsdGFyZ2V0WSx0ZXh0LWFuY2hvcixgICtcbiAgICBgdGV4dC1kZWNvcmF0aW9uLHRleHQtcmVuZGVyaW5nLHRleHRMZW5ndGgsdG8sdHJhbnNmb3JtLHRyYW5zZm9ybS1vcmlnaW4sYCArXG4gICAgYHR5cGUsdTEsdTIsdW5kZXJsaW5lLXBvc2l0aW9uLHVuZGVybGluZS10aGlja25lc3MsdW5pY29kZSx1bmljb2RlLWJpZGksYCArXG4gICAgYHVuaWNvZGUtcmFuZ2UsdW5pdHMtcGVyLWVtLHYtYWxwaGFiZXRpYyx2LWhhbmdpbmcsdi1pZGVvZ3JhcGhpYyxgICtcbiAgICBgdi1tYXRoZW1hdGljYWwsdmFsdWVzLHZlY3Rvci1lZmZlY3QsdmVyc2lvbix2ZXJ0LWFkdi15LHZlcnQtb3JpZ2luLXgsYCArXG4gICAgYHZlcnQtb3JpZ2luLXksdmlld0JveCx2aWV3VGFyZ2V0LHZpc2liaWxpdHksd2lkdGgsd2lkdGhzLHdvcmQtc3BhY2luZyxgICtcbiAgICBgd3JpdGluZy1tb2RlLHgseC1oZWlnaHQseDEseDIseENoYW5uZWxTZWxlY3Rvcix4bGluazphY3R1YXRlLHhsaW5rOmFyY3JvbGUsYCArXG4gICAgYHhsaW5rOmhyZWYseGxpbms6cm9sZSx4bGluazpzaG93LHhsaW5rOnRpdGxlLHhsaW5rOnR5cGUseG1sOmJhc2UseG1sOmxhbmcsYCArXG4gICAgYHhtbDpzcGFjZSx5LHkxLHkyLHlDaGFubmVsU2VsZWN0b3Iseix6b29tQW5kUGFuYCk7XG5leHBvcnRzLmlzS25vd25TdmdBdHRyID0gaXNLbm93blN2Z0F0dHI7XG5jb25zdCBlc2NhcGVSRSA9IC9bXCInJjw+XS87XG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICAgIGNvbnN0IHN0ciA9ICcnICsgc3RyaW5nO1xuICAgIGNvbnN0IG1hdGNoID0gZXNjYXBlUkUuZXhlYyhzdHIpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBsZXQgZXNjYXBlZDtcbiAgICBsZXQgaW5kZXg7XG4gICAgbGV0IGxhc3RJbmRleCA9IDA7XG4gICAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpbmRleCkpIHtcbiAgICAgICAgICAgIGNhc2UgMzQ6IC8vIFwiXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmcXVvdDsnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzODogLy8gJlxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJmFtcDsnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOTogLy8gJ1xuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJiMzOTsnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2MDogLy8gPFxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJmx0Oyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYyOiAvLyA+XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmZ3Q7JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgICAgICAgIGh0bWwgKz0gc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgaHRtbCArPSBlc2NhcGVkO1xuICAgIH1cbiAgICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xufVxuZXhwb3J0cy5lc2NhcGVIdG1sID0gZXNjYXBlSHRtbDtcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTIvc3ludGF4Lmh0bWwjY29tbWVudHNcbmNvbnN0IGNvbW1lbnRTdHJpcFJFID0gL14tPz58PCEtLXwtLT58LS0hPnw8IS0kL2c7XG5mdW5jdGlvbiBlc2NhcGVIdG1sQ29tbWVudChzcmMpIHtcbiAgICByZXR1cm4gc3JjLnJlcGxhY2UoY29tbWVudFN0cmlwUkUsICcnKTtcbn1cbmV4cG9ydHMuZXNjYXBlSHRtbENvbW1lbnQgPSBlc2NhcGVIdG1sQ29tbWVudDtcbmZ1bmN0aW9uIGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlcXVhbCA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGVxdWFsICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVxdWFsID0gbG9vc2VFcXVhbChhW2ldLCBiW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGVxdWFsO1xufVxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBhVmFsaWRUeXBlID0gaXNEYXRlKGEpO1xuICAgIGxldCBiVmFsaWRUeXBlID0gaXNEYXRlKGIpO1xuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKSA6IGZhbHNlO1xuICAgIH1cbiAgICBhVmFsaWRUeXBlID0gaXNTeW1ib2woYSk7XG4gICAgYlZhbGlkVHlwZSA9IGlzU3ltYm9sKGIpO1xuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgfVxuICAgIGFWYWxpZFR5cGUgPSBpc0FycmF5KGEpO1xuICAgIGJWYWxpZFR5cGUgPSBpc0FycmF5KGIpO1xuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSA6IGZhbHNlO1xuICAgIH1cbiAgICBhVmFsaWRUeXBlID0gaXNPYmplY3QoYSk7XG4gICAgYlZhbGlkVHlwZSA9IGlzT2JqZWN0KGIpO1xuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiB0aGlzIGlmIHdpbGwgcHJvYmFibHkgbmV2ZXIgYmUgY2FsbGVkICovXG4gICAgICAgIGlmICghYVZhbGlkVHlwZSB8fCAhYlZhbGlkVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhhKS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGJLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhiKS5sZW5ndGg7XG4gICAgICAgIGlmIChhS2V5c0NvdW50ICE9PSBiS2V5c0NvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgICAgICAgICAgY29uc3QgYUhhc0tleSA9IGEuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGJIYXNLZXkgPSBiLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICAgICAgICBpZiAoKGFIYXNLZXkgJiYgIWJIYXNLZXkpIHx8XG4gICAgICAgICAgICAgICAgKCFhSGFzS2V5ICYmIGJIYXNLZXkpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcbn1cbmV4cG9ydHMubG9vc2VFcXVhbCA9IGxvb3NlRXF1YWw7XG5mdW5jdGlvbiBsb29zZUluZGV4T2YoYXJyLCB2YWwpIHtcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChpdGVtID0+IGxvb3NlRXF1YWwoaXRlbSwgdmFsKSk7XG59XG5leHBvcnRzLmxvb3NlSW5kZXhPZiA9IGxvb3NlSW5kZXhPZjtcbi8qKlxuICogRm9yIGNvbnZlcnRpbmcge3sgaW50ZXJwb2xhdGlvbiB9fSB2YWx1ZXMgdG8gZGlzcGxheWVkIHN0cmluZ3MuXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB0b0Rpc3BsYXlTdHJpbmcgPSAodmFsKSA9PiB7XG4gICAgcmV0dXJuIGlzU3RyaW5nKHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB2YWwgPT0gbnVsbFxuICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgOiBpc0FycmF5KHZhbCkgfHxcbiAgICAgICAgICAgICAgICAoaXNPYmplY3QodmFsKSAmJlxuICAgICAgICAgICAgICAgICAgICAodmFsLnRvU3RyaW5nID09PSBvYmplY3RUb1N0cmluZyB8fCAhaXNGdW5jdGlvbih2YWwudG9TdHJpbmcpKSlcbiAgICAgICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgcmVwbGFjZXIsIDIpXG4gICAgICAgICAgICAgICAgOiBTdHJpbmcodmFsKTtcbn07XG5leHBvcnRzLnRvRGlzcGxheVN0cmluZyA9IHRvRGlzcGxheVN0cmluZztcbmNvbnN0IHJlcGxhY2VyID0gKF9rZXksIHZhbCkgPT4ge1xuICAgIC8vIGNhbid0IHVzZSBpc1JlZiBoZXJlIHNpbmNlIEB2dWUvc2hhcmVkIGhhcyBubyBkZXBzXG4gICAgaWYgKHZhbCAmJiB2YWwuX192X2lzUmVmKSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlcihfa2V5LCB2YWwudmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc01hcCh2YWwpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbYE1hcCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC5lbnRyaWVzKCldLnJlZHVjZSgoZW50cmllcywgW2tleSwgdmFsXSkgPT4ge1xuICAgICAgICAgICAgICAgIGVudHJpZXNbYCR7a2V5fSA9PmBdID0gdmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgICAgICAgICAgfSwge30pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU2V0KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtgU2V0KCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLnZhbHVlcygpXVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWwpICYmICFpc0FycmF5KHZhbCkgJiYgIWlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHZhbCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59O1xuY29uc3QgRU1QVFlfT0JKID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgPyBPYmplY3QuZnJlZXplKHt9KVxuICAgIDoge307XG5leHBvcnRzLkVNUFRZX09CSiA9IEVNUFRZX09CSjtcbmNvbnN0IEVNUFRZX0FSUiA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XG5leHBvcnRzLkVNUFRZX0FSUiA9IEVNUFRZX0FSUjtcbmNvbnN0IE5PT1AgPSAoKSA9PiB7IH07XG5leHBvcnRzLk5PT1AgPSBOT09QO1xuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG5jb25zdCBOTyA9ICgpID0+IGZhbHNlO1xuZXhwb3J0cy5OTyA9IE5PO1xuY29uc3Qgb25SRSA9IC9eb25bXmEtel0vO1xuY29uc3QgaXNPbiA9IChrZXkpID0+IG9uUkUudGVzdChrZXkpO1xuZXhwb3J0cy5pc09uID0gaXNPbjtcbmNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IChrZXkpID0+IGtleS5zdGFydHNXaXRoKCdvblVwZGF0ZTonKTtcbmV4cG9ydHMuaXNNb2RlbExpc3RlbmVyID0gaXNNb2RlbExpc3RlbmVyO1xuY29uc3QgZXh0ZW5kID0gT2JqZWN0LmFzc2lnbjtcbmV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xuY29uc3QgcmVtb3ZlID0gKGFyciwgZWwpID0+IHtcbiAgICBjb25zdCBpID0gYXJyLmluZGV4T2YoZWwpO1xuICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgYXJyLnNwbGljZShpLCAxKTtcbiAgICB9XG59O1xuZXhwb3J0cy5yZW1vdmUgPSByZW1vdmU7XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5jb25zdCBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xuZXhwb3J0cy5oYXNPd24gPSBoYXNPd247XG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5jb25zdCBpc01hcCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBNYXBdJztcbmV4cG9ydHMuaXNNYXAgPSBpc01hcDtcbmNvbnN0IGlzU2V0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IFNldF0nO1xuZXhwb3J0cy5pc1NldCA9IGlzU2V0O1xuY29uc3QgaXNEYXRlID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuY29uc3QgaXNSZWdFeHAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5jb25zdCBpc1N0cmluZyA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuY29uc3QgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3ltYm9sJztcbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcbmNvbnN0IGlzT2JqZWN0ID0gKHZhbCkgPT4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuY29uc3QgaXNQcm9taXNlID0gKHZhbCkgPT4ge1xuICAgIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnRoZW4pICYmIGlzRnVuY3Rpb24odmFsLmNhdGNoKTtcbn07XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmV4cG9ydHMub2JqZWN0VG9TdHJpbmcgPSBvYmplY3RUb1N0cmluZztcbmNvbnN0IHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5leHBvcnRzLnRvVHlwZVN0cmluZyA9IHRvVHlwZVN0cmluZztcbmNvbnN0IHRvUmF3VHlwZSA9ICh2YWx1ZSkgPT4ge1xuICAgIC8vIGV4dHJhY3QgXCJSYXdUeXBlXCIgZnJvbSBzdHJpbmdzIGxpa2UgXCJbb2JqZWN0IFJhd1R5cGVdXCJcbiAgICByZXR1cm4gdG9UeXBlU3RyaW5nKHZhbHVlKS5zbGljZSg4LCAtMSk7XG59O1xuZXhwb3J0cy50b1Jhd1R5cGUgPSB0b1Jhd1R5cGU7XG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbmNvbnN0IGlzSW50ZWdlcktleSA9IChrZXkpID0+IGlzU3RyaW5nKGtleSkgJiZcbiAgICBrZXkgIT09ICdOYU4nICYmXG4gICAga2V5WzBdICE9PSAnLScgJiZcbiAgICAnJyArIHBhcnNlSW50KGtleSwgMTApID09PSBrZXk7XG5leHBvcnRzLmlzSW50ZWdlcktleSA9IGlzSW50ZWdlcktleTtcbmNvbnN0IGlzUmVzZXJ2ZWRQcm9wID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFxuLy8gdGhlIGxlYWRpbmcgY29tbWEgaXMgaW50ZW50aW9uYWwgc28gZW1wdHkgc3RyaW5nIFwiXCIgaXMgYWxzbyBpbmNsdWRlZFxuJyxrZXkscmVmLHJlZl9mb3IscmVmX2tleSwnICtcbiAgICAnb25Wbm9kZUJlZm9yZU1vdW50LG9uVm5vZGVNb3VudGVkLCcgK1xuICAgICdvblZub2RlQmVmb3JlVXBkYXRlLG9uVm5vZGVVcGRhdGVkLCcgK1xuICAgICdvblZub2RlQmVmb3JlVW5tb3VudCxvblZub2RlVW5tb3VudGVkJyk7XG5leHBvcnRzLmlzUmVzZXJ2ZWRQcm9wID0gaXNSZXNlcnZlZFByb3A7XG5jb25zdCBpc0J1aWx0SW5EaXJlY3RpdmUgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ2JpbmQsY2xvYWssZWxzZS1pZixlbHNlLGZvcixodG1sLGlmLG1vZGVsLG9uLG9uY2UscHJlLHNob3csc2xvdCx0ZXh0LG1lbW8nKTtcbmV4cG9ydHMuaXNCdWlsdEluRGlyZWN0aXZlID0gaXNCdWlsdEluRGlyZWN0aXZlO1xuY29uc3QgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gKChzdHIpID0+IHtcbiAgICAgICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICAgICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xuICAgIH0pO1xufTtcbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGNhbWVsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiAoYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKSk7XG59KTtcbmV4cG9ydHMuY2FtZWxpemUgPSBjYW1lbGl6ZTtcbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgaHlwaGVuYXRlID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKCkpO1xuZXhwb3J0cy5oeXBoZW5hdGUgPSBoeXBoZW5hdGU7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKSk7XG5leHBvcnRzLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB0b0hhbmRsZXJLZXkgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ciA/IGBvbiR7Y2FwaXRhbGl6ZShzdHIpfWAgOiBgYCk7XG5leHBvcnRzLnRvSGFuZGxlcktleSA9IHRvSGFuZGxlcktleTtcbi8vIGNvbXBhcmUgd2hldGhlciBhIHZhbHVlIGhhcyBjaGFuZ2VkLCBhY2NvdW50aW5nIGZvciBOYU4uXG5jb25zdCBoYXNDaGFuZ2VkID0gKHZhbHVlLCBvbGRWYWx1ZSkgPT4gIU9iamVjdC5pcyh2YWx1ZSwgb2xkVmFsdWUpO1xuZXhwb3J0cy5oYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZDtcbmNvbnN0IGludm9rZUFycmF5Rm5zID0gKGZucywgYXJnKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm5zW2ldKGFyZyk7XG4gICAgfVxufTtcbmV4cG9ydHMuaW52b2tlQXJyYXlGbnMgPSBpbnZva2VBcnJheUZucztcbmNvbnN0IGRlZiA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWVcbiAgICB9KTtcbn07XG5leHBvcnRzLmRlZiA9IGRlZjtcbi8qKlxuICogXCIxMjMtZm9vXCIgd2lsbCBiZSBwYXJzZWQgdG8gMTIzXG4gKiBUaGlzIGlzIHVzZWQgZm9yIHRoZSAubnVtYmVyIG1vZGlmaWVyIGluIHYtbW9kZWxcbiAqL1xuY29uc3QgbG9vc2VUb051bWJlciA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xuZXhwb3J0cy5sb29zZVRvTnVtYmVyID0gbG9vc2VUb051bWJlcjtcbi8qKlxuICogT25seSBjb25lcmNlcyBudW1iZXItbGlrZSBzdHJpbmdzXG4gKiBcIjEyMy1mb29cIiB3aWxsIGJlIHJldHVybmVkIGFzLWlzXG4gKi9cbmNvbnN0IHRvTnVtYmVyID0gKHZhbCkgPT4ge1xuICAgIGNvbnN0IG4gPSBpc1N0cmluZyh2YWwpID8gTnVtYmVyKHZhbCkgOiBOYU47XG4gICAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG5leHBvcnRzLnRvTnVtYmVyID0gdG9OdW1iZXI7XG5sZXQgX2dsb2JhbFRoaXM7XG5jb25zdCBnZXRHbG9iYWxUaGlzID0gKCkgPT4ge1xuICAgIHJldHVybiAoX2dsb2JhbFRoaXMgfHxcbiAgICAgICAgKF9nbG9iYWxUaGlzID1cbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gZ2xvYmFsVGhpc1xuICAgICAgICAgICAgICAgIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZlxuICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHdpbmRvd1xuICAgICAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZ2xvYmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSkpO1xufTtcbmV4cG9ydHMuZ2V0R2xvYmFsVGhpcyA9IGdldEdsb2JhbFRoaXM7XG5jb25zdCBpZGVudFJFID0gL15bXyRhLXpBLVpcXHhBMC1cXHVGRkZGXVtfJGEtekEtWjAtOVxceEEwLVxcdUZGRkZdKiQvO1xuZnVuY3Rpb24gZ2VuUHJvcHNBY2Nlc3NFeHAobmFtZSkge1xuICAgIHJldHVybiBpZGVudFJFLnRlc3QobmFtZSlcbiAgICAgICAgPyBgX19wcm9wcy4ke25hbWV9YFxuICAgICAgICA6IGBfX3Byb3BzWyR7SlNPTi5zdHJpbmdpZnkobmFtZSl9XWA7XG59XG5leHBvcnRzLmdlblByb3BzQWNjZXNzRXhwID0gZ2VuUHJvcHNBY2Nlc3NFeHA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vue/shared/dist/shared.esm-bundler.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n      return content;\n    }).join('');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === 'string') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, '']];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring\n  var cssMapping = item[3];\n  if (!cssMapping) {\n    return content;\n  }\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || '').concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n  return \"/*# \".concat(data, \" */\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhYi8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanM/MjRmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICAgIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcbiAgICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG4gICAgICAgICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuICAgIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSwgZGVkdXBlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgJyddXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuICAgICAgICBpZiAoZGVkdXBlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuICAgICAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19pXSk7XG4gICAgICAgICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcbiAgICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgJycpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG4gICAgfVxuICAgIHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar runtime = function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var defineProperty = Object.defineProperty || function (obj, key, desc) {\n    obj[key] = desc.value;\n  };\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function (obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    defineProperty(generator, \"_invoke\", {\n      value: makeInvokeMethod(innerFn, self, context)\n    });\n    return generator;\n  }\n  exports.wrap = wrap;\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  defineProperty(Gp, \"constructor\", {\n    value: GeneratorFunctionPrototype,\n    configurable: true\n  });\n  defineProperty(GeneratorFunctionPrototype, \"constructor\", {\n    value: GeneratorFunction,\n    configurable: true\n  });\n  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\");\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n  exports.isGeneratorFunction = function (genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor ? ctor === GeneratorFunction ||\n    // For the native GeneratorFunction constructor, the best we can\n    // do is to check its .name property.\n    (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n  };\n  exports.mark = function (genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  };\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function (value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function (err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n        return PromiseImpl.resolve(value).then(function (unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function (error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n    var previousPromise;\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n      return previousPromise =\n      // If enqueue has been called before, then we want to wait until\n      // all previous Promises have been resolved before calling invoke,\n      // so that results are always delivered in the correct order. If\n      // enqueue has not been called before, then it is important to\n      // call invoke immediately, without waiting on a callback to fire,\n      // so that the async generator function has the opportunity to do\n      // any necessary setup in a predictable way. This predictability\n      // is why the Promise constructor synchronously invokes its\n      // executor callback, and why async functions synchronously\n      // execute code before the first await. Since we implement simple\n      // async functions in terms of async generators, it is especially\n      // important to get this right, even though it requires care.\n      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,\n      // Avoid propagating failures to Promises returned by later\n      // invocations of the iterator.\n      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    }\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    defineProperty(this, \"_invoke\", {\n      value: enqueue\n    });\n  }\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n    : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  };\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n      context.method = method;\n      context.arg = arg;\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n          context.dispatchException(context.arg);\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n        state = GenStateExecuting;\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var methodName = context.method;\n    var method = delegate.iterator[methodName];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method, or a missing .next mehtod, always terminate the\n      // yield* loop.\n      context.delegate = null;\n      // Note: [\"return\"] must be used for ES3 parsing compatibility.\n      if (methodName === \"throw\" && delegate.iterator[\"return\"]) {\n        // If the delegate iterator has a return method, give it a\n        // chance to clean up.\n        context.method = \"return\";\n        context.arg = undefined;\n        maybeInvokeDelegate(delegate, context);\n        if (context.method === \"throw\") {\n          // If maybeInvokeDelegate(context) changed context.method from\n          // \"return\" to \"throw\", let that override the TypeError below.\n          return ContinueSentinel;\n        }\n      }\n      if (methodName !== \"return\") {\n        context.method = \"throw\";\n        context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\");\n      }\n      return ContinueSentinel;\n    }\n    var record = tryCatch(method, delegate.iterator, context.arg);\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n    var info = record.arg;\n    if (!info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n  define(Gp, toStringTagSymbol, \"Generator\");\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function () {\n    return this;\n  });\n  define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  });\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n    this.tryEntries.push(entry);\n  }\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n  exports.keys = function (val) {\n    var object = Object(val);\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n          next = function next() {\n            while (++i < iterable.length) {\n              if (hasOwn.call(iterable, i)) {\n                next.value = iterable[i];\n                next.done = false;\n                return next;\n              }\n            }\n            next.value = undefined;\n            next.done = true;\n            return next;\n          };\n        return next.next = next;\n      }\n    }\n    // Return an iterator with no values.\n    return {\n      next: doneResult\n    };\n  }\n  exports.values = values;\n  function doneResult() {\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n  Context.prototype = {\n    constructor: Context,\n    reset: function (skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n      this.method = \"next\";\n      this.arg = undefined;\n      this.tryEntries.forEach(resetTryEntry);\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n    stop: function () {\n      this.done = true;\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n      return this.rval;\n    },\n    dispatchException: function (exception) {\n      if (this.done) {\n        throw exception;\n      }\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n        return !!caught;\n      }\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n    abrupt: function (type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n      if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n      return this.complete(record);\n    },\n    complete: function (record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n      if (record.type === \"break\" || record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n      return ContinueSentinel;\n    },\n    finish: function (finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n    \"catch\": function (tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function (iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n      return ContinueSentinel;\n    }\n  };\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n}(\n// If this script is executing as a CommonJS module, use module.exports\n// as the regeneratorRuntime namespace. Otherwise create a new empty\n// object. Either way, the resulting object will be used to initialize\n// the regeneratorRuntime variable at the top of this file.\n true ? module.exports : 0);\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYWIvLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzPzk2Y2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICAgIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24gKG9iaiwga2V5LCBkZXNjKSB7IG9ialtrZXldID0gZGVzYy52YWx1ZTsgfTtcbiAgICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICAgIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gICAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuICAgIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgb25seSB3b3JrcyBvbiBET00gb2JqZWN0cy5cbiAgICAgICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBkZWZpbmUgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgICAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICAgICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuICAgICAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICAgICAgZGVmaW5lUHJvcGVydHkoZ2VuZXJhdG9yLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB9KTtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgICB9XG4gICAgZXhwb3J0cy53cmFwID0gd3JhcDtcbiAgICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gICAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAgIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAgIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAgIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gICAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICAgIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICAgIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gICAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcbiAgICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gICAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICAgIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG4gICAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gICAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gICAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICAgIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHsgfVxuICAgIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkgeyB9XG4gICAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7IH1cbiAgICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gICAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgICBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICAgIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gICAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICAgICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgICB9XG4gICAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICAgICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgIGRlZmluZVByb3BlcnR5KEdwLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgZGVmaW5lUHJvcGVydHkoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb24sIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICAgIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICAgICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICAgICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgICAgICByZXR1cm4gY3RvclxuICAgICAgICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAgICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgIH07XG4gICAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgICAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICAgICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgICAgIHJldHVybiBnZW5GdW47XG4gICAgfTtcbiAgICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAgIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICAgIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICAgIH07XG4gICAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgICAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuICAgICAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgICAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAgICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgICAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAgICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgICAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAgICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgICAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICAgICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogZW5xdWV1ZSB9KTtcbiAgICB9XG4gICAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgICBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gICAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcbiAgICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gICAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gICAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICAgICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApXG4gICAgICAgICAgICBQcm9taXNlSW1wbCA9IFByb21pc2U7XG4gICAgICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgICAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgICAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgICAgICBjb250ZXh0LmFyZyA9IGFyZztcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgICAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICAgICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICAgICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gICAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gICAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gICAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGNvbnRleHQubWV0aG9kO1xuICAgICAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAgICAgICAvLyBtZXRob2QsIG9yIGEgbWlzc2luZyAubmV4dCBtZWh0b2QsIGFsd2F5cyB0ZXJtaW5hdGUgdGhlXG4gICAgICAgICAgICAvLyB5aWVsZCogbG9vcC5cbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgICAgIGlmIChtZXRob2ROYW1lID09PSBcInRocm93XCIgJiYgZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1ldGhvZE5hbWUgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICdcIiArIG1ldGhvZE5hbWUgKyBcIicgbWV0aG9kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG4gICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgICAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcbiAgICAgICAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG4gICAgICAgICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgICAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgICAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAgICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAgICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAgICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAgIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuICAgIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpO1xuICAgIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gICAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAgIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gICAgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcbiAgICAgICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgICAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgICAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICAgICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgICAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAgICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgICAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICAgICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgICB9XG4gICAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgb2JqZWN0ID0gT2JqZWN0KHZhbCk7XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGtleXMucmV2ZXJzZSgpO1xuICAgICAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgICAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgICAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAgICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgICAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgICAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgICB9XG4gICAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbiAgICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IENvbnRleHQsXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoc2tpcFRlbXBSZXNldCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAgICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG4gICAgICAgICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgICAgICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFicnVwdDogZnVuY3Rpb24gKHR5cGUsIGFyZykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgICAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICAgICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgICAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG4gICAgICAgICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9LFxuICAgICAgICBmaW5pc2g6IGZ1bmN0aW9uIChmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImNhdGNoXCI6IGZ1bmN0aW9uICh0cnlMb2MpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgICAgICB9LFxuICAgICAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiAoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgICAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgICAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICAgICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICAgIHJldHVybiBleHBvcnRzO1xufShcbi8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4vLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbnR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9KSk7XG50cnkge1xuICAgIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59XG5jYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAgIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAgIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgaW4gbW9kZXJuIGVuZ2luZXNcbiAgICAvLyB3ZSBjYW4gZXhwbGljaXRseSBhY2Nlc3MgZ2xvYmFsVGhpcy4gSW4gb2xkZXIgZW5naW5lcyB3ZSBjYW4gZXNjYXBlXG4gICAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gICAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gICAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAgIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAgIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBnbG9iYWxUaGlzLnJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime.js\n");

/***/ }),

/***/ "./node_modules/vue-loader/dist/exportHelper.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-loader/dist/exportHelper.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n// runtime helper for setting properties on components\n// in a tree-shakable way\nexports[\"default\"] = (sfc, props) => {\n  const target = sfc.__vccOpts || sfc;\n  for (const [key, val] of props) {\n    target[key] = val;\n  }\n  return target;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYWIvLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qcz9iOWE2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gcnVudGltZSBoZWxwZXIgZm9yIHNldHRpbmcgcHJvcGVydGllcyBvbiBjb21wb25lbnRzXG4vLyBpbiBhIHRyZWUtc2hha2FibGUgd2F5XG5leHBvcnRzLmRlZmF1bHQgPSAoc2ZjLCBwcm9wcykgPT4ge1xuICAgIGNvbnN0IHRhcmdldCA9IHNmYy5fX3ZjY09wdHMgfHwgc2ZjO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBwcm9wcykge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue-loader/dist/exportHelper.js\n");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[1]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=script&setup=true&lang=ts":
/*!*****************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[1]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=script&setup=true&lang=ts ***!
  \*****************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst vue_1 = __webpack_require__(/*! vue */ \"./node_modules/vue/index.js\");\nconst vue_2 = __webpack_require__(/*! vue */ \"./node_modules/vue/index.js\");\nconst gl_1 = __webpack_require__(/*! ../common/gl */ \"./src/common/gl/index.ts\");\nconst image_1 = __webpack_require__(/*! ../common/image */ \"./src/common/image.ts\");\nconst noise_base64_1 = __importDefault(__webpack_require__(/*! ../common/gl/noise.base64 */ \"./src/common/gl/noise.base64.ts\"));\nconst frag_glsl_1 = __importDefault(__webpack_require__(/*! ./frag.glsl */ \"./src/firework/frag.glsl\"));\nexports[\"default\"] = (0, vue_1.defineComponent)({\n  __name: 'App',\n  setup(__props, _ref) {\n    let {\n      expose\n    } = _ref;\n    expose();\n    const $canvas = (0, vue_2.ref)();\n    (0, vue_2.onMounted)(() => __awaiter(this, void 0, void 0, function* () {\n      const {\n        gl,\n        play,\n        injectTexture\n      } = (0, gl_1.simpleInit)($canvas.value, {\n        frag: frag_glsl_1.default\n      });\n      injectTexture('iChannel0', 0, yield (0, image_1.loadImage)(noise_base64_1.default));\n      play();\n    }));\n    const __returned__ = {\n      $canvas\n    };\n    Object.defineProperty(__returned__, '__isScriptSetup', {\n      enumerable: false,\n      value: true\n    });\n    return __returned__;\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0xLnVzZVswXSEuL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMS51c2VbMV0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzEzXS51c2VbMF0hLi9zcmMvZmlyZXdvcmsvQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmc2V0dXA9dHJ1ZSZsYW5nPXRzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFiLy4vc3JjL2ZpcmV3b3JrL0FwcC52dWU/MDM1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdnVlXzEgPSByZXF1aXJlKFwidnVlXCIpO1xuY29uc3QgdnVlXzIgPSByZXF1aXJlKFwidnVlXCIpO1xuY29uc3QgZ2xfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vZ2xcIik7XG5jb25zdCBpbWFnZV8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9pbWFnZVwiKTtcbmNvbnN0IG5vaXNlX2Jhc2U2NF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9jb21tb24vZ2wvbm9pc2UuYmFzZTY0XCIpKTtcbmNvbnN0IGZyYWdfZ2xzbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2ZyYWcuZ2xzbFwiKSk7XG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgdnVlXzEuZGVmaW5lQ29tcG9uZW50KSh7XG4gICAgX19uYW1lOiAnQXBwJyxcbiAgICBzZXR1cChfX3Byb3BzLCB7IGV4cG9zZSB9KSB7XG4gICAgICAgIGV4cG9zZSgpO1xuICAgICAgICBjb25zdCAkY2FudmFzID0gKDAsIHZ1ZV8yLnJlZikoKTtcbiAgICAgICAgKDAsIHZ1ZV8yLm9uTW91bnRlZCkoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBnbCwgcGxheSwgaW5qZWN0VGV4dHVyZSB9ID0gKDAsIGdsXzEuc2ltcGxlSW5pdCkoJGNhbnZhcy52YWx1ZSwge1xuICAgICAgICAgICAgICAgIGZyYWc6IGZyYWdfZ2xzbF8xLmRlZmF1bHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGluamVjdFRleHR1cmUoJ2lDaGFubmVsMCcsIDAsIHlpZWxkICgwLCBpbWFnZV8xLmxvYWRJbWFnZSkobm9pc2VfYmFzZTY0XzEuZGVmYXVsdCkpO1xuICAgICAgICAgICAgcGxheSgpO1xuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IF9fcmV0dXJuZWRfXyA9IHsgJGNhbnZhcyB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19yZXR1cm5lZF9fLCAnX19pc1NjcmlwdFNldHVwJywgeyBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBfX3JldHVybmVkX187XG4gICAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[1]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=script&setup=true&lang=ts\n");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[1]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=template&id=c032fbdc&scoped=true&ts=true":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[1]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=template&id=c032fbdc&scoped=true&ts=true ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.render = void 0;\nconst vue_1 = __webpack_require__(/*! vue */ \"./node_modules/vue/index.js\");\nconst _withScopeId = n => ((0, vue_1.pushScopeId)(\"data-v-c032fbdc\"), n = n(), (0, vue_1.popScopeId)(), n);\nconst _hoisted_1 = {\n  ref: \"$canvas\",\n  class: \"canvas\"\n};\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  return (0, vue_1.openBlock)(), (0, vue_1.createElementBlock)(\"div\", null, [(0, vue_1.createElementVNode)(\"canvas\", _hoisted_1, null, 512 /* NEED_PATCH */)]);\n}\n\nexports.render = render;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0xLnVzZVswXSEuL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMS51c2VbMV0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3RlbXBsYXRlTG9hZGVyLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxM10udXNlWzBdIS4vc3JjL2ZpcmV3b3JrL0FwcC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YzAzMmZiZGMmc2NvcGVkPXRydWUmdHM9dHJ1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhYi8uL3NyYy9maXJld29yay9BcHAudnVlPzAzNWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlbmRlciA9IHZvaWQgMDtcbmNvbnN0IHZ1ZV8xID0gcmVxdWlyZShcInZ1ZVwiKTtcbmNvbnN0IF93aXRoU2NvcGVJZCA9IG4gPT4gKCgwLCB2dWVfMS5wdXNoU2NvcGVJZCkoXCJkYXRhLXYtYzAzMmZiZGNcIiksIG4gPSBuKCksICgwLCB2dWVfMS5wb3BTY29wZUlkKSgpLCBuKTtcbmNvbnN0IF9ob2lzdGVkXzEgPSB7XG4gICAgcmVmOiBcIiRjYW52YXNcIixcbiAgICBjbGFzczogXCJjYW52YXNcIlxufTtcbmZ1bmN0aW9uIHJlbmRlcihfY3R4LCBfY2FjaGUsICRwcm9wcywgJHNldHVwLCAkZGF0YSwgJG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKCgwLCB2dWVfMS5vcGVuQmxvY2spKCksICgwLCB2dWVfMS5jcmVhdGVFbGVtZW50QmxvY2spKFwiZGl2XCIsIG51bGwsIFtcbiAgICAgICAgKDAsIHZ1ZV8xLmNyZWF0ZUVsZW1lbnRWTm9kZSkoXCJjYW52YXNcIiwgX2hvaXN0ZWRfMSwgbnVsbCwgNTEyIC8qIE5FRURfUEFUQ0ggKi8pXG4gICAgXSkpO1xufVxuZXhwb3J0cy5yZW5kZXIgPSByZW5kZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[1]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=template&id=c032fbdc&scoped=true&ts=true\n");

/***/ }),

/***/ "./node_modules/vue/dist/vue.cjs.js":
/*!******************************************!*\
  !*** ./node_modules/vue/dist/vue.cjs.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar compilerDom = __webpack_require__(/*! @vue/compiler-dom */ \"./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js\");\nvar runtimeDom = __webpack_require__(/*! @vue/runtime-dom */ \"./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js\");\nvar shared = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/shared/dist/shared.esm-bundler.js\");\nfunction _interopNamespaceDefault(e) {\n  var n = Object.create(null);\n  if (e) {\n    for (var k in e) {\n      n[k] = e[k];\n    }\n  }\n  n.default = e;\n  return Object.freeze(n);\n}\nvar runtimeDom__namespace = /*#__PURE__*/_interopNamespaceDefault(runtimeDom);\n// This entry is the \"full-build\" that includes both the runtime\nconst compileCache = Object.create(null);\nfunction compileToFunction(template, options) {\n  if (!shared.isString(template)) {\n    if (template.nodeType) {\n      template = template.innerHTML;\n    } else {\n      runtimeDom.warn(`invalid template option: `, template);\n      return shared.NOOP;\n    }\n  }\n  const key = template;\n  const cached = compileCache[key];\n  if (cached) {\n    return cached;\n  }\n  if (template[0] === '#') {\n    const el = document.querySelector(template);\n    if (!el) {\n      runtimeDom.warn(`Template element not found or is empty: ${template}`);\n    }\n    // __UNSAFE__\n    // Reason: potential execution of JS expressions in in-DOM template.\n    // The user must make sure the in-DOM template is trusted. If it's rendered\n    // by the server, the template should not contain any user data.\n    template = el ? el.innerHTML : ``;\n  }\n  const opts = shared.extend({\n    hoistStatic: true,\n    onError: onError,\n    onWarn: e => onError(e, true)\n  }, options);\n  if (!opts.isCustomElement && typeof customElements !== 'undefined') {\n    opts.isCustomElement = tag => !!customElements.get(tag);\n  }\n  const {\n    code\n  } = compilerDom.compile(template, opts);\n  function onError(err) {\n    let asWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const message = asWarning ? err.message : `Template compilation error: ${err.message}`;\n    const codeFrame = err.loc && shared.generateCodeFrame(template, err.loc.start.offset, err.loc.end.offset);\n    runtimeDom.warn(codeFrame ? `${message}\\n${codeFrame}` : message);\n  }\n  // The wildcard import results in a huge object with every export\n  // with keys that cannot be mangled, and can be quite heavy size-wise.\n  // In the global build we know `Vue` is available globally so we can avoid\n  // the wildcard object.\n  const render = new Function('Vue', code)(runtimeDom__namespace);\n  render._rc = true;\n  return compileCache[key] = render;\n}\nruntimeDom.registerRuntimeCompiler(compileToFunction);\nexports.compile = compileToFunction;\nObject.keys(runtimeDom).forEach(function (k) {\n  if (k !== 'default') exports[k] = runtimeDom[k];\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmNqcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFiLy4vbm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5janMuanM/ZDRkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbXBpbGVyRG9tID0gcmVxdWlyZSgnQHZ1ZS9jb21waWxlci1kb20nKTtcbnZhciBydW50aW1lRG9tID0gcmVxdWlyZSgnQHZ1ZS9ydW50aW1lLWRvbScpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJ0B2dWUvc2hhcmVkJyk7XG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZURlZmF1bHQoZSkge1xuICAgIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoZSkge1xuICAgICAgICBmb3IgKHZhciBrIGluIGUpIHtcbiAgICAgICAgICAgIG5ba10gPSBlW2tdO1xuICAgICAgICB9XG4gICAgfVxuICAgIG4uZGVmYXVsdCA9IGU7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG52YXIgcnVudGltZURvbV9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qLyBfaW50ZXJvcE5hbWVzcGFjZURlZmF1bHQocnVudGltZURvbSk7XG4vLyBUaGlzIGVudHJ5IGlzIHRoZSBcImZ1bGwtYnVpbGRcIiB0aGF0IGluY2x1ZGVzIGJvdGggdGhlIHJ1bnRpbWVcbmNvbnN0IGNvbXBpbGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbih0ZW1wbGF0ZSwgb3B0aW9ucykge1xuICAgIGlmICghc2hhcmVkLmlzU3RyaW5nKHRlbXBsYXRlKSkge1xuICAgICAgICBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcnVudGltZURvbS53YXJuKGBpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjogYCwgdGVtcGxhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHNoYXJlZC5OT09QO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IHRlbXBsYXRlO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNvbXBpbGVDYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlWzBdID09PSAnIycpIHtcbiAgICAgICAgY29uc3QgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRlbXBsYXRlKTtcbiAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgcnVudGltZURvbS53YXJuKGBUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogJHt0ZW1wbGF0ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBfX1VOU0FGRV9fXG4gICAgICAgIC8vIFJlYXNvbjogcG90ZW50aWFsIGV4ZWN1dGlvbiBvZiBKUyBleHByZXNzaW9ucyBpbiBpbi1ET00gdGVtcGxhdGUuXG4gICAgICAgIC8vIFRoZSB1c2VyIG11c3QgbWFrZSBzdXJlIHRoZSBpbi1ET00gdGVtcGxhdGUgaXMgdHJ1c3RlZC4gSWYgaXQncyByZW5kZXJlZFxuICAgICAgICAvLyBieSB0aGUgc2VydmVyLCB0aGUgdGVtcGxhdGUgc2hvdWxkIG5vdCBjb250YWluIGFueSB1c2VyIGRhdGEuXG4gICAgICAgIHRlbXBsYXRlID0gZWwgPyBlbC5pbm5lckhUTUwgOiBgYDtcbiAgICB9XG4gICAgY29uc3Qgb3B0cyA9IHNoYXJlZC5leHRlbmQoe1xuICAgICAgICBob2lzdFN0YXRpYzogdHJ1ZSxcbiAgICAgICAgb25FcnJvcjogb25FcnJvcixcbiAgICAgICAgb25XYXJuOiBlID0+IG9uRXJyb3IoZSwgdHJ1ZSlcbiAgICB9LCBvcHRpb25zKTtcbiAgICBpZiAoIW9wdHMuaXNDdXN0b21FbGVtZW50ICYmIHR5cGVvZiBjdXN0b21FbGVtZW50cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3B0cy5pc0N1c3RvbUVsZW1lbnQgPSB0YWcgPT4gISFjdXN0b21FbGVtZW50cy5nZXQodGFnKTtcbiAgICB9XG4gICAgY29uc3QgeyBjb2RlIH0gPSBjb21waWxlckRvbS5jb21waWxlKHRlbXBsYXRlLCBvcHRzKTtcbiAgICBmdW5jdGlvbiBvbkVycm9yKGVyciwgYXNXYXJuaW5nID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGFzV2FybmluZ1xuICAgICAgICAgICAgPyBlcnIubWVzc2FnZVxuICAgICAgICAgICAgOiBgVGVtcGxhdGUgY29tcGlsYXRpb24gZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgICAgY29uc3QgY29kZUZyYW1lID0gZXJyLmxvYyAmJlxuICAgICAgICAgICAgc2hhcmVkLmdlbmVyYXRlQ29kZUZyYW1lKHRlbXBsYXRlLCBlcnIubG9jLnN0YXJ0Lm9mZnNldCwgZXJyLmxvYy5lbmQub2Zmc2V0KTtcbiAgICAgICAgcnVudGltZURvbS53YXJuKGNvZGVGcmFtZSA/IGAke21lc3NhZ2V9XFxuJHtjb2RlRnJhbWV9YCA6IG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvLyBUaGUgd2lsZGNhcmQgaW1wb3J0IHJlc3VsdHMgaW4gYSBodWdlIG9iamVjdCB3aXRoIGV2ZXJ5IGV4cG9ydFxuICAgIC8vIHdpdGgga2V5cyB0aGF0IGNhbm5vdCBiZSBtYW5nbGVkLCBhbmQgY2FuIGJlIHF1aXRlIGhlYXZ5IHNpemUtd2lzZS5cbiAgICAvLyBJbiB0aGUgZ2xvYmFsIGJ1aWxkIHdlIGtub3cgYFZ1ZWAgaXMgYXZhaWxhYmxlIGdsb2JhbGx5IHNvIHdlIGNhbiBhdm9pZFxuICAgIC8vIHRoZSB3aWxkY2FyZCBvYmplY3QuXG4gICAgY29uc3QgcmVuZGVyID0gKG5ldyBGdW5jdGlvbignVnVlJywgY29kZSkocnVudGltZURvbV9fbmFtZXNwYWNlKSk7XG4gICAgcmVuZGVyLl9yYyA9IHRydWU7XG4gICAgcmV0dXJuIChjb21waWxlQ2FjaGVba2V5XSA9IHJlbmRlcik7XG59XG5ydW50aW1lRG9tLnJlZ2lzdGVyUnVudGltZUNvbXBpbGVyKGNvbXBpbGVUb0Z1bmN0aW9uKTtcbmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9uO1xuT2JqZWN0LmtleXMocnVudGltZURvbSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIGlmIChrICE9PSAnZGVmYXVsdCcpXG4gICAgICAgIGV4cG9ydHNba10gPSBydW50aW1lRG9tW2tdO1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue/dist/vue.cjs.js\n");

/***/ }),

/***/ "./node_modules/vue/index.js":
/*!***********************************!*\
  !*** ./node_modules/vue/index.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./dist/vue.cjs.js */ \"./node_modules/vue/dist/vue.cjs.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUNBO0FBSUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhYi8uL25vZGVfbW9kdWxlcy92dWUvaW5kZXguanM/MjEzOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L3Z1ZS5janMucHJvZC5qcycpO1xufVxuZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvdnVlLmNqcy5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue/index.js\n");

/***/ }),

/***/ "./src/common/gl/index.ts":
/*!********************************!*\
  !*** ./src/common/gl/index.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.simpleInit = exports.createProgram = exports.createGlContext = exports.useInjectGlData = exports.setBlend = exports.ensureCanvas = void 0;\nconst DEFAULT_VERT = `\nattribute vec2 a_position;\nvarying vec2 v_texCoord;\n\nvoid main() {\n  gl_Position = vec4(a_position, 0.0, 1.0);\n  \n  v_texCoord = (a_position + 1.0) * 0.5;\n}\n`;\nconst DEFAULT_FRAG = `\nprecision mediump float;\n\nvoid main(){\n    gl_FragColor=vec4(0.);\n}\n\n`;\nfunction ensureCanvas(canvas) {\n  let ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  canvas.width = canvas.clientWidth * ratio;\n  canvas.height = canvas.clientHeight * ratio;\n}\nexports.ensureCanvas = ensureCanvas;\nfunction setBlend(gl, blendMode) {\n  gl.enable(gl.BLEND);\n  switch (blendMode) {\n    case 'add':\n      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n      break;\n    case 'multiply':\n      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n      gl.blendFuncSeparate(gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n      break;\n    case 'normal':\n    default:\n      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n      break;\n  }\n}\nexports.setBlend = setBlend;\nfunction injectVert(gl, program) {\n  const positions = [-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0];\n  const vBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, vBuffer);\n  const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');\n  gl.enableVertexAttribArray(positionAttributeLocation);\n  gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n}\nfunction injectUniform(gl, program, name, method) {\n  const n = gl.getUniformLocation(program, name);\n  // @ts-expect-error\n  for (var _len = arguments.length, value = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {\n    value[_key - 4] = arguments[_key];\n  }\n  gl[method](n, ...value);\n}\nfunction injectTexture(gl, program, name) {\n  let index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let img = arguments.length > 4 ? arguments[4] : undefined;\n  const texture = gl.createTexture();\n  const sampler = gl.getUniformLocation(program, name);\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);\n  gl.activeTexture(gl[`TEXTURE${index}`]);\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.uniform1i(sampler, index);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);\n}\nfunction useInjectGlData(gl, program, canvas, options) {\n  const lastMousePosition = [0, 0];\n  const start = Date.now();\n  function inject() {\n    const now = new Date();\n    // 为 u_time 提供值\n    const uTimeLocation = gl.getUniformLocation(program, 'u_time');\n    gl.uniform1f(uTimeLocation, (now.getTime() - start) / 1000);\n    // 为 u_mouse 提供值\n    const uMouseLocation = gl.getUniformLocation(program, 'u_mouse');\n    gl.uniform2f(uMouseLocation, ...lastMousePosition);\n    const uResolution = gl.getUniformLocation(program, 'u_resolution');\n    gl.uniform2f(uResolution, canvas.clientWidth, canvas.clientHeight);\n    // 为 u_date 提供值\n    const uDateLocation = gl.getUniformLocation(program, 'u_date');\n    gl.uniform4f(uDateLocation, now.getFullYear(), now.getMonth() + 1, now.getDate(), now.getHours() + now.getMinutes() / 60);\n    // 为 u_camera 提供值\n    // const uCameraLocation = gl.getUniformLocation(program, 'u_camera');\n    // gl.uniform3f(uCameraLocation, 0.0, 0.0, -2.0);\n    // 为 u_sampleRate 提供值\n    // const uSampleRateLocation = gl.getUniformLocation(program, 'u_sampleRate');\n    // gl.uniform1f(uSampleRateLocation, 44100.0);\n    // 为 iResolution 提供值\n    const iResolutionLocation = gl.getUniformLocation(program, 'iResolution');\n    gl.uniform3f(iResolutionLocation, canvas.clientWidth, canvas.clientHeight, options.ratio);\n  }\n  function setMove(e) {\n    const w = canvas.clientWidth;\n    const h = canvas.clientHeight;\n    lastMousePosition[0] = e.clientX / w;\n    lastMousePosition[1] = e.clientY / h;\n  }\n  canvas.addEventListener('pointermove', setMove);\n  return {\n    inject,\n    destroy: () => {\n      canvas.removeEventListener('pointermove', setMove);\n    }\n  };\n}\nexports.useInjectGlData = useInjectGlData;\nfunction createGlContext(canvas) {\n  const gl = canvas.getContext('webgl', {\n    alpha: true,\n    depth: true,\n    premultipliedAlpha: true\n  });\n  setBlend(gl, 'normal');\n  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n  return gl;\n}\nexports.createGlContext = createGlContext;\nfunction createProgram(gl, shader) {\n  var _a, _b;\n  const program = gl.createProgram();\n  // 创建顶点着色器\n  const vShader = gl.createShader(gl.VERTEX_SHADER);\n  // 创建片元着色器\n  const fShader = gl.createShader(gl.FRAGMENT_SHADER);\n  // shader容器与着色器绑定\n  gl.shaderSource(vShader, (_a = shader === null || shader === void 0 ? void 0 : shader.vert) !== null && _a !== void 0 ? _a : DEFAULT_VERT);\n  gl.shaderSource(fShader, (_b = shader === null || shader === void 0 ? void 0 : shader.frag) !== null && _b !== void 0 ? _b : DEFAULT_FRAG);\n  // 将GLSE语言编译成浏览器可用代码\n  gl.compileShader(vShader);\n  gl.compileShader(fShader);\n  // 将着色器添加到程序上\n  gl.attachShader(program, vShader);\n  gl.attachShader(program, fShader);\n  // 链接程序，在链接操作执行以后，可以任意修改shader的源代码，\n  // 对shader重新编译不会影响整个程序，除非重新链接程序\n  gl.linkProgram(program);\n  // 加载并使用链接好的程序\n  gl.useProgram(program);\n  const message = gl.getShaderInfoLog(fShader);\n  if (message.length > 0) {\n    /* message may be an error or a warning */\n    throw message;\n  }\n  return program;\n}\nexports.createProgram = createProgram;\nfunction simpleInit(canvas, options) {\n  var _a;\n  ensureCanvas(canvas);\n  const gl = createGlContext(canvas);\n  const program = createProgram(gl, options);\n  const {\n    inject,\n    destroy\n  } = useInjectGlData(gl, program, canvas, {\n    ratio: (_a = options.ratio) !== null && _a !== void 0 ? _a : 2\n  });\n  injectVert(gl, program);\n  inject();\n  let timer = 0;\n  function renderTick() {\n    gl.clearColor(0.0, 0.0, 0.0, 0.0); // 使用透明的黑色清除颜色\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    inject();\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    timer = requestAnimationFrame(renderTick);\n  }\n  return {\n    gl,\n    inject: function (name, method) {\n      for (var _len2 = arguments.length, value = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        value[_key2 - 2] = arguments[_key2];\n      }\n      injectUniform(gl, program, name, method, ...value);\n    },\n    injectTexture: (name, index, img) => {\n      injectTexture(gl, program, name, index, img);\n    },\n    play: renderTick,\n    stop: () => {\n      cancelAnimationFrame(timer);\n    }\n  };\n}\nexports.simpleInit = simpleInit;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tbW9uL2dsL2luZGV4LnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUZBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFiLy4vc3JjL2NvbW1vbi9nbC9pbmRleC50cz9lNzQwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaW1wbGVJbml0ID0gZXhwb3J0cy5jcmVhdGVQcm9ncmFtID0gZXhwb3J0cy5jcmVhdGVHbENvbnRleHQgPSBleHBvcnRzLnVzZUluamVjdEdsRGF0YSA9IGV4cG9ydHMuc2V0QmxlbmQgPSBleHBvcnRzLmVuc3VyZUNhbnZhcyA9IHZvaWQgMDtcbmNvbnN0IERFRkFVTFRfVkVSVCA9IGBcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247XG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcblxudm9pZCBtYWluKCkge1xuICBnbF9Qb3NpdGlvbiA9IHZlYzQoYV9wb3NpdGlvbiwgMC4wLCAxLjApO1xuICBcbiAgdl90ZXhDb29yZCA9IChhX3Bvc2l0aW9uICsgMS4wKSAqIDAuNTtcbn1cbmA7XG5jb25zdCBERUZBVUxUX0ZSQUcgPSBgXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxudm9pZCBtYWluKCl7XG4gICAgZ2xfRnJhZ0NvbG9yPXZlYzQoMC4pO1xufVxuXG5gO1xuZnVuY3Rpb24gZW5zdXJlQ2FudmFzKGNhbnZhcywgcmF0aW8gPSAyKSB7XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoICogcmF0aW87XG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQgKiByYXRpbztcbn1cbmV4cG9ydHMuZW5zdXJlQ2FudmFzID0gZW5zdXJlQ2FudmFzO1xuZnVuY3Rpb24gc2V0QmxlbmQoZ2wsIGJsZW5kTW9kZSkge1xuICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgc3dpdGNoIChibGVuZE1vZGUpIHtcbiAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbXVsdGlwbHknOlxuICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCk7XG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnbC5EU1RfQ09MT1IsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbm9ybWFsJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuZXhwb3J0cy5zZXRCbGVuZCA9IHNldEJsZW5kO1xuZnVuY3Rpb24gaW5qZWN0VmVydChnbCwgcHJvZ3JhbSkge1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFstMS4wLCAtMS4wLCAxLjAsIC0xLjAsIC0xLjAsIDEuMCwgMS4wLCAxLjBdO1xuICAgIGNvbnN0IHZCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdkJ1ZmZlcik7XG4gICAgY29uc3QgcG9zaXRpb25BdHRyaWJ1dGVMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3Bvc2l0aW9uJyk7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25BdHRyaWJ1dGVMb2NhdGlvbik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkF0dHJpYnV0ZUxvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucyksIGdsLlNUQVRJQ19EUkFXKTtcbn1cbmZ1bmN0aW9uIGluamVjdFVuaWZvcm0oZ2wsIHByb2dyYW0sIG5hbWUsIG1ldGhvZCwgLi4udmFsdWUpIHtcbiAgICBjb25zdCBuID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIG5hbWUpO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBnbFttZXRob2RdKG4sIC4uLnZhbHVlKTtcbn1cbmZ1bmN0aW9uIGluamVjdFRleHR1cmUoZ2wsIHByb2dyYW0sIG5hbWUsIGluZGV4ID0gMCwgaW1nKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBjb25zdCBzYW1wbGVyID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIG5hbWUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIDEpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2xbYFRFWFRVUkUke2luZGV4fWBdKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC51bmlmb3JtMWkoc2FtcGxlciwgaW5kZXgpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1nKTtcbn1cbmZ1bmN0aW9uIHVzZUluamVjdEdsRGF0YShnbCwgcHJvZ3JhbSwgY2FudmFzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGFzdE1vdXNlUG9zaXRpb24gPSBbMCwgMF07XG4gICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGZ1bmN0aW9uIGluamVjdCgpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgLy8g5Li6IHVfdGltZSDmj5DkvpvlgLxcbiAgICAgICAgY29uc3QgdVRpbWVMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV90aW1lJyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1VGltZUxvY2F0aW9uLCAobm93LmdldFRpbWUoKSAtIHN0YXJ0KSAvIDEwMDApO1xuICAgICAgICAvLyDkuLogdV9tb3VzZSDmj5DkvpvlgLxcbiAgICAgICAgY29uc3QgdU1vdXNlTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbW91c2UnKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmKHVNb3VzZUxvY2F0aW9uLCAuLi5sYXN0TW91c2VQb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IHVSZXNvbHV0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmKHVSZXNvbHV0aW9uLCBjYW52YXMuY2xpZW50V2lkdGgsIGNhbnZhcy5jbGllbnRIZWlnaHQpO1xuICAgICAgICAvLyDkuLogdV9kYXRlIOaPkOS+m+WAvFxuICAgICAgICBjb25zdCB1RGF0ZUxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X2RhdGUnKTtcbiAgICAgICAgZ2wudW5pZm9ybTRmKHVEYXRlTG9jYXRpb24sIG5vdy5nZXRGdWxsWWVhcigpLCBub3cuZ2V0TW9udGgoKSArIDEsIG5vdy5nZXREYXRlKCksIG5vdy5nZXRIb3VycygpICsgbm93LmdldE1pbnV0ZXMoKSAvIDYwKTtcbiAgICAgICAgLy8g5Li6IHVfY2FtZXJhIOaPkOS+m+WAvFxuICAgICAgICAvLyBjb25zdCB1Q2FtZXJhTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfY2FtZXJhJyk7XG4gICAgICAgIC8vIGdsLnVuaWZvcm0zZih1Q2FtZXJhTG9jYXRpb24sIDAuMCwgMC4wLCAtMi4wKTtcbiAgICAgICAgLy8g5Li6IHVfc2FtcGxlUmF0ZSDmj5DkvpvlgLxcbiAgICAgICAgLy8gY29uc3QgdVNhbXBsZVJhdGVMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9zYW1wbGVSYXRlJyk7XG4gICAgICAgIC8vIGdsLnVuaWZvcm0xZih1U2FtcGxlUmF0ZUxvY2F0aW9uLCA0NDEwMC4wKTtcbiAgICAgICAgLy8g5Li6IGlSZXNvbHV0aW9uIOaPkOS+m+WAvFxuICAgICAgICBjb25zdCBpUmVzb2x1dGlvbkxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICdpUmVzb2x1dGlvbicpO1xuICAgICAgICBnbC51bmlmb3JtM2YoaVJlc29sdXRpb25Mb2NhdGlvbiwgY2FudmFzLmNsaWVudFdpZHRoLCBjYW52YXMuY2xpZW50SGVpZ2h0LCBvcHRpb25zLnJhdGlvKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0TW92ZShlKSB7XG4gICAgICAgIGNvbnN0IHcgPSBjYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICAgIGNvbnN0IGggPSBjYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgICAgICBsYXN0TW91c2VQb3NpdGlvblswXSA9IGUuY2xpZW50WCAvIHc7XG4gICAgICAgIGxhc3RNb3VzZVBvc2l0aW9uWzFdID0gZS5jbGllbnRZIC8gaDtcbiAgICB9XG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgc2V0TW92ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5qZWN0LFxuICAgICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBzZXRNb3ZlKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0cy51c2VJbmplY3RHbERhdGEgPSB1c2VJbmplY3RHbERhdGE7XG5mdW5jdGlvbiBjcmVhdGVHbENvbnRleHQoY2FudmFzKSB7XG4gICAgY29uc3QgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCB7XG4gICAgICAgIGFscGhhOiB0cnVlLFxuICAgICAgICBkZXB0aDogdHJ1ZSxcbiAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiB0cnVlLFxuICAgIH0pO1xuICAgIHNldEJsZW5kKGdsLCAnbm9ybWFsJyk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBmYWxzZSk7XG4gICAgcmV0dXJuIGdsO1xufVxuZXhwb3J0cy5jcmVhdGVHbENvbnRleHQgPSBjcmVhdGVHbENvbnRleHQ7XG5mdW5jdGlvbiBjcmVhdGVQcm9ncmFtKGdsLCBzaGFkZXIpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgLy8g5Yib5bu66aG254K5552A6Imy5ZmoXG4gICAgY29uc3QgdlNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSKTtcbiAgICAvLyDliJvlu7rniYflhYPnnYDoibLlmahcbiAgICBjb25zdCBmU2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgLy8gc2hhZGVy5a655Zmo5LiO552A6Imy5Zmo57uR5a6aXG4gICAgZ2wuc2hhZGVyU291cmNlKHZTaGFkZXIsIChfYSA9IHNoYWRlciA9PT0gbnVsbCB8fCBzaGFkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNoYWRlci52ZXJ0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBERUZBVUxUX1ZFUlQpO1xuICAgIGdsLnNoYWRlclNvdXJjZShmU2hhZGVyLCAoX2IgPSBzaGFkZXIgPT09IG51bGwgfHwgc2hhZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzaGFkZXIuZnJhZykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogREVGQVVMVF9GUkFHKTtcbiAgICAvLyDlsIZHTFNF6K+t6KiA57yW6K+R5oiQ5rWP6KeI5Zmo5Y+v55So5Luj56CBXG4gICAgZ2wuY29tcGlsZVNoYWRlcih2U2hhZGVyKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKGZTaGFkZXIpO1xuICAgIC8vIOWwhuedgOiJsuWZqOa3u+WKoOWIsOeoi+W6j+S4ilxuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2U2hhZGVyKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZlNoYWRlcik7XG4gICAgLy8g6ZO+5o6l56iL5bqP77yM5Zyo6ZO+5o6l5pON5L2c5omn6KGM5Lul5ZCO77yM5Y+v5Lul5Lu75oSP5L+u5pS5c2hhZGVy55qE5rqQ5Luj56CB77yMXG4gICAgLy8g5a+5c2hhZGVy6YeN5paw57yW6K+R5LiN5Lya5b2x5ZON5pW05Liq56iL5bqP77yM6Zmk6Z2e6YeN5paw6ZO+5o6l56iL5bqPXG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgLy8g5Yqg6L295bm25L2/55So6ZO+5o6l5aW955qE56iL5bqPXG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBjb25zdCBtZXNzYWdlID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhmU2hhZGVyKTtcbiAgICBpZiAobWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8qIG1lc3NhZ2UgbWF5IGJlIGFuIGVycm9yIG9yIGEgd2FybmluZyAqL1xuICAgICAgICB0aHJvdyBtZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gcHJvZ3JhbTtcbn1cbmV4cG9ydHMuY3JlYXRlUHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW07XG5mdW5jdGlvbiBzaW1wbGVJbml0KGNhbnZhcywgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBlbnN1cmVDYW52YXMoY2FudmFzKTtcbiAgICBjb25zdCBnbCA9IGNyZWF0ZUdsQ29udGV4dChjYW52YXMpO1xuICAgIGNvbnN0IHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKGdsLCBvcHRpb25zKTtcbiAgICBjb25zdCB7IGluamVjdCwgZGVzdHJveSB9ID0gdXNlSW5qZWN0R2xEYXRhKGdsLCBwcm9ncmFtLCBjYW52YXMsIHsgcmF0aW86IChfYSA9IG9wdGlvbnMucmF0aW8pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDIgfSk7XG4gICAgaW5qZWN0VmVydChnbCwgcHJvZ3JhbSk7XG4gICAgaW5qZWN0KCk7XG4gICAgbGV0IHRpbWVyID0gMDtcbiAgICBmdW5jdGlvbiByZW5kZXJUaWNrKCkge1xuICAgICAgICBnbC5jbGVhckNvbG9yKDAuMCwgMC4wLCAwLjAsIDAuMCk7IC8vIOS9v+eUqOmAj+aYjueahOm7keiJsua4hemZpOminOiJslxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgICAgaW5qZWN0KCk7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICAgICAgICB0aW1lciA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXJUaWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2wsXG4gICAgICAgIGluamVjdDogKG5hbWUsIG1ldGhvZCwgLi4udmFsdWUpID0+IHtcbiAgICAgICAgICAgIGluamVjdFVuaWZvcm0oZ2wsIHByb2dyYW0sIG5hbWUsIG1ldGhvZCwgLi4udmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBpbmplY3RUZXh0dXJlOiAobmFtZSwgaW5kZXgsIGltZykgPT4ge1xuICAgICAgICAgICAgaW5qZWN0VGV4dHVyZShnbCwgcHJvZ3JhbSwgbmFtZSwgaW5kZXgsIGltZyk7XG4gICAgICAgIH0sXG4gICAgICAgIHBsYXk6IHJlbmRlclRpY2ssXG4gICAgICAgIHN0b3A6ICgpID0+IHtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRpbWVyKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0cy5zaW1wbGVJbml0ID0gc2ltcGxlSW5pdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/common/gl/index.ts\n");

/***/ }),

/***/ "./src/common/gl/noise.base64.ts":
/*!***************************************!*\
  !*** ./src/common/gl/noise.base64.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = 'data:image/png;base64,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';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tbW9uL2dsL25vaXNlLmJhc2U2NC50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhYi8uL3NyYy9jb21tb24vZ2wvbm9pc2UuYmFzZTY0LnRzPzc5OWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFRQUFBQUVBQ0FZQUFBQmNjcWhtQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUFCR2RCVFVFQUFMR09mUHRSa3dBQUFDQmpTRkpOQUFCNkpRQUFnSU1BQVBuL0FBQ0E2UUFBZFRBQUFPcGdBQUE2bUFBQUYyK1NYOFZHQUFRSENFbEVRVlI0MmdBQkJQNzdBY0xFajZZZWFqZk1hQ1lUQjFlc3NJV04vbzVrRjQwZ0R2cDFoWTEvUVNMZlVKc2NCTGlpTXFIdXBYd0QzcnhIczlPUWc3d1ZVTGlXUWRCbXF1cUZzMVJJZjRxNi8wdmNrT3JnRngrYndKWUxRUUdZUE1xcWRuTlVuaURPS0hrNndFbEI0T3NjUkt6TzF0ajI5ZFUxczVQWENKWGNHZTU4bFhMaitnREQ5a3FtVGxBbHNKbkxGUlhFbmFVaC9obmtZdUJiTXAzejE4YWc5Q3V6ckFEUEVCWHhKeFlLcXZjUGVYZXpzMlYzYlhTVXBiaGhBVzdJYkJhMVZTVmcwdjlhZ0VjS1NJRGhjL1J1NlN5VnplcFJvcHM1b0d5UXBZc292cU5iRk1OSTRLWXg5YUNLQnFtZVE0UlovaTdsMDhpM3pMTkYvSFgvMktjSUVXTWhDT0hUM0VvSzZpOFVmZmZEVnUrU1hUTnVoVTg1Y0xHa2t6Y3ZaeERQWnQ5K3h2ZEtqbVpydUJXb3l0Kzk4TUdwd0pUcnNGM1ZMM0lKU1FBTk14MmhHUTdMOVA4L2FBdVB4MnhSTGFZUzNYdHo0U0Nvd2hqR1pqY3lBVitoSTFYeWxyNTJYMHoxemlxbVJMUUsvQ0lYR3hEOXRUN3UzbkpjbGhBVWFzWGFBSTFXSktuU1RYQVJjdWpzYUc3RTRpZkJsUEg3MTc2dlhmSlhLQ1pEbUlMUlZGY09ucTFXZ0hNdFYyaml3UXZ6K3ZuVEJJM1h2K3lmOWhPelBIWFAyOEk5RTY4bUdSUElsWFRKbGh5aFlJK2JQdHkyT0JYNTFkY2laY25HYy9ERHp5bkFBMXAzYk14aTIyNEo5d2RVVExZU3RhNldtUW1PN3ZncTgwNzh2THBmdnNCcUhyd1JaQjRCSVVsNlNFUFdnc0lwRDZQU2ZoWjhTZVQza2lBUWZweVBDc01NYWYzQXA2R0RIYWdSOHJkOGlodjBvaDY1bnJMZnBWcnRSK1FtbTF6bUc2QzZKWTlJd2NiYUdwMWpvRGltSDhQQktqUDZFQ3B1OUcvUng3QjY0WWUrM1pvZXlPWDRMR3JkMFg2NFA3aEVTUk5CZVBuZXJMTlZPUms4TjJ3NXgvMUpUelpJSXErOVVBYjVadzlzYWUzeXNuNG43cW1UMWdpQVQxTFpSNERjTmlHNGJObFhuSFlSRXgzUzMzcnhWTlFKR09aWnFjQzJvcndXSGU1UUFLSWZFMnllWHVnbDhLNS9uNHZSZVA1OWUyUmJyRlR2aGVtemwvQWVXcUZqMXZsd0M0MHBpT0RwM2NhNFdiQWNTOTJjQ3pPU2NuU0pEdTZEOUVtY1R6N29jNHA1ekh6UDYwZEZCUm1nZUhlbTRlZXVZWEsrM1MyM2kyZHN3T1NZaDVWZmM4dUZpTDZERDhqQWpDMGpiYzJsa0loY3JScTNnVm03R2dzYnZxYXMxRnZIc1JhQm9ERlZaZVNiTVpnREZNSlV3TmN0UHRySnpQeWYzQVhpZ1YvdnIrdTBwSnBKdGNEWnpOK2hLK1NUaGgxWFlLSGl0M3JGZTBGTGc1bUM2ZGJuQitpaGRrTE0vL1Y0T2I2eGp6SVNHZTYzZ2lZZDgwcll3VFhzWGhwNmU5ZWV3cUNOU01rZ0pOTmt4LzhSVXJwdDNNREtDakh2eXczVVFtMFdRZVJHU09tRUJ2ckhITk9IUlJpNVVNZS9QZGoxV245NXgxUktDMkpVcmd5bVE0VjMvMzVKSWFXUFFlTFI2dU9JRFUydkM3U3FQSE9LV2pBSEJXZEhOTEdCUnM0SUQzY0NBQUVFL3ZzQzU5VnBsZWk4ZGQxWE1lOGJYWEV0dTluU3NlSnBKZ0JVazZtelRmcHlqNEUwaUhWQzhwdDd4NnlwQ01KT1RrK3lwNXpyQlpIRm1NcmhHeUE2dHF1Ujh5OHE4djJEUUNOU1hMYXdkOEJsQk1nTGFnVWcrUE9EREs3LzNJeWVNQ0JXMXdHM2xaUmlEcjBIZnQ3dmpMMVhpZkdmU1haSzlCZU9jMkRuQkQxaWRXNjdIQlZIcWRJMGVKdkl2YnlmZHg3R1JPc1E5eklkSEtOcGluamU5MDkvSDJrejAyZGgyNHAwNTVoYU5ycEM4MmY4SWErcUhRUVp4bTdtVys3TUNjbzRmUEJqTHdaK0ZhZW1KMDNaTTlnTTQ0eWRWZ1dSRHRsTDNjNmtyVEt4cUcxRklkWWNNd0pJNmMyOERuK3BVYW4yaGhxMG93MDFTREgzMkRJelYvbnREUzR5bWhqa0ZvTmpNb2FkV0hVYkNXdHFTb242cHRPOFRWQThzb3pRNkUyOC8vcnMvajhuK1lOTG5nakpuVzV2c0Vod21yVndseU1qN0tUbWo5TlhEZkhWNi9QUkpGOCtGVGMxQmJNTDlNRUcyelcxdnVObE1DUzZFWkUxMWVqdVFoUUFWMkRaaDV1Z3hYSHFPZjA4RGxBS1JLVXRycDlLaFNJYXlSVG9WanR1UFhnWmxEb1J1eEV6Ums0UFR1ODBKNlk0VlFNVXV0YnJnaStCUXV0cjF5QkNoRjRoKzI0eU45MThPVHc3QUlYUkdzVDVEQ0NSVlF0aGczL1FPUDVRQWZFQ1NaTEFUTGlvZVBlZ1dRZ0RPQXJZZUFwSm5CZlRZL1lZbThGVzlvOEw1NjFpVU4wOGtMTWhVY1ExTWdRak13QlVJMit6dmxQRTJlR2ZSclNYTVY2N2hJSFVrb29rZk1SWkRRcmViVWJkanR4VmJJMnlnb25SZGI4bHM3WnkxY0VnQVR3V2Q3T0ZZTHM5T2Q0M04yL2JRYlVtNVFUSml1elRBRDNDQ08xcy90Znp0WVg5UTM1T2gxelZGWDR6UjJxcXZ5REU2UEQ1ZEU1UXloTGhVN2JLaGlldzdKU1I0N3FVeDdnMjV6S3hsQnBKbEJQSFpaaTZKQTBmZFc4TlZXWERSZXhKU3A0OVFOYjgxclc2WGtBYzdDUm1mcWJRWG9MY0w3ZXRyZGJ6eHVHOHlmREZ0M3JtOUVHYUovZHY5M0poTS9JSTRGdjBvSFNpM2dJTC90YlZlWmZpM2NQOEM1ZzRhZFlTalNTVU5OREFRZVFqaFZUMmMxNTcrSkIwQnJSeW5yOUtmS3h0dFNMTnBEbmo1bTA0a0RnbDJMUFZ2ZnZpbUt5dXg5OFZXZDJNOUl4ZDlJbnlwWHhLWmxvWG1OVDdXell6QmpmQ0V5Vmo2KytHeHY5OWtOSC9QdU9MWDQrTlJjWTQ2RHF4bllOcGxWL0I4ZUhoT3Y4a0NSVWlaVVZwa3Qyb3BLUzkyZWRhMWFRUXdJWmtFRlEva0lWV043UXFqY1QvVXltRzVUTzhWcUNCSlhnSTV1OVpPTCtHdlVlS2JCUStwUUozaktMWEMxOUVjcG9VY0FjU0Y5eFVMRGVlaUJzMmJpRE5QcllrWjY4Ymh6a2NKSU9TQmREZmYvWEpDaVB5VFRacmhyNkhEajR6T2Rld2dGcDBYS3Rrb3JzNVFFMGpuQUp4VWZ6Q0xKVFJnbjRXM3kwd0djTzNxMDhkWUN4TzI3dWlYSXZ1ZVIyckJOUnZ4QjZpNFJKTEJ0bGZLL1M2dU1NRjZJOFdtcDFFUTladVE0ZXhHaUFoM1FJQUFRVCsrd0lFMXBhYWVGam9sWTZTUXZNRDBaOFpnbnZqSklDcUdrd29MVVdzbm54eGlLMUFhZlBXR0tTb3RMeElIb01CSFI5S3oxeCtJeUNHL2htTjFGWWF1M3dPeldmV3dHZVg0Njd3MlFZMDA4bTlsN1ZSL2l5MUdwa25xaGhUU2dxUlRkcDVodzJtbFJqNzg0NXQrdTBFM21UWFRsTkR5aWhoYmhhQWd4bnltelBmVXNKQmIrN3lmYVBVOVdsL3NMMll5Nm5nMUd0OFU0aVlIUTBVVDU1Q0VWbStXS1pNeTlNK0FabkdOblRQNVBOaDIyem1xZTVhQUUxZ2FIM3U2MkxyL3N0WXpXbHVVN2hsWE9zNGZESjRYRVZCcWNqWlcxVXoya1FXTHNvV2pPb2RXZmk0MWdBa2E0UTV0VjhaL3BFTEtmOHFOaDg0dmJwS3Rvd1Q5T25RYTU1N0FoM1ZpZUNDRTMwV2dYQ3lYb29CL1phUmNlTUFUWHNhZ2xQNDRYcTVSMm5rTVBjMnVQY00zNkp0YS9xd3Z6cE40eUN0L3VCK3lCTWsyM2NPUVc4VnJSTXNEend0VXRGWGpFclRVMU54MGQ5bXZzTjZrZnYreGNCM1lhdGUvMHFqTjBMcGdJTGVaNzQ5OGgzUzJmeFBjcGlEdXpaQVJGV04vNHVVaG52S3Q4VSt0UmVkaWlTSkhQVXMwOVRDNVZwWThNeS9UYnVCZkNOdVh4NEUrM3lNUTBsU0F4T2t2YjFibUVkUXd1M0Q2NmRWMHNla09ndjNLWXd1cEs1UmxXRHIxeWxMSExUaE1MR3VidGtiYkYvaTJwVW1JR1krR05pd1VjVG1qV3o3YjJYV1Q0d0lvWW9mZFBqU012aGVqQldrbnVWU1h6cElSQWVzUFB0eXpER2hGWERSWExabVJ4OVZNaU42a0NVamN6TUsyOSs0OU1SYWxWdklUN1lKbVNHOHNZbUR6TUZEYUYwYmZ0aFBMNjNyMUlqTkliaktGL0lFS1ZSdVRHbmZGR0V3ODZLWC9EdEwyQjM4OGhKTjlqcmdDcDNydlBydVFoTk85eUVvNWFBNmt6UWhZUU1yck5kaTczYlhBaVZheGUzeUVaTU4zRS9CMko4TmEwdXZmZEJRd2l2Tmk1RDhYUk4rZ2RaOGprdkNrcEVQejhqTkhHUE1FbWgxbFg4RS9yOTQrUmRIR3RPMkhzK2E0YzhTY0J5SXEwT0t0QkkxSHRUMC9JQS85NnMrWElwRWRoSXRwL2U3MXhnRWdhc1psdGd6TUR3RFBQWldKV2JyMnIrTlU4cXFFZm45VkEvejBHb2Jpa1BFQXAwdFZoK1pyOXhRTTN4dXhXNU9ObDFEWkgzdHBvdUtIelB4SjhYNDdNZmd6U0dJanBzNGJtWCtBWjVwOU9lcFZhR3JMbU9EZ05yNzQ5MjBuR1ZMODNTU3Bpc2xrTCt6RXRIWGY2amVLQm5PNkhpMk05TGVYTzJ0TnkvT2VESUVKZStDV2ZpSUlOL3pBL3JmclJlWVBXVkVrUE1xTStmcndzR1lhNVFMQk0yVEdZWGl3NEJtSi9qRDRlbU1ZRHRzamkxaVRlNSsyNzNIcDBGZFBwcEJVdjhGRGMvOENSNUlucHl6bnZQaG9PcmRqb1RQbWRib2h6YlV0RjN1b0NvVnhSN0lYVk5KOUdyd0U3U2dtdU5qSzdtN212UW9jNC9YdWYrZzVOYTAzQmlnUjY1bkNzNGdyaU1OZU81K1VIU3dJazk2YlBlTFFTL3cwY1d0WmJWbExuTlRUaUU0a2MvNjNzR3phN1UrcXNWM3hOUE5BZ0FCQlA3N0ErSU4rNmlLMlFjc3M4UHdIWUtqNFAycGZTc1BnVVJiY3RTbEllNkJ2eEdYdWR0UUxLR1pxQnJvd2kvdmJ4K2lOUVdwM2dSb0NpeUNWb2lWNTFYcHdjbWQwcVJPdVROUUFFZE5uWjc4bWpIUTJlSzFHMUxaaXZMWmM2czJQdUtuSzZSMUNkaXlqV04zS0k2NnNRVHlXV1lQdHpHRldKdDZ5MzlETjJ3YU1xSjFBUzFSajRiR2pGVXFQMnJtTXNsTWpTQXU5b2hKVXRNNEttVHc2dkV2TCtWbWcyaC82eXNGM1VDeTNVU2N2OFNvRGlsVVRDbVpESHdac2FBMk1VK1ZlcktuTFpaTUxhZjVxZlhheDBhVUxMWE9wWXZLUGdHZEpEMXIvVEtsb2cxa09EaXZ2VGxSUUNCRjV5dG55SzlrWHRKcHduMGNLNE1Yd3hRcFN3cTE3NUNwSHE0SENJVXp6bTk2TXYxcFlIWlVLSlM4N2R0cHR3OGZJeDF0Qnl6QU83UWpPbXhxdWtuczdZSU91MWVHQWtNVTVVcnJZZDg5MVF2dTA4Uzk1TkhGVGdXd3VaU09nUUxidjg0WTBDY2dXeTZldjVmZ3Q3RzR1aVNEY1BaSEhIUjR5Y0FFdktRWVZXc0pWazBZUjArbG1vNS81bU1QSU9hL3BiK2NEU0VvMDVBbkNwVHEyZXVDeGFUSmpac0pIU2U0aHE1aDg2RU44WWlVZlBGOUVPNDVJRDJWWUgrT3huR0hhZmxEdXVlNTdFaksyak1sc1YyUHMzWFNjd1h1NUVldnA0OHoxclZQQUROZEFuT3RVUGxHY0NvbVFtZ3B4Q3NZTGtwdVZwb1phd1dJNC8vejJmekVvNGU2ZkFEUVkwZnpoWEU5Zzk5Qi90dGQycHpzYytyS1REL2tEN3hyMldhRzlSRDBPRnNaSDFBSkcyZHBjdnlzSHpYWU55NmllcEZoaGZPbENFRDE4d3FiQVRocExkdndUM2hhNnV0L0xvRHp4MVJNSDUvbFFZaFkrNURINGYrNngyWVNqUzVONjErTnFrYzFDTkg0cGEzODUwT0podFlmSHBKT0FtajJNMnM0R3JBeXYwSG9Ba1pmUDFjV2NCbGhuanhPNXd2RWFacjRBeHhUblp0ckxlL0FZVzVsYnZyNERSb3U1dFpOWEpMZWRiZXErVE56Wm1iSVQ4UmEyemZPcG85OG9RbG84MTk2c2ltNjAvcnkyQVdrRnc5cmNONXVxaFhXMlZaRFJlYWdUajZhZ2l2Vk9uMkFLMkllbjgySUhySSsvWWJsTnJXdWhLWThNcE5PSW1VLyttUkdoOGZselJHNU9mbnN4Y2V3VEJUQ1I5ZXUrQU01cm5kbm82ZW5PdEgrM1FPTEJ4UVpQQitOQ0p5VmJNUGN1a1ZSWk81eGNFK00wSTdYQytEOFpyUURpMUhqTG1RNm9odlZoZlN4Ri9ReEVGNGtBMW9hTldQRXIzdzF2MXgrSGw0YmR3YSsrUmlFalZJSFQxdnFEODdwZ21MMmo2a2pFT05oNEJtOHBzUmlSaUVaYmZWV21IdXFMRm9WT2c4a21vNlowRkhWR0M3MW0zajNQT1F1Z3Z0UlhIU2JIMG00aG45K0FIREc5K2ZzQm9xL3NlL0QrZUtRdS9zTWV1Q2E4aGFlVjRTVnE0cTNWamlFVkh6N0pjUUhlcXdRS09UZFcvRngwdE5OUDdVSDlVNStXUUU5aGVWZjZpSmV5WXJXRUF3TGNxVEdPVmhTbjFWVzFJeFg0aGpjNEF3ZVBCN3llenpKbWkzT3JwSkhQQXhpdjlBQ0FBRUUvdnNCSFlBM2VnKytHY3ZJNEpZOGQ0RldENzBOMkFMcDBIV0puTVB4Yi9XZ3RlUTFYVXdtTFY1U0pyR1NwRDZxb0lCNE5ZMlU2bjYvTEc1bVh0aytvUUJ4TzZ2K1VjQmUwNkFhM3ZCR0ZScTVQcnZLRHBsRkN5NS9rcFVvbTBOaTJMbGdyNDhzWjYwS0l5WWxZYzBUbjg2QUZITnluaHArUFZjSjRNamVOVFl5bWpxVjBPaG1uNmtHa05tbTNUQXlXSmhQd1YxazZNVWdNdUYxZjUxN3M4Y05LbW42ZnlsZnRSS01vTXlDbDlzUENqUEUwQkJrRjFCc3RDTXdPMDgvUlhvTGJXcmNQQXY0bG0vSXZodklVbzZaS2s3MEx6YVczc05hU1FaQy9PSWRqY3FMNUxJUDExNzA5dnJEME4xZ1NYak5mcldMNTM1eEJLWFRmaHB6SEF2ZksyU2RjN1NIbGRkZG9mNERNNEo1YmlwSDlDVUVZY05rZm93bUl1MEpxdGV3UWN2V2JtU1ZiMFRIZ3Jpa3o0RFNtaWcwbVZJaDFQT3AxVlRQQ2Z2UnEzbzRhelJaOERNYndVNWJKWS94TWxMLzZiZlFUY0FtYW5BWlJOVEtmL01SaHlPNWJ5UEhiRml3cWdDejFiOVd1ZythNDZjdzJ2aC9SQVFsVHNWQzdsOVdKTnRPYmc4SDZMSkZXREJjWDNkSyszMU5QNmt4VkNyM0E3emt0RlBBczN3ZVJ4UGhzM0l4aFphRWZOeHBJK09CQkhmT21KR1pSV3pQS3hrZUZzVkNUaGo2YzU3UHNncmx2VTR6cHp0Nm9zcXVPb1lDTXZ4aXE2WWx6SUpYRlNxM1ZuZVJoZVJnZDFjeWNoVU9LcURZK3IweDVOSkNaeXlBNEZzQ290Uzl5NHcwSFJLd0o1eml3aUxYb2RpdVplc01KbVhxd3JTZVlhSlBObFNFSFRiQUFqQzNhMEJtR3hmb1RVbXBjeUlnWGROTzdMNkduajR2WHdTRjdvU25uczNQWDBJSys4UGFZczBqc3lEQitmc2ptQzl5bnNaRXpQV2RwUmJkZ3VyUjRaYzJLVXZlcWVRRURvUXZwOWtUZVJBampteHVtZHA0WFA4a1FPbVdScndzVkxkVW5iMWw0U0lCQS9WSGU4VE1TV0YxTUl5WmtBRjAvOHJaZVV4YkZJaHVXVDd0Tm95bVZWQ0RNT3pOYnJYVWcyd0lweU1hbkMxdHJ3WGd1MjlKUXF6UDVZYVc2QzkzMEtaTWhSSTRKOU9ibldYOWVWYkdXOW1sZXdjUk53VFZtQWNhY3JJKyt2RTRtWDhpNG1Tc01vU2hJS2dJM3hydzRwa3RYT0E3b0E4WjYvdm5LcE1vZ3EwdEUxa2JmSU0rK0FFOFVYblhMTTRQVTIvTGdTR20rREFHU1pSRFI0NHJaY3NyWU9IRFUzUnpGYUFZM0kzNW9BTmQvbDBobEFFT1VNaVUrTUljMFdEeTN0RStBSVg5VGl1cnF2ZDRCWnJlTTh2eStVYzJJV2VOTURkMFVSOG5zMWVNcGhEODF4dzZGNVhQZVAwaUt3bm9nQ0I1a1RxQjdvd291MnhNL2hLRkNXbXlqSHlpYWRnTGc4NHlVSjNldjlBYVJiaER6V29tL0ZaMzRsSUVWOTE1VEpOLzBHRGcxdEQ5ZHl5Tmo2L2RTak9ydWRqM09rOEZZZnl5ekp2d1R6bFF3dG40cjFWYU0wZjhpZkV5d2ZxTHBuUEtSUlUzdjdUTURkeSs2dWZ6V29neGhRd2xWSmtielM3YjhvWmkxSXZqeStRVFR5OVZGUUlBQVFUKyt3R0htUlBqMGxLTTgxRGl3NkY2M1hZZjJ0VXJrbVVwVWwxWlo0NzkzUEpwbTl2WmszOUxPcDExUkxzZ3V5QTJOeERnNGNYTzVEWklzbUlhbG8zY1RkVUxoTkZOMDNVR0xJVDJjbGNVMjhlYjJ5LzkzRlFYL0pzTVUvcU1LeDRjdDZxRmVFNjdaMk0vN2xLeW93dG02VmJWL1gvbnlkSytpU1RYWDdPbEdTQ092QTFzRmN3dzJPSzJSUGxrYXhucVUybDRNY0N3TDRKRVdDWEhYRlpuQTdhYnhnYUJ6eWU2aTVwNDNDZlUyUi9ya1RwbjBpaTM0VWhZZkFxZExpRHQzQVlCc2RSeW5jZ0owT1B4YjVucXhiNFo3U000cXlsTXU0ZUVicVNoR3ZHNzdXclRKNGJWREtVYWUxaGQvYklXS3g4VWY1YVFBS1kwWTkxYjRRUFVwc0tIa01rUGpLMlVjWkVzM1lmL1k0QktMQjBqbzNmaWRHcGpLYloxQjZjWWRKZzc0OG16OGxXekRFYU9BTk9NNjhzVzd0RndZTkdDekY2UEF6WDRwNDlhdHdvR1RXNmNvUWVnY3lia3JPeGl1dm1HYm5JUTBHU0tGNi9PcUtrU2ZTbzBxR0pLNjloNDJLaWZ2ZHB3NWtTMXhXV0trcjVtNFphdUZtYUR5YlU1WENuM2Q1bksxNlptc2l5aVBXcytYN3o5UDFkUHp6S1dxckpsekIrbXFmVG0yZlp3K1llTEVYWFZ4VkJaRDdvU0t2RlNqMGpmTmtMT2NGb21kZnpZQ3U2emJJMDZFVE1nSGdoWDlFMytpeTlkVnVqeWhhaUFNWSs3S3dGN3BVME81Qm1la1ovZXZzV1NQT3RMS29YODQwMk5pZExTejhReFJBWmlKOGZTYjRmMVVPRmNEbGYxaDFqbTFSNDBZa0xKdkVrUFBpcG0yMHBOOUVOZTg2RWI2MDRGVUQzVnhHWStYWm1YMVVEMTJtbWhHR0NPbndHMytnaGRiTUhxZ0lWRlIrNTVKZ0pIckJqcWNzZnZFMWNIT1g0UkVoWW4vWEM3dTNnTjFIQ3FtRUNxRHBiek1acnNJeWxqQlVHZHlsRlQrVkVBb1ltaTRvM2VwTmI1YnZVTEJuRkVIQ3NmK2dXeXhUN21XNUljNmxBZkhKVDI4STd2eUVkc3BDQkpaeWxacVV6Q0svVTlwSUh2ZlJOOXNMQjQyLzIvZWhxWHVGTURuSlEya1dCbkthZmR4KzhZRC9UM1V5YWlnUUgvbCs4enlVQzdpd0szNzBMQ3R4cUZ2RnUwSEtVbVgxSUt5RWY0MUtROXIzSWJuOUtKUWY0TzRiY2dkOXpTNGI4ZE9MNlkwQ0tpL1BUSE9HaTAvZzZiWG1QU0c5MlFBVWxkcFlScFBnY1JZOVRVaERrYlVPNUNmMGhRaE05MEFmQm9pU3p4bW5rZ3NEeDFFRFBQRno2ZDBDVGZOOVBkTm1PNnlldEI3Mk9yVjFWd25Fb1Q0QXl4REkya0hEY1NzdEVyNG84WjRxQWwwaS94V0ZtNk5BNGg1cm5tYUFWY1BJblZrRUloL1RRQ1dZUlpGelB2LzhCVE93UDlzQWp4MTBhVkNXdkNOTTlkOEVwYndIeVBFR2RrY00wbUxRZ0pteFQwdHFMRDcvWG1aWlROb0NiS21aSlpBMGVQaXV5ZHI0WlBqZ3p0YXlVUEVmQlB0QXVoUDVnU0llTzF0OWtOL2Q5Ykg4TFpjc2NTYTV0YlVLMWRpWWRxT1FEaEs0aHlaUzUyc2ozc3lqMzNQTjZZdmNOUzQrdXVnRWpvR1pjUEFnQUJCUDc3QUd6azZFSGpnVXJZblV3TklmQ0Y0K0YySnU0UWxsR2hnVGdReFhTWGxLVlNxVjN1TDZRMEFlay85MnNueWV2dlR5dWZaRHZUN3ppRnc5Qk4xV1JEaUFyTDVtTFlDQmV6VXZwbmpTZk5nN0tmUXloQlFDRHRuZWRMTGw1Vm44ODE5T3cxRy9yYzlwbGxlVUEyaGwrZnl3WDlCYm52b01CMEhSdjBWZDR5WEdQTHVpdm0xWWZnQTQ3MXZaL3hTeUJLN0l3ak5qY0REUmduWkhvcGxPeC8zNDFkelgvcnNvWTVHOWJ0L3RXWGRPeXVHeVBCYUN2cXdwdGVrYmwwNEJuV1dvMkRudGhZRmFESkNyNHY4NndUcGlSUWpIN2lLU3JFREdPUDJJZFNPUkRHZC9aU0dDZTVLQW9PVXFGbVdHZzI3TklaN0c1aFplakt2SVZ6dmppMXNaMXl5ejlKdS9vYjJySlhuTmNRazBRVnpKcTN4dUpEVDBlNXRZbkJRSWlNMWJVMFpYNUV6Z3AwV2VFSml5ZU5OS0dJeEtYcnBiajNTQXlaZklpTjNiSlZyMGhTd25CTFJmdm02dUxQcVZzT2ZlZGZRTGltRlI5dytNK05LR2Y2VUJtSEVUa2ovZlpLeVBXKzhqVVpPYW1Sdlc1aHNWV3VqMjBzWTJnL1ZlL0MvdHBoaGJPN25ONVltaldESGFZby9BVzlpZEEzWFBsU29TcFhKZmNCa2p3bFZqSXg0VStKVjFpNFB3alNjdlU1RHBzT1VkTE1kKzZnWVEvczYxTUxNbFlrNGhsY1JKWFBrcGVHL3gvZ0NPamxKaUxjbi9DaDBYREt3WFRmZWNHbTJiYVE3KzIrK0ErKy9zNkRGTkJyODY5dWhPVnNEUGdkSS9YelNGc0VxN0ZUeVhZblM2UDNZc2RnWWVvZmpqTnFCS3J2MStlbEVpVWthdlhKYXJabG01dFovdStESmJZQTk1dXdyZU1TZDFLMXE1L3c2dnhWazJkcTFVT2Q2dFhsTTQ3RlVjbzZXWE1ZaHdEUUZkeXA1ejg4Y2tQc2VKS0xCaVpKMVNENlhCZUF1VkJVTTAzczVvbVlTV0pLMDBlMGhuWmowNU9UNjZNVWhseDRqT01sdHVjbEEydExiU1FlV1ROdmUwdmNlRDZIRXhRclkxYlYyOTk1aEVwWHlhcUpSQnN1T0c3a1A0TWh6WEUvZURweHJ1cFoyUHZpbkVUKy9Bamh6VVpLR0h5cmJPbmkvL2NJSDFZRlRRM0FESEhsb2xpVE00TUEvamt4NDZVc1llZW1aN0M0QUpKR1ZxM2dvVzJpcXVVb25sQmxudDhjU0x1QUdxTHRVeWdPYTJjYU5PNHd0MEJPeUdodktjblVoTWpZa2JCdUdWNUc4dXd4L2tjeHppRU45Zmk3WkJUQnp3SFVnM1gxMTJyTGU3TGIycmtUMGJxNUVTc0hmY25wdm44M3F2UytBTmJ4Z2l4cWRLR1QrMmdVbzdKQjF4UmpFa1RGRUNZY1liclVHb0Zud1NZbUVMSHhheTRrcVdJL3Z0djhNNUR0dktlelpIY1ZZd1BsaWhLM0ZVMTNiZWs1cFdCMWtpQ2IxKzJaWlphVkJTMDU4Kzd2VUxHdXprUmFWRVRXa2lwa21La3dMMGYvWEtTQy8rbmREUzByWUluaUFtVUpYSHMwRTdZOVpwUHArdUdFRWY2T2xGZTB3LzBSdXB4WFRpWUhQc3Q5YTVpa3U3Nkd3VGptYWpTazJXUExXUjNWckFZMVBIak9MMWlHRENMUjBzMXdOeFI5TGFSZHlwT0h4bHNDQUFFRS92c0E5WXlCbGRtMXhTSEh2TnhsdU9Qb0NkWjB0dFpMeUNYY1YrM0lVTm80WUZoZHFCK05wbTVnNDVUMEd4VjZSekRKa20wWG5TZW5nbEJ4OWVhNi9qNnVqNUtESWxkTis1L3RUR2RHVVVFSE1kQmh1MjVBQ1E0eFN0NzJUTkpodXYyNjh2NjBmWndrcy9Ba3BjM1dqT3FGZ1dPZVNsYVRHOUNuQmw4Qk03M3R6eWM0aFJNWkNoZXdqQk5ObWwxdXNod1F1ZUF3dlpRRkN6Nk96dGVlV0VRVjBzT1dEU0EvSkUzWnRUKzU4S3l4ZUcydndzSXl2bzNZUy9lSzk0N1lMNERJNXBVZzlFMlhQZ29xQWhUb3NManc0ZjExazRHSDl5QWFOa1BnaVhaakhkazJadlNoZG1xMEhOc1IxWGJDWllYajVQRG1NcTRXSHhuQW1DT1Y3Z0h0V2h3amxiWnUzbCtLZkMwRG54UGV5d1oyTUFwRTFOTTRya2tHdlZQL25BRTY2NW5QVmFuaExZVGpmb3dlalJSS2FtbHd6dTlNakNmaE5aaHdYWnNiSGQ4dStHeHNmZWZ6RXg3dWVIZnMzZ3FQMkhRTVBGR3R1WCtPTVZaQW8zRVRMa0czaHRUOXBZcE5vTjdId2cyMzlTT1ZFckVrTTJPWHpFdVM1NnFpQXBwT2o4NEpBaVNCLzM1bkFHcER5UUNpb0xMS1dla2xmeEVxNUFzVyt3dVR4bmEwQVJEVy9iWFhFWXhJa0J6TGtGblZsbW9aYTNEWW40YVNJTWdJUEErbk5UMFM2Z2dPZEhBR1RiakxPKy9lZkg4bFVhQ3BpMTM5dmJoQ0p0K0dZaHlwN0ExTnVZSzRiLzZuVy9sMkozSXM3RHNGMDZNOFk0YlJhUi82Lzd5TExpMDBlL1Vkck9LMkxHSTA4VzhoOXdyb0VwcW5WNkVtcWtJVDkwSTBYelZXN2MwRFRHSmtxcllXMDhnSXI0c2M1TTFpcmJVSVV2RUk0QS9FZ0RScVNtRDd4cUVid1ZOb3VLSGdtK1N3TmdaYTlEN2hHYWludkM3RjNIazhNSmZMUFRGRDA4dzdTM1BNQ0cxZDBBY1VVRTV0WGIxMGFpZlVudk9xOWFVK3pYVEFIanpZdEdvOHF1RDF0QmRxQWFrSmViOS94NW5KdHUxNSt4K1lzZHNVTHQ2cG9PWjUzUWRJSlRpWkE0c3VQSFBMbXUvNCtTRnBxclJzaHZSSHFiTVZFRXgreFU2QVhoT1hYeDR2NVJORVg5MXpQVGJoRFM1aGhPaVAxaGVyM3FyMlFRNVlhdS83R0NmU1VQNHIxbVFQTi9rdzRBdFNuSlIxbWJMRk1kS2w3YVNFZWd0WHdteklqUlBjQTZJVGZ3c3ZvR1JvMjkwZ0toRnNFZWNEeFRlWWRXaDBaZzZxNVhIMDM2dzU1QWgwdGE2S28wNUcrY3RKVnA4cmVYdG9xZEU4c2dCS1FDNnJYSEgrdzZoNUw1V3Z5b0NiUlplYUQ1SVhYS2xlemRYbnhMc3pIQ0dFb2VGZndyaDQ4VjFmZHZMVzMrNHo2SWUrQWtTMk5iSGtWMmN1a0o1eXBRdmdzc3AwaHJLeElxa0QycjNZSDF0Nno1cXRxRkI3WkprczlobDE5YWpscWRpK0wrNHpCM0pBWGlKVnVwNEovdE42R2phU1JUR2JmeGtlQVdUb1U4WlV1c1U0RXNGejFzREVwVC84TEw0UjQ5RXJ3M0U4c2h1WWtvMkd4bmh0cVl4WlFXak95a0UrcFVCcXhIS1JvVzBzYjlEOTlOZGZoWEZWb1c0ZndBSUFBUVQrK3dIR3FZN2cwWCt6ekhaOU5TbEsvMm16SW1BWjJJY3VXSDNkZHNUSldWcVRmc3E2OEkyZCtaOWFzcHJyZjFlYXV3dStXQURIUGtZdGZybmI1SUNDNWhtYWRrYWxRQ0pvcytYMnpjUEg0VDdpMHlLZGN4VGkrQ29pT1FrODBLdkRGekx2YU83QlY3SHhLbHY2TXB5KzRoVWExOFNhWi9FZDFIMDNCdE42dVMvTC9oZ2hXVG1vaGYvVjRWc3lITElsQ3BHaC9LdnJzenNZRy9aK3VRSzVOb2xTc21yb3lIa0tOS2xGbmM0R1RGV0YrUnlOeTZ6Ymp0NmVxR2NSUUJ0TGl4dXZsV2RPcHhEWnRza2NDTDdPeUhqSWxKSmp6bmxtdWhqVU5ERjhoelFHWGVlWDdkOWNQZUJ5bVFLRU1TK1E0NndyclFkU0gxMURkdnRxYURvdmxubmpML2lQWW5QNzZXRHBtOWN2VFdhTC9aTHhYN2NCa1ZVbERlNkZTTjdRbDFQZVI5MnVGYlBHU1pTRlB0WGlXWmZib3lYdDFrVmFOTkdGeDJqUUNBVUlTNFR0V01ITjl4Rk5FRFZyK0xteE1jM2p3cVVOM1VDLzh6UUNOMDZnelcxMTErclMvNk0zQ1dGa05vVCt6OVJocXRLQjRrcjdKNG9SRHJacWgzbnI3NEZTVFhadDd1clFXTVNqY3VFU1g2c2FIeE1hYTRIc21pS3hVUEh6OGFDZ0dFanl1dTFjY1FFUnFyWXdUYWsxY0xjK3BFdVJHWXJNVXM1cjZtREFlamR3WG00QjZkWUx5NmtrRHVqcW1OYUM1c295NVBvL2l5OXQzaDNHYWV5SXk5L1RkTldXRDRtVW5VSW5Wdm1YQy8yREswN2pXNjhNVk4wbkxUYzNHcW42bVF6MUxpTjVVc0dvUUU3VUppUFNrUDVvZzhJbzBpMStMeUp4L21yYjZPNU5pOWhJTjczeENnZmtiQjZhRllsL2N5eTQ0Y1NTWE5CY01iTTF3eGgzVS8rMEl6K21RbDhjcFRneVV4b1RFZ3BBRUhqeDE3aEptVWx4aFFHdWhna1FYeHJOdURITEpEckR2RitDOW96VFp1S3Nrb2t1d1JmMGJjN3g5OTR4Nzg5WHNyWFBVOUVVNFJBbkFEQWlTQ1FPOVlTUklOL3hWVjBGZ0l0bnNoMjhDUWs3WU1wOHROOEFRN08wbktFd1NaRVh3eVpUZU1wRVB1RWZhTHM1MzZMeGJmMVluL3JuSTV0Mm5EVnhEQUxxVUNHZXNwUjA0bVJqZVJhVDNHd3lPOVRUdUEwUk1TSUlxNTllQkFhQ1c3TGJjcDBOallvS204Y1hpSmwwZmJpbTdFbGJyVnZJSW5Ud1c1OGd3WkZPaWY1Wnh5UXd1aEYxaGR2RFhncFF6UVlQdFlxRzdxeEdnWURzcXpaTVBFSFN3ZENFdHJhS3gyT2xNV3BxWlk1Z1FsRmpFUXlRUXk0NGxacGNCRUoyL0VSYkl1NlRyQTJMNHBLdjUvUTdWbW1zeUY2WjlvRzVrWXUvbnp4TE1DQmpwOWpjSWtsbXZLcjE2TkpHY1VJRURQaU5wSUlDanhieVAxMTM1S3YrQ3MzL2pQT1Y1OVFXVEEwenpUVExZbDhqYmR2ckQ4SVowNGZNdUR2aFZCWEhWL1BEUERscUU3KzRDdFZqcFhTOUwyeWhRbjhleDdQWHkxUlVyN3JkaFEza0ErakhOSkRMZFFjNTgxM2ZRSUQ5UzVrdDFId3ZFZU9CdC90UGRGTno4UEhEQzVnUkxRblFUUWxvWEVHdkRlTUduaG5KQWdBQkJQNzdBRFhYZDlyY2ppdW52VGp2MjhjQXN5RjNuNW1DanN6aVhwVTRuNkR4dDlpNjNvWFpLZnF6K216b3U5MlRsbDhQN1VQLyszUXE0NlRuVFRkUWZMTWdNdk42MHd1elZUWkZ3SE5jdEFqSFpyUW50dlluN2VnYU93OUVjd3R3OGRkTEp0TTloTDhueFVMRzd1MU9yN0dKbnRyVE5yME1idmFhbVZFT0Q1UlN1dHQzNkNYTzVaTkN3d2NjcWRnOGh1MTFMWEZYVjZHLy9Pdy9oaEVqYkh0dkJyeGdFeGpnMVZ6bFdtbkNhYU5pcVhsZDVkeFJ5TmNGTEw2UENrMFpJNDJxRHBPSFduc0IxU3ZERWpCVVdwaUhuQkVTTXFXZ0FoVzloM3hGL0pWT096RmRwV3REQVh2YzZnU0Jsbmg1R3BhR1ppb3dOQ3I5UnRlNC9YOVZ3eDlmNjZFNkEreHpRT3JFYVEzd3VzUzJIWGtrdENOUVJEVXdLVlkwbERnM3N0MGhvVTFvVkV0YVBwZnRxbG1wWERtbnVJVllpUHJ5U2RKQURUZWl3Y3p5NUdTUERLSkJVcnBwc2JoekR2LzE0MlZpdUFtZlJGQjVhSithWjNabkx6cFFHQ3pYTHRETlJ4UGorQlVoWE85cjhIK1c3YWlpYVNUUnIyVVRBNDBsaHEzS0c1akErczQyYnQvSTBzYnd4RlQ1aWFiRFFvTXJuNU5DV0FOWThiYmhMU015NGZkREJzVE92NVNhZEJiTEUwTUhHdlZHSHFyaTFxNmlBTDZ0QkNqakFiRkpVVHBjRCt2cG8vQnpXTmRHU0JyTzFiWEtvL3YvaGdBQnJnSjlsdXdNbUJWRzNBMDdRcm4zVlF5TXphQWhqUHpzV0hvKzZNR2JwOWswaW5mVjcrZEtJdC9GdHlGREQrSk1Oa3RuajhkMVdkbUV2VUg4bnNBSTY0enY4NnlsdFhVcyszaXkxV1hTTDNTZnB6eEZnUGphVVdwT2J4K05aMEk4c1ZTN1Vjd3MwRE9USklSWEQ5S0dJQWoxU0NlazdRRVE1MFVEM3pnS2xPUG9JSlRwTGlhTkVna0ZKNnB1eTNqa2lHQkJZNUlkQm1HRnNXb0VQQjB1Z1o2QnNaQm1qR2FGZzhsSkZOSlRJU1oxdlRaRVQ0c0NKNmxLdDJ2aDVqL2lJUTI0K0E5U0c4VUhnTmlIR29mNlFDeEVQTlBCUXVQSENSRG1xazJhN3dFajE0cS9YbE9WekFNaXpNeDlGbGxuejMwKys2WTltdit0Y1puakN3TWFiK3p5TUNhd2d3Yzlkd0Qvamk4OFR3cFEyNnNYaFN5NjEwSzZ4dUNhbEpudWNINVg0Nlp5a2xjU0d2dnpWQU1WcDdXYm15SlhiVjEvSXdESEc5eWlxR015RnJqZCtJb0tocm1IZUNGcytGSkZqbVN3UzV0YStEQUJKekdwejU0ODJVTWJ3UDI2VlFhbjNUUnZVSW9ML3Bua2J5R1c3TGRxdzhyeFB0a0laMXgyQytXK0p2N3NSMGpaR2Zod2Z4NitMQTExUk04MjhnakEwYUNPQUtxNWpuTTd2eE1DSnBvUm53RXRUU3k0di9LOW5ySGZIQWlTOHJCQmhBcnk2Q3ZLQUpOQ0lFMWduRkpVNEJ1ek5RSEs5RHY1QjBodDc3SXlFNEJvZjFFSTB4WDM3Y2JQdk5jSVh6aEVUVmhLbzdBdGpEN3o2eFgxV0lpZVgxWU1hUUhwTUhGc0JQb3NSVU1NcWxYcFVEU2ZxWUZsNjU1bkhkZmZDK0ZzZHZBWXZScGlXSzlkZHVUa0tMa0NBQUVFL3ZzQ21xMXlYWGg5UStHVFQrMW9tbytReDFhTXpVQldlL0c5U0xQdVNVdlBjWnlscGROaUJrVjY1a3QyT1FPTVVpUElROW0yMnkrMUhLaGwyVFM0bnc2MmdueTZRbGdFbklTZnBHclVIWkZCSkhKVEpUMzVNbTlvbzRpNENxNjNsMFN2ZUs4a2l5blZEWmFwczRGaTlDcmtkZG1YK0prV0tXcmlGdnFsRldaZXhRNDNNdUhpRVRuSTBWNFJZbFlCT201a0tDc2VFL21zcGNYYW5uZjJvcHljVkhJdFZVR1c5dDN0R3ZIVjEwSHBqZnNnRFRId1ZkcFgyeTdtNDlibVc5blJDL2pWZDd4N054QWMwYjA0Q0VVdSs5UVZ1U21mVUk4Qnd0UE1aUzM5Nlo4aGh0Nm9ranhZN2tUR1dKemlPSXNscGFnOWtIRlk1aGc5Ym5uYjlpWkdid3JXQjZkMWhtT2lhNzBUR0FFTzlZRGQwNnJRUmNJcnBTS2Y1WXBEUEk0azhqdEhaNXpBak42UUkyREdIb1BzMGU4UDRjTFA1S3F6VzF2RlZGRmhIclRCVll3U3B6Z3VNeG9CR1pWRW5QRE5ZK09YVlV0VU9VLzRnYmlvRVpXeVFveG5MWTlBN0pZWlBhVXlwVis3cjEvbVIyM3RxWHV5K210TFVFRlpiQ3I1Sk5YcXdNK1JuMEZoS1U1cXk2aUJOTkZpQVpwaFNzNmJvVVhiRnI2Rnc2RytYYmJIS1ZPMnZHNU5JWDV1d2c5RHlxWUozNkNETUNYcVViR1BLQUM5R01QTmVoK3JFT1FTVFJ2Yk9STG9aekZvMWtVSkk0eXVHQzNiWlVkajhFbHdmbGhXdnlrUTJaaFRKVTNkbUxTemtRUVBiaDM2OStJSWYxOWZRWjdQdk1Ubno4cDU5MC9YbmJON2NzOHl6eUdUQ25EV0FBZmRtZGRPaHVvZzY4NmV2L1RrMDlxQVh0cEhQWGxzWTRpTEhoQ3NKYmpoYURpdFBPbyt6aFozUU05MmZhZ3FraGJXaHVqREl6MHZjWXVLcGV2S1BLTkhSUGtxTmpJUUVTeDJmaUdvUGZCR21lT012TGRMUk52dGxaUmVwU2J6aEdic0pJVm9KT0tucElhMkpMbWNkZmFnU1BhMXJRang3UGsvRGlqc2lsLzVncXlJbVYvZXBka1I5czF0QkhGMU1vOXBwZmp6L2VLTGVreDJFWUNZRUV0RmQ4S2ZiK3RrRTlEQW9SMjBTVzN6UEMyYktVeEtWekg4QzFQRHhSWEpLalE3RzBVazNzL3BCTE9YUEMrbzNvWTJLTnB4bEJIa2d1Z0NneTdoU2xHa2ZSczNrUFo4R1I4M2RQN3VadlVFUkx2eGFlbUJ0WmVFNlFJTWEwVXBDL3E3WDNsR3VJNWNsQ3hqZFc4YkltbFBNd3o1amxoS3JYeXo1cXlaK1ZVSFRXYmd5UlNEdHlkVmplemE1cmNKdE5WeXF2QmZ2cDhZelcvemZ5SmZucHZmQ3B2cG9MNDZRVDk4ZkJIMDVkaXQ1cXg3cFVRcGFCTUVKR252TzRXbDQ5T2d6Q3c1QUp4T3ZhNEcrMCtWU2ZGVC9ZbXoxQURnd1BuQTZoOUkxd24xWWRUZTdQRUdKaTRyVDRiTnM3UW43RVlzSURlN0JPOEsrUTVWUmlaUlV5MjRkTDg0NC85K0RrZVdwRjVDZGUzSEJ4T0wzdGEvWWdqVTlvbjdpdG9JNm1CTTV4dm5ZYUhCWnlmVEZSNkdDQmNNM3JpcUVRMGpNUDM5UjJpUkU2NDFJSml2bXpZR1hORThiUXA0NWdJQUFRVCsrd091VUNxbFN3eU5ZUVM5c0dCUjRhQkNhK0hKbVZmd3ZBRVVQUmt0ZFlGNGh5L3hCbGl4RU5XQ09raWVWNkJSTitNcGc3TVdvemJQWnBNTGNDTTNUZGU5T1paYmo4YW13ZFNzSVRmMjlxT3kzNnorVnJ6OEg0ang2MWxEWWtMdHduNWxQSEtXTHUyb2xHTllFNEtjbTd4MGFWcGVhc0RnMkgvSVpyV0wzZ2F3N3FzSFVBODZxZTRwYUJRcVI3RVpQVEVDdGhLVTB1Tm9UNVFLSGxJMVB5MVhEQjhsVExDMFNiNmlaMXZaQWhuZjk1ZEszVGROdStKOHFvbTkvRkpGb1J5S3Y5N2F4Nk1aRUxjdmE5RDVSNC9xVDlzV0Z3TFpKaHhBTWV6cjBzV0pVK1JkQW1YTDM1SlpGQW05enNGU2JPNGVpYXJTdG1TSDg5UDBrYVNvWjB1Z0pWRjFJc3I2OHcwUUtWdHE5SDdGNDZHM0RtWFY2TXh3VTRoWThoU3dJRTF6R2tDWDhJL2grUHNOcDZFOWtyRW12a0swSXZ6SVJOT1M4OSt6cDU3Qkd6SzVESlZUVUxpMGZmaVFMMFE5NVI2bmt4Y3djTUtsdjAwL3RYUVZPalJhRSt2czFCdWI5M1hrNXRXbTRNcGRJQS8xcmtNMjRCSTRqMEpZeUNHVGNJYWVFRG55ZVFsVm5FQWFrRlNoWFFsVUR4d0dTQ29QWjFhVVQ5dEs5NFl5aGNuTnJaMFlGVnQ5Sk01a0J4T1VhTy9mRXZiMXR0SkJ6MFZWSkdLeEt4L0IzQkplcmFNRE5hNkE2NXJtRGVoWW5JYzJqdDgvOFk3Q3BranlIRjFSSGtnS25LZUh0RHdUT3NYU0pwY2xRRnVSR2d3UUE1dnRNTlBFZzFCbGk1Sm9ZNVlUMm9QNDB2Z1FXNStPSWM2WGMrRXIvQmJaNzIzVXAvanQrMmVYRFdGYURLZDNrZmxDSHV2SDZOb3VwMzkvRkswZVdEZnNLdm1wV1BDWmJ1bWY4U0h2TkQxS2FjN3JnSCticTYxR0lmaERnbHA5VmVqTURqazkxakhtc2lMY1N3ZlBrRUFUK0E1cUZvK3p2YjhKeE5hdzltUy94QkpxbEdWVExNc1VwdS8rUTdTSGltbEN2UUFBMk9rYXBLUFV3cmhBZVcxcEZQbEJMQkhIWllmUUsvc1dFL3hpYXR0VFQxKzB6TURvYXZaV01aMEdpN0Q4bXQzZXlCZmk4SDdDOXlLOEFDU0pBVk1pQTU3K2d2RlpBZVgzUDhsT3RSN2k5WkxxdVczc0YxcHJXc1RGZk9JV1huTW5ZZUxqcjRMRFQ3TFczMm1NbEI4YUlyZVpuV1BjbDQwN0FuUW1OL2tHdlFUc2prNmZ0T3ZQTk5jOVlUd1FIeXh6d3RDMERFcmswNWZIdzMyK2RRUm9FUmV2dFdEclpXOGpabTJwR2wxaDF6dW5ZQWlha2xHSGM4VlJqYnluc0V0cnowL2cvanllV2pJMkRPZjRxMU1wQUd0L1Q4bU5ralk0cGM5YUVHNHpSK01mcVAzNmRudTVDWXMrZDE1RHJKQU56cmtUQUhka0V0MzQ3RVpIM2t0aUE2cTZZZ3JSdktITnV0MjZkMEVwQ1JGSUR6TDdsVGNONzFyODZCN1VtSGVMa0JNUGUvTkw5czNiRGkvZnZHQXRhQm9DREVzbTE0cVFMR1VVZW4zNnFVT3JwSFNtcE93dVg0TzlMblFLa0JzQjRrbG9mVFNiRGppZDRMODJSb1huTFV1Z1kydHdjaVJ2NmlJT2pUV01Qa1YwVkxlREtsbDJBZ0FCQlA3N0JJeEhJNlM0WldFbHZYSXNRUlRrSGZlSVJYQk9qZHlYN2RDWSsyajNEVUNzQkFHY0Y0K1d6bDN4dy92U2tEb1NBSkRqUDhaazVyR3plU0l1UDN1RzVwZ2kxN3l5c1djWHlqcUdyTURTTm1peG9SYWdIRjFQUWg5N1Vxamp1dkZrQmpTMlpyVFhPYk52QzhmZUEzS0c3MWhENWplK0RXWjBrU0c3dURrWHM5YjVlZ0VjOERRRjVmQ1I3RFp3YkNCWU1VQm83MEhoVkJEcjByOWY4ZnZYT0hOY0lBK1g0aDdCVFk1QWRSOUYya2Nmcy95SXFXL2NNMTdDaTdqNk1TYnIyVUJSenRGNjBST1pja1F0dVgxWDc2NWdkTXhQL1dMZTl2N0ZGL1NBRWhlNzlVbWdabUpxSlJwSWtweDZLZVlaZktzODNSeWJxNGQxN0dnbVpKQVozQndDZzloUThFRU1OM3Npd2t0ZStVQy9iZ0Y0enZkQTU2aWgxemsvblFnZFloMWRwNWVlTUpHNHV1UTZLN2RLVHJHSWdoUDVTRER4dXpSSmhEdjZDbUlPdmJXTFdoaUc4K1JPOTdnM1RDUS8rZDROTHVJSW5ZaWlpNjFZRlh0NHR3c2tVZVQ0YzZoak8zY0xncnlsaDVZV0Fwdi9GcDVYTjBaOEI0OUw5Y2V4YWN5T2hzaklJVHhVWTVNcGl0b2tXdDdON0hHR3hUcHhSemdDbVhiUzZLd3BtejdNL3puWFBnR3J0YndIYXJNUklVcU9LbDN3d3Z5YnVaOGxLM05SZ3l3bzlhMUtnZmJMNDRLeTByRjgvRFZ4c1JHa1R6TTVnY0ZKcUFvZmUvTFlURDYyYkpaZVBwU1FhUXFTTGRFRXVpaEtMNHBncXhKWU9WeTFyWEh0Wk9RcnFOczBRUGhWTHR0Q3FXN2lOS3lrYmJQMHpNNURVL2R4aStJSmhkTFFVcWVMcnVWSGx4RHErREc4Qm5JQkZlYm1Bd2xUejloVExOekJyaVY4WTQ5SnM3eHJyTVlzTmFtV1lDckVPemkvS09VQU1WS0VNNDBqRjZDN3R5cWJ4ZmNIazBqaTFqc1orMXAwZW1yMnVUeVhERGYwMytOKyt0eTROc0lPR0p4eTE0RmVxNjhnRS9oS2xNUG5HdTd6eHphWjlueGQzSWd3R0xGZ01VSkZYM1Zrd2JBTXFCSEkvS0x6c0g5VFRtSzlEdXVLdUp6NVBqR0NDVXRqd1RhTDJFd1ZSZ1FVc1FkbjJVYnY4cTRDWjVHR01hWmtsWDFwTzl5ZEN6U3FINzBEVENkMWM4NjdWd0kxU1h1bzRFZTVTaVl6LzBKT3I4dzRjUVhzQnM3a3NxcEE0dURtTXQ3U0R3Q3BMMUhERnc0R1Ric2YxemJFOWxPbml5VkQvT1E0bkU2YUtLeEorL3prTUNxNTArdG15dUVVMk9zaUsyUWU4ek80S0FoTU4xNjZQaG5SemNlaHM4ajI5S3d1SzFMRGM2NGcxcEpYRWR1ZEI4cGpYcmRQeG8wQm9WWTJPU3hDUGFQQ1pReEF2eEpRbm9ONkRYaXl4elphbFQyQmFVK05pTUZXTERWWjFTL1Y3TkhwUGVCQXZ5dW13RUM0WTNSeE5xV2YwWmloQXhiTDlTN0N5SlZUd2VLMTZTSGRiUUI3S1VZWXRJQVRaY0cxVk13RTQyVWZ1azFnYWs3UXRXVjR3MGxHaURvU0ZGWmJ4Vmp1WTlMaGlVeGhFTEZZalFLUUpuL2JkT3RlN3F5WEVYRE5zbEdMZU5qdU53bHVadm5welhjam90andQckpxQThnQ0FBRUUvdnNCaGRIaVNTTjZaL3M1azRJY0piM3R6bW5aU0dCSDIrTmdHcmRhQUFUSHExUUVkcWpBeUVJeGt5a0dYdE9ubE04YTBjQk5MTWoyVHI2LzJpeklhRGhva2c3QUJuNkhQbXI0K2FoR2FoYVBPNnhyTjRKRE5nK09jY3hGTGloM1NFV0RWdkkwQnV3UDM1ZHlnQm1nNUNhYUppdFVPRkxDNXZtWExPNC9LdlZpaENIZTN4VUJNMUQ2QlFFdUpESHdwNTg3bVFwaTlIVmVuZCtWaElUQzZ6TEpFK09ZOFVsTWVFYTc2R0RuMEIwOVZOU0NXVDJhdmZEN3RJMGZTRlcydGFnMnh5WE9xbnJCbGUvQm94RnRyODRVc2RCNmRzcTdZL0YzQTJ5WlNycFRtR09CTWZoaHMrRkhlMEJQV3dzV1ZPZS9KeEF1b0J2MzljclU5cTd2RUlkeU1RcklCTGJ1ZG1VbTNJVVNncW1lR2pVS1RFN3c1UUZKWUg3N1B4MGR1aXZnQ3lYYmVUNG9JTDlyZXYwajN3eU04eVZvU3RUMDUxRmExZU12eWdmOTFhYi9PTkNpeEZoeXZxUXExeFc1QXk3Q1R0bk9uQVVodVo4UkxBamxxcENMZlIwUWxuMHh6R1MyV0xsM1dBUHFBeCt3MUhEZ2xaZ1cyT0M3RjNKeWJSUWE3Wmh5RWkrbnVTcEc4d2RuSUt3aFIwMkJYeGUzS285QzVGTnBqMXh6QzJSVHI5ZTBTZTJ5UmRTUituaFVqTFE3RFMyMkhkQnp2N1hKdWppTTlCTllOR3laTi9wWDJ3RlNSakVtd0t0bXIwRi8ySHBPOFNaTk9YU3J6cmxFejdEWVIvU1VsTEYwNDBFUGZQSWwzbEtiSG8wM1lNSHI3b09lRS8rUkY5aERBS3ZsZmx0SmFoc1VIUlRLb3hZWXVkb3NURzJnT2VwUWhqNk5zcTcwRTNGaHpvQTJLeHc0L2Z5VE9MeVRUY2s1emhGQlJwZEhDQUE1UHgwTVltYThqZWNIbFZ6aEhMQTV1SWpIWXJWa1Mra3Y5di9tZEY5UjhwMUY1b1FWQ2Q2OGw4aEhSeW14RU5TZE9qMVVPNEtqaVR2WEJ5ekN0dXYwd1p3VWdYTk50dFpsN1hqZFg0dTkvVmlkUG9ENHg5bCtjQ2tNdFltRGJjRWFMbXZRTDJ0R1p6b1BWcnF2V0hhcm1KK0p3b2p3UTVsT2hDREVHcUJ5ZDRyVWcrOUNPMkh4QzhCbUZKR0ZtRlFkSlpaMG9wMC94VENrb3RrVTIzZnRoakdNSTVWdnFoVUhrL25Jd3RxNnJDM3FlOURFVE4wNG8wNGVJbkhtN09LckgxczlvaDQzSE4zZmxETFFwaE5IcXlJcy9lSFlvelNpNk5tODJNTG1PWmtZZW5xT3VwbWFEV21qb3NZYy9xalJsSlFZY3JjckdHRDVSTkVCczNkRkk4MnJ4d1JqeXNGT0RiUlRVaEhUREdVMW9oMHM5cFRtN3g5NUxZQzJHQko5c3JMSlVWQ2xCQzl4a0FRYlRxRWRzOGVSZ2p4cGxvUUdtamZMcUJCYnF2bnBSaFV1ZEE3NzRjMnFYVGtBZ0xMc2N1b1lsYnp1ZlF1STY4U05QL2lvbi82Mlk2MEdpY1JhUFg5REZVQ25rNWpKbWFaZTJJUG1jN2IrNm9wbmQzV2R5RHpHcVVHSDhneXNDNDhRY1NIR3ZEZ2FpWUoyZkJIQmw2QUxOY09PUW4xNFVPRHM3QnVXRnM3NzVpK0ZIOVVUbjZ3emlUckptbndHcmMydjhRVk5ES09OM2V0Tk5pd2VyZ0lBQVFUKyt3TFpTRlJRY1RWTU5JaEJESkVxVlZ2M1VSSFpWTm5sSmdxai9QelhEYnFxaGRkby9HVXZNUkl4VlJNVGJwQVU2eFh6RVFPQUg3dTRhOG1NQVRCSTRCanF4VWJVMnNnS3BOS0NIQUpPVHo4a01JV2NzSytmMDA5ZDdDSDBqUVBVai8wVFFqRGs1QkRUc3FqU1ZvaU03c2hMczJZUU5nKzV6T1JoZEswVGJHeXhLdmRab1VwVXlzSjNzTWp1TmRpR3lib2Z1SzR5NGt4bWpwQ2ZXRXZoK1U2V1lqWFAzNHA4NkEycjkxeHBGaktnS0lsb1JjeWRIOGNmM011N2JmSnNMd1M5RkZJSmhyYVZJeW1MUjhuNTRGWTE3YUt0QU11NnErMm1WY0RaQnRPc2ZjWERPK0VYVWRXaW1TcHRuU3R0WUxFeFJIbUVEMEkxK1Z4YTZvYkM0R0ZuT0Z1anZRWkI0Y1ZZNG5HdkRRZ2tlQUVGTjFISGxMTnI2ZWVtSmtaY3d3ZTBzM1ZpdTgwSzJndTY4c2xhZHU3eENMM0VWZ1dvRXRKbG94M29nUUp5L3g5cUc3SlhpMjI0WnBHcWtqYmx0Z0pHV0FKWDU5MTd4bW4rRjZYT253ZTA2WnVPWDlxWTh2d2xIWkx1dW9BenZNbE5MWGR3bk10NUhLTGlzWFBSWW1ld0ZoTG9zWk4zNjNXWWtVcE1tamR6OUtud0szYnpFN3VWOHErUC9CU0lHdGxSMnpoV240M0ZMN3k5NVVvbWtFR21VbHA5QW9GcGJMS2FuT01adUpsRXhMK0ZlYXB1ckZudC9BMHd4UmV4ckpiOERDQllGYmVqMURRMyttUkdaaThrR0kwdGo1M2hNOTJjUnFQdHRWbWVKQ05hTnRqWEJiZmhzZUg3K2h5aUZtTmJINlpSdFcwKzVxcW5xMFRIQndndnpiYXVqVG5hNm5VZ1dVUXAvVE5LTkJwQVZZbld6NkkwKzNQLzdXS2ZVUEVMUE9zYXVGajNYb0NFTXpOb0RDNHFraGFBMlpEQnVNSzJOMWV5bFhvenJMdHZ0blZZemd0bjFXRDB1SkhmYTZiTEltTVYyc2dqYkx5Mkd6eUZNbTA2bkliRVUzbUlHK0xGS0dMMjhWaldySEZRWktpeUxkRkNhc1hhQlVyUWVoSDA3UUhzOXAxRzhZeTVlMWswTndwcURVS0htUHRjTU5EU3Arc2V4OElZNmxJSkdXRnBLTDBhZFkzMDd2b3ZXcGNHTjZTWFhyb0tOUzUzcU5qc0Y1aDdRTXlnRVJ3UlkwOWRpV2J1RHNaODA2bC9DbEMvZ2l6UStHRVNxZXVxWS9UZ011Q0JpdjNyQWlqNHBtTThZSUZSWGVYbHM2WmxrdnQwaWp4ekNsQXNHM3k2eHV2VDMwSDhkZW96Z3pqSWxJRHBQN2ZzVkNGYVpRTjJ5cnhlMUNvK0NSUmtUcFJMZkNOL0xZYyt0ekJuYUFkd0lDU01QaldaYjlNYWtuWVFTc0NXSEZ3b0NTTFhKUzlBNlVVUU1UcW1MQWtDb0FLVk8yOFVpRnIrTkhualo2VVB0bCs4TVhlL3pYZWkxSzNHWGdKSi9YOVoreU5URW5YN0xxUVlFWk9YOEJJTzRkRkVIUFdnZkRmVzFraXQvREJ5STZERXY2SlFiek1ZVCtZRktLLytlQmE0R3lDeFdMT2REaW1ZejJTaUw0MTZSWXNGMkI5dUdJdi9GRVNFOGp1WXRjZmpuNDc5Zm03eVRJR01LeHFicFF2NkJYUE45N1h4M09EalNWVEorN3ZTQlF4eFlaNitpc2xWcnVVbkFnQUJCUDc3QWNZVVBMVjU5WWVGdVRYNHgwei9rMHRjS3hmYTBHblVxc2F1MUxEaDJIVURvbnl1cDVNTTEvemVQNGhucnlmYXhkTDh4ZksrMDRjcFhJR0Y1VExld2ZDampybVRlYmlISGFMTWlFUjYwR3ZJaGtPcUxNSXZURWxPbUNxY2htMXloeGZoQUNtdUpTYU5WZnJ4d3U1Z2tuUXBnNEdsd3RGTFRaQ2lENGhjWkpUaHNzeGE1dEUxZzNZVVplMzZGTGswRXgwRDlCdXIvK2w5d3BQNU92WEVhdUFVa0dVWVR2YU5pSlo1QnA2YUgwSnZ1aTN2SXE1UGM4TURUcXl5dStsU0VIdmhCWjVYbmNwakR6dURXVTJHZEFXUGc0SEd6clNPWmxEc2VsT3FVdjJucDkxMnRHck04U3ZiTUpBREFlemltRlczS1lHZkdFdEYxcno1WTVYWm9oYm1IODdweURaMk9BN0kxdnZWWmdJQVdvTmZyNy9ockFPOFhPTG82WVZsckZYTGFuWFJVUkdhZDhUVVl1cnhjdTNpK3lHSGs3d0gzaGVocnZzWVpVNUJkNmYwRGN1RFFueWVNM3ZOVTlubFlNSGZMQWUwU2pBMC80bVZ2aDd2OEp4VFh2WVN5Tmt1SDVhK3FRQ2VOS0lxNy9NT1NZcVZidzlJY29tbzNUVXFzQlJIZTIyU3FKMkk0TkMrMHV4OXZkL2R0alYzc0ZBNk5aVG5GZy84ckNYOStCY0lNMzZ6d0RIR01lR3FERWpLc3hWSk13bWhHUTA5aWcxM01Xc1VEdThJZFJ5d1J6d080TnNBYS9DWEhxWTZURkFNak4zWEQ4dk5iTTk5Y01VNXU2NHdDUjJ1dHh0cGVjY0dXazFVaWRaRWo2ZG9aKzN4WU5xcmlERExnNE9mdFN5L1ArcmxiMXNRSDAxdnU4UlcyeW9JRDNOQnVTenNKcVg5NlR1Y1NRTkM3bTZ2R3JycitXOGRiZDBIVUwyWW5oOE9WcXgwRWlsNXM2aDNnRmJ1UHZMNEtGUVpPSENmL2J0OUFrK1Q5K2kvV3F2NEZDd2NPOVlnUlh0bUZ4aTQ4MGFkbmY2NThBdVdseWM4dXhXVVZ2RjRTRXdBM2Y0R2diekdoZ3IyQTJwdzlMaUwydzl1LzdibjYvL25DKzdlOS9hdExaQXRIUkVYTkM1UmtDZDUrdGF1R1N1UzdaWHVTUWttT0JXM3lQd0h4ZXpzSUR5dE84bmM1N3Z2TEoxY1ppU1RXMGxNK0N6USs0RStzQ09YS25OZzdURFp6VDZFM00vMUdraUk2V0QyTkd4TXNCNk5wYitRTzN1eDJYUGQ1T0crMTliYzJPL3llc3FOSW5mTzFObjh3OWhiT1RjTlJkUmYwRGFvT3dXVHBhaDFFT3UxU0MrM0RMVEg5ZTRrYWFIS041eHBFK081cUhZOWo0Z0dwUkdwUmRUaVVUeVh1UTViU2pjMlZzRUxqKzdONW5tR2k2STRqcUI3cm9RcXphcUh5QkhESU9GSlRETk1mN3pTWTFEK2JseFFXSUgvdlVTMVFvTVBqbG1udjhPS1FjQnREWUl6Tmt0bkRIU1FYVGo0TmN4TEZTSG5ZZklRbUF1RkkzR1ZzaEpTMXN6bWdidU9LbmVGb3N1WSt4T1ZDSSt3MGdQK3RSZlhGZEdNV2FFSDVWQ3pYZjFvc3VZU0tBT1lhMDZnOEJtRm0yam1kdnMzanNXRno0UklkSjRFRVpuWDdXNW1tTk5ERDM1SXpISHE4KzBDUEZCVmJDN2dCU0VuelBOYU0wMzFucFk0bTkzcllkM0twNHdDQUFFRS92c0E3d05ieGdhU0pkQTJ0eEJnT1E3bXhIRmJBcTRvQVdRYi8wcmh6aG1RSFU0OXBubmlwaVo3SFVDMDU1eDhKdjM4Z0U0RGxEWDFDM05EMEFsU1NnRFJ3NS9sRHJFM2I1aXNkckE4dm9rVXNuVWs0bWdhdGcvMEd5Rjl1Qm9zUE02d2dTSUpVM09reFdKWGFDeHpLMm1MQVlnVUFGckFBNHhpTWxmRFFnaU5hM2JuZjBaOVl6dXAzS0NmZ2VSYjZXRVExTEZCZ2luNm5KNlp6U1BTUytxa1owM2R3N2FYNzdHd2tjcGQ2U2ZmUTNLakloWXN2RG5XdkYvK1pCS1hSeGE4WGVUM1VyQTh4dUlYaWpFaWthMzJOV2dTSnZza3UzUFFLdzVTaHNRY0VJMEg4TFhNY3Y5V3BsOHIraGVhRjQ0Nzl6WU1HNjRFRWlBZFhXeldlMFppQWFnaFI1MVQxaHlCVXBWRkpNVzJsRFVVN0dqL21ibjZ6clRQdzBHWFVGMFRpdEhDUmwvZFNzdERCL29LRVRBRFhYZjZIbkJKNm0xNk1SNVVpTjhZMnZLdzN0aVZuZ2UzSmZhcndtTVhpSGwvaGVQbmdTby9NNW9kWkZxVFpDcHlhS01UWVhNbTBRb2xiWkhrWGhFYSsyTHNlY2ZjNVliUVdybzhzK2M0dFNSM212OGU5K0VZVjhnV0RMNEFtQTR5RHFGUzlUTFJmeTN3TXJSdjhpcXFxMmV2cFRWK1ozdW1mb1JZZUVJM1ZJNVJrWXdCbUxGV1Y2NERQNEpnSU1GRHBZWVRURWJ3SERUYUpKa2pMajdzL25PSXdMRjk2SHFSSU1zUFhoYU1NZXdsVzhCdyswMytoZUlNT3JYN3E4bE83RmgwcDJPd0R5WURMYW1pVkl4QzM3dW9Cd3d3dGp2OHQ1VkR2bWZUNUZ0VG5IWG15M1Q0TEIyVkV0eFIvNjZQbjVqV3kxVWc0SWw0cXZQT3UvSlNGOGdJU084WlNqQ1VHZm9pU2FybDdYbTNhWlFSSTlCbnA3VVNIdGtkeTVpb1JOZEtVaDFRMkJpQkRUamZHTlBGaHJMdnBhT3RYOWo1b2lRM2ZSVXJqb1QrUnJZVUg1d2RUU1ZBajVFRGR6Yk9meHNsRjJxVkZqLzMyb1VoSGozRjRSNGNRdzhWL0g1ZGpKbm1oWEN5YlB1REhiejZyenVGVUIvUU5qakFXSGxQWDRyNDZYQk9TTFlFMFVnbk1aT1dGZTh2Z2xaZUxwS1ptZjVybURlUnViK2xWRmtraFVKSGFOa2h3ZmtFTW5Zc09qRmFKdE5sYUZ1S3FtSUFHSlBwd25wVCt1Z1hEUmxueUVIYWpXblJaVkR4NG13cGdhMys5dFhTTVBLMkwxWE9qZjl0bU1iM2ptQS9vNVpxaWVUd1ZOdzRYc0dxYVFEWmJjTE5Qc2pIcnZ4N2NsQ3JLeHNJVDlBWGRsVE5VaUlCUzZ5U01qeXJCelg2eXNwOThxMXg5WGRYaEo5eGFyTUI4c2NMTTVtNHcxaUZ0Q2h3aURpZlJRVGZoc2tOcHo0NzFVWFhBaHFRbWpENnVGZGxvdVlNKys5bXptL1ZMRmNNSEZra2kyd1hCM3ltcm1MZ1ZaL2JWMzZNejdYeVNOM3F5amVDMFdtNTYvOWJHOUtWNUN4VFJTbFNjM2VxT3pxY2ViYTBJOFhkKzRIWVhLK2JIZERVQ09xc0ljc3NpaUh2U2FMMkF1L3htcXpxTytpZ2FQaW1sR2s3ZnQzV1Z2U1lPTHdsamF3bmxuRDVLZXcrRExsMHczRitXREU4aEtyQ09RSUFBUVQrK3dIWElDbkJHT0l5ZWlkNzFrc0xtVi9wanVjVDZMbDJKY3lmOWFJNW9MRVlNckFaMTdjR0pxbnppZGlYTlNWZXZucjIxL2JDZzQyVnlkSWt1MlI0LytCU2QyMGp3TUlLTWUrTkRYWkNHaFp6NUFGSWdZUzkrdGNjSFlkSUdIZFFBYjlzMktGYS8za1hWSmNMN1ZSSkRLSkRDWGZtZmk0aDRvOE80b3pxdFlnalRac0xxNnJkY3dOYTJ3ZVVaNVUwQjRGMHpnRVAvZ25rbC9BZVFEZWRhT29UNEZjSXNFNk5VSTZTRnd3ZzkvcGVoZEYvYlNKdVVJRWNQTGdVTXUvdWNueGQzdE5Ick5NOGc1TVZLN2h0UVRkbS8rb2lzd3RJbVlxWS80dmNTT29tRnh1YjI1WlVRVzJZV01yNGRxUlU4Q0NVS09vNlQwbXk0UDRjTjZ4VzFqdjJlZFU5czRyWGNwVzJHUzk4NDNMWCtsbkRua3FYVGlFbGo1bWxGWWpFMjZVMS9xRGs4K0FXTWtEejBjYnA5RHF6YndCU0VITHhIUlphcXZZUElYZFpzMlYzYUhRMXBSMWhGbTU3Yk9tMUpDVUQwdjFhWFVlblNHRGhaL1J2NlRpVlcrb0lvbjQ1bm14a3BYb295S05pRktoSVdLYUk5YU9LZUtsWlE4MVoyeTRSMDZTM3E3TU4vTEwvS0tkSEVhVWg2ZUVpM0lJS0xpK1pmUVBEbnU5YVhZeHU1ayswY011a0ZEY21aeURQQk45SXhzUktYV1lodU9PbzZOKzI4RlNwWHBUUXNEalZPbkpaU1hNTjhoMXhHVkxMVnYvMGFHaVBxR3lFTGZnU0dYc3c0ZnVvdVJoeVptZ3k3bCtySTZyeXI3NnlYN1QxVVNwVFJBb0tlaUxpRzhMOVNENUkzb05jaVJBT2F1ZmF1bzJhSk56U3FIQlpjc3Zzb0c2cTRvN0I4dkhJMSt1djNQTCtLQkpETzRMdVZFc09JNjI4Z0lFdHYyam93ZEh6WS9uZEJDalh1ZXpuOXNpejFIWEcyMnM5ZmE5M0diTElRblJrbG5XaDM0K1FQalcyaEJYVjFTWWlIc2t3YzJQRFlTa0lBNHAzNjh4QjIwb0ptZ2NQVEg0UzhxNWxtYktPNFBqTzgvajh5YnBVdmdocTNid2FaRDhCS1VrdFNOUFc1OElORDNUU3pCYmNTWFAzVkNBTGZ0NlA3OE9kYWJmQWI2RS9IWFFSSGJlN2lsbjBtaDd1bmxIZjdWcW9Sd1VtdjF5aEc0YTZEbzh1d1VEYUVaMVpvR0dtMWNQUktyMzZoeXJtOU9IUjFiRFE0VTYrc1pvTXlCYjR5bW9tMGFlNHNMZzBTVkZCYy9rVHJMeFZJUm42TndNNVFQM3dUM0ZJb2E4NFVPcjU0ZzliYWNEeVNuN2k3b09UVVFpQVR5SFpZSUJwTmxpNGVObnJuTUVST0IwbDN4Znh5ZFNQR01CWmJNRDlvdThXZys2OUFOb2ZobXhWWGxvbFhxNVlud0hSMy82RmV4dGIybFN4aFlHenZ2Q0JXaGxqR3ZraEMyZ3A2T0N2M1pLNEJiQWRTNWljc2pOOWNqT0pCTzcxOUllY1hqNDNjMmQ1Ulh6VzY1VkYwQm1CZUEybUtlZXVZUk8rN3kxeWl3MXNwZVRwaDNWZktjc3NpRG1Ed3NqM2pHQWpWODNoa0N0Y2locUdnWkc3dXd2ZXZqQ3MxRnYzc1lxQnZERWxaUldiNlpoOUZQRlVEdGVmUGp2Smp2d2kzRi9pOTE5OXIwRzBtNXEwdGFMWk05LzhLK3lUQWdBQkJQNzdBN0pJWXVkSUhKNW1PVmh6OGlVNng4czNqUzU3d3lBVHREMEk3VzNTQkY1MzV5ZVBPSGMyeFE0N2ZKNlFaUFFUZmIvamNmOHdPUjMvOUlya1kveU4rWlZUTXVSV2daYWV0Y3lMU2xqSG1IT0FDbW8wSkRXOWlzL3dyL2l0RUhTZVRHejZtczdML3dvdmhpemt0U2c3ZlRMY0s2SE00SEhVWkxZYkpER0NyY1VzUTlQZUExUEZ0K0pQclRsc2Nyb0dwazVLZ0dWNzM5aWtLd1MxWEE0WHVqN09YWjBPU1hGNll1K0lqTGoxWEh2MjFQQWV4ejdmVmJ4a05HQmFFcXJBQ1Fkbk0yK01haXNGUU1oK2Y2czViZ2R6dTZsYkwzaXA3L0hyL2hpTmtCYXE4T0NDOXk5TUNVK3gyRzg4SWR4QnE2YmJvazkrcllLWE1MY3RDVkNvRnRLNGM5L0NxQmNGYUp0ZUZMR0loeVZaTnVVT0p4ckVlZTB1bUxJMHlLbEFkb2ZSNWJLblpSa2EwQW9hOS9sSzA4U29RejNMZzJaZ0h3TUNaYWdrOGhSdmZJS0lnTVh5aWVaSjF1NTRTTHJQNFNIK3RNcGFPaWlpbWprYVhzU1lEZzBMVlRjM1g0OVRCb09lazhKYTV1YkN6bWg0cVRBbnI4Y0w1U1IvOXVDSkFabXNpdjd4aTgzZVVVcm9Rdjc1V2grU3pMTENNWWdNdXhnTXpaZzZPSm1LYUpPeTRpQm9BdGNzalRhckptVjV4QytMY3huZXl1d2lLQlJpODlZa05lQlZ3dU5EaDJTbW5KeHhFMTMyUTF6aGRjT3dHb3VncExTRjhIZGJxaTY1cEJYZ0FSTi80a3FJQkEvSUJYM2FObktJMXp6VlFpUThkZlR4WFBWSzZwMnFtaGxldUpqN2NjeFdzWXN0OFRpODY5WHBHMEJiQVlRMTVoS0RabWNISFZGcUxZdDVIZGZwdEo1VmlNM1lPU2xBRnJGY2JhNk5uZ240RGpUa0x0bGhIVFpQT3RReTh4TXlsVzNxRTdDL29ITUZYOU9kUXJsYjJ3TVQwK1JIWUtQaldhZVk4OGsvUVArMGxVQUlJZ3JieGlKZHdYMmlvcUVJdE82Qlk0cForSVZCK1JRT3BpN2NEdEt0YVVBRjNaYlZ1djBrUUhlVHVtbnMyVFlJbytidDNNNEVYQ21zcW5aWHVjTEthTDdLWEVienJJZEhJOGkvbVkxRWI3dHNNZmtwejZoSEtFZzdDQW1ocFFBU2VnM2J5bURhbnNvUTVkSGQxbk9SR04xY1F3NTIwT29haGwzeXV4MkpDUG1jYWt4SldUZGllQnFsVFhwelBBaG0xcUR3MitSK0NPL1E5ajRHSWZSVFRhbk1tUGVwbHdFdXMwOVZGc1kvSzNnckl6SmlySTVrSDc4NTVUOVBkQ2ptb3JEU0I1eUh6NXY1M0VxZlh4YUJhSkRlTDk0RUhqUmJSd3NjWE1ZZzZNMXJrK1gxZmtKTDQ3MkRkcXU5eXJ3QTJwSWhhbGdFSGgzd1ZWaHhDS1FPbllHeHNFMjkraXhMVzgyNFZPRmZLamxuYUJlZHV5MXBHVkhWZ0FyT3N6Y3o0TjN5VGF4cU10RG5RRHVTYVFJRU80M29xRlVRWVJJS3RJRDBaZ01QQjBDNDdCK0xRUlh3K3MxS1JiQlI1TlZwRUlKNlpobzUvRVpnRHR5TjZtNE13Z3dSSWQwS1JtSjdkQUhMbWwrNHZLa0cwWXVTMWVKdi8rR3g0bGs3M01FYTZ0MUJrbFA5a2owMk14d0NQNXJPTisvTzg2WUNBQUVFL3ZzQ2Q1TUZoZlhEdG1haCtPVGg1WXdOTzFXT3pXTCs3bURiS2NjRFFRcytpMEdFLzRnTnpmeUpIb0dlQ0xQRzgrT2c2OTNSaEhXWmJlaGNOcXUwR2U1TEtrdkY5Y2drVXcvMGEvQXl0UGlhNFdPSXVjZWEvU2g0anpDNTRxQS8xaTdjUzZBT3JzSUtOaURWSTU5NGhuNTFkQ3NpWUhybTkybEJSZkRPeFZWbHBtWDhjM0pPRHpqbno0bmUvN04rdFRPcTZIY0cwd01FdVpiN2VBcm9MNDZQUXNZRGQ1Lzdnc3pqYm9DRUdwVW9RMFd4bmt0eE9xMjdhUUhXd2FTaHRLaEkwNE1HSGNGS29Gd2RJOHlHQmhtZjFCRWFNbnpuemMzV05XZDg0eEx3NWdaMjA0UzlwcldJL29TMWdKbkFxcXBUZ3dvQVRUQjVGUTJxbGViNzFJNkQrb2tFNFdSV1RxSkQ1eWpuYmhHQUZCa3ZtL1BmWWNMd2IxYnkyS004OWRkL2dyMVh5NjNnRld1WFU1ZVkwUTJ5VDFGQ3RsbDNXQ3BNdXRQOEFiUEdJWFRpNUc1aHVtenJxZmxhakUwM2FHYnVSR0pJL25CWXlta1RVNlZsZ2VzdGZFOTRtVVhScWZyWnlWWDYybHNXUzhxNWpDc2Q3L2lkMWw0azBJUzZ0ZUVaV1pHaEtTb3E2UjltdlpkS3hZejM5TlBRRnA0a0FoM1ZmK0FERTdBV2lIQWZYcWtCZXBaT2NRd0FTbnZkZ3N6NDRub2hSeG5rWC9jRnVQNE02cUpHYTRTdzZ6cTU0K1N0TCtBbnlGSWtEbmRmUWJvVkJoT1NEOW90WmRHdmpQblR1Vk81MFl0bTljTjZrWTcrZWNEWVlaOWVpa29DTndicGFZTGtaNUk5WWgwZTJWQlBuSml5dXdoQUJGV2QvNTJVQTNzQXQ3aytpQmRwaWcySjl2VnAweUxDSTFvUzhINi9iN3Q5ZksxdWloNWgrNGVNSVVuR0F5Q2t5YjFkbUdWUXV1MlM2d0JWSDhlZk9wdjNpSXp4cEZkUi9HQVgxeTVMdXJSZ01NeXVldG1wYklqaXBKVXNJSXMrOWRnUVVkem1ZR3k4YjRYV0U0dzVvVFlmVS9pRk1uZGVHQlU1bnZoU0FqcGNSQmFzNy91N3pHZWhJbkJQWEVwbWhSOWdNcUo2S2lXVWMwc0twdC8zOUN4YTBWc3VUL1VKaVNISHNhNkRPTUViYVAwYmhOaXFMLzdyUFlpcklYZktDL0luS1RKdTYya3RGTHN3dGFLdi9GNUxKaDFIOG5kTlJEcVBDaTdycC9vUFFyNU9neUh3NWFFNmF6U0RZZlFyenRmUTcvYlhSeVVDeGZmeVVaTlczRUhCNkorQ2EydXZiOUFod2xQTnlaRFBYU1YrM05aSGpsakNIcEVvejFYTnhHT2NFaloxRjM4VC92WjRwQmU0R3ZtMjZNL3A0V3NTcUJ3N3F4K0t6aEsxSGluMHg0RHo5M2craW9wN2Rsd3RDZmMxMTVnRXhLdjBsakF6eUR3K1BKQldBV2FMMm1TTlRzcmRFYno5Y0E5czBHVWJhME9pQWtVdHV4OWRyM1pRR0h4bHhVaE8xbDFhWkp6dFRJdGhIeEh4dWNWcDdITGd1aUVuampzNG8yVmZBVGhwamVlZ1ZRS3IwV1B3Z1B6NzF0M0xuTUpMejNSbXBvOGxtTCt3RXNQWHRxZ05LRGJPZTNqd002ZmUwTzBWTnk3T3NqSVVKVUtDRi9nYUlFUHpVL3F6clhhWVZHWDRrT1lxUStkM3drZVljWlNGQkFJQUFRVCsrd01xVXJQZ3ExYU1lNEFzT1JYQkQzK2EzSm0zVVJzWW5mVWtlRUU4UEM3dCs0QmNVSnRaU1hDR3FuN1NjR1gzV3V5S2lqK3hzTVBBNG9tN01BeHo0TER5bzU2K2hJS3JPYmNrT0hGVUhmdXV4SFI2WUJCUDVNSmI5bkY3MDRRL21RZnRUb0paS0QxSjVkTHFTVjRyaWpFUWNBdnZwTEk1clZLNlZXM1VnbGR6R0liZ25oNzVIcmg3NjhseUxmT3VZa2U3RENLL05wZHd1dzZLc1FjQXM0L3djWUtENE5PcFdTdXlnWmhiak5UdEllQ0JreEdKdWZwUUNxR0FxUHpvUkMrVmIxcWlkd1VuM3V4b2F5ek9WdUdWVWxYTndZV2RvS1RRdVU5UXYwY2huU1g4WURITTJmSzF6MUlOaXYzWmRLc1hQcTZuMzZUUENXS3lpMlBTS0lPNkt3UTNXZFFQaVRHMldMOTZQWDlXTjRRYUpLSzJBUkpSd1laZGpLNHFNMm9hTW5sTTVpQ0s5c0ZKeGRONEtyN3daUEY4TDI1bU8yaEs2OGNGY0VDUzNUaWNLc1Q2RHJkVTZpbUhERkVaS2FER01SQ1ZycktPTFExTWM2ZTZxUVBhWDBZWExQRE9Db3Z5UG9LZFR6M0cvZkNsMFEyN09KS3ZMVG5oUVBWRkNTdDF5RUprU05LaXd0TWNib09NdytzcGlRcHc3eCtwUks1V0NIa3pJMjhJTXRscDZYWWpLT1c4WDl0WXQwa2ZRUjNGQnh6QUxyU2VPcVZxaUVuUjdTTU9URmZnQXFNVTRFcGZZZGM5NUF2czAybTljdEVLVGtTd1ZwVFBnVGpiNU00RzBPSWd4UzR4djdiZ01MSEZ1akdEWnZZL0hLNTRtOER1dkg4WXBXc1lWaEVZRjArc21qRi9rV09jSUcyLzRMK0NEYnNvakpDc0NtenFUT3VpeGFUSlRwdGRIWHU0QTY2RDg4a05kWWhZZk9WOWhPNGNJSUtWdEgrK3hqdUhrZmx3dW1PNWhraWUybG9sK1YwZXN3elNLQVgrNUkydm5JOWMxaGxQanpOakF2MnRZZm04Y0NVbW5HZzB4SFVZcEVyT1ZwNFpLZ1Z1NDV6emkvejJveXk2NWdDNFkrbnppWEhZZzFsQmg5dloyb0RzYitwK1RNM2toN3lxMmVLR1N4QVdPTlVab0ZCVkc1cHBPL3dqSDNMWTNTN0hlbjVoUVBOTUNIMzFXQXFzQWROcGk5dGdUM2xhWStzb0xyWHpPbFFoSHozbE1vZ1crOW5ITGY4MXh5VVNXQzdrNjFTTjBFY2hDRUw0QmEzdTU3NkpZZGJISGo5TzBHajVNMjQ0UDdBYnZ3cm9OMFlJUCtrV1Noa0NubVpPT3d1bmFlVDQxeHpibldScjZlOFNZYnhsNnZvTURVUXUxZFlvWFBQZXNyY3grVnR6WG1aVFR5eGFBamVicGdkODRBbXQ4NjU2TXlrZzB3bnlBZ1ZmRjF4ckp0NkhxcmZXN2xZdVJadWdPejY3Z3ZIVk1uM1NLOVllQjgyWUhwZys4NGFsTmtTdVVxYXlNdGhPbFdVbSt0VkdkTWVoemU2NTNQazJ4V3F3c1JTY1J5R3VGZ01Mcml0bnVxZldPbUgrSUFNb0Iyc1pGQjkvQ05hVkJzTmF1bXBSNmU3aWNLQ00ySTdXQzNQOGZyUWRpei9qZm1TYm9xSFZvL1NzRjdreEZsNFNBNmNhRjJOK3IwZzFabHk2SHA4YmlRYU8rY0tFU2xMUlQ1YnFNczUxZ2hyMkpLbmpFQWRoVXhtWHBndGlBZ0FCQlA3N0FRUGhzcFVhbGJaNFBTSVZDUUtBNEhuT092L3VOU2l6Yk0vK0NZVU9hWldNQXFLQjJPQ0RoekxublF5L3ZSckd1RDdOL1NabFZsUGlUd1JKM1U1TTVYOEpZTFRXQnYyU0xHMlBzdDNSTTZhNWVQZUFUL2xoSGJMNm0rNVB2VkFjMmFxdjUxcWdSOFdKQkRMcCtpQ21Zc3FXRlptL2Fjd2QzT25xaFBNVGlLT0Z5aVdnbVFmTjdkdHZoa1hVdXVPRTVIaFBhRlZtd0QxYzN3K1RHVWpJT0phbGR3QldqYjEvMktucEluVk5uTzd4ZVBWRXRiODFLMHhjTGRKU1dMSHpwTnlxN0lCMU5SV1VUMzVKTEJSbTJObWJvY1J4NGF1bFVZSmU5cUFwM2tCR2xScWNQaVhLUVpuckM3Wi8wSlUrbXl0aWZMa1FyM2NzTXExdUl4SWxGODNjbjJHQS9YTjNudFYrUjFkNTRQTGVFaloybXRPVkRlZ1RuNFlHTDlscjNic3krSmdFd1hWa0NzV1lNdEoxZEoxS3MxRU4wbW1nZjZGZkZoSW1vRzJDN2R2V0NqM0U5QkRSRit4c1VTT1VPL1EvdDNvM2JhM2Mxd3NRbHZUSXlSdTdVbGFaRDA3ZkwwR1d4TU9vU1ROQ2grTFZqVTZMZ0xLRDE0ajAwdnFTMEk1Z2NIaFhmcjJMSG41M0JHalRzQnBpSEpMZmJHUy9jek9IUTlkZm9Yb0Q5WUtoYnZsSEx5VlVZU1JrU295OUl2RUpOOWUrUVJIV1MyUlliMC9IQWJnVnp3TFNJaWdDbWJBaDZQTkYxV1RQT2Z0ZHE3TTRRelFwOEI0YjkwNHVKZFh4aWxKZjZjL1FmTUJxYW1JWjk5VGxmd01ScENQeGIwakhGRmdXcWhtemRiOUR1bSthRktjRzJveC9XZ1FUVHV4Q2lGOG1KTEZPOFErSjZKRkZhakRrWHdoSzgzMFpQL294WlNvZUE0dmtxRk5XczU0ZWd4TW9zMWd4RjVaRGZGOXA3ZU04Qks3T3A1RzFSYXJQYkJuREZsOUNGaGh5Yy9MUEpncVV2VU16T3p2OW9nS3VGSWE4TWxWaU42WXF6TnhYV2lwZFZqaVJRZVR2ZHdzeVF4V2xLcXZZSGIwZzVGZENvQ3ppNE9vQ2c5UTF5L28wMUJKTUozZml4U0pUb2JXdVd1dERKdGpxY2JUUlllZFB0VlJ4SFJiQTFUQWRhOEptbGhjVFRjMnBsaUlpWGUxT0ZiNFNub1F2NWdUVzdnS256TTNlWHg0S0hNUDFZa1lqNHlEdStXa2pXeThzbmdsRVVQVTVwWlhkTnVwRjRkODJpRXRscVIwRVc0U3pwN2dUMlJBWWpnbHVoTnFlWEdja3F1azNSa2dzcWJlL25ldGxmeUx1QXl0SGc4U1NTVWQxQW96dGtGcDBuTXFHZVRsYjNJaTdXUlR0ODR3R1ZkR0RNK3l2YnZ2VUNXd0NwNElhTHkwSXJ3N2dHRzhTUXBQUE1vWnY2UGQzZmFhRWhmSTRzOVA3bmVuOXExWVpXMDJsYmdmN044VFZ1UWNZY2swK0tQR1BtUUlpMDJUdk1zZWhJcWdPMy9Ed3NwbWdYQ0U3ZWc5cDY4Zm41NVB5Z2lVdHgxbDlmS28rdlFFNVVmSFhQczQrVTdETHFTRmUrQ1VHdkpTRVI2WXJVc3ZpWUUvREQzUUFGZWtZSDQyWG9NWmQvMTFxbEtFTzlNakErTkVjTjJEYzNtRSttWVVyVHF5clh2ZThCZmplWGN2RCtlMDJ3V2RlTUdGMFRoOExzN3FNanhBQ0FBRUUvdnNFWkdFU2NMbzhGZFg5S0VYOUdxb1loSkFYOU8vUXdMcWNEUDJuSDVlTW1paE1heXcwcnJMZW5EOVNBMndzWi9Sd2x5WjRCdlk5V1JpUm9ua0hQM1dNUCtpZ09zb3Vrc2NEUjlsYkdSeXZBNjhRREtzYThvbTBDVlcwUkZ0am1BSWhUdkJ2ZkJ5bXpsdElhREp5R1VpdG14NVFqSnFobUNRNDNlR1VpREZsMkw0L1BUWHZVUGNYOGtYbFJIQSs3VDZBUmVqVlR1cWtoT3EwMGpsb0dyWEhmTUM0bDV5ZjJzSXJuMlZZekRzT0NZN1g2cFBTMzV1VFpKQzVVSjEyUkZJcnpTRHE0dmlpelJNVDVGZ3ZnbUkyeGFJS3JsQ200eVpONy9vcDJGSVNEdWxOMHlaR3hTK25JZ0FYLzV0MVU2Q1c5TDZPbElxVTBMWmxaM0UvUVZLOG80N2hvSDdvekxsbHp5QzlpZWpYdmM3cytybkNuM0tWRlhBd3hlTC9ibmRrMXhuZlUvbk42R21rZHVoRXpTYUVYRW5hazdabU4wemxvdi9ZaTJQWHJnTmwyV0xraGt0eXRneTNGWUtzWjkrZDd5RERSclM1OXRSL25VTkhrK043YjhUK2lDcVduZjA0MFNsVEsvR0VHcVROR3VLN1JHb0FNRW5WdHFXaWV3RnVCVk1ISVNJVUhpemVhNHcwZjkwQjRjelVzdVVMV2RXaS9IK05jZE1zU1lkNTZ6UUtuc0YrR3ZiaVhTQzRhNlJ6ZnFjUmRIRTdEUU83OGp0SGQ0UVhSeVNNdGNzdTdrVmZYcmVxekxTUEVEV3Rwd1phcCsrSFRVR2NSd2RoRGlMa0YrelhlWDJHK0JzUTBDTTdxYStMNDMyUkxTZ1JxRE1EUWlkS2c5eWZhTm85UXpLMXR3N25razFtZEpaMUZoRXFxeDhTMmJEeU9DUXB5WmlLU09iTTM3UGZEMnVRUXFOUC9qSWxxdTFsYmg5V1RyWWY0ZE5RK2FlTGxVa3gydXNtS3l0dVVBZFNia2gvTnRwd3YzaWZkYUhZMjdvbGJETS9Kak9iSGlHOU9FMWJEZDVkRUVmWkorK0FDRlFsSzRRREJSRC92UmVlcVo4N3Znam02K3NkRUg2OSszQ25pVVZlUThSd2RubU5PTWVVYjlObEdOVWhZY0xLS3RkSTFXcHExVUtxdk4zNWJDclMrcWhOMU81dEJxQUpmSlFCREViK1Z3eHVSTzVXenR1YjJzUWZoeUFkQUVVNTROa0hiRlRxd1lVaFQ5bDV4QUttclByUEI4ZGc0aDhIU1VCK0VwMm02ME5odTN3TnYzQ2ltSWJJbHBZUU1WcjhqU25ZZmRqSjdyc3RzckVBdllsZkQzbXJFOVlyYmtPczhVVUFIR1VmM2JGbHhiam1oWW1SNmw1Znlkbnl3M280QzVZUjNBcEo2dUJCcWZkSnl2VUlZUUx2VEJPQnNQWDdmeGJ5Q1Z3R0xFSjJkWDNKSXZVTmd5bVFMdTgzRHh6M05NaHVnVGYvYU8vMUM0Kzd1UUxwNytta3RuRE52QmUwRHFVZVgwekIxMDQ4MU5qeS9YSzJMZGhMYm9vekxKSWdpTnh5RXgwZE1aWnowQmlpM2YvNDhsNHhPOU8wWHNiU0VkV3NBYU15MWEyYVVZSG5haVZJaFA0YmRlWGNhRGpvQ2d4Y0FTWVV1SWVST3RZZzhGNkNGYkdOU3ZaZVhUSkJROFVRci9PNkVYNzI3OUZMcXkzYm5MUHltVzZRRExha2VtQlFTWE1ydXFMSERTTWw2c2h6V0ovUDFGSWs1Z0lBQVFUKyt3Q2gyNXd6YysxU3AvbGtDeFduQXkrS2tyYzhUWjV0T1RuYVlPeVNPcHRTN1F4bFc1VUdMYlh6NE84bHNaM080RnFkUkVLUzdHUWtxZFl2eS8rZHBCMy8zOTFvTGJaZzVPS0ZaWTVjeWpSSHRyVm01K25PNFZrUkxJNGNWLzdEV2hHcm5BMU9Bd2VzeTZGckRxU3l2c2JCRHVZRE5JblpJTXRRSGJpc3R6WEJlRjR2bzRZSUlvUFMvWEN1RkR3dGFGMWhrOG5HT1d4SzZIM2pXa3JNblZrTjMvQ1k0eDUyMXU3c2xxT2hvRGc1eFQyWFFhV3lxYVB1NzZTNkFaby9vR3VVeVRUdkJDc05aSC9UbERnN3c4bE5LR1RnaUhyTFEyTGtDREt6dWZwcWpWWE5pYklnUTBwQitDQjduZXhMd0Y0R24xTTE2K3h4RzhiYzRKbTRlYzAyUjErRHk0SDlaTGtLb0lwMHV4dElWY1l5OG1OaHVoYm0wWWU2QTk3MWlwOVBTMkpLRDR3UE51NERRUmhaWkhrcFdleEkzODFkU244bXNqazUwTllEL3RHWG4renRHL3JCQVN2SHdrbGVWTG5QNElUVzFvMTBub05ZcWFCMkNwWXZMYXhvcG1GUWJINzdLVGJFOG1OcTJGbFNmQkF5ZDVKU1NTZDRLRGdPaDZIa1dMazI1dEpDN0QxaEt1aTZ2Tzl6N0RoUHNUVnlkRDkvdXdRYmlyTHFuTElRNDBTVnpPRzMxdUtkVDM2NXQ0azVRQmVNNTdWb1pSVkVrQXFaV2JzSmdpZEZOSktJQzZVNnBiWDNvQXlJZkNlTjJySVpyK0JTOG5CaVJRbm1iZUtscVFRT0hlZWhRQSttc0IreStCV05TbWNtVVB1SDJ6a3QvWFZLWC9XYThrY1pDS24wdmNwaDFWVVJqNzBzRG1pSVZSM0NTZHBnaFdLN2VkNkVtZ09EQ0tZNS9McTludERQWEN0U09Db0ZKZWNCdGp6ZlZuSXhaay9tVjFPNEZnaHNjdWc1WnB0K1VkSE1lTzduWVRQc1FGTTZNb0lrUlJuY1JDalBzSmM2LzlMZy8raUxKdjNjZmZCajBiL0tBSFM4ZWZPbVNMYkY3NzYrM3c4di9yU0RKZERsOHlSdXZ1VXJERk1kT1BXUVNPVUV5TEdzeVFNbjNhTUNZc3hnVytwU2p0NXFEYW9PMXh1bGV5WHphdDNKWjdZam01aFoxKzl3SmVzQW81dFlyZThTZ2xJZXE1L3dEL3p0azFGcVcwTW42Z0Rsdlk2WlVkYzZIWE1kaHczUWt0d2I1OXc4KzBQcmVDaUxFaWJ5MVdYNjVCZEZ1ZVZVdTAzOTVsS1libUlTMDVLMFIzYk8wMnFUQnFORWhtaDRhK05PdHBVbFkydWViVkVlTERPd2UremN1ajdDRTVRcmNGYU8yL1Y1ekVyeXljbUp5aHNFT01ua1lJTnl6Y28vN0RyanJqdFp1L3VHbkRqK2RBZ3J6UlpLcG54aGJEYmlxL2VMSHlZRjVRMEZETFRsS2xnVk04WUFFRGtFNDR3c3JPY05aNGk0VjVLalZrRGdNVzNxcXI4b2kxQ3RudHdjWnJ0aUdwenRIU2l0YS9JYU4rNnZ0eDVPREdpUEtlSFVHY2dSa2JsdStGNlU4aFV4K0VkVXptOE5aZmdZWkEvQmRBRzJnei8xNm1yK2V4ZmJ5cm4xMFpxNWR5dHlmWnpwZTM4R3FycSthOVlTZ25CcSthR1krL0VVWjdJWDE3cGprMFErRU8wY2dycThHcWxuN0NZQ0VNZnhhQzQ4cVZVL0FnQUJCUDc3QTBJSi9iMElQZWtxOXhXTXhyUFZjSDBLOGR2NHdBaENwNU5Kc3lZeERDeHlFWGkrWW1RSGphSWlFeXNUamNkakdPK1gzT0NJKzlrYUxsTTBHa3hXQUVvYnNNcUU0Y2dnQldqam1mdVhDcUxiWGRNcHNJRFVaaHFBVldXOWJhOFZyK1FlYlhVL2FOZ0FMcGQ0cnEwK2l2Ly93VnhnbDdvdXhNTDgrekwwQmc0Q0xqTFozVXBiNDRvYlNBYlVxZUhXeVRvb2w0VHViL1QrNisxaVlIb00yWE1FM1pnSjBqOWp5em1WUW5vVEZxQlRCV1BrcWdhY0VIaEtKaEJRbHlKdXRwM01DS3NRUUNiTiszV2xXMnI4L24vNmxOVDNLSzVlbWlZQUJUVlFxU1N3WDdVanRRY2Z1elZ5eWF1cytMU3BCUkNqVkwzeVRDSW9YYlh5RFltYVAxbldTMVM1OXA4aHE0VVNWM0djcnhKdkxLRUxuWFY5MFRsYXE2K2x2NVJwOC9BL3lxbzFQSllIM3paZTU2d1MyNzEvbXg0NjAybDB3N3VGblNvbEt4Y1VPQVlxcG1KTTRDYklVWGNXL1dtbEw0THRZcHFHTklXUk5xNkEzaFgvQjk2dlJhbVRrSDNzM05UMDRIVS93Wk5rS3pKaHBhSEE0YjJhU01NbTg1bnlLM29wMlFDMUdpQXVxZ3lKT09zTDBkcDFjaENEQ214RC8rZ0Rsd2RXN0J5R1Q4MTNxQUVIb0VtbktERU0vNFBPWGR5N2xGM1pFWXFjcGhMcXdTWmlBM0dUQ0g3cTV0OW9WM2pGaVVVSkNhNGZlanArakpLSldqVTVMdG1iTlcycGpraUp3Y2RJNy9mbis1SWJwT0hxd0xQK0tkakFYNndHWUU5ZXV5SUZwM0lKV3JIeFBiMHdPQWFPdmtuM25Cd2xhRWhTZnNidDBidDZ0SC9hak1VSWVxbEhRK0x2NmU4Nm9BQ2V4cnhudlNuNzhwbm9uWVdFYjVWb2ZKU2tTN0lRSWF0TXhQVmQ0enZFSWIrQUhDQXF5UU8reWhBcVJ3MUppcGpPQTVUKys1Z1VEbGxLbzVHYmUvUk9BZlJGWnc2VGJndnVmYmI4VHIzSUZLM01RVHJuMW9Ec2JCODJNZkhIUzdNWlNBNHowZlNUM1lhbVdhMXlSTXY1UWMwTDdkelRJWnVwZzEzaXJUQTNxRWFrUkdHT0s0azErK3JvVlhHS3F1N3IyNUFLVkQ5WEdobEd0eUhIVE10eW94VmtDckZJVzdYdThhNitTc3JEZ3RPZmNkRnp4aUQvV08xMWtRWDJ5L2xNcnR6UWRxMjdSNnhJRktxYnRvUTZBM2J6YVB5RE9YQjAvb3lZR0ViazY2OXhFelZVRGhwNUI2UVRoY1A0SDZEb0NuZVBmY0s5VHVId0pkVWh3RWNGVE1TL1pZanRVSG1nZUVHU2ljanVDMFh4cDk4dk1Ga28wMWt2T2FYcEZzNmtGYmtVVHUySDhrdjNyNWp2cnRWSnBFOWh3TzFJay80dnl2aXI3NDFadGhBMDk5UUhUTCszSTVDM2MwTllwazdKdElKQ25IbkQ3U2hRK2l5dm91SllKOWxqQys1MTQzOFhTWDh4c2ZPcThRaXlMazZTMy9Jb3JaR1d4KzZGbFVGMWc0dDAzbVdVK0NqaytKY25FWE1xcTZLc2s3L2JOWmZoTnM4WURaMkhuUjBaSGxPSExkeWxWQmVxUzAwaHQrSnFmUnp1SFQzRENDbzBOV1BsUkFGTG9NL0VQSlM0WlNlR1hDRTZsaTBmQ1Z1dGFVeXpUdDBDQUFFRS92c0RpMUVKd0cveFRnaTBvZ2NQZEZqaERkRW9rYU1kbml1dUdxL0pqeHVhV2djZ3pWOUhmKzFaOW9neHNDZ2pUMEI0NHhwTHRJbS9Zc1lPTTU1UHpDenJYek9GZHRwZG40Ly8yTEoyNitid0dzZUJrOXc0YldBMDBtYmpKbTVaNGI5eUc4LytlY1FFT2wwNU8zSWp3ZFBNbGgxQjNPenFwOE1FTG9DbTFTVzBEVjhGMXBGS1RkTkNjZW9BWGZDZVU4SUw1QmdlUnZmbnpnVnZ5T09ZdzE0YzZDLzFhVEJjNCtndXFwNDF3bzJ5SjRnd1c2RnRwTGVDTkZaS1RidWt0N3Y1OVVLSHRMbklNbU00WFg5YTE5SzFkb3d4QkRrMW5NNlgzeVh2dVZnTFpNOWI5bFhhaUJpdlBtQVZDMDBOOHZGbVVyOEZCL2FRbWc1RkcxWUk1SWJvTlJIalg5V083NUNDaU4wOXhuVmk1aGJFcEkyUmpTTDdZalhWL09iMTNiUWtndkVJVkRPVU4vREZpWXBGZXlpK2pCNEJEcGs1b2ZaQmFJT1hZYlpSNmQvYi81V2RRUE1wZ2U2NWR1NS9WL2tCcnkwK3Y5UklIcEIrNVBFbnBldnZWN3VSNlYzV0dNOHpUNElyOVd2Q2xlbnp2eW80eWdMWHRsZExjc0FmZytCRE8vSU1ESkwxT2ZIa0dUT1VuUHc1V2NJVzJ6bE1sN2UzLzBubTlFank1d1MvZjJ4QWpia0t1Z0xDZDBqTUZCWmdJcEJGRXhlSnZyMlAwSTNtd2oyVUVld0E3YXBGeE5xS1NrYlRtN1MwRzBTWnhqdENuSDNOYnYzZ3F4RHdPZXd3c1lNSVlqYVVYTzRld3dLRU8ycUJEV0ZseVlCTkhmcmlFWGNSQUFFNCtXSFpIZ1hwT2NXbHZFSUlvR0pNRENwZjlGTmd3SDV5SElkbTdFaWhRSmhIZFcwWE9jdVpPQjAwakhEUzVjMkJBUWVNQmpaV1NBRUZHNHNWejl6Z3laZ3ZuWDcxb3RNQ05WVjFEM0M1d3I5cXFJYkR4UHRVUWVxL2p2OFh4a01aWHB1MlRubFJIakU2NHFOWTRmQUhBTk1LU1JZUzk2akFmczdJR2pSbklrTGdMdC80TldhMlRrTDNLK2Z3Z09JZ1N0UDkvYjBZSWtCbDVUTjNucTlYSDB1RitrTnNubkdobE1xYzl5bGwvbmVJV0IwYkh6MDFndGlUZnE0VnhKMThkRFFqUTF3MmRIbko3N3g5MHlVMWhxODI1RmdUZjJSU1l6ZXJkTXZsaGtUTUZMc1FiemtVRXdORy9ZNGUzTGdKWVFsQ2VTMFltZnFGZ2VpMGZkOEIrVGRDNDlSSHFNcVZMR3ZHR3k4RmxjZWsvNWNBTU1WRDR2K3lPOXFLbHVuY3Z4RFRGdlgvdVl0cUNGT2ZKV1hBY2tlQm5WUmJ3TDg3a0xoZEhtSDl6YTQ5Wm9JeldZbUFoTkQ5aXJERk5HeGJvQWJpbExFMVJEeGF2VkExeDJTYy9ZZGd6eDUwL082L01HYUsyU010MzA3dER2VE5Sb1hsMUJMeW95UVN0Z0JHN1dUMmFKMDIwL0pCN0xmM243ZFRiMDlxRG1ydTRrQitjRzRyK2xZVlExQVUxQVY5Zml2VXFyNEdGM28vMktLOGdpYlJGTG4zTkpsNUViYmlreWNYaGtJNzhnN0pjUVJhQVB0SnkwRzlEcUdsUGRVTndYdllRODdnT0JOdWxZTk1uUWhyTWNnYVZoN2tzdlg0eUs1Z3pMQkZaeU5lZURYdGdiRUlUK2lRTFhkWUV3SUFBUVQrK3dGYno4THloL0dtcnFCQU1obDdjOVlHYzQrKzJ3cWRJcE9RamFpU3RwRSs4bEZmSk9GZmxQVHlhRUlscDNjTyt4ZUxUUWxhQWdjU2Z3L2hCSzg2QmxnOVVqSzBxMXFtbExadlBvaHJvS2I5ODZMRlRFSzFmSTVGOVJKaVk1RkNza01jaVl4bGRJbk0vbWZMcDVPL0NFOGJ4N3ViUDExK2ZxYnFpdlhBOERHRjliYTROMEdheEptWDh6ZmdwQXBBbkVPZmpBekw4VkVFVDR5bnNyUmg0V2ZFQ0FxWHhKbXdvT1pqRjRoSnZRZnh2U1ZjcWptSTdaRUJsQnhHSWZEdWNPTkNyb2N5YWEySjdQSG4yS242STFPczFHYWU0Z0xIemRtOTJ5RTZ5aDcrYnpKVWdnQ3M3Mmx6Q0RKZUZERmNJOUE5clZWQUh1SzdPU1pVNkw1UXgxRU1HOE8vVVA4aXNoOHVtdzNkcnVOMGRha0Ixc3pHbHFyekZhdU45VitKcFJVMmFxMmRtK3NmNGh4T081V1N4M2MzQlBYYTQzM2xWQktBZFdITndwU21oS3I1QkJCRGd4bllrdkl5MjUyNHhDSDRsT1JkdW5EcHNPeHUvOUVERWZVcEZvYTdTTWQ2T0FtYjhPY1lVbnB5UDNEU1RUVldWNmtTQXRZcXA1b0dJNDZVbVEwT1hCQlByaC9UVWFNZEFCSitQQ0lDbHNvYldnSHZCbG5ZSE0ydjlnMnBwNy8zL3BEWHc0RXMyYVgvVUErUGZ2anBYcHN2TTR3TmpFTVhVTmNTaG8rREQwc2ZMMExvOFRoR29PNHRnUUM3dXFQWkdwUGRJNjRCY0RhNTNVNU9jTlZqMXlaRzRpaHdBRnNUN2dqSXZkTmFzWjZkc2Jqb2NGOFQ1ODdQZVFKVzlpTjZncE1qOHpmS0RTdnZsZDVaYzNzOWxoTGxNUCtlbytWQ25ENFIxb0orbWROdkJmcTIzQ3EvUW1UTHI5YmVnREpvQUtzZ3crTzVmT0hXdzFmNGVlSHhhK0t4RnhYdEpwQk5IaW4vRUNqM1ZEWWhPam5VeHJldlQrSGxiLzVXMmNMNmo2T3dJaVl4dkdZR1NueTZsVE1LdzM5LzBLa212dDAzR2gvVGowc0ZBR2hNY2U1Ny9BSWh2L0VhNzluODZGMEhUU1BlZnYrV1Nnc3JkenkwUTdvcTkwcDVTQ29qS1FQajcyUXZkc0dieHRPQWpjTnhxU05hOTU5UzFmblJqbEhtREk1Vzg4NFdHYVVkd2UyREZZTFllT0lMK0swazNLN2J5ZUlqNHdjSytBSHAwVmd6enpERmdBVDFGczBHQXdhUEtRcmYrSmhoeHI4Nk9aVUlmN2k5aXY2K2xIYWpKR3gvZlh0a2tnK3pDeVgxQXowZmo4R0tVQkt3YXJVZXBjN1M0OW0vMEVRYW5IMTM3Q2NpRmdsRitNMWlMa2ZDdUFlZXVmdTlUSlBwL2huMFZNNU40K1dLRkZmZlBlUytXWHlTRFN2UDhRQnY5RXFiVjJja2xHckFCUVJaTk5IazlwTDlqTEx2cExlK2thNFhLbjJqVWRZOEVIeXVuOUFOMFZFU3dBV09kQW5mMmo4T0hPbzU5YnYwNUhTZ3FOaWMxdW5idEkyWWJYdSswcTFkRDVQeG5MeWlka2pUZElONkEzUmxxZEQ5UXB0dWNVZ2tCMnhQQnBQMlNPVnZ6Yzk1c0hkY01McDlOQ1IxT3ZpcXQ5LytxYm5YSFVtWVpJVDlWRWdaTGVFNlBSYVpkb2lkTzM3T3NGNEhiaUt6TGRvb0ZnVWt2RTlYQWdBQkJQNzdBdjhrWXUvTmhTVGpPcURETE9JQUdFNDJyZzM3eHBVRThXYjlGYlA0QUtuQWNjQWFIK2JYTi9WdzFPcnNxZ2JSTGdKUEJjMk10Ri9zTlN6Yk4vUUVnUXE3RGtkR1hsSEFMZUIwSHpoVC8zY094cGJpWG10MUQ4Y2ZFd25lT0wvbkNENzIrZnQrMm4vcXJVellHenRoV2NGcEp5c1ZtWWJoRjIzZU1Lb0NEYVl3TnYxdmFPUVRZalhmbUxTYmZ3YjcwWHR0MG5pdm1pSnk5WGdGUTFXVGtPMlBtZytRVzFZSXpiTldhUEVQU0VQdUVVdkRjVHlsVHROOUJrQjZBVXU5T1pTTURDTlpRMnkyNmkvOUhGOWwzVFJobndxMnMzeFhRb2tFZklUWXBFN1VXcEVTSkRoVE1EMXVNamRvTm9nekNvUzNLMFJnZUtna3RDa2pEYnFwN1lFdzlBN2tVOW5JK09vVzcycjVGb3FsZjJib3hYYzNnK0h3RVIvSWVsNXZZbXNCRzI1OEtQWWU4dm1VcFE3YTNYZW5vdnVjQTNKWlZRNldDOTJsR2w3VjZFRUJqU3dnRkRFMFZRWlhaeTRCNDkzbTl0bkFDK1BWZEx4eE56Z2NHTDExQ0dZdWpOUnF1WEtmcUkrRnd2UE00QzNtNlJ3aG90NzBrdHBZbFVTTFdOdmlDWXNkcFdvOWtIRU81akE5TG5sSDl2cEdtQXFlQnl4MVMyTmpheW9US2dGajlaRGRFNm9VUlljclBDSlc1YzVEeW81TDhzZEhBNXlqakF5UTNtRFJIc1hzNmUvVjRZclBkcW9KV3dQRlpsR2pIc2ZCcTR6T3AwSXVWeHF0R1QxRXpQRFVZM2FYNEV1RE9VajQ5TGdQRVNleTc0d1JMYTlBVFpaZVBkY3kwbCtrcjFMbVhtMTZxZEt5Wkd0aFVCNVpnaXJPSkJqcVRzL0NuejVoRVU0SXkwYUJndEdHQWFsaE1NNTlvU0RibHI3ZnczRyt4YllGS1htMlFHNmhJYlZ1QUEvL3lzMEpKNkFKTUNycWRyRnNLTGU5WHNPT2VuV3IwT1MvVFo3YjVSTGxaL0pvOWtXWUk2K3VVQzAvWlN4amxra3pmamxXS0NuYzJZOVQ2azJ6bUVtem13UlRibFA2ZCtJT2YrZGZRWjU5dk1mbkNzcHo5NkxYd3JNYmNuWXlUeUhCQ2hYV3l3ZWFtUU5Pck9xNTYreWVkL1JvMDBTQS9Ob0tQU3RzNFlpOUhqQ3NWN2pyYVBDdFgrcE16bFIzYjgvdmZTa3FhaGF0aGs3RGxqMHhjZmVLZU92SlBMWkhwL25zTmg0UWlTeWtmZ21vQS9CdW1lbU1acmRQUksvdFRwUWtwZlB6V0diMEpJUm84T0pscENpMi9ia0ZkY0NnbXZZaHJWdnhXdm1BRGovc2xsK3lndE9JdjErR3BSTVJGYzFjQkpkMU9ZK1NwWUR6MCtLMmVqNTJHWUFpRUtwRkpNSUtieUJrOTlCZG9UQzAxMjJTUEZ5YlJVeU9WNC84b1ZQUHhWWEpkalRZR3hra3FjK1ZCSTJYZFMvUjNoSTIvOW9LbENqa1VlaWpnNC9oc0ZGcGZWYzNqdlltR1lFM3FmN1RacTRFWUxzMmFZbUI2cGZnNlJjTXlFVS9DM083bUhrVnVPTmNYeXdjZFlNYjhXbFVNd3o1TUZodXJSdXo4cXdvK1pJSDgyYmx5WFdEU1Njc2plN2E3TGNRdERkeW52QS92azRZUW05TGY3bGZGWnRBQ2hUcFdyNnNRU1I4blJGUDVTT3R2YXlmcFRncER4TUNBQUVFL3ZzRG1oZG5wZjRKWVQ0K1hyV3NuZzBQdVE4QUxXVGUzUy9zZEVlT1M3SURzTHJ2Q29xOEk4MkwzWGwzNHltN0VkNFAyZnNUTjZ2dkoveWZIak9ZRFl2TEU1UjdWVXM2eldVTzl0LzRZTTVva1FMTVMzdlh6cENkWlVKNm5QcUdRNUtrdXFicjdEMWZ1cjJDZE5DUVJnRllTU2w5UXB2ck9QemdmRFo4aGM4dCtLQlphMWR5ZjI5aEltcU5wb3pmUmFWVUNZUGVXVVE1NGJEbVN5T05yUVFGc014UkQ2REhhM1BKYzFmWXZQY1VBeG1GZGN0NFJTOW9CaGV4bjlYRU9neWVIcURkTnlvcHU3T2xveWZQU0pOc2NIdzNHOWVMT2N0Ym1jWUJ3YmlzWlRldDlsZXluYXlXVnBUODc0aW82NGhEalVKZ3dxcGxtWEpHTG9hb0UyTjhFMldjdWJ5MWFidGV6OENlMk92SU1yVVkzdDZ3dktzUlVQZzZ1TzZWYUFncWRiR0lQZGNDVmhKdjByNW9QWlJRSHBrMXV5MHNERGdsK0xEV1NXK2lDMXZwQXMvZmQ1Y3IzVmhOamVMaXF0TzlzMUlhb2QrS0V0N1h4NUlaOTdmS2E2bjU0WS9MVDFNVzVBTGRKc0JBZ3V3MjBtZUpqZVNyQW8vTFdaSkxGQVM5UE1FQmJEc2V0cW9SdG91SFE5UHhrVk9vcUV1Z0plaDF1TXJOOCtrUWlGdEk5UG5GcWFHUERodlZ5c3hhVTE5WWdSVFdJS056czBBMThPYmhpUHVGcDNVOUJMSDl2bDIwK2Z6SVJQNlN6OTgzcDhMQnV6TDhERkZUbkxqY2ZVS1FLa1NWNVdHbkF4Zm5jSlNsbDAxcXRZRVY3elEyRTY3czRSc285NGprbHRVNjRKZGRaQStpcnBBMmd4Sm5qN1pZcGlFd2NMT2VMRGtrZWVsVjkwQUxrTnlodWdsWkQ4OEd0aW82WjBTVU50dkQ5NUV5N01sMHJUb1lWRnVjSkRka0VoUEthQ2JmNXZhN3RyRkJWVVZGSkcyeGt4OVozSDllS3FPY05SZUE4cG95RFNWWWdJY3JqdUEvK1k3dXBtenl3RjBiSHRzS202Zit0S0lUak1WL0pzY2xCbHVDR3BnUUs1dlBNRkRFOVZDOWl3dG9LSlltMmtENDkvaDBXeCtPQWM2UWM5SXJBaFl4N3hqVU5QaTYrNUNYM0dGTURGeDNBdm5QSGsvSE1kcDBwNEYveUswRFdDYnNGdm50V0lLWmlPbkw4ZUx2d1QzUmFRbnJDMysycXl4R3kvaEdndEo5SytpbER0ODlBekgvc2pmYytRY3FrRVVUT1E0cEZ2U3p3ci92eEt5d1dtUTB4TEpxaG1XVExDOFVCdTkvUTVLSFRHa2Z2U0VBaStrMXBEclVqN2h2ZVFGcFcvbDVMUHJIUUlmakszMFdZZnpnYXI5VGdGK0p6RzNvZFBiak1UY0dKTERZbWh6ZXhSZko4TExDVnlMSkFNeUorVk81QXdIKzNmRVlBU0QzNE1taHRYVGljNUpUdWFyczdWcDBXaXpGdnVKcVhnNG5lT0xLcnhqREpiSlIzMkdNV2grbElzV1pEV082bDIwN1RYU2VOMThHeGdSVWppT2ZlT3Y3TkZFOTJ6d2hIMEZ6WGRCN0RMamtyWmU1dzRpK3VnVHVFV2V2Sm1DNFpkd2pRbTBCR2toaFBqczhZR1NhVUZGemMwaFJSTHdNc0J4ckYwL20vaWFleXpKRURKUDRKMU9HQUFkLzBjazdraVE0U2M5aEVKNHpJK01OcUFJQUFRVCsrd0pTRk43Y2w1ZFQzenhUY1ZyRXZYZHBDazhBd1N2Zll6TmEvRUhzQmVsaTRDeVpLWTVGTGF6d1czRytpYlk0UXdwaEZqcjFSTUxMbGRsRU1Ob3JJVWR0SEh2UXZXeERNSG9meTJLV1dRUXcyQ2U2MDJBc1RpM1lyM2pwTWIvMEdUbWlWc1hsWnU2czBqS0p1cUxSNE5Bck5wQ0pYbGNtM1o5Tnppb1I5NFVMVVJmZ1MrNUZDVEpSN2VrNlRnc2U3LzBIc3JNREpJem9JejdhRm1IM3E0OTVGOGdrSFZPSU5uQWxqYXNWdEVxUSt6YjNMRUROQlBYeGo0K3h6dE9qS2Z0bGtNUVNycitUUCt0azNmZTNlYjh1S3cxbE8wa2lDOVRMejhNWDYxTkVyRU5mczFseW9hV3hKMTBMUXJ2SEQ3dlViZUJNMDRac1pzcUVUYk1HQzhnNFdISnFRSTFETHpjSGJHUkEvS0tnRFJHRlp0WWFlazFYWUkvWFl6V1IvcG04R2Rqd3lFQWI3M2djdUJBWDBtaGZTUHRiVkl4Y2JHUzN3cHJCMTQ3T3Y5aUZCMGROeTBqQlFqckY2TTRjajdoTk1aenJWMEFCenFDa3hhazVjc25uemhwTjd3dGc4OHdKRzc2UzlmN2FtWnlBdk1rRldtV2dETXJJczhXaG9KeTV5WENRckdRdzNUQjBXSWRTbDhZbUE1QzVIR1dxUHRpWHlRME1DVFR2d3JHRzdrQzFWQ3g0SWxPTnlWMmhWZjZnV0VBZHRrLzlwMjBCTlpFSnVnOVVvRStGRHpqK2l5dGJTSmp4VVRSWGhDemNMQzgzdll1THZmSEZvMnRPcUZaYVhJdnlWRG8zTGxVSXI5ZjVpeGRZZUVHRHQyWjRPenlwMitlbmtYZkRSQjhKbXBhWkFtLy9NSjROTnhaOEhJOHdCYk94QTh4MUNtQjRUenpTMWVFcERkcHFwUGxSK2dEdEdqNXhPRGh4SDRuU0xxelZmSjNIWGtlaCtaWGFVckJXVnYvSGlLdjlLdFRvZlB3SXVTTWxRSFBlajNsb05hMTY2Mm54UWRCaTBoUmpHWFNFczZIU0RRMklnY3hKOEhQT2V4RWNETnBiYkJWZU5SekUwMitTUjYvalVDVG9VNHFmcXpsMDBVMWVyU1B0cHVTb3FMd1M5SjlSTG81Qzk4WmR0eFBGZ0dVdG5Sc3QwUGM4cW5FSkFiM0tVc3N2YStWQnNvNWZ0OTB0WDhUdDR1WTQ3VkZGOU1uUGZaUitKU1g5M2UxcUhwME9IMzdXaXFuUFlFN0VzVGhNdW9kajBXbUphZTdwWTlWNGxSU2JWS0dmUUkyeE5iU2ZsS1FWV1NkQnVTSzdxMTdzL3loTnRkeklqdVFHeFFGMDExRmVZNitMamk1S1h1aEVUdkR6clpoQjlpOWRRSWhod1drYnZUbUxYek9lQWczc2JPZmFIdjVraVV0VHMxUVFMelROVWI4Ykw5YUNobTl0aHVqcVZld09SbkFDa0FtOTJRdjl0NW5OWnhKSFFCd05VOWhwc0F3Y0MwbXE1YjB1b0tRaHRYWWtlY0o2bDlNYWFYZTV3cjRuOVA1T2ZjemtjVkRzajZJcU1rcEF6T0REWWwydU1LRTVML1hEaUE3UTZnMGY2amJMOW4vY2xTWG8reTQ0RDA0ZmYvZWJSUHhFOEp5NUx1c3Z5Z09oTGFSbjRHM1FQdjJZNStOTWtWNWZuLzdSSThlc3N4MnJtVkVZYVBKOWFxN3hSWmE5aHZKeHVsQmpoSG83UlMzZVQzVlZKLzdVSUtNSldIQkFBZ0FCQlA3N0FoeWFHYXR3YTJYYmpKYVVnQlNmTHhIVklIQmtISjdlUk92T2FmcW5yQXJ1cGNRM1UrdHZ4SDI4aEVWbjRtazVjMmZhYTYyQjVtVjBUc3paVnkwTkgyYzM2ajhCRXpRb2VJanFsOEVxTHhnRkE1QzkyaHhkMlRVRHZXdW8yazlYU2UwZ2lINjhsTzRPd1FvTEtsYXB4eXVncXZqQ0tURnk4WnZLMitUOHFXZDk0Zm90OWpQK3pTME5aN1BDTjFKTnZkYUdtbmI5NU44aGtrOVUxY1BMTml1WGg1M0d1cnFXS2s5S2ZuWmRsTDIzanRGUXhyOWVPZElsSlJoKzBGMkVRV2ZMV0J2YkRFYVE1WnNHTGVOZWxxUFNTNDRsYnZ3UWJ6MzBjT0hOc3g5aWFQZEROZVd2ckJlOG1HK2ZZT2xsSlNOdFpRYTdqMTk2RUtSRnIyeEs3dW9tNU12TnYveXBlOVd4K3dCQnZLU0hiWnE3WEgzb0psVUY1NDFxdXI1UFdLVkNkRGpjYUI3SnBQeW0rRXRDbU15VE9JRmRrNlAzUDBnTlhkcXdiY3hNaEVYYmRMNFVMaW5aWW5UeHBHY3NzZTNueUwyWURFN2crd3hWWW10TUNPL0RmdVpZeDZWTHp1OWpZdUZJVmR4anRzWUlmUUpTS2ZyTC9kNjhTUFgxZzY3aUxWR2NKeWl4UTZjMU9lcVA1bFFpL3c3cXR3ZVV0TEVGNUE3Z1pzWEVrTEYrMGhwTm5aTGRPelQwandNRXc2OGt3cURJRXN2RUI3SmRmZ3JCWWtIaDZaMS8vOVVqeFFDVWxzWC90S1N5MXNIOUpkSm0zMDN0eit6TUo4SXBqbTB2QjMzYysxekhVMnQ0SnRQcjVTRnNHbVV6dGhOZzVhVFJ3dVpNMXZ6YllUU1NRcmV1dXVMQ1pOT0FFeFBsbTdPUUFSZTdGZkcwV0VpZEZONHJpWUQ4N0cxd1RXejdYdVJlZlVwdGFqQWFhKy84UDN5bkZFclh0MTZGdUNmWXZIVHJvVitlcnJBZnRJNWduTG5xY05DL3QyS2xmVzd5ZUQ5RWtLN1pDSm1ZL3pkWkVsOEZZZWhndzRGUXZwODZGTy9uWE96aDhIS2hlSnVYOEwxQkJrVGtJVnNsNXhPa1EzYVFqRzQ5UjBFNXhNNm94dkxKRCszY083dVplZFVQL09TNXR6SlFDVkVHMHJEVGx5cmZUdjRzSUkzWnBCWDJRSnEydGxMdHZUcytKNFd3QzF1d0RUVUR6ZlNIVVBMa3dtSkxnR0NZSkx5VkwwWElGTWdHZWlwUkdSQXhnVkFXVTVuUkVjMmJGMlFyczZLWHl6cFdNUklRS3dtMFNQUlFoU0JtV3ltcU50ME0xS04renUvT3lEUFI2RWtpeWJ1elFjdkQ1bzc1UG9kc3RINE5wdVZCNE1kRVc4SEprbWJDdGc1QzQ0eTY2SkV4OTVab0oxVnZKOXhGVUR3YzgrYmt5WVlhenUrd2dkSndrRmZJTDdndktxeWJ3QitQSFhBNmc4UThZaTIrT0txc3h3SThxVXNoeXBBTWpzeExTczhQUHp4VG1EZTFVd0lid29FeG1ENmdMTWFlSmZyVmZUK0hxVUxFc3k4RFNsYk5uV3N4ZUxoNm11dmU0eUZBUzR4aG5uVDcycEE1SERzaUpQMGhrLyt3SEJDblhPbE1MRkVNYVAvNnU3UTVVNzBySEt4YiswZi9OYW53dkV5NWlHL0trY0tlbWdBelJ3Z0JSQmdtVFhPN0NuYnMrQU9wRlhJci9WaFI4aXM0aXhBTi91ckU2ZUFXUkFNQ0FBRUUvdnNBZFR3REZmL2N0bE1PTDRGdVNOWDA0dHI0N1JMYTBET0MrYWNXbEJOS3JnRUx5dk1pMjZnZnNERHF0SUhydEhabXZSNFpqS2ZEQk12eURsaXdDRmVJZ3VqWmpzYzVOd25FSnJjNkNYV1RCQzkyNitkdDEyKzdPMG96SVc5c0p3Z0VHWU9qOGRZV1RIckJlZVQrQXYvWnVTZHB4ZTN6TWo0MXFERVlGcHZhdGgzc2pFTHgzU0lwRWt4amJkUmlpVmZZUkhaM1VVTmUyalp1R2FpVndta2IxM2t3ZUJQTXdGRFpKby9TQ1NsekdUbkQ0ZnlTaGE4T2pBZlB1Tk9zSGtveUhRQ3AyU1EwWXo3R0tHSkJZcEdXdG9KNEN6VjZBK0wzUTQwaE1TQkFhZFd4STcweUZjVFZRSEFVRTIxRkxZNUFhYnRNSUJVaEFmVmMzclYzN1JRSUU4TGNVQjk1THYrZktrejFWRnZLZjNUcnlrZjhCek9RQVI3RCtSeExJSHhzNVRpZTVxSVkwQzJGVUtTQ2ZwTXArRzNQVWJjSE0yVXA4cWZBaUlPd0ErT1NPRmg3K0MxMlhSbityOXJ5eWhNV1JwWnRNaFFvWGlQemF4bjdscy9EdnBoTzllRjFFald1NGF0eW5SR0pSa3NGb3czUExPUGlWcVRvZ3plM3FsZ3F2bExNQlA1LzZVdXVlTDc4eUprRFh6b1BCMGd2anlHT2tVdWtNYmw1V2ROQjEzR2d2TlgwQVh1QW5zWUdJRVg0ZzVva1FEb1Q0czIrV01PQ1d4TXRaOHRCVXUvVEZPRVBjUVVScm1RNi91aC9YUjBTR1Byeml6cjJJMDhwcWY1ajh6THNuY3lRdXJlN05rM3BOTWtEalpIWTBRaHNFTDhsN1RMVzdVL1ZUQVJDYlNpbzZ5dzFFZzlvQThiYzlIWDAwTDF2aUFQbnJxcjFGMkxJc2lGRDZZNFlIckEzRGFQSTQwYW5ldTVKNG4vZERKSmp1RHlHalZrQ2RQRWlyekVic3g2bW9wV0hUQ0lWc3hmd215eWtXOXFIUnJBOG50M1RHZHRmKzBWa05JSWs1N3ZWaHpjaHFtWHFMS0xrMnVId2txNHl6eWUxN1lvRTBmbkI0eTdQR01rY3I4YmQ0S1luMVgrNFZjaWIvOEpIakVDRFBkck5XeE15SDcyeTIyZWE5Vkh3MUZ1SXl5TlMwQ2ZONWtWcytuWU00alc5bHhsdHpTVE4rRmNIQVMrc2ljOHBjODZnWGRuL0g3SUlZUEJBNC9IZXJ4OTlPWnBvM0NqOTBJeE9LSjdINXBwTndPNERxZHFYL3dTeUE2WXM0Vys4dUJaUktMaVZIR3Q1S1d5VUM1d3NTd2loVG1IYnBkZ2tKMGhYTnhFU1BNd1ZRRVVqUS9rb1dKSFIyT2oyYlYxajc0VVRDV1hOdE5PUVBhZ2VPdXZJMXZGU0JwRGI5Z3RDRWJjZUZUOUlhMzV3TkxyZm9oMjdpT05aWXk5RmppbmNWNTN0ZGY4MUh4WEJhZkYwU0V0Z1JBS1FNQTBUbmJIWTVXZjA1U2l3NmlsOGprT2tYTVVqMUF6QUtYY0Nkc3RqNk4rTVhLbFlpOUpvTlA5dkFNekZ0QUpPbXdsS3c4bzBLVGNOT2xwU0dxSmIwemZra1ltSm9vQVVnVHV5Tk1FbTl0VEJZNmsrUXhaNFN6amRUYzBibThtVFRkelpHbkEydnBwWEhJNS9lMjNEWGM3L0RPeUNNZ1FEaHZNUGtJZ2ZsamVhcTB5M3FDNVBaaHFkMEN0N3ZYd2NrckNPdHpMdmVoYzZIZ0lBQVFUKyt3TDhvYUgzMHFpZ2ZHZVdWODRaY2xpUUg3WmMxTDQ3ZWx6Nk1MWmZ2WFRJNUw2TStFZ3BIN1JzblMrelo2UG1mQkJ0ODFXTVFPYlVZR1Nqdml1SlhjNE82N0tFbXNTdG02UzVmWFc4MVFrUGZHUFpYZGJBbzV6NHFHUVBMTVBtRnM0T1Q5U3dhQVRYeGJPeWFoaSttaGIxRDNQelArbDJwZUZMWkk0ODlCQmVZNEJqbUxiL3dPVElaM1N1bklucGZvTzMyVTZ4VG1oWkJxb21YQzZIajFYa1VSUUVPMjdncW93ZjRaWXdzY043MUpBMkdmQ0NDcW1rNDMyS05LQU0vbDF2MmJTUU0zY244S1ZCSW5RZU5HZUVGWDlGeHN1WHVyMzVodGtLUjNXMTdtTU1XL3llOGFlWVBHTmx0N21ZMkE2QmtBYWdvMEdkeTZBeU4yKzBVWWpFZVhjMlNxaE8wMHNKOHA3aDZBUW0wRUZndnR4VHFYOHhoZW9IbVlhaEJEYituUlh3Lzlwc25mOU5CVEd1ekdHMHhvVW1YNU0xU0ZJZUQvaUEzSndOS3lLdWw5WGJjNHZpNEZCRjJIaUhDRWhiZGh4KzJGOFNrZ2R6TDRSNEh2SkVRK3pabFV1M2hVbUM3QUxvY0Y2bHRJenVVeTJ5VmRFY3BMb3NMRERUQXNuV0xNclJubFFLc3ozNjdFM05yeWZqd3M2Um5NUTBIQ1QvUUQ3M2VTQmdLMzZYdTJDbjgxQmVZUWZhUlVRakkvVnFrdmNTNG01dTd6ZjZJRXZsdGdrNk0zSTdKRGlCWFNYY0k3eU5hZ1VwQVdQNmdDWGsxQkNnWDZQNEhzNk9Lb1Z2V0lVd0ZidXFRdVBKUlVEZE5WWXh4RVJtcG5KZkNuK2xCZmJsMmZnbmQwditHWFdUTGtnWmxId0IxSGs0QkMvVVRHckZtemFjSGxxWWNaM0picm82Ym1PbE1EUkxVRTEwd2dIVlBWTVk1Z09NbUNlR1ZJb0Zld3hrWVcwbDdCaG93bDFidW03dURpTGo2VTBXOUFKWml3VHRFcVgxSEF2cS96UHhSRkY0MWFobHZpaXRZZjlmTkl0aGRwTm9jL2VBQkdsUnhLc3pueUk5bW9QWVdmTXlzTGcrRFcwNHJsTmpBUGNXcDc0a01UK1kvUE8vL3duYVc1SDI1N2Y0dmxlc1BZUnp2VEFqTTNBcElMV3Yyc2FGbjA3WWt4NEY0OG5ya3NRcFd4NnhYNzZqa0NJei9GcjhaWGZidVJhUFI5T3VmdVpTRk9RZmo1T2U4cHpZNjlUdU4vOHljMnJGTnJVY3YxVFZhNzFSYzFMMFAzWHBzaENtSERGVlUzOHo3MUdMZS9ZdWgyZVNZRnBqc3BzQVFWdE9FNEVxdkJyRDBCMHk1YzlXcE1QQ3NYME9UQ1NCN1FRckNUVXdmdWpjaW1GUnZzd2ljQzJ4Z2NFYmJHUmxvNyszbnlmV0Z2NUN2YUVRZVVTbFB3YnU1YkxBd2RYeEYwblBrTWdCSi9Ga2FVazZNa0VRTDJEK05BRXMzcWRmUGdxUDR6MndOTkJWK3lXS3poU0NkNUxzR2syTk5hRkJDUDFtYUdXY3lQeDc5L1hxQlFGKy8xeUc3UFZDSnZnYkUyNVJxaTQrSkRGQWY0cVNtcXVCN0Q0djlEL2xnL2ZhcmoyRS9PQVI1TU9NeVpNcm1mTGIyK1JQMzc4L2VNSFNlQW8yYThvNk85ZjNrSmVqVHJ6cVh0bGJ0L25IaUErRTdUb0s4WDc3cDNNWTdXdlMwZ2dkT0RIM21MTG05ZG9uUTRsZ0FnQUJCUDc3QWNpbjF6dkVucHJIY2tzUkxrRW9HRFZuTGplV3RZQ25kTS9HaVoxOExjdC9vcjZMOFJhWCtHVEs4VEozc2Uxa1hqcThlRFd3N3lubmtZS2VMdnRpNUpZV0VmMndEeVorTXVYcEJTVURlNkdIc1NjZ1h1Si82eHIyZExwdEo5d053L3plV1NTeEdGSVRBRTlycW45Szd2UTh2V0QwMUVOeFNRc2JBTHZIWmliMTBtdlY0MjRDbHM1SWtMaUZ0TVVJYnJrR2M1RzBhM0taTkJlYXltMHdndXVYQTB2VzNEaHlISXEzbG1MaDE3cDl1Qm95UElva0xGd0RhY2dDTkpwR2JIdzhIQmJzQkJvR0M3VTVDS3dPalA2MEJ6M0l5MVc0UFlPWVhZcHpQekNrNUJQRmRuMmJ1TFlSa3BDTXJtdit4RzRMT2hhaFZWNDcvL0lvdkxqa2xtY0YxRjFmMTEwWmRiNDRLNHl3Y2pnM090YnlxSUhmWDl2MGZDbGpjVDFSMkZLN0VPRCtlYm5ndUZVSVcrMXcyNGZNc2c2QkJnTGpIelZLUk83bCtoNnNKNWJBNXZOODJkTkhHUmJBUTZNWGppMDQ1N0xseG83aDUxT3J6NmxuYzJ1NmVnUEY5OWNVTU9xODRrMkNCeTNmNEpuWnZwcERuYVYrYXoraFp1MVdwSzQ3aXBUa1hmWitUN2RNQnV0dnMxcFVYbVQySWkwbTVSdXJodFdVL3pNcGUzT3dUNTFQL05RQWhhS1M4eHNkeVQzakFacTA4eU5sR2RVNGlFemsvYkRSenFZSjgyWVJHMDNTSmsrdTZEbm4zYTdHaGtyUnV2NXA3cGpmVEZqaUM3SWhXYmRrYmgxdWk2WHdUQWp6anllMVI5a1l0ejhlNzl5RCtLbDhSNzdhQWFSd0YwSGJRY3hFK1NZSjVkWHU0eXQrT1hHNlloNzY1RWZ5T2RBMWpHZitncjkwblFrb3cwSXd4emo0WVVGQ0VmaVFQRW1GaElxb3VFdHhPQjFaMGphejVSYXFXdUZ6TVNDMlZoNVNRU3QrSGJ2QnYyWjVDV2xxK2VpSE5KVHZyaG9SMitwS25iTXpZRVRnWnVPa3pVVEJyNDRxejhxRUxQTFhGWWEvcHpBSm4xNlp3SzIvV2M1WUNYOGtmZHQ4YzErY1BZZ2NzUzBlRGtYd1lOK253dlkrM3AyNnlZeUxKOWpwUm44aHRyQ3Rhc1d6N0ptY1BMaUlSNzUxaWd0RmFFaXVTU0VXSHRpVVFzZWx0TER1dGE3cjVEQ1doUGlZN0djaGx0cENzRExNdWFiUE9Rd0lxa0Y1WnNaQXZUREhKOGJQcDBnY1JoMlNjQ0ZXcjhYSWhIb0hhd2RMRzhpUVRsYktPZldrcUVSbU4zUTlsNlRSU1NkNm95Z1pSUy9pUW1PbHdDdmZNaTZzNEtoT1o1M2FLS1FaV0hhbWE5Ly94eDU4VnVLVkplZ1lpUE1YVERKQW1tdkVkYzJ3Zy9GeFFjTGI3bHFjTFVHWi93eERWZENyLy9PVFV5Y2t3OTVsbSs2UlJNL2Z1NUdlRVpFelAvOVUrdUEweHpWOFJmdWxqK25Yd2tqQW15WU91dGwvdlRSeUpyV1FFOE81RWYzWjNzdDV6U2dsU3Z6bVhXemMxTkJoeW0vNHVNanpySk1LRlVIVjZpSlVmRzNhTVJZWXdGbGtaWVVGVGI0Q3EyU3ZycW0wcEdEOHRBVlpPNCt0YTFxNk1Xai8rd01NSHl4SS91TktlQkNxUTZxOEU5eGkybDBBTWhUeC9TV3MvQVFZUllSNjFTMm5ZWVFDQUFFRS92c0JFd0dtL25jYUJpR3RhTkRvRjYrMWt0Y0YyUjB5bUhPeWZYMm9NNllFQVBYY2gxZGVBRGZrWjlwRlN0WWdsUXpRT1lIM0RTY3BocTR2RXhYdmIzS2VEYm1sb2VuSWRYQXBBU3hUT1M3QzMvZjNZSlJYWmVFQ0sxdUtWb1lha1pXN3NON0RNRExVaXZlOGlyNjhOU1hERlZycE9YMTc4UnNPNlovU080Q081eUxiWHdiM2ozMFJRUzZiUnJRUm9vd3pwZnhSN1AvZjhZZUxHREF5elNjSjF2OEwwVityamdrVHZybEtKWGlmeTZMUG9OZ1lackRaMTdNR2hLbTNpVG1YRFNYMnZ0djI2L2FaZzdHVmpkS1J1MFI0Vk9CN2Q0TWpWc0swTVFhTlpYWkhHcjV6bmdFVmdSRzlKOWZjSFlkSXduZklBUmhza0tGSC83c1hRNWZBN2ZWSnFhSllDZGZteFM1eDRrME9RWXdYdFlNanZwdnBxMERkekFOcjIvZVVwcFZqQjBaMGR3R2ovdkhrYS9BeVFQcWROK3FBNEM0SUMwNGZVS3FTVXd3eDk3SmV4TkdzYlpkdTJZSElQQjhVaGU4WGNxUmRtZFBBckVZOG1wT3FLM2R0eWpmdy8xWWlxZ3Y5bVpTWXJvdmdTTE1tRFJ1WjIyOVVsbTNCV0xYNC9LUjc4SVdVQ09vV1QrNnl2djQ2TjZkV3BqdVVlWkE5aW9vVWNvYTJxQzlUNDM3WFBGbXluaUdYT1NITGo4NmxSb2pJMitzMXZhQk04L3dXRlVCQzBSSHBsam9oYjM5U0hIS29IZGRhd3ZZV0lUOVpGV1ZtYVAwMWtCMVVGdmg3S09uekpKc0RuLzEyWGM2bmhHQTZaNzl2MlRqU1d6d0k5bjRLbnNCa21YcGJ5QkppOXFnb1dOS0lzYU9VZUZ0WitjM2gyMVFSWjZRQXE3RU5uckxiS0o5SGtxVi82UmdpMklLV0xuS1pNQU80bnB4YWxJeW81aG0wZXN0VUZFb20weUNZQkhwSUg4UzFYY0FoVytQNzZMTzIyVlEyWGxMUXdqZy9PcHRaNVhNajhtdHhqMUpCVmxMMFdXaDNxQ0tFQnZqNUdTZ3dML3VvdWVKeWEyaTk3bXFyaktyNXIxV3k2TFF6VVpwVHh3cDhlb2JpcXNJeFNBUklCWVBoaWZJT2UrZnJ1bkNhNHR4aXFPVlppOHM2b01hcXhvN0I4djNJSCtzVzNMRCtPeElVTy92dU0wc0FJemU4N29FS3YvL29XTkdmWTh6ZG9paVF1YmJuRE1nODFQVEcwR3NOZmJWM1hiSm1RbzVrN0hXSDMxQ1FMVFdLaEkvVlNTWmdIakl3UkdPVFlZNEl6WXF6NnhSQm9VcERtczhQSlg3bjhyWmxlN0owNE9ET1N2aEN5VzlVUVFoazNiVWFaejlYS1Q4dFR0TTI1K1FOaUhSU3pNamM2SE1PVk1FTDlkNy83M1NkR2Jjd2I4Yy9aWFFESFUrN1IxbUJtdUR1dTFITTdZNm9rUVUvdnl1aEZZYWZEbzB1bjBBdkVlZFpUbUYvMWFiUm5MMHhoMG5tWWVHejFmRFF0VTdTc2FZTWV4YUt5ZzhtOXFkTnNPVTBTRkhFYzBjVE9Md2ZJYy82Q0FNdlFPWHczWEh3b2UwNEwrcmI0bHhiNmNCR1NwL2lpWVB4VWE2QXFTSE5ZS1ZwTFZoSGVOVHJWY0UxT0tFbEJCY3N5ZVNQNU1BT2JGRDkyTzlUZzZlOUJOckdoZ2RWcUZySlhzOVltZ0YxM3g2RjFCc0wycUd4TW9IU3ZnSUFBUVQrK3dNSzBjc2VFNzByTEt4Yk9iaWg0U1lxQzJldkY2aTdhMmxjVWJHQU5NNG5OK0RndXZJVHJLNHlodWQyTzhWcDJnVHpqY2FvWXhDYUVxYTA5L1RKQStjSFFyaDlINTlCK3ZDWXpacEYyMUhkMVZNUXBubzhHbUw4OFdDQzNPRHFVZ3l6REJNaENRcDNZdVowVk10Ulg0aThJZ1lXaStMVkptK2M0UlRpcXpzb3dXN3FmRUU3VTltUy9UWUlIUEEvak03UTcvanpXSExmSlNwSUNaNTNPVDV6bWlVV3h6UTN5QzRadzdNVGpqM2E3VExTL0Y0VDU1dVBFWGMxeFgwN0NaNVNaUFlUZ3I4aGNZY3dSaDFxOUdma2lmeHArZEpUYWVUOWdXdWU4Y3pMU2h2SHYzUGJDbDAwNnpWMmlrTHdLUGdRRUJDZWxHeTltdWJMMHdyNmhwM2tqQ2lnZlZUY2k2RU00TGZVSXJZQ0pOK0N6c1c1UStuZTlsUGZ0NHhQY2psRmNob0dkRTZNZ0dKN0J0Z2hLd3ExUXc1MHV1dk9aSjF6U1hsNnYrK05qTWYxRW51TDFLc2UrRDdWVlZ0a3RXQ0dFdWpBNmdjV00wYU11eXNBUUpWK0ZLdXVicU56SEttMUx3aXBqdkZkL2hxTlpCWXk4QjZDVWkvYkNVS3hrVytYSVVWQmE2WlBvdUoreFlMN01Qc3RyVkF1RmphNHo5L2pxSGtGeVpzQUZKYUl0U1haTnZrT0ZocENlVTR1NWJKSXlHOUE0SWZwNVlPblFSblEwUDhheXZsWTB3K296VDBMZzI1Z0VRTlNaVkVrSGhST2ZJV0lSc1g3aWRsSmMrNjZTTHpQWENGcXRFaGFWU2hqbWd3YS84UUhEazRMaURjZFh4VlRtNFByazc5YWxlYUd6b0I0L1RDM3Iva0xKaVJuOXN5Smo1bG5pZ1B4TU0xOVVXUG9PUDYwV282U0pMSVBNVThNeWhnWXpSUTZVWmtTYU5leUxTQUpBbGNzVmpiYUp0cDVrQzlVYzAvZUdPd3hLSWRpSDlZek5TdFZWZU82aHorbWxaeVhFMm4ybFZ3VWRkS3dJNHNwcEh5RjQzZVlxZzI1K3hYc0FWZC9yMHJ4QkRiSThYMUROZ3VJMGp6TVFsYzhpL1QvWElGS1FaMUhtcHRlQVpoeGNkVldFSXZGOGZPOEtkVk1HeDVidW9UbjV0K0RZbWRmSFJwcTQ0djBIWmZwMlo3RWlBVFlmU21iRnYxYzlLNU9ubkg0NGpSU0x1UmhGalprT2pZeXFoT2FsVWpxcXJDVW9IOEZQdE5rUWl0Yk1nTjIwMFZIc0tPTFdReVl4Y21HUUNPMG1FQmJJc3JiYUNMRHdjYWkycUV1dEtpQi9ZcjYrSWxCOVJSY3BnWGNzTklhYWZzRkZKYjd1a3NrUG5mUHVqN3NyelpwbzRudGU4NjdYRHVzdzNZdHVkbktBYjRwWEZ2ekxZY0JJK0MvKzQyUmIxUnNjZm1WejdKSHhFaVdDQVNoR1FCV2VoUGJ1V0FxbnE4US9kRm8xbVdScHQzelF6dDJWT3FtaG92eUN4MHJDSitjSFV3RFdTdGl4aHBKVGVCekhRaUgxclR3eGVRU0NBUFE0VDY0SVVOVEhxblhtTjZwcndFMHM4MVZIY1lXS3dJcjRUTFlyTEZrS2IrMzViNVBxeWhkb25IU29weGR6eHY1a2tvalh4R0JIcERxTDA0RU1EU3BSL1ljOU1aZjZISnJZT1dwZnJCTFhiMk1kdFc5a3J3ZzJyd2hpbGlDSHEzd0Zsak9DSUVPQWdBQkJQNzdBM0ZxS3RxcEZWdC85ZTBqVU94UkxrbVNXVFpSZE5ibXMzTUhPV1diWjlRWHBEd0VTT3pnNGJhTmZodVpzV0NtQVFIaGxnR2RqaFcyQUVGSFkvaDlMMUh3NFJ2c3RLT3NOWVhpUXFVQ05xYi9PZGFoRVB6clcyMXBidkxydjNVMkFlOXRIRWRhVnhRaE9DbzdZMXlDMkx3UGFRVHNaZkxrZ2EvMUlFM3pmQ3dvc09QOWU5KzN5dzNRTStOaEpDMFBHYzFoNG1tbURuL0JNQkxNZklDVnpjMjFCZm4vSjRjbzhXSWE5SXZMTW5zeGh1MDh0KzF3OG1pVnp2NmROVUJaQXMrMjF1aVVTNUlSUjN1Tm1XZDJvOUVnOXl0bTBFN1l4bW1PZHZtNHFycFJ0cTgxakI2a3VIcU1TamZIa1Ivd0NNME0zd0xFWndZQWZPcUlNWGNlS2UyVWxCZFBoRUhuQmxMS0V6dDBQaW5tK253aWY2ejlQRGFDWnJxbithRVVMckZBVGkzRzkrd25ac3lCZURvc2JBM2VKRjUzZzRDWG1tUFNPOGpxaGMyR2lPbjNSRHpRbGpnN1o0VVowQWxOOEFtR1pacnZCNkZLaFljVXRJc1RWTHpXdE1yZmlsQ2NIUERnWGJkOFNsb2ticHhneFo1M1dNeExwVVhEMUdYNmE0QzVGcWY5YUJUMUkxR2dWc3FjVU9EU3FqeVZ6UWM2RnNwZzlwd3ppajBmeUhTK0kxVy9nTWRXYnRBalFXWGl2REJnNEJldU9NTThtMk1ROFZsaG80VklwTGpPMkN2WEdoSzY5d2VBeTQxRDU5WHIveFROQmlCeVhaQWRWZTZRWEZIZDgzM3FaNEYxNEdHWHVvY2RYMTJlaVdKeHhoSzBwQzcxZFRUS2NSVy9TbDF2TVp2akgxYTdFZW8wdlhIenFhWDVCalpyU2VSNTAvc0tJZldza1g5SjZCVDgvU0NqOTZWQ3QvbWZ5ejdKZWhnZzdwM1Z1SitHZTIzeE9PTDhRcHJtRDlrckVYZENyaWJxbDZjVk0ralJ1KzlTQmxCR0djcStGY2NyRjNuMWNrYWNHMytRT29QdURPYnhiaGxiUldkek9NTGtmTi9kR3Q5OUtpeXB2bGRUM3ZIVTVLV3pyOXRlQ040Z2JPNUM0ZWtUT3Nqem5mYXA3ZjdnaEN3NjV3U1p0d0NRRFlZTE5ORWJQL2VTQ1F6bDc1VjF6WHhlSVFJQVBHd2ZKc0dTaklGZndqNEM1ZCtENTR2VC9DQ0JFMDVsZTRZTmt6YlpDVk9uT1RKYjBGNmpGV1NDMVV2ZXF1c1Q0VmpGZktzMmNEQUlEYk82SlVqanVFRkVaV29GMmV6ekxzUzZidWtWMEJ0MTJlTDF5UlVBcFExNWxWMXlCUXRrOXVCR0l0dWVoeitHRE1XaVo1T1dZMGxJb3czY2ZhNTF2MFg3TUJLS1dEUEtoTkt6MmV5WlRHbGlmdDdGRkFXN2RYSzdrYVgrRnZZZ2h5NitVMUxXS2R5czNTRktITWsrVy8zUlhKci9FS05DdVdpMEQzWGNXZWhDcVN0VS9pQ3ZleURLMGhRR0xKa0ZtQnZhbGVVbmV5dXg4bUtpOCtlRGN1THBTZ3dSODl3YWRUQjJWajUxamV5WU5POTFPcU5KV0RUUmYrZVhyay9HQ0ZFc0VCOFUrWWg0b21GdU1LSXhNd0YzUU56anV6Tmd5QWFFSytodTBoa3EwNGJmdUp1Zm4xMUUvSm1RNFZzcTBKeXJpOXZIYlA3T2x4dzJER01ZeEo2RjA3Y3pTR1ZJM1Q4ZUtMNENBQUVFL3ZzQU9WYjYzOHRwM29DWHdoM3daWFdFd2I3WXVwS1hUdEhaVVAvVnJOaSt0ZWtQTlJvbVdCZmRQZlV5NEtaM2hPcUJlbDBQNHZKb1BMS201aDdNUm1UcFBKcHZNWjI0ckQ2UStEdFQ3Y2t4MDJYeXQyNzRRS2pCdkRJb0Joa1lLSER1enNTMHJ4bTQvY3haZFVQdnhNUys0L01sSm1HeDlwN1BSemVyZnlWdWQyU0gzeTU0TXdRamV3NkZKWVZDbVRUdkdWdjVBdGQwV2ZDQVJnaGlLY2xMb3k1ZEZ3SWNIOHZ6RlZxRUxNcWVMcHpydjhSeUVVTDc0OHJEMVJSclZFRU1ncXRQaHJaUkl0RDhDdTFZVndlUWh3emFKVjhHR3pVbHRKWW5kTUhxUkF1b3Y0VXZGdUc0aVNnWTF5UGpZVFhBcy85ZEYxTjRMNlQwZUlYSGdGV2Q5ak50THdyRTZVUW9TVURQL0VvUDJ5UjhqdzNxNjlJbmRSN0Zjd2RtamVlNUJIcU1GVFU4L3FkWlltclpLWHhvTzZ1SFNmazdHcE1xV3hrS2UxYkd2Q1lyRlVCekd3Y1UwYm56aEtLVThnSWcxWmlDYWZBaVRlbzc3OFRiSGMrdDdaZFNrM3ZuM3hBdzFFWFNMclp5eThLQ0NtcXdQSGhNOEpZbmxhQnpKU0crclN2dkJwcHU0ZGova0xpdTdlczFRYmRJZHRZYmtiejZKNU5iS2M0TjlpTFh2SlBPcEFJd3Y0RVVYTkVWNHF6MTZYandDT3ltR3VqNGxuMVAxSDdZOTJqa2REbnNCcC9YdzU5SjF5NjFxYWZkNG5KSUNSdzltV2g3YTNZMmpISEtHTDBDNE9DUCthTTdDZWRYS3poSW9OVkYyYStYMjhHaU44UEZ4VkRGTHhBeDBsVUZ5SUFYUzZJN0hoVWJUVWdKK2pwU2NFYk45WVVienpnY2VWUmc1aC9WbzhqSFNLc3FTRWhvbXRxS0RNNml1RUdoejBxWHRaV2F4WVVuMnNIOVlOc3FGY2w0a0M1b3lESWtNM29HOGM5RVZLSkRzZ1ZhaUNHZWkyNlV6WHlxY1A2ZG9jT1oyZGlXOWZGdDl3dWFWaVhwU1lFcGJCLzJCT3FJbU01Wnl6eGpRTmFUcENYVENHa0FDUXhDVWRpL0JmTGh4amZuc2pjS0ZyemFBQ1FRTUtIdkw4RVM1aVQ4eVlNTEpPRlhwTndYSGdpanlmK0NPa1dKa25iNVR6UDljRG1QdzIxdkJQeDVZNnhjSnRCckxycCs4ZS91V1JicmNaY04veEZKYzF4MnRjTkYwazJKUkd6U1M3ZW5rNjlOUVZiNnEyR3pJbnNXczZoazlmYllLU2cyTmdsWmtSWUlwbW1sbnhkOEJDd2syNHVOUEJ4VFNSSXI2ekVObi9mbjdneVJseHNrMUZjQkhuVEY1WTViejNkbDR6S1BzbkdjTXIzcFdiWFQ0VW5qK2wvN2w3NUNRK3JBeHhQV2pqZit6NmZqWHE4VWFyNDJYZko5NG52N01UVEk5Y0t2QWQyeXcrQ0o3VkM5dkw2NU91eFpBTEdlMm9iOWJEYVY2c053dWtCeEdXZVQwSG9NTDh5eVQvaVE2S250bjArcHU0RURwVk84UzZES3VHblE4Q2xDMnNFazhNRnZYTk5GbExRMVVWaW9Kek9lYmFsZEhvMGNjZy9Pb0gwalhxeDE5YWw4MWorOGZQeWZZQnBjK0d6VUllSDhGOU1HRjhTeXdqRDR5Z04rR3VMNmkyNC92VE1VUTFLRndPKzZqWTFXOG9CVHpieFQyNnVDWndJQUFRVCsrd1BWN01nR1Z0S1Z2NHRoZmIzaWVESHdpeStCOWc4QTU4Q1ZoZjhCMTlDRHdodS9wOHZKRmw1cXJtSGZ2eVhyWnVDZE1GVit5WlhiWEI1VXlUTjlLQytkV21neGZhTlRXSXBaWEdOb0t0TWdkTnNnZ2JySlRaNzJQMmJmS1RhRnRXRXJiVXkwZFhyQVI5N2JuYVVOaXRnQ1VNMi9pQ1dRbWN5Znp4NDhTNW5MRTl0Z0FkRFhEQ2V1eVRNbUtiRklQTTh0K3RqUGIzOTdNaUg1ZU40eDV4SDQ1Z0VqSG1EdG83U2hIVDNMRUxBRnc2UEdrbWdPL3p4bW9aNVVsUEhNK0dIeWFzcmtqbmUxMlY5ZzMybnFmaUp4eER2Y3hoSDlENlRjd1ZpMVd3RnUwc2F4TWcydUx3Mk44VkhLSGJRcXJhN0FtMFVvU0twOXVqOTF2WHBRT3BYcGIwd2V6V1dVb2FaN2h3UU0xbFIxN2tzeVFtdzcwWVYxdi9xUFNTeUJERDZxalFmeXBNY3NUd1JlUlQrTy9aT0N1MUF0RW9vSUZGMTh3ejIwaUU4TlFTQ2dydmNmZURnVk1vVWhObVFDZ1RPdFdRRVpYMFFKeS94bGgvRnlDVG9uWmpRa0V4NS91Qkh4My92VnRGb0pycXAyM1B4VXdPcFkwa1BTOC80Y0JYcnU5UHU1cEJYZUxmai96M3ZlKzNOa2pVYnUrVS8wRXowMEFqVnNSeHd5ZThKVHAvTmZoVHA0ZWtZZXdlOEovaTR4WTVuTllYRGhud2dlcUdVME1ybHU0TXlRZGF5Y0d6MGIvZVExSGFycEUzUHBRNlNKSmdLYjJEMzVOamZuN2Y2ME41U1I4Qmxwbk5tWklaU0p2WkVwTUQvSjRvMjFHRnFHODkxOUhTdEFMTE9zaVlKVWlIVWJWVFg5eXl1STFabE5Jc2UwMlg0UFVQZ05PQXErUFVZOS8xVnN3VlJLdU1wZmhhaUl3bUYxVWNJUENFQzZETEthN2VLYkVROGE4K0dCT2RZQVE3ZGxUQlhVZUVkNForMHdkNnlrTEdMaU5GS21RbXc2VTZqL0tRTW4rSWpwRkxRVkRjSFlIc3ZncTBhOUt6OE50UU56bGFPS3krdWhjU2xNa0V1TUNCN2VzUkg4cmZkbTJqY3FHbFZIMENRZ21JbnlLZU1VNEJZM1o3amhQUzUxTkVROGVROFlJL08yNmx0WDgraUJ5aDZxSitDOTdUcnRzWlFrZGR6NUFhQkpsRGwyWU5pemVrOWFkREVCRTFBRjdVMFlQaFFZby9vczBZdWw5SFgvRGx1MXdWU0tIQmkyNytiWThWZTBSL3YwRmRaRHNSK2lGUWRxQUVqNEtrUVpETkxUYmlnYURESDdkTnhWamxpQVhTSHNXSUlyUzZJQjlwYTRpMnJja05pLzJMajJjUjFGNEhuNkxIblkwRnBOaEpjdU5xNHVVS1UwUEgyTzlkUFduRUYzK21acWF2VTE5TXZxaFJZQlo3R1FuZmNwaVB3djZTL0JzMTdwOVdGMTk4ZlFZbithUjBRU0FLb1FaUVR5NGM0cmlIOG1USXdRbENDY0htVkNtTFJiQlpML0QvZFFaOTVMUGQ1V1JnSjdMZEZCQ1lBUE5RZ3hpVWFrSkJhdXhxb1ZUVHh4cjdHN09RUFNMcmYyK0NBbWtjZTZNb0hnNDhUQW1odkRZRWVza0UrbW9CNjlrTHlBd0t2bUJlYy9FQVBMaTZyM3BPSWhUaksxUWtydDdSSW85VTRXcTgyOWE2bHhvQ0FaWVBDbHVlQ2huR1duT01LZ1pZMWRBZ0FCQlA3N0FwVzI5RWovMGx0Sy9UZGRmdWZCVFpKNkNobU5tTFloZGtKZGVZY2M0VDRmNEhMaEhVT0MwSFBSTWF1Snp4Rzg5U3c3WGJUL3h0Z2JNN1hob3c2WkxacHZnWGRxSEVpMi9nU1lJTnhXT0MxQVVGemFoRG5GakFhMG14Znd0NEpwc1ZKS09SQzNFbGREQWh4Y003RkFPL2IzMFhPcmRkdXNNNCtacDVDYnRxd1NUVkFZYzhRZHVRWUhJMXJxckhQRmZ2aU5ZNVVYWkRrUzNRUlhGYmI5VEVXMkdBdDl6SkQyY3FZcm5BY1NQYzZuVnNiRHJFRVFpeXpZcmxmZU9BYW4xUklzTy9SY2x5SnZ4aWhzZFphUmZIbVpQMFVnTXg3NE9qcEcxVFZ4Ujh0YkNFdXp1TThRL0t2aUNiNUNPVnZFbU04QlpuNEZUaWtHYXh4OHp1MWc0UmRFV1dpdEdPR25vTkdoYzZmM2xjU1UyTFBzeVowbzlGNkJjU1NJMUVXYy96dysyajY5QzhqVlBlcEpoT1cwUERtRDBwekkzOERaWDNXZkZxS0huOTdZT2p2Zzh3clhHSk8rMytUNzRwQVBVUDhldWE4b0R4V3Q3UGg1WmJRVDJIUXZndHZTam9ucHJsNU91eWJCNzVoWnhWTEpKMndLNVNZb3hTZW5tOXArLzA1MVA2Q1hQdXF5bDdqbjBMZ3oyZE5wWW82bE14VGxvRy8vR3VLcnorSzlCZWlwaU1YYUlMblluKzlCeHZ4Q3hWLy9PWGVlMXlWZW44d0U2RGhtVnVoWFlWaUVDR0F4azluMHlrd2FvczRPMWQ4a3JyOVhVbUxqb0t2Z0RkdGxDYmlzUnQvVXAvTEQyYlNzREZCL3hFTjBIbC8xY3NUOGlPeExKdjBJMjg5VENQRktPay9Oc2tmWncyK0FkMGtYdGhJWnpBRmhCUjBIQmlMdkh0bmlWWXcrZjh6ZDUrbFlzaDhMSDlXVi9IbU5FTk13WEJSWGdlK1AvT04rdlBiMXQrRzRNNTQ3Zm5GNGNUSHFkSjY3TGVNR2QrcjUxSVphckdxU3dPL0xRQnVxQ2JTWUVFeDByQVlIYUNpSEdJRFZSKzNxYUR0aEZ5UFhpMzFXK09FUVB5UDFxWHEzT1VHODRlRnRDU1BjWnlaWkdTMndhQjA5QVZjeGhRRXFGY3dNZEdZYnZCRUR2NWtTUW9xWk9DL0NLNWpDU0k3TUNoY2gwNm1kcm9wcG9TQktjWEE5TGVGV0ZMYVptVUpRVWhoV2xjZ3lJS2dUSzlVcGN3ZjJicjUvcGlVZnY2S2ZWcDFCZkMrc0pET0w0TU9veFNGKzlWeGJIdFlTYVF1YnZET0FDQVlsdjRSeUtia3BBQmZIcVlNNzBNS0FHekFkVkg0ait3Z0lCRVdLUXg4VnlOcktUc0dVdE95MHNyc2g3U2lwS2x1RDdFR0JJRlNxRU4yblBoZlNBTmZBditOdHVLQkswMklCZTBaNFYvMXU1akwxYjRHYll4RjFOZm9kOVdpMzRKV0pmMVF4U0draGNVUDB4MnJOOTh5NXdZNUp0UExOS1I1K3paMVRZQ0d1Ulh5VHY2bm9VRUUybGwySVdJdGorTWw5a05nRHN5OHNVMHg0NEczYmwzbUhFOXlCTEVNT0tvdWFpS1lmaktDTTlGYXg1bWFSRWw0ZHlaeE9DbGJrQzlzUlF3cmU2dnhCbWZlbDk4NEkwZndrVENxQlIwWVpCZUF2YUYrZkxMeW12cUhqdWlDV2F0SE9MamdGM2h4aVBiOXViUEE3NU96MW1uaFF4Um5wdCtrQ0FBRUUvdnNBcEFUaWpGZXNpdzM1aU45WDBhTnFRRVF4ZXVxNnYybUxHSzA4M0ZkbWMySXZuR29kNzYwaDhtbzNvSy9qSGhvTWRJL080UjBaRGhIT3VlbjR0SlJpRmZYNEFWUkpiMjlsUmhoaUQrRjBVN2FvUDNqcTNQNFdGMTNLc2ZXN21rWjM2SElmbk8xN2VnYkd1b1JydUJJTWNDcjU4Smd4OFJSbmRSZkd1bjJUWlQ3WDdiS0NicngrcVFyc1p3TEx4d2xvcFR3RlZjR2hXcHhkYzU1U2lQbWhDNU9ua3kveGtzVTh1SjRZT2QzYUJ1ek9PcTVTcVF6Slc2QUdCclVYNERnbGU1MjU0S3lkQmtMdzdFVWt6dGJueTFDZCt4MFQzMjVvL3JicjVJZUZ5WTd2eXVOSDFyVlk1OXpPR0ZsckxKSWM4UDQwV2dXckdBMzVBeVdzRUtHTkRrV3lyc1k1RHNnRFg0bnRJTUJRSUxoSHQ4YkJxVjUwbzFrSUg0UHgvY3l1SFR6bWFBbGhnY21GT1FaS3BIMllXdERNUWxtUDMvYVlweDc0MXREc21hTmdvQVk1dmozM1FZMnlWS09RN3dXNkI1cXRvRVNVdWpSeEJENE5UMzlIbEtvNy9Na29LTGpnT1hvbVE1M2toakt2dVlkcWRWV0VpV01nQ0VwRytKbDdoZXk2d0ZVR2lGUDg2eEZ4MnNaTDRPcTQvODBrUi9DRDM0RURaUGtLKzRxYXUrcEljY2FFOHVkaHp4YkcwUlM2M043dmlpdFBybUl6RHpvUEFPNXBRVE5aOEhrT1dkbElXczNyU3AwbUdqbjgwQ29EYjlFMW42RHR5ZnBDQWYvSFRVbjdWRTNQRFlULzFweDBQWVBRcVFOMjNKWURMWnhvV1dHQ2JFUDdEVFpiOHVacVdWbFFmTnd5NTVLVVNmNTR0VGo1aDFMa29ibkM1cHBDYmowNEt1bTY4dTluN09aUC9qVklkTUovUlFTWmltM3FqTEoxNHc2VmFlRVIxaitkSFg2enR4VTVDeGR4NTd0b0xoVk1rTkNaaUx1L2dsTkZYSkxIQzE0NnpMV3dvSWFJa2lkMTJxOFp1dUFwOG9aaWxBbFFiVUtsTXdRVUhjK2hJQTlxc08reVZSVkRTZ1VtMGZ0cTJ4QXREM1hkWDZDYW4wZFBDRm4wUk1yeTFSZ1IrNzAwRG5PSVRoMHpTVWhnM1dJcWVZT0Vld1BtQ0ZRNUtib0JuZ3JQRUN1c09Da0Z3T2ZxdGdYZndIS2ZadVhtbUZOdEZnaHN5dWluWnBOK1M5RkFlSkhuN0ROa1FFRTZwSUllUlZuY0tTZ1dzRTQ2RWRJNC95V0xCUDBYZmRSanFyOUlBSG04dVBNL1NJdkZ5NzZkMzlrdnNMVHlKYWJsMENRQXZrVXJQVk5TT01lUTVlWFB5T3lzU2dNWjNid0M0c3dBV3gxU3FON3NEY3dPemh2WmUzSHphTjNCWjlJalpwajIxOHB3Zk91ZW82WllXKzlxZ3RBZTdaOFhEL3J0QlZIK1d6UW5pUUJLdlhTWnN0Y1BIUjRka1EwK2tuOGJrTnpuK3lqckZDZ3lFaER5QUdWTzVMaEZGZVYydTVuOUJGTHViamNTeUpMMlJ5VE9rV29TQm5CRXpXZ29hd1pPUjVXN1k2MmVwbEg3TEgyd1RPd0Z1Z25DV1pUTGNQR08vUFVwelB6eUNjbWt5Z1FFSDhuY1lEaHlOTW9XN0dialJqdGp1L3VHL1RqNmRHOHI0eGFicGtOaHRUYW5xNFNMRUNZSzVXa0ZQN1NNS3J3VkdNYmZFQUlBQVFUKyt3R1JJQVBtdWYzcUl6aW9Sbi9KUFFHUVoxa1c0b1VmNWhpcFJkOEgweXZmL2Fqa3duaUtidnQ3Ymk3K1JnUExlNUFBZTAvZ1VOd3ZPZ2JkYVlRVFZ0NVBLSkJhS1ZVSWVaejBkeS9RTC8zQ3pMWk5Xam5lQ2g4T0tteWMzYktqZ0N6d2MvbzgyWkE1dmFXT3lCc0RpckpzQUVRWENpUTRpV1FMQ2p0cmZTdFFnNm8weE13UWJHV2U5V0c4eklUdCtKa0E5RzVrS2JQL3Z6TDRFZXdSTHRGMkk2cE9NYmdpSVlydXpSa3FCOWNXNER3Nk5SeUY1cHFrbGtNdHpoWk04RDBjY0ZDMElCbzNoS0ROL3JEc2dpdUhyVUlBdUxJUlRNd2xPb1I2cW96K2kveVhKYXRtaHp3c1NITTZqRHRwZUNlT2l2WGlZaE1rSTVJUUlNd0FSam8zU2FzeWljVFZUelhXd0JUN1VHOElGOUlkOFNObEhKRE5PLzhLNFExTDFDa3RVN0hCeFUxMDBqUEcrZ2ZZQXJ0NU1iaW9zNEp2QmJqTHBTSEdocUdFS1hzRWpEMzF3L2ZualIya1VEOXgyRFJrMjgxcnVYRFhHYVBqT0JlYkdnak9PbHB0V3dHMGtBL2NNZTlERzB1dXdDazZ6UnRCZWdjY1dzdUJocks4S2N4c1huUUc1TlRUZUVjL01CbVZlSUFVV2VFVFRaT0ZkeGNrLzRCSmkxTjViVEtaTE5FQVl2WTJyRWpXYzVYQjZ1cGp6T09YSzg4bm1Pc05VRzlVSURFWVpwTEJwVldjUVAyTDNHRldDWU84UzBTQVBnVTlWSU5qSVdLWUZRQ2hLWWdKcVlXNVFKM3BNU0RXY3JRQmNmeHZBeEVqTmJCKzJxWkl1aVlZTU81aTVjeGVZYitVVGpBMy9ZcTBKcTlKb3VqSjlSQXIrOWdWRlN3b0lSYmh0R05vNGRySDMvU1ErOTZkQWZFMVdnVEpOanQxYWhPNVNLYmhGRWZDbWZmcUhEdUtJYkRJdU1zNVdwazZpRXNWZ1VzYXJnSmhPK3BqNlY2Q0RFWDhGbXhkZEU3NnJNaXRNZ3pkL2lxcFR0eW9LZWY4M0V6SjVrL0ZTQ0hqNmlqUW5ydEFMUWJwZDZYczdOd3RzTEQzdzJHTGZaWC9LNGlpU1I1Njg5NDlaVld3dmVmNDJtVE9LWCtlU0JMRjk0S250bER0WWYwOVc4cEMxTEZ4SENCanN6QmNoQWN6cFJMeS9NTWcySTNsZGE5dGI1cHFFSFRoaEhXMERURnBCVW1aTG45bVJTRmsyczNiV0xjR0dKb2Fvb3I2dWVNVlVIcFRLeU5TMFhWZzJidHhHeGgrY2lONmkxelVvR0xsQlBtdlJWSVpPUUZrQVdDdU1HSWtHOWZGVTVPUExqblFqZUp3NlJLL0o2amtHMEE0TDVhY0NFdjlRWFh1OElIZmhMM2NQS09KRnNOamZWN3d6YURGTUlmS21CMFdRUE5FcXp0bldPbzV3c3U3TWNzdmJJa0EwTjB1cFg2T2szd1Q2Tzg0MjdTT0w5K3laZ0hZSE9FaW84WnFmRUhlZ3g2TDR5WUNacm1uWFliS3dzV08vYTBoUWRDY09BaXAyL1ZIWDFNWUNHdHhLenNiQmlOMXNZeHNXNkFsZU0ydUd6cWQ0L1ZSYlhvdWtDbmUxTUliNU92OHNPNDliK3QzcU9GNkQ4TEpOblc0Z01PK1VNUm9UVjEvN0ZJclc3R21BRDhWRWRFL3VyOHdUcWowbCtZcU54ZGJ5b0t5OTVKd3dnaUpLMVdNblFQUEFnQUJCUDc3QWx6YmJ2VGRZM1N1b01KREtmM2xtbDVjUmtHcktRbHQ1a2UxWnJBVGZDLzQ2aCt1RHlObVZ6ajhYQ0JwSW5PelF2by9jTVdPTnB4RGxRQkZuZXZzTitZMDBQdGdwclZMbTVqVHcxNkZvYmpjaFVGU0U5c055c3VtMURUM0JHRWxKaW9GTUpvdER6S3ZLcGhQbU1BL0t3UjhnTldhQVEvWTQ1bFk1YURLaTV2V0RJdFl0WEoyUUdsTnYxSlBqUEUzUTg4clhrY05RclRqUzVTWlNWVm5WdkQ1VWtUQTNlbnVyQTByMGV5M1JOalAyU0F0TTU0OUxxYW5mRlBGVVNBTzlGZDc3K0FLRXlwNXU2d3d4a2tqdWIzZ3ZIcnRzb2dRaGt5RWdaV3ExRlY3ZHdRVEFqby9EMGZ3VS9FUjlGc2ZHd0ZCd05zV012VGFydFZQUWZRQXhuZUk2OHZEdnloV28reWU4NWQyUll0bXdqa1dMcHdUKzhGaFY3SXloL0R4WWJQc3lSTFJzOXcrNnUyNjZZRms2WnRvR1NvUU9RUWdsUVdMenM5SW44SUliVnJWREtUN1hiUHRrME96aEdkMURPcHFaQXMzOG9pQUQ4Q2paak1MdGN2YXI4L3Q5SWxGODVGaE5LWWQ2cExpMUxERVI5MTJDR3JKWGRtaERiQ2lkVmsyakNnaGcyL2RUeGd4ZkcrVkRBcmZ2azdHMlMxUHRvK2xQOFlsTVEzcE5jRmE4cFp6bVdzMW9vTDM5aVZwQWdJaDltay9xK0R3eGdKYjl6RzJkWG1valRDb3p4WlM0eVZXNmJ3SjBYTFBudDdLVGgyZ0Jvb0JYOHJqWDgwQm85V1JTKzc3cVplY2tUMGdFbEprUEVLZHpsbjE4K1BURUt6cU9zdnVUZWFlNUdKeWhQMzlaRkNrZzF6c1ZuVFdkTjVlMWdTd2Zqa0Q5cjJ5TDVIb3B4YWVvM2RVQnN0S2x2NHhQR2ZKRlhwK0J4aHlIR01uSXdtcGZlOUNva3V3ZWhIaCsrK3pMVTBQcmhBVUlKUld5NUJCYkw2K2x2QzVuYTQzZktxbkwyTHVMczQxTHVsbmErTXR1aXNYdXdaUHc0QUZHT25NakpoWStncmhkS3RVcGh3eFlnN1RyNXpWeEVuRExPQVVRdHhDaXlJUjFpWEZ3RE1ETER1TU1JQ0xjaktmM1B5QkJCWTZScDJDK0gvWllFMEVyb3hBOHFNSmdIN2M1aXR5WWw0bG1tUitDZ3RBYlN1YUlVL2c3V1hKOHIrS0RhRHhwN1krQXZLSkw0WlhnOVFkM1ExbjVJZXVuTjRMOXFzMlRzb1F3Rit2S2RMUTJHUStTNjEvdTVEaEZPd1d5cUJkSm5jUytzakFpbStKQld4dDV1MFZ3L3NoRGtHbWIyWit0Q1VNYjlRN1gxbnliZzE3UjVCZXdEcmpBcjl3QzAxNzk5MGEwLzI0UXR2ODhZWFdtcktNWC9KWEZaZVdRZjFDdW0vekhOZ0RVT1RqdTJmZGdIbmswV1RzQUtyL0NwaWJKQzBWcVd4Q2RnYno3cjlaa0gzNGdaZWxldXNPUFF1dDQvcGlLT1JqZnlZQnNCbXkxdEd3Wnd6U2Zzbm0rQ2hZMGdydHJBL0VlUm5KWHpOdVhORzZOb3JLUnhOYXhoQm5nUkdFcE50REJwRUtYK0YzcWY5d3Jwb2laNW8xTlZ6UVF0SzFwYU1CaVFnVG1razE5ZDg1aFVpZlIrY3VOZDc5eVBlMG1FWGVrYThuaE9HSkEwei9XcnpiTzNhVjVrczkwRzg0R3BIeUlTU0VaMHdDQUFFRS92c0JRRWNXeGNLa3NiNVNydklxV3FNbDFvZ1FpSzR0ME5YUlZSSnFCU04wVDk5V1A0RWMzRG51dTFUa2hLRE0yRVhXaU5zdWplcHRwcjZKcmJrUElmR2V2TVoySHROYmc5d0RFR1dVMEdwQzBtNlVTSWNIMWsvMGt3OUlzbThKendxd24xd3B1bEUwcW5XUStJMjNPUDdSdVIwZFBKZ0JoQWxVUUJsRjRSVTlicGtHaU9FN0xjN05YazV1LzdPVTJrc1czQ1FpVC9jU3YvYWNoOU9tNXFESE1qZDcwdGFqYzNHK2N3cVlJdUdRVUtnOHRxRSsvRkZaSkcxZnNmUmFhQTBsdW5lNSt6NkxkQWtYQWlJU0NBL1pCT1E2aVZodVVydTBXRnFSbEE5djFZaDNvTHY5aUtKcVROTzFqSTZ2OVNCaU9KRVlzc2tjTEl3Z2RBVE1OV2NpcDhTL1NVKzB4MUtieFYwV2ZwdnFhUFV2OEJXRmI3WnVOMkNhTTVsTzgvYmd6QW9NbkZlZkFneHQ4ZGdFbVl5YXNqWmhNV2NTQ0JlWGg1bmhvTWxqczRoTnZTanhBU1ZXcWpXSWVwSHJsRGxHVmZBSGNQNUNxSWRhYWJ5SjhmSDcyS0Q2cTFPdjFLYWUvd0pUemRPOVdpR0d5a0grTERKT2dsU3NjV2xaQ0NOZXF6SGNJL3c5Q1ZXSUhoRzdRQ1pINklCUVQxSHpHMXUvelA4bnN2TXVNQTNRcmhOMDRhbngxalRHQWFyc0ZRZU5zMS9JcGNRMldxMDRtd1lmWEJ3R095dVN5WGVSQkJqYStuM2NWT21BZm1GbHdzT200YXJmQkJSRDJCbjdrbzB5dkoxdnhPejRFK1MvdXVicHp1elUvNDhEaS9YakZrMjc4c2NXT0lTYklPZTNVdjF5UW5CelRkZFdlcWxXQXIwcTJwb0tJeXFVQWcyRlhDTlBwUisyVVdFZGtoSXhQQklDczhxZ1dpdnZSMWwzSEp1dlVRMGFwK1AzUnBDa3d3MHNIYVVSVUNDUEl2akZYbTR2UzR4ZmpMY1h6OWRUaGsyRFFVdUlMMnpvc1RpQW9Bc3RrZ0F1dWdIWkg1TjdJMXNCZERZZDNVOU93OVV6MTlGR1BTaG5BRXdUdmdoanZacGFLNTdlc1NEby9WOXk1NVhQMndMRjl0dDZ5Sk9IOHpmS3pTdnpsYVJaLzN0ZWxtbmxXLy9FbzFkQ25UNEMxZzUrQnROTEJhSzIraXJNUWhQTE5kWnlnS2hvdmF0Qnd5SzVjdUY1dzg3NEorRWlheUt4RnhWV0pvbE5KU2s3RUhQM3hUYjVPalRVd0xlU1QxYmxsLzRiMllINlphTk1JdWN4aTJhaVNrRzZPek90dzFwL1RxbmR2aDQzSWg5dmo5MEZ2V2hSY2JSN1B3SVh2MHNhRWRtdzZIWUhRQ09oZnJPV0VBdktkMmEwM0xvMDl3TjVPaXE0S1Nuam5HUXlkdjJiSU5QK2pkSngvQ09WOTlwU012bWJqdmZtQUk2QTgxZ1dScVVud2FlREI0S0xlQjBMaHExNTNGamJaZUxWNDlBS3p3SGMwYjh6bmpEbWdEejEvczBHQSthUERBcXorRDVoS0wvb09aVUlmN2o4aXFTK00zYVNKTFIvK1h2cWtqdXpCaVZmQThrZjFNR29VQ0N3K0xWTXBUdlNWTmxjMEl3YTQzM3Q3RFlpREFtaitGdGl1a2YzdVBtZS92dm9USjdwQ3hsUFZKQk5oK1d4Rk5yZisrUTFXYUNTQ1N1dThXbHZPRXFyVnpzazgycFlCYlZaMjlGZzlnSUFBUVQrK3dLbEdWeXBqcFdyaldwMUk5SDNFdVAvRXdxUUtFbFJScU52ajRXd0sybkJWNDZPQ0NZS2dVdXA0Tk9tcmtaZ0p6WmhpUzNxNGVBN0YrSElRajh2Y3hTWWNoVjg0eEpmRHh3M2cyRHhqVlRXREVzd0oyN1hHd1B5OVNnUWtwbnp1K1dSZGZ4SnhDeGM3ai9zN1JBTk40V2VNVDhkVGlkQ3FrdUd1WVVWd1VBOUZLUmFwYXhwSkV5ZExFOThJNis5d3A5NU9IUVAxditVWXVUTk1TUURPdC9EZnVLaUdMczJMUTJoeHVVRVltWTFGUy80U0trNmNRZ2EwT1pyTjJ4d1pPcEtxZzdSYWdMNkJlT01uMS91Tlc3YkUvVFRnUXU3bUVjb1hyYkExT0NTSDRsVDVYZnZ4dHppeFdzZUQwOGZiQWtLT0xybk5ENEErUmQrVDM5d3JRUFkwVHYvV1NCcGZDdUNtV2ZoOVcwSk1KSUNlcVpYTm54dmZ1UXRZaXJmVHJRUmYxcjd3bnVpMHZ1dkVTSks5ZHdGRmxWYWtLU1AzUTk1VzhNSUxiTVFhSk1QaDBPYkVSckRUend4VG0xOUJFRHRBWW05QjVSVURFcFpQR3c2NnF2OTFWOFEzVDVoZ3dvMXM4NVhHWW1LZkVuWUQwNG5XdUVTNVRpdk1OWnVpemZuTmxFekY0U2JLN2xnbGFqenRNa2pVYnJMN2JBd053NDJVMWpJeU9xazc0MzUxSXFOZjhmbzNYZFBnNWZ3VEIvcmV0cHZ6R3NxR3paOEZQYk04dVdVTWc1VTNSS25TUHU5QTBWWmNRNnVDeU9sUkY2azZBWUJyeXdxRkEwMGZnYkxaL01CcjkzbTlzekF1ZU5sZEROeCtEallHSjkxeW1hTGpLUnF6M0pRcUJ5Ri9QT1A0S2ptWEJ6am9yTDBsTm83bFRXTFVkdFlDUjBkdEdvSWtENE92ekFYTGhSSE52cFltQVdlRGl4N1MrdGprU29TS3Z0anlwRGVFMnNVMzRlWFBQaFdvTTZpeXBCTFZzZlhBLzJqeWd3aDNuRFJWTVhkNlc3VjZvck5kdVFKeVFPN1p2T2pWOGRwcTNiT0JFSmtWeUN0cFQxUnpBblVDWFlWNFBXRFBVZ3o5RXNQYUNlQjd4OFJaNitJVFgxZVJ0ZkYwbzZrdkZLc1hteDZKdExwWkROaDR4N05na3ZPN0JnUlRzRENTRDRPRVhBSXMwYmRnaW1HUktsa01BaDlDeUNFbHNIZjYzSHR4VjRGR0hrOFFPMmhEN1gwQUtYL1E4MWJKdzRKQUNyMWRwMXNXcmU5WHQyT20zV2kwSlMvcHA3WDVYSGxtdkliOWcyWVVLOVdVSkUvcWl4YmxwWXpXVG5RS0hYY0o0OGY2b0t6M0VsVW0yQlROMU5MZC9FTzMrZjlRUjk5ajhkTEN0UnpuS0ord244Yi9uWTFUeW5COVJWRHl6T2E0UU4xckk2NVYreGVkK0ZvM1VUVS9ITUs0Q3RhNFFXOTVURGJWOHJyNGZBZlg5dE04RlIzYjlYdkdTbWJhaml0WGs3bWxwd3hOdmZ3ZUNiSnVyWkFwNExzVkI3R2lRaWtId2tZQTVGdWdPbUZacHBQbGE5Y1RsOGtxZlBUV0pmMGw0UVo4S0psN2loVS9TZ0YwOEJ6bWxVaDBWc1lXcnVBK2ovUGx1S3lVTlB1djdDRzlCUHpGVmhjWVpkQU9YeVNCSUJwMDlDMjFENElHZVlpWktwSEpLc0tieUFsOTlKZER6QmoxOENTNlZ6d1JjMk9LNCtQb1UzUFdWVStkdFBZQWdBQkJQNzdBdTF6aENtZDB5Y3dZcFkrRFNqcFVHNm8vazdEcGIwRjB4TGIyVEZKcDRXdlRNYTlKMm5hc2E3ZlB5VlJyWXZVV05RSkpGL1V4Ymd5aHhNM1R2UVcvNzJCUUJNc2diUmlzTVhDcXI1K1gxVFV4b3RsSEJoTzQ3cEMyUG9YaHFBVjByZ2ZuWmJsZm1pT2hsWnBvcTVLeXpsM3J2a1A4ZmxIQlhuLzAzRXlNQmdUTXMyc0o0SHJGQ2M4VFZCQUFtTm45VmNGVDZpVGJmdFZtd29TVi80OHEvaXpxZ1gxT0FBaFRvWVIwRW1SWkhiVzhzQllzdDdxbFpqaUx2ZE9HNWRpSHIrdVNmeDF2bGp5ZWNSQzZxU2xlR2drWTJnQTdMa2VHTm1ZTjJyQ1NTYTVqT2xRdzFpMmU0R2UvRlNBWm11cUxzSm1wV0VuM0RaTUhWSHF0OVJmSDZ2clQ0cEZBbFlFTGc1UERQa09SRTdXVTY2QjVTODdvMGthZUY4LzhpLzByS0loL0lsdnpJeXh1UmZLanl1SXBDRERrSk1jaUhNS0VsM09vSy84L0h3N2dtaDB1b21scXhQUFBvdGpROHM4dEZ6dmJPOW5LNjNwU0NpenUzSjRMbEQ3VEFkNldUZjc4Z0I4aDdkSmpTRzVTbktQV1YrTThPQnJuaVRDK3NUS25mU04yRWYzanNoZG9YUzRxN0pEdlNwTkNTWUQ4NkY4U3NqMFphckw1Z0RabW45b0Y3SkE2cyt6ZlJCV0J1L0R6aVdZblhTWHJSdVZyOWNwSTZ3UlBlTytia1JoUHdHczd3YkFwVlo5RW45M3prc1d5cE9ZRmVDNmYzd0ZKa3JNZmZHZnlySWF5K0FHalBiNUtsMENUMkFjRklXc2Jva0Fzak1nRVE2a3N5RFJFdWUvakh6RTdBM1Zwa1AvTkhWRkoxeG8yUzBqQXkvUzltM1V4L2ordG5UbVk3UVNDbHZBeXBoQUg4NkdsdUN4c0FxbW1kWmpKOVZOckJ2WkVFMmFacHdhYUFLRmZZOGhqblMvcmQ1TlFZaE1udFBBYTU0S0x5U2FPRlZhQVM2R0tPOEp0VWFBVU85bjNzUW0yeXRyWThjU3VFOTVHY3pDalRiZjdOUG83d05lelRZdjl5VXVRQ3dKTjRCakVhc2FZMFhGZHNhaFpYQU10MTZ6RTk2RlBlMUw1TUxyd3FsRGNYRnlrRWtkSXdvNzdLSkpMZ0tiaGZJekVHOSs0WkVIVUNuWFhLdmd2cDg3dXV4N2RPdEFXMGlEQis5cEhUaWhQbG9pOS9MSnkzdW9FVGMzZEV4UGtoWnJ4RC9ONnA2L1ZEL1orQUUvQnhIMG5OUlpmOG9mTURiRUh4ZmgxN2ZoNStHbmVrTWZlYTdMekRhL1oxTVRNek9EVHZUOVUrMjI1VHhPQzRWVklsR1ZETlQyM0RFNlc2M2Y4MVMzUE41RHY4KzFCTkQrdzhNUHBSamdmY3pEM3NScEIwYTZGeitXeGZ4UE8wZUthWTc3Y28yMjJRaWlHZXprdG9BTnZzRzRhemVNdXViWURqWURsOERySHhReGkxNnNDTVl3U0w4QktTaGd6WlRlRWxrVTRBOGlINFp4SnNJUTU3ZUxJYlB2Q3IxQ0lOMDlHcStYejhpdkl0MFphRjJQQjliN0lvWmZ0RmxZZ2xScTFoWkRhRXFDNXhPOThKZzk2aUkyb3d3b0w2NjJBOU1sUGVkYm9HNWU0SHhlZVVIaisxZWdKalFRaVBWdTMwVGIrRmJuWDNDaGw5Szh6MlNqNWFRRTl5d3JobmtMNy9taEtDOENBQUVFL3ZzQzhoeGFTVkhsdEM1K3BOcTFPaVIvd3ArWHNScWlkNVhDQ0NmbS9xbDlXT1R3VUJpUEp5cEpTcnpNL2NOSlhhOHd3VG1oOVcrSUhOQW1EYUhxUGN2eGZ3K1ZHZWlJTHVnUHp4K1Q5L3RFRlVURm5FWXVEaStOQThFdDBHZDZiY3crRlppVzR5aVJRVjlGL3RZanI2d3BIUnFaZGhpZDhocHE1ZkdibHVXR0UzRzRVTDJFNURzWExiTlB6MVc4L3BBZ2hnbXdjRWhTZzk3UWw0ZFR0endpY1dURWRYZWxDcElBdEN2Y1kzbGF1a0Z5Qlg1aW9Td1lLY0pGeEt6OVc2eSt4N2E1UTA5aHh6cC9ST2ZMNU5uWk1QNHJkMGQ3SERyUUtXeVZNQVVmbG1KUldSWXdmU2M5MHdnczFTMHRyelBwVWIvN0dVV2ljc1ZRWnMrc0d6SXB1Z0xSRnRBRE5uS0pXbGNsM1dGTjFTbzM5ODBMR3hkUVM2cEZtakprN1RVNkpBdG83ODRIN0xOZUpDL29lVDQ0RmtiM0FZOGpGd2trcDFQV05nZ2wzNnNBdFBPUW9qWXhMSkhOeGZXemo1eXhzOU1rS2FWbEZjVGRycCtUOCt0MDNUaTM4YjhkSytObHowa3ZDMGZMcnNONzYxNUU3VVBsczZCeSthVTFKL1lMU2J0VUQ1TFVGK0FIMDlCc084cUlUVzhHemNodldNcHFNbzBvTDlNSGEyU2QvQ0Nnc3hHeVpsWWFKMDE1WUZ6WHFEVkMvcGU4dHRpRHlEZ2JzWGdNdU8wWDcyaVJTSzFiVDR3ZWJCYTN1cHBpMXl6TzR0Z1BCdzVOS1VocFFvTEZGczUxajRoTkdweVBWeDhCTzZEN3hhczVXTWxBemc1TnpBdDk4MWtKR2I0MjlaM2FCNXhVdktvRkUyVkJETXpJdU1Vdm9PRzVFSEFscktZd1NEQ3ZXSE5TVk1hUEE4bTVHR1h0UGdHWEhRMzJDVVR2SExHazdzeTFPeXpnSXZPTkNGMmtWWE9nbFVDWHRyYjltVzAvTmJBSi93K0NvSmVGK0RoeGkxRmIwNWk2VWZkWEN5ejFMRWszbjR0dHZVbkZSV3VmcUpaYU5Zc0dWSjAzRkZXY3J3SDVkQmZPZUJ1RFkyYW1PNXVwWStkQmtkL0RYaDh4bXJDWkFtK2VNTEFOWnhZeUhMc3daclBNQTdKMVgyQW5UNWZTOHVFNURlVnFSZmxrK2lYdGpENkdPQWx4YW9sb0x1WFZQSjBGWHVTaFRKWHJVaDFXRi84RGlCYjlRTlNlZkRJSW1DT0FRRTNlcm5sZU5kRjZjMm0zUWNGaWVoVE1HZU9FRDZGTERWU0lic3hYOEt6T0d4SEFESmRibnhXOE5VM0VEbSs2UjRYand5VDNVNCtmaVRsQjBUaGVvU1BBcG5xb2Fid0o5R05SVUk2RTk5NWRTQlBSZ0NjdExSdkkwRjQ4K0hIaUFRM0tkY3RMYTBwQlZvNTZ0d290Tk1UWTRqZzRDRkZUOUZUUFZKU25KWEQ5RSswU0hrWU82SDVlaXVEUHIwNGFzVlpNR29kMzBZbUpXZTZOWXhkNEFoU2tWRWlmbzQyUE5ZeWZqcVJpV1RoQnJ5SWJxKzdzQUNnV3RmVElCdVRieFZWMEVGR3VZNzJMVVM1elhzSkVEdkJ4cmVaQldTOEtRS0Joem1rUXZaS0wxVE01QW9qc2NlY1BIc3hrd1V0WXM2Z1FXVFRlVVVFYng5YVZocnB0QXVnblZRTU9GSERaa0hhOW1ndXR0MDNOaGhKV1FOa05BZGd1c0FJQUFRVCsrd09idzlNNmxndUxybVpNTUJKZklYdks3ZDhEK0ZURFlqSVZiRHRxempmc1dUdFptNUVMa1hDd2tnRVlYZkE5UDIrU21YOEk0dXBySVhxUWFnZXcvYXUyRndWRHlZQjF2WGRCTWR0WllwSUIwU1l0QStWeE1UTDZxU2kxeUwvUmFFZGtmUWRMLys0TCtUbVAwUDJsOVBLaGxRMmNTSDVBZE85Mm5MOFo5UGk3Q1FZa1R5ZkpIc1RaNUJSaDFBYnB0Y1hSQjkxRGsvSHNLYXQrYmtnRFJsQ3FoTnNOZkV2OVhhUGVHSzFpUmJZdERJRFp2ajJLMysvVEZURmJ6a1ovdEVCcmxtYzVlTVVHWkNPSUNxcDdKY3ZZRFF1VUNiUFJyVDBiRGpob2xLbWJ0NVZkWmVQZXhrcTl1VzBHaGEzRC9HSjFzeDRiQTc0aWQ4dTg4UHdhRzZRVlhtVGlncENtckJ6dExZdWdiMXQ5MmZMN2NHODBMOEpNaUJ3SmE1Z2FHcUFnRHNVdU1keHpXeDdaaThZMHdoZVBXN3Z1UUZSWXhOTVZiWXRzblZCZEtDQkFwSmI3VXo0Qk91cnhMUHpZK2g0ZUxHTklhbEdGVEo5aTAxKytmL3NITVhnSXM1cjdmcmhBWVQ0TWt4bGZhSHUrRitEK2xRUlNwcGUzdUNEV0lHdy9yWklVZFVhZlRScVpJVFpKMHhEM0dwQU9Bemt1NDdubUFWNk14bzdQODlQOGZXdnlUeFhDaDBudUlvN3FYSkRCYTVWcUo2cXVkK0g3U2tySmRMeXk1azZIdkdxZWNuSUtPSmZNaXdNU2syVGxCdDZSU3JId0xtNlBpcmFuMmVvL2tCVlJvS2hzejFzTEZobzdLbkp5a0NkaVZISzhINno4dnp4M0xoV0ZGc1VUd3ZWdHVzanNtUllSSlJraXVNQU9WcXpmVHIveU0xSkRzMFNHU2RzR3MrdEU2MWtyTnRnVDE1RFI4TnY3OWxzazl2K2hpNHFwSVNjRm4xajdIQzJ1aTdHc1BFdWcrMHhsMWFVdURTNjFyQTBUeHA1TklwVFhDcFVLNFFvWWtBQUJKNjN1dTFMZzhMa0krZmtEREFSUVc4Mi9YRzloR09Qb21EeU1XWEdZSGF6Uk1JQ3doWGc5S0NwM0tNTVdnNHBUOUdTVmErUmUyTXhucE5qVEpxbllaZ1ZZQTN6MTZXbkd1cmJkUCtQMXYrd0FhaHlHZEdXcWhFWWsrUDBzV05WUU9oT2VzTnNFQlh0ZkJQU2lpMzM1d2lGQnpYeVdoZmoySjhsQTRWeTdMY1h4dlZyRjQxR2Mzci9NNFRidDdzZVVXTVN0am1XRjY4cU1kM1Z3OUtVU2VnU08rZVkzZXUvekNFZCtlaU9Xdi80Tzkzdms5SDRjSktYTk0wTGVJVVZOVS8xaDRiMk9iL1VMOGFJeFJjaGZYUEQ1em5MOHJBdmFjWVBUcWJlek9EUFRmNUFqWTM5c0NqbzVWWG0vVUZLc3drT25aa0duN3BDbUZlZldtYmFSR1lMWGhwaFY0V0crT1BCTWVIU1d1NWo0T0JLQXVkaTZOSWhBRDJCcHVUMkhNNzFpenUvZWh5ODlHL2RBM2g4TkdOUkJvL3dhRDd5ZFp0ODcwM2xPVFBUeDNGbVoySC9pM2pxdENyNkM0aGJ4SkdrbWdDRXRvUTVFeUVWSUhzMkJYOVI0cU1UdERJU1ZITnpJMnNtRWpFaGVZNGZ4dUVOSUEvdHl4SkZHYjlaRTdBdzBSWERhQzZ1TlRDcmpaa0s1OUI1WGUvaTNkUmQ1Kzk4YmhFR1ZBZ0FCQlA3N0FMbmxtZlF3S0xQcWNId2lRMkpjb1NOTkRFd3BnUUw5eXl2b280eGZxU2lMNkdoMy8zNEFhOFVUQXZTYmlFbzZ5dFFwZ2cyWldsNGFvMXVxTnphUlNvbHhnRXlCRnJMZndhVDJKY0VYcWZSRFVYakZPRHRObVJzOXlkcE5uZGtNY0FhK0NGY0FqaUI3OThNY3pvY015WUpxQkcyR01RK1dpUG1XZHBxUVRGaW96RStYR2tqUVlIc0JmQVNTTTQ0WU12cDZDenByZFowRGpmODd0dTRPM0lFd1NDMzAxdHJoN1VmYXRqTU8rZHNXNFJOeXJvMEwrZk5yMnhBZjBqQ1J0T1RySlhaenZSVVp5YWRPQko3eUVGaUpDSytJRXVnS2pxODVPZ2s2Sm9BNlVIVjJCRVIyd3VjVjEvbTc2RXFRSVQxczFnaXZHUkdqOE5hc1RJWEJJT1FFQWhIWmV5ZEF4Y0h6Tmo2SXFLSVljSnZXdGhYc0hVSlAzWWtwcjB3RGJSOWlVMWVYUk9sM1RVT24ybTV1K2FpWHdvOGJ5bmxXZURYTWcxREdKb0hTdnlta0dWWERjZnc0aGVjT25nY1d1R0tzRkVxd0hlR3BkQ1NHWTNIR1MySUNZbWFXNElMQkM2TjY2dUxmUTBraHZTRHhhWEN4RDczakZhdlY5bkFSRXpaRnNvNVBhZk5NTnhYdUFUMWNRclUxN1NnSUZNSm1VQnA1N1AvT0t1ZjFobHU4ZjlMci9rZFNCN2VRVUI2RitmdExobnhlNWVxZUhhTDMwTmVGRUtUK2ZwQXBVMjBwVVFRSHRXVVI4Z0xBa29PWkE4aVNXMWhFK0VoMjVCa1FyMlR5elJNQlJpZHRxeFJNWG83elVSbFdscGZEMFpqVDlWRjF0VFVlNGM1eUZCRThSak1GL0ExK0xGRGlPS1E4ZzFxM0wxaWx2c1RNV1A3ODZSU3ViTDRqeVB3RHZqb1ZCL0F2cFNIcGtTbWtqTG1vV1RkQk1IRW92RzMwMUh2Wm5od0dua1ZTZzVFa1h6cCs0cGUrVnNPUlc0Z3RpTXVhVXNMVC91SG1jUUVSOUdRSC91NS9XUjJZR056em56clNJeVlwclA0Yzh5VHN1c3hkdW95NzEwM0ROSjhESEpFYjBiTnNrNytqN2FmV3IwK0VUR0ZDZWloWjYyODF5QThFQTJ6YzJIWEIwUDF2WmdPMHJoWDFWV0lNc3BWRFFvN1FIalkzVjZQMTQwbW5pZTV6NG5qZGpwS2R1TldHclZsNWRGa2lvekZNczdpbVNaV29UTGdWWEJlem0vR2tNTm9KUmo0OGc5MkNHZnBmcTBXeU5Dc2tScnMyaDJnaGhHVURMRmZrQitGU2tpOHlxU2RwN1hVRVcvbWE0enJQR01tOHJ5RGR6S1lWMVYyNFk4ajAvOHRISEVBTFBjZk5HaE12SDN5eXRXZDI5U2J3UlZ2ank3QlN3eWNFNXZSczVYYmg0c1M5V1JrRXpkN05iRmZkQWFXczhjOE9jd3lnZHRra0gxUUkzUEFuNDBmZVBoL1JPUUJvckNpZTBBVk9aWjVsNWtKTmorNGRxYW1YYkFSUkF3NHNBbS9ldUdWUkdMampISHQ1dFd6SUMvMHNPQWhpVHFyYlZkZ0JKNzlYeHhFZlBFZ1ZIRVUxUTZFb1VwRloyQjMyTDExUzcwNFQ3R1gzdEc2USthaEtPcDNJci9FT0J2YmJaUXVXRWNrZWZEK3BhNnh3SUxwc29tYTc3ZU5QWTJGRmZ5bjlWNGZ0T3Y4ckgyZkJiL0ZpU0pSZ1BBSUJNSzRUeTdFQ0FBRUUvdnNBNTBTMC9yWUw4NXJQVEp3K1plWVpON2lEbFJWRVQvWUErQ25laWRJUm5TZUhaSlgySWVyd3hxb0JtQ0ZtUHlYd0JFUTZlOTRFdUZqaGpPUzJpeVBPTk1Gc2ViQ3g4UnhFME5ERi9vaWwyVlRPTzRBQmNYaVpEWkNrWTV4Z21JRG83WkJsWVd2NXI3VUNtbmhlcnE4VVBnVmk5T0hIQ0drUWF4cisxR2s5L3FNd3d2d0hmS0pRZytPMDlZa25RUG9udjZFeHcyRnhnYVN5MFpWV3AzVW0yRTFoNmt5MytTVkptWmkzcmNuemZNenQwRTkySmNsWTY5RUV1OU5EelVSbmpJNGg4dXNxRkc3SDU2ellFbGJTRnJTUi9GYVEwNWNTa1AySHBNM2ZQYTlvU2dvVDI5bDRSSGlYY2xlNThya3dXaStsSHVRbmdYZFlQbU1qcG5TeVRnYkFTdTlKTnZxNGQ5eXE0M1R6SHFhRWp5Y1VQR3puMnIzY2Z3MXVzMVFienVzdTFZbjdFY1ZKa1gwekFSaktCQ3BKNW5BM3loOThmRHFsK3F4RnAyaWoyazZVS0ZQcUZmUUgycmVaNnFCQ2VFdy9TSHlNcWwxblYvcUtNMnRlaE9XQTYvM1psOUZReUVYZm5KWThrL3BMWnhzZUp4Uk5HTkt6NDN5RnJPbDQxZjRpWmh6cUtGSnR1Skdlc1B4NzdNQ2hONUFZTzJDRyt5RmcwcU16ZHBNZFF3T2w1aXd2QlJSYTB3OE5vM2tBWDlIbmdNSGpick1Hb1NBOFFJUk9xVFVzTUlyN00wUjNKNXE3clJrUWQ3amtYNkFRb0xRTjc2N1RqZ0h0K1hQMGQycVFHNTZocEltdTdHWndLUHEzU0YwTzRyVUcyd1hPTmNCR3VxVmpDWFJEZ2ZmcmJwRUdZR3JlUTdOQlNMV3ZXdWRDV2d5VU1wWTVuR2p6Uk91UXF1aVZnQ3EwL0tLWTAvUC9QV1dRaGVML011bTVlci9KTE5kalBVUm0zUEI0YlVwTmFQSHRaaHV1SEdOUVZ2WGw0NUZBQURaTi9wQ05qQXZwUG81TkFjMEV6aFVuZ09KeG5TNzhKUU9pbWYwYmhmZFRLRWhpcUhHYjRUUmtycDZKa3F3Uk5WbTZWZXMzSU43N3lWdVM4c3l6S0tSejBZMURRWWQrNzMzdm94b0VWRlZzZVlPazM5a2tua3RLVDAvczAveDdkZjArL0Z6RHpHc2E4L0pYMktnVUswZjZJdUFQS2c4K0dSQmgxRDdZd1k4cUhkRWJud1ArVDhrNkl6ZW1BTzZ4d2FhTFpUc3pCK0hxK1k0RHpaS3JpZUNzTTh6MWVkTTBCaUMzbVVtTkFYY09WT0FTRkpzbzY4d2daeWFRayt1N1hzS29lVi90ZmtvZVZCTTRNSzl0YitJakg0YlpQRXY4SXRaOGJ2MFZ6V245SlkyaFpYUXpHQ2p1TnNJL1J4dVZSRExnRmNDNmNkdHYvRjY0NTVFVnN2MnlQV3BaWHlXbWgvcDlQdkw2dGg0RU4vcVI4c1F5TTdwWWxmdkZHbU9vbWlMdzFWMFk1cmNSSlAzRksrdGdid3hVQVg2d3J1K2hHMkVPMUxkeGNmaGZXMm1XYmlLN2p3ZmdvelhtaXQ0blRMTFVKTDFtN3kvaEZUNTFuUGM5TmFXYWNuT1VxUkZ3dUJjaWJoZmtlSGh4TWxXTHdaUWtZWmEzbXB3cWQ2dDJmdDBnM25WQkMyNXBkMk95Ry85V0lpcFJXdmNGNm41SU96WVNqN0lnWDdJMFdzQ0NNYUhETVFNdWlSUm5qd0lBQVFUKyt3R24vWmhTODU3Z2tSay9ZRlFxNEMzSHlIemcrK3VQYTlkblNIZWJLdzVUMlY2OXNuSzF0ZEFUNUxsOC9XRGVjWG5US0paS3Z1WUZiSnpVWFdFTmJ6eTRqdk9oazVVVnhkVUtJcWg4UGRveEZwZkFsV1RlaFJ0TnBBSmVaUDZ1RHJTNFlOTzBiMW0rajRCcmhMcmVhSEQ3WkF4aExOTCtza3JsRURORGhMd0QzS0RhdXdDbkZPYjlOYXlwQk9sRmMzcVNMUkZoMXV4NW5iTEVZNW9WY25zUk9VRlRHRHBuZXpmSnRaV25TYzhLaWYxOGQ4dUVvak9MeVJicitJWEt5ekl2c1Ixa0JUcENlSUN3Q2ltZmtXR2VpUHZiNUZFVy8vMjVEM1Irbk9VaEJUb0RLNkY5c2Y4Z0grS1g2d0gySUxveko1b054ZndBV1JLeEkxSUxBRVJyUjM4dTdvMDh3MkFmMUQ5eDJBc3pBSDNIK2labjBxblZhbTZvbHFkSWJiaUp0R1lJcGJrWWM1QzBNbkxLTkEyYVhXMzVncmlYREV0ZzNQeHlBSW9DbHUvaHE3cmV1SVF5TTRvS0xLa0RLOGphTkI5R0szektITjNzK0JvRkMvbzVLYXo3alAyMHN6Mld5eFM0bjRPUlhSMXo2VEQvNUZQRjZIMTV1S0VSaUpEVHJwcitvMjZGT202aEVWNkMvek1vRGJqUWxpMEZrRjFsMThJWms3N0xLNDJ3a1RpZk9tRHlEWUZJWHg3MGZTbk9jU2xSWGxJSUVKVCtxN2w3dUE4SThPM3gyeVhNanc0NUJuL2o1RFZDUk8zbHFCNGFKM2ZBK3ZQcjJRdEhBaGFvUTVvWFJ5M3U1MFhsS1k0ZDUycXJmYW1KY3dlNk93T3Y5MnNVOCtvVDRwT0NvUzA3NERUWlVKckNuZlorcHo4RlpqbFdycTdqaWlQa2N2YTlUL1ZNd3VzYnM1SlV6bVFySW1FbUVoc2hobUNVdHpQTWV5aXcvSjA2L0djQTc2Sks4NVVkT0QxT0FiaTBraU81R1o0NHYwd0wvUlBSanFaeDgrc1JzVTJYSnVtdTFqbG0zU0RHOEVxS3VyMXBiWmlXVEQzaTByS2hXWmxrN1IzWmk1cnd2d2piajF5MVpObCt0OFllcE55NCtFVjhWNzVXQWJad2EwRUpRWDFFRUNaYTVabnVTQ3VKT2UyNlNCN0o1SVR5TGRCampNUCt0ci84blpjbzJrSit4NWY0L1VFR0VaT1FPVWtMaElhb3VFdGZPQ3RaampaWjVXV3F1T0hLTVJXMnRSNHdRWjErRUx2dXZ3QjVFV20xK1p1SFhwUTFybkVSNHVySG5jY3pkVVIzWnVLa2RVUTVyK3dxNk1yUkxKN1hkNFljcDFVSmxGNGp3UHEvTk02N0NhY2swTnZTYzl5Y1A0aDdzY1VlbmtVOVlER254ZllWM3V5NllveUtKei9wN0gvaXRzcXRkTVZQN0IrY05MaU5SNlIxK3d2WmFLZXVsQ0dQSHVXVXVzZHd0Qlh1UGE0SjVIU1dnUGhjN0ZjaEZkcjNzTHJNeGFaMU9jb0k4MEVUWmdwQXN6QnVKM1hQNkVoQlJ2MlN3Q0VGcjNmSWZuclhheUpMYU1qYVRoSEtZZlh2cUtsbVFuUTdsL3JSS1NlQm81c1pXaStjUWx5bGV5djZNdVNzanFqZlp4RGFkcVFRV0JlbUZ0K0x4eHA4dHVJVEpVWVlhL05rVEFwQTZHdU9kYml3WC9FaVFjdmJqVm9xTGJTWjN3emhWYU9yZWZPWVU0b2tSZDVibXpHUkFnQUJCUDc3QUpJdmJHUU9Gdkt5ZkpYeldQd3hKWW5YZXU3cVlpMncycDNpYjZ3NmlHWW5DaEpUTm5nSUxvT0M3YkRMbmJIQ0V2YnBCREhDdUVBNU1lY1BIaHJFZHc2VXNRazlvNHl1bWVSMWc5L21GTGRvVmdXb0ZzQ3V3K09vVTlFUTRKcEs1TXZ2bWhsZWtLZ2Q1cnpMQVpPZ0hnLzE4S1BuNkVQQ2ptMUg3RlNnVG9MOFlCYzV5dzZ4ZmtDano1UVVGdHJJdFI4TU1vZFlFNHFtSklwOHJGQTNRM3lvVHNZeGNpV2tDc3BYeEgzZjFFVWxSWHFPSlVKV1pIelVWcDVnWnpBcXFpcFExN2JyaVY2dGpyQ01NNXZmTFVnZVRwcm15QWRuaDNUUDMvYzgwRmhLYS81TktWUDF5YjM1V3JDL1g3V05GZnZQVzZwS2YvOXRoTEcyOTlsdDVyV0hvdTk0ZWZ5SXNScDNyOHd4WUhLZXZ1QkFoZmk3YklzSVNuS2NZSGlqNHF5SnBHNUpMclMvenkxOXNEaTRBZUJvaFRmcE1vUSt1dmt2TnNQWTdZRU5oMldEMk1rMHk3Q2htbWFKc0Uwd0RTVUUya2E1RWNrOFJPeXhKd3VGaTloNUV2NXBJMWFjdlRiUmEwRERKeVQwdXkxc1dUQjBBQmNiRXI4c05TT3NVOUwvY2RvYndjMmk0ZG5RTW0wZ2V1MkRZMG10UzFpaFZrV3dmUzFVZFRlZXk4TGwzL3JaV21LR2w3dEwwOWVKRnpoQ2xnN0U2TU54VFM2bDZFdlJQOW40UExzTEVEYWdRdTIyVW5CZ3dRNlBibXNUNHV1YzJKU1BZRFZBOFBkU0dSTy9hVGl2UkpaUCtlaXI2TU9veGk3cFFoWFlqTG4wb2lTcDN2aFRVNmIxUCtma283dkhNVllVMU56dm9FTm1oWjhFV1RwYUFDSzFqb1hCdlV5YlQ2dU9XWmJsQVFBOWl4eVVxeHVlSHNBdktLU3AxL2ozTVZYSU0xMEg3bFR3UUVzZnFnNkhaVGpXdFZDNWt4ZWNsNCtzc1YvUnRjSW1aNG5qOGVhUC95Nk9tdGFlVUYvc2tvKzVBU1QxcnY1dGhUeFMvWDF0ZXVad0ZSV0pEeVdMck4xSER4QVhPTTRxOE9xZzFTeExsZ3MyMlZZNHp5V3g2K0dqcDJZSm4zbXZ1bU1OaGhWekJoWDJMVnJyWFU1YVJRNUwrQlBwR0pjRGUrNFdYcE0yN3J3cFBtQWZXUVlZQlBVVHJNT2RqY1ZnRnhvWkFHR203Q3I1dUdicUdBa2JUTmkxZHBYVDd5bldyRjVmRVA2Q0lWczk0N3p2SWxiZkZZM3JibDdPS01EeEozczNOMGxNUFc1Q2lHVVFjU0FOeEZOUGVCRVExdUsvblB6YjdQRUJ3N1FrMlYyajYzZlo1SEUvZzJxaVhvYzZwNUZvNVpsMDR4YUVSbE5iWnZXMXhVc2ZRTVNGOXdaVlN6TEhwRWdTNXVwZWRwYm1tUktxaFpTQjNWaVU4eFNrZ3JBZUo0SHhkdUlndkVLU3dzWFNPWGhHM3UrMDNkS2doSmpmcXprV1BCbWZ2OHJuaTI5UkJ0dTZmdDVsbFExcHJ1RnR3ZUF5c2F0elVUOVFRTVh5N0ZRdGs3cVhqV0ltdktSSjJISnd4S1hteXFUNk1Qbm1ESi9JSjVVREFkdzBhcmt6YnFrYWdmamZER1h2WjNxM2FpODNuMjg5ZjJDcU1wTmY0S2FNZUdqV0tEK0lPL1JDRW9wZ2lUb0xPR2s1eGdVMU9GVGV4dFNUZGZHRnFBV1FJalVDQUFFRS92c0VrSEUzY1dKaHlPRmU4ZUtEcE5EcFlqZ1hMalhGckUwcjR2NmZTU1h5clN0MUZNUE1mM2hTcEV5ZFBCZ1VGcXNsdTVOY1FGODhqTGl5eHNXMzVqOFZhZFAvQWhYM0RDVytNYlRYc3lsWGRjVlBpMHV0bVRubVh1QzAySFZjOW1oaUpoaUJKK05pYU5pNVVBZzdQSzBxMzV3QWwvbVZvQktKbzFzV3prdGNzWUNONU1DNWQrQ2p3VytKWkJIVi9hcS91dU1vaW8wa0J5Q08xL1J5b3NHQlEyQk1leUtYR3NSbGQ1em5MZzVNWkp5blVmb3RITmxMbi9VVVJOQ1NvY1JWZW9TUUZldlpDL0lKWTVPa3daL0VyOTduOUxlT1daZUlGbWVjOW9MbGxyUERUQTF6UTVxZWZ4Wm80cVBBeStiblhRZXFLUlczUFRjSy9Zc3B0KzNQbnRVdFNxdlNDeElJTEJvSkc3TzdiU3NOcVVJeGE0ZnJXcEpZN0JJRzlaajZRUE9Bb0hidS92QjlZQWNJWXd5Sy9OcVcwRnhtenM5dnhqeDY3c1FDenQ4SzA3elFiRFNUQWdINlg2OXVORHBLSjNMWUFNajd2ZmwyYVVvdGxwOGhCQXRvd3FCWlBRTmo2MzRNcjlRUnBHaVM2MkhNVHZLcnhpVUYxZ1NZNVZZdnpNYkR3MkFTM1JKZGtVajdrZ3VMYzRyZWxNTWxsMFc1L1VEZ003YzZZMisvNmtGclE5L3AyUUsrZlBILzlkdnBUYkZiZVZVLzFCWjNkaXhmNjBzWVQyVXhGRStBTnlSb3l0SmFPK0dQdGtLdDZYcU92aFc0VFppd2E4QUczMWJoYkdhS1lIR1ZVT0Y1MHg2NkpFOFY5Y1QwblRyNUJhNzJTcTJwK3FTMkNEUU9IeDV6eUhvWmhENWNXZk5Cbm04SlE5UFZ1OEE5dHlYdk5UT2dPeHliekMwR2R2N3MwVlU5TGhmeHRaalNkSERrcXV6cy9KVGg3SW5iT3hiUkZEa3dzV0tpNUprNnhSWTVxdmtWT0dkdU5ESW52L200RnUyUERXQlh4Y2c2TDRUV0UrMXg2azkwR0J4ckpWN3gvVTBVQ1MyY2ZuUzNoNEZkYkhxVmlFTndPRkpHNUEwQy9kNmdkR1d5dXV0bDM3MzBwY3pWcHBwY3MyV1B6YWZRSi91eTZoZ01VZHhYTDRTNmZrRjFhN08rUTg5WGtUNGVYUExlVnRoOGExWVB0SEsvR0IvM2dFU0NIMS9xcWh0K0x2WVZjN2RGT3d6TVZxc0R1YkdhNjFFNEJTQXNub2VCRGlWWjloaThNb2E1dTBWdFEzaHQ1VmswYWt3ZjZkSU0vaEZGU3IrWDBaTTdTQSt4NFh2WmNYTnNzekR0S2IvZnRtOHppaXdZMFIvTVRLYk5wTGZ1a1pHdmRRQjhhM2s5eFJTVjV1UlU0dWFKV2NvTU5lNUx6UWVIZVB3bGRNQUVWeXBpOUFKS3M5N2xDNVZyODYyWFZBZFJnazU3SUVFWkZudG81V3VweVAxQ3d4SzVMQzBjcXg2RTNlaVJqbFNBMG1xNGJjVWdQMlIyd3hjcEZDZDMwNHRvbmE1Y3RTcXEycHBZOU9ZaEJSTk4xLzVXZXNIZUw1Y3lrT296U1pnUytRWkEvcEhYOXNaRTZNUnE1ckpYR0YrUUNIOGxxcDNOOWlDME9ZMXBoTzVKZitKenFaM253VGpGWC9JRlpNMTBEQjh4TmpYaEF5dk5aY2tQK1J2RHB6ek1OeCtEVThlOTRIT1FPaGF4SUF3RzN3TVVwZ2NobTdJalJ3SUFBUVQrK3dNRmphMVExTndhNkRLcGcxVDJJR3Q3YnNxd0ZNY3NjQVdxR3hhVmlDZVlLNm55bHFMZDU0MXk4K2xHRE0vejJ4b3FNSmhXTEhYazdIUTB6blhFbzVCWUp0R3I1OEd1dWNhbFViVVFwaFJaaUpLaUlXNjJvaFl6cUhkNDNLNjdsMkJUQmxZcncyNXVHVkxURXQvRG0rT2Z2a1FMbVo3aDZpb1JuQUNMUGNlUi9vQ1hSellrWTBYRXZZVjR0M1JJRFVnMFAyRW9ZbWc5RjFTcDJsdno5V29qc096RkxzaVNGellqZEIvbU5uUG9PWGVicnRUd3BBWUVtZXdUNGJTTnR4dXBzZXVtM2dIVGxnZWRmUlcxQUFkSDhmanJMd2Z3dXhzSXRFeXM5b1ZNUXJrQytLWkpPZWFoWS96NlczdHBudkp3dnpJMkxPK3BISzVhWFJUR09CVTdzMXd2MkVnUFl3U1FaZlBrTTY5L0lPdnpLQ3dKc0I3OXI5OHF5NkhRV3VQbkpDa1BYTTFTNHJpbXkzOHdNTnpNSklESnpZaTFkdm5NSitNb05HS2Q5RjdMM25zZGhvYzhxTzByOHZlVjZ2NUFOWmhadmMvazFxNlVJcEtwUi9hTmUyY3VvK0FnK1N2KzBOYlkxMm41ZHFTNERycER0bHcxL1I3UnVOU00xemZZa2J2d3JNMnozMEhFSEFhOWZGeUloM2NZS1phVThSZGZoQy9uamxMSEU4bDBRQ21WK3M0aTRLektQSjZDNWJxZStVNFVyN0hYVGhiRzkreXBabkdCYURyeWJQbmVSbDZEZzJxWGltTWhPK3ZxWHMwcGlOTDNjanovbHI0Nys0WFUwSjVOM2drVlpUbnZsS0h6aFdRVWtZc2VWSnZXMThyRWlqNmNGL0NkWFJkOEIxcmlib2RnSlo1eVdCRkxua1ZsMUpyNjNvQnlGaFA5QmhRQUk5T2c0TW9vVUZ2U3VEeTh6ZTg2QjhxVDlnZ3psejFxeUI2K0RsVUlnQnRXVDlCYlFmSGk1akJHNEc2dVdjT0FtNmdRM1ZuWm94aEl5Ymp5MkdYWDh4SjQ5MjJBOUkzSTUvWHI3eFJ6QnNKeWdaQ1NWZHFRcjFFSzg2N3ExSUU0NFBLWHhZY29YNENldDJKOXh0QzBYeTdIZGVES0RCV05TbGx2M1p0eEg0Uzc0dXJRdmNEejhhWHRCa0ZyWCtTdjAyZ0taL1h5a1poSkZSUkIvVUNqT0tXVXQ2V2Z6ejZjZWljZ2ZaMm91RktHMTIzdk9LZjhMNXJERDhrcktIZm1ycmZxSTZmZU14RFJETzhlQm5KR0lNb25GWTRya25ta2NnR2NJMzk3T2hqdUQrWWliaEZieldjWk9PamtCZDhHR3Y1OUZ5enN2bGxUblBFODVLU3o0TnZkQ0MwZ3JPN2s0WUFUWDhqK25ZaXA1LzdWaEVFNjRBUlR0OUdRVTRaS05EMGJqL2ZCQ1hibDFaV3R6VlZlRHdJblBFOGZNOEh5akNWZmx6NTU1VVNERzR2Qi9CR0JkRTdPZThBTk56WVlDYjJudXpMOTBDZWpRbVRjMVVEZVdlc3g0VXJGTEt2SmNMb0lYTE1pSmVMamNFRnBaZWtGbWV5YkxrQzZidW41MFA5MTkrSll5ZUVBbXcyc2xSRnlHQXVsOXZGR3R0c3ZoMytHRmNYNVo1cVdNRWxCbzV2YzBLNEV2N0g3dFJKMldFVEtTZEtRMlRHWjFtbGxmcGZGOVFYM2RRZTdFcVU3RnRRZzlpNm5VOW5XRHR4cDNYcEtrTW51VytEUlVKcHJFQUpDQWdBQkJQNzdBRGp0QTcwT3ZoczZqbG5oc2NEYXhQMm1OcExxZkhCTlFONFo1NU5WZWowdkc3SnArRFRvWisyQlQrYTd1Z09aVXlWTEY4cEVhUTN3SmtJYndYSHdsMjhIMDJPVUt6V0RXQVluMFo0bnFma2VpQng1RDRpZ21pTlVySkQxeW55a1AxQjhCWjhSR2xiNEFOUjk0ZDBYQ0FaL3hBRENkdmlhQTBVYUJQcTJibHE5aUJURlVpekFYN3BxalhUeTcxUGl2Qy9iNUlMSk9XLzZVc3RsM2dXWDhSMFpaZDZFRkw0WHVzNlgwTkdIVU5mVjF0ZzZ0VUlQMEJvMVdIUGQ4UFhLNFB4M0VPcVplbjRQT2ZLUVBNeW1sQjRJUmhqcERab1hNZTY0b2o2ZStKZFQvTW1HMC9YeXZtNmhRRlhCVHpLakJoa1lLbkQ0enBtMFpSazAvZXBaNmtPUnhINitLZk9sSmhPeE9KNGVSL0NyZUNYZ2Q3Q0hCUzdyTSt3ajNnNWRKVUZDblRSUkdjajV0TmVJV2EyQWpBaitLYzlMV3k2UUY3WWNJOHRORmMrRURNcEJMckhyVzhUOEVWNzczOHBIMVpaclUwRVJnaGRQd0xhV0lwSDgzTzJCVisrUVdneHJKVklHSlRWR3RKTW50Y0hIUklTb2s0V29GdXk0TnlqQzE1YmpERFZIcytSZDdGTXZMMG4wcjRWV2dDQ2Raak12THlIRVJVUnVTZmZQVmtweDIrdDhKdzFMNjNJblBoNjljeFJtditkdEJIaU1IRFZJL3M1Wlcycm9LUzlvVnFzQ1NRMDdwcE94Vy93S0dWWmJ2R1VyamtEWkd6SVVPYmxNaE9hVWJnSTMxUmFDdWZBSFRmYzdBOFJTSFRHdFY1ZUJreFRuRVJCOTFKVFNBN1preThhQ3NHcENQTlZNaHBaU2xXbHpwQ0ZsclYzdkZKckU0ZUwvTjdpZTdiMDE0TGRJZHY4YmxyekJKeTFicE00czl1alh5Sk5ocEVRd2pvRUVYRElWaEt3ZTZYendBK3hhR3YzNC9IM1QxTzdZVFdpVGRKTHNZcC9Kd3k5SlBDNmFxWEhkQjNLNUNmczlOMmhvYXdJMmQzSHdHTVVDZmVDVytaSTdtdWUwSzhWSTVkWE0yZFNYbE1HVE41L0ZvVkNETHgweGFWWGl5T2tYY3FKTUhtOGIvMGlxK2hwU1cwYnA5WndicmpoQWVWeGd0eDhJbys3SEdhc3RTR2xvemRxWkRFeWlNRUVKejcyWEk1Vld4UkluZnNGNVlEUXEwOG1Ma0p0b0pETC9NNHdHYU0vM1ZObEQrQVZsaUZxZUYyNCt6Y3FxTWY2cG9YdVpGOWg5OWE1dERndDFWdjdwT29HR2JKUDJBZXAybUUxWk5EelFRSG1UQkNXZ0NGMEFFUXpEVVhPL0xQSzR4dWJudFRka0ZoRGErU1RDTU1QdnBNSFA1a0w4dzROVEpISlhPdHlZSHBlajYvOTFPaStKQzNhRFQyNzkramtLdzBodm8veDFZNmhjTGREbExoaCs0Ty92V2FycmlwZVgvekJKNUZ3YXRhWkZWazJZUklYU1JyZC9rOEJOZGxibXEyT3ozbnM0cy9sa2FQWmFLWVEyTVFtY2tYOEkxMm5ubndaODV5eDUyL3lOaVJ4eFNZUXJLVEZYbjBIbi9ReWFsM3NrWDFjQ0hxdkZHWTRhejZabFlESWdzb3FjVmIwNVdmN1RQVWw2K3VEN2tyNXpRMnJBd1JPSGpnNytTNmVNWHVJVU83NExYVng5NTNzM01mTEl2c0pPQWVleWV1QUNBQUVFL3ZzQ05hYmF0Vk5QR1E2WnFCaFRPTGtjRDJEQ2FpMWZxYmVESVZ1K3FqTU00MWVoeUw4RUpSOE1DYThKTGw1V3F1WVljR0pTRmdOR1hxYU80SkkzM0FvQzlXcE1HN29SclBQekRZT2NuUzh5Nys3cEkrdVl6NUlCaVE1VEs0RUxYK2lyZEsvWTBHNE42ZnE4ck1hVHN5dmdHWWdOUG1Qek51VCtzaklaMGVHYW1zUVRvMXkzMVJRNGw5L2NvMUFKY01uNzNKUm5wMEs0UjB2YWFYQkl1MWxDZ1ZZblBUNWpjbnFGaU52Um5wdW1POHpNNXBCNWRuS25zWnJkTWxYUVRpV0lwZ3RzSlFHaC9sWERYVGZ2d1BMUXorYW1NREVjZzBRbG9WVWxaT0xqVm9wK013TWxHT0E2eGwwU1lsY2VUMWZvdFdyYzlHQUZZeVIwMG5TdGdpZG8wUC9ycFlJbkxrdk1LTjBid3pUQ0Fma0lQYUhoa01pVkZ2bmw0amVnenJwQXRmNXJWQlZBakorUU1DQ2FLT1JKN2JKTy8yWlJDajF3WG01bGdSM2IyU0VKSTRGQUlLVEFaN1ZOcHRUeWErVlJRTlpUNmpIUjZiaHlYRzJuTU9wMHpjTXhlRGRxQXRBdFNSV0NIUzJQaFczTEhGS1d2dUFKWEpQbit5RkpXODdMaG9TMzQzZWFFeUwyUll1bHB4Rys1TnNTdVh1Y252c1NNbXNjbnlGdUJnN1VESmQyUkRocVpFUWZ4YXBOdFl5KzEyS1ZzYnNNVncyNGtWTDVSVG9BaTJQRGFObDkyNUVwdWE5VkEyUER4b014Yk9yMTVtdFU1aGhjYjBGQ0VjZ0p5bitQeGlOTVNDUjQ5OVExRkZMc1p2R3FvUGlGZnY4dEZiVnBFSkhWa3FJSHJmdmRhSnAxKzBCRXVQWW14M0NvWS9Oa0V5ZktySjJDa2x1ejNvNEd2VXF1RlpQVWYzY1hrRnk0K3p0Y3hHTTZJZlVXYk03YVkrUmYzWjM4TzNSV2RrSXZBZTNvYTNmdFU5Z0hKYXNmZXA4YlpNaXJJOG1tYjN2djJBanQ4L3ZIWHAyMkZrbzlPUWFZRWptVjlFcitCMHF4NldEb1lzRDNnTk5OZHV0UTBOdUdsOGdpSGhaa2ZidFQxdHFUY3Nhbld0NXVGTy9ScmNZQTVXb01hQnd1QVNKZDEvVHVRcTNBS204VXpTTHlJSVNnNkVJNi9EWnJRZjROYWZHZEVYN2R4L2ZpWjhHbFhobUU3YmE3ekpoZnpTekxwSFo2dVBNSlN5NHJHZXRtdkl5SXpHRjRiZEd0cmw3TU1pV3k2RGluT1drRG5nRlY0Ynp1WTlkeTZJeVZrdlMzNm5YQ29FWHRnTEpVMWlpbXRtRmtWRXdDOE82K28rcFdIUU0yaEJqMjg5UU54WFhhaG1qWGhsRlRYTFVsaC9KV2Nnc3ZTZ0dqQXpkQmVQT2Y5ZWtiYTJzcnBKSFRzUXkzSU5UM0tnVm9qb0ZEUTEveUxZRVZ1alIvVHREVG4wYTFKeGc3OUl6MXFnN3dTK3ZWZkRzWGpIQXQwV1FCR2srQzljQ3lZTkR6RHZMZkVaTXVWYVVPZmRLRTBINkxLdnBEcE9vU1ZuWm1KYy9ncWp2YkVHak52ZHBwcmxzOTBFZlJWcWR3QjhYTE9yRGdSQ3dTeVpaOU5SQXVUM1JRMldubUhOR0hySHhObHFoRno4UzhiWkEzOHlnMEdNeldVL1QzQTUzQTAvVVk3Skg5c2haaldaZHJzKzNCamUwQnp4WktwRWNhbVF6SXV6azVNR1JTOUFJQUFRVCsrd0RIL2ZacFZjWlExbTIxVXRFdnNiVFpFMHQ5T0o1ZXJWWmlIZU9OaEx6OTR4VFNFMS80MEJLRzkxdEFTTHNBL3VNMkdpRjM5VGJVY3NST0hBYmdoVi9zWno0azdzdlZSZnc2RUwxTjgvZ1JxQWRKRFl0RkRaM3Y3ZDBNY2wxMGJZK0srUjVBbDBzbkhEdkhkNDNVSW8rSGZIQkg0Y25zOU9UK2JNYzF1OVpsdWMrVjNXczZrMGE5QktTWExpOWQyQWU0aUp6Z0xZWWpPWk16U1lGNzdaWDc1WE5uRDVxcXVsaWpDbnlRdERpSEdnL2E4R3pSWWR1c0NuaEtBbTBVWkJOT1VSakwrRWNEd2ExTzBBT215K2pPci9vQVIraU1HODNxS1ZoWWRkK0wvUlpTVHlYR0lsOE9ISXZhcEJzMXV3WFRPVnJOS1NXT0VRdWljQUZ4Z29kdkZXRFFlNVlZSVdWM0F5ME5jNWpQUzVQOXZBUVpuUFJjN2R6SEUxempnNy93N0VSTmdGR00rendlS2l6NFFTSk1QUzJGL1FYdWJKTGRWaEpDS3BhclFSei9manlVNWJudVNKL3RXckVONVgyc2VjUFNQR1ZvUXY5dXUrdlNyTlFtNmg1cVE5aW5PSmN3VHZKS0lIMGthUnhPRzZYVGtPS1VQTXlJMVhwbGIyRFRvQlhjbkJ5WTVWT2RVdjNuY0JqbEozODcrYUFWMUttd1IxQ0tjNGdLVVBCTkhoVTRqTWhkTktjSnhiRlV4bFdMbkpjMHdVeExjek9EYzc4eDBONCszOUVEZlJnSjR3Nm15WTF2ZDVNRm93VkpBNC9QMFBNR3o0R2FiWjJJVEhHTjlldlhGU0NJWHdjUEQ1Y1hlWEdqTkh1aGZVUkUxWnZmS24wSktnZm1MN3drSTBEWTRid3VET3pTSjFxRlBXVHdBYjZ5MXNWbnkvdkRrMzdFSkpGY3hGT2FvZnlmQ1JzRHFtMmMzdkwxMkppYUVPNW5xc3FmUzhqSDdZK1VkcUhBSGE3dllEQVhvSmZkajBiaVFuRDd3eWZUOWdQaS9YSmZiektvaDRsckRvQ21RQzBBL0xYUGltQWl5TUEvMnhRcWpUaS8vN2g1Q1BVMDFUaDEvejlqNHdGMDFJZG4xNXlNeFAyVEJMYUFzVXF5TEd6a0tEeE15UmNyTStQallidW50Sjgyb2Zvdnk2VFJJQ1lkUXl0SGVQTDQ5eU5aOHRwT3JFTnM5d1FsQlQwMnVtY3hjNGJQTTJjeXpwZndSQWRqRHp4YXc3dU9VSU5QZnl5SnhQM1lwRm52bEl0Q0x1dWlkWm1SNTZTcGxubHlVK3ZMdEk1M1c5dUNITnpINnJLYmVZTEt1Z1gxbGd4aWJ1T0lxWkgyZmQydjVIY2hIbmpsdHFQKzB4K3BJV3piRzRRRFRhMG9wcm9NT1JYRW1qeUM0ZHlpbzhYN3JBYkhjOEFSTWEwUmkyNkI3UkZDalg4b3VkWkFhTnJLUElGdHhMS1N6ZFNqMHJuUnQrRGpOM2oyOU5KTlNESHdLanlzRHg3MVNRa0pnOVRVWDNwTXdsakI2bXlEQnlVSnhpVlFLRFdycFIwcDlSVXZvOU5kNjBrVkd2Y2E4RUdMYTJDZ2xDbzFRNU5BM084Rkp2WmFKVWlCS0RPVnZzRXY5T3Yxb0o1bzJ6cWZsZFZHNktaYXRpblBHeGRUQkxGcHpkVkpOMHNuY01MUnJhZUMrOThoUDdNRHAwc0wrR1dlTUYxM1FZaUIrZ3YxU2tvS1pPWEE5VmhnaVBUV1lPQjZVekN1RDZNWWgwUElBZ0FCQlA3N0FJK3l5dzgzSHZXUmZqNGhmL1dRSXVlNEtDSVVKVEp0RUtnQXNVNW11RGNWV1habm1WVUVNdTdwTjlYSSt2WmRKTXlSclJMZGNHM05yaWdQQmdGSFc3dUxyZUdtanZzTGZSQk1WQVhyQ2IxWjVjc1M4YVg4WENtdy9Cc0phcVFEQkJvZmg5d1pPQmswUXhaaVpwbEdSV014Kzc3OTAvcndiNVRqc0p2MFE4bTFZS2RMaEtRUUJRcmZhVDgvV0l4QXZEUVlOZCtpcEVUaWtWZWVpNTc1WE4rRDBlWnF0MFFqZXBxNm5Xa1FHSDg4RUZmOWMrSXY0R3B2NzhJaDBHcktvSTNqSUJwSWRJM09laDJrRHB6T3ErbHJ0SjlpYy9VQUFUdEo3RytGUnVOaVVPRnZVeUtvSEhqSDNFQVc1RjNhc1VDN2lVWXc2QndmdWUzUWVnZkdJNFFUdUVJTVFDcHA4SU14WWhSdmRlN0dNSDJaWldYWDdMTCtibjUrcmdxZlo1SEwvd21hcFFvRk1zSFNXaDVkT0o2N2lIK2hrSlBwa3h6eGVNVnN1RjRZOXQwSkJ0ck9XcTc1cVRISk1LQXpCazRYYkRoV2U0dTVKcXhpQmhId1kwVjN6bVhucmxBUis2c1RPVzY4L2picmFJZld5VTN2citPUTF1SllVdHdtR1BwcjZKS3E4TDgwUmdWM0dEZjVIaVVWRUZlTjNFVkdyaFE1eU1oWlg3YnRJTURJSUI5SFJjYkpxUWgwRWxtaUgvcnh3TXdBSFZybXdBbURnYmFGbVFZc3BFMlkyZENtUXRlUEVQYWRwK3o0ejlCTG1ZeGczZ1pydmx6M09vMG1WS2lROEFYZkJ3V3R2MFFPdXJGeGh6N0NUNmxIUzZyaS9CTW9YYmhkT1pVbTBaMlZobEt2bklkSWRiMkVTbU5qQ05CR2VKbVhoYlM2bzFVWmlNTDh3UkhUMm5kTEV1cWwvNkFreVBDMjM3WURDZmtEKzZxYWN1cVZjZE9FQk9kcHp3ekc4eFQwM0VQdnlpdThycGd6dXpvWEFHcHByVE11OEhJT0M5bWpXdDdyM1owQkdyajhQaXBVYndNMUw2QmN5YzlDTWY4Q1RZUDdrVTFQRFJuL1daeWJQZFhRM1FQVDNBc0RkcHpBV1kyQ1NrUGdEV2xibHVha1dhWlFtOXl5NXpHVWN2NVp0ZXo1ODFJam9VVENSNXJGYmcwNE8rbjk4Z1ZuL3VhWC92SkkwY0kwUmJlWmVHM1FqRVoxQ2c3Z2FSNFJjVDhUSFl1ejZoV0VDOXh4QnJzT0xuRk1qZEJwaUVTL3gxTTVYRUhIdFY1a3pDT3dBWVp3a2dSMW1LOFh1aWNwdllaZmxFdFFSa0tCTTljVVJjOVFJSDFxWWUvelZRcERvUVY3MFZwcUZCQlJENlhkZDZDZW4rWlBJRmtWUkx6eVZoaGgrK2sweDNPWFRpb3pnVWdjM1U4cU80TkJlOWptVTFTVEtUY0JHZ3E0RUpTc2p5bDd3QWJxdWdVdXdQK2ZwdVZWbUN0dFVnZy95alduN3BQVlN4ZEErNUVON0tGazNrSElwS0FlYzFuQktVSVdOazRDRVpNNEZpVWVCQ29YVzlUa3FoWkkxWG5xdUw0Lzc0dTZ5d0dkMmRrWnNQUHkyNmJkMElFQUFFVUVQYWRTZnNjbTVUWFBuZXlGU2hBWmJMeWY0aklBY1IwYnFISHNQOHhNenBqWnNIRTVhQ1RCS05MQlpvSDJ5OG9XZk1PZXlhWitXMkZxQXRDdjdab1h0ZnFWQlRIK0tEUlhpU0JLNUhRQ0FBRUUvdnNCakxmT2VWOHZSckpLQWRJY1BpS3d4c1I4TmQ2Y0hvbmpMUUludVNsZEM4cTd4ZGY5MFNISjBBWTR6YW1ROWI5Zm94aUFhODBydlJzckk2YXh1R3krb05GNDg2NEVPaGZqUEZFL2VnaVFQdDRRd2xEa3cveFI3bnR2czNjcjRaZ1BHc25GZFhLQWU3NWp4QkJOMm45YlVtWmJxNlpWUHgwUkxUL1B2NE5PQ3ZRUDVndzNYMXNqZ3FMM3gzRFpDS3dyMFl3OUF5Q0tvRExxdVU3cURqakNSanJKK2dHQlo4RVc5NFY0NXFlcDV0OW8wMTNmaDZpMXdwbUtKL3Y0YmpqK0VnTVRlOWNBOUUvVVVBTXZDZ1pqYWFJVGw5NE1LRjlhOEZWK2VSRDBKUzgwTHpyQ2pMWkpXbHplUWgrVktuQ2NGN0luZ1BYd0Evb1kyV3M1Q2FYS3lNSURQYktZQUhNWGtpVHZpVTRMTURzaGZiVlF4YW9WeEljUWpXV3g5WVc4dklSeCtMVUF5VzcxS1pILzZUTHhFUThScE5FV0kzQk81N2dzSVMzdWlSbU1COUVXOFR3Nk5YdUZRWm9obHMwdGh4YmI4QUVjRjFDRUlCWTNiYUI3L25Mc3lTdTFyWUVBQ2JJOVRFa2xyWVQxcXUvK1gveXZKZGRtYmp6M1NGbzZPRHY0ZU5DT2lQVzNZakFrK0pMRUlFd0FRanJ6U1RneVRzU2VUK1BXWEJTL1VCRUlWdEtSOGFCbHNwRGZPNG9LNXcwNDFJOHQ0YkZ3eGZwMDRUT08rb3ZZNTd0NU1ZeW8rb0wvQlRMTGxDRWxob09FckhzZ2pEMzFWZmZRamJla0J6L1MyT3BrenMyK3VkYlh1NlBqT0lPYnBBaldPcFp0U0FFTGtOSGNkZThLRzIydXZTbkp6VkJCUEFmcFd0cUJsTElDS2Uxc3ozVHg1RmJUSjBlak1GeVZDWUQ5V1U0VDNwTnJkNEVrbElERmk1dDV5eksrTE1ZQUwvYTZySnJXRXBVRDZudGpadU9rS3djbkgrdWFVRlZVb3pFTVppVEJzVlVSUVBHTDlXRldDZDI4eTBRVFBtMDlCWU9nSVMrWTVnRGlLWWNKZklYNFFNZnAvQ0NkY2dZQlUvd1NBKzhqS0xEejJzaElBaVlXTUg5aWRNeU1ZVlNVMkRBeS9hKzBycS95b3NqSkpCQ2IrMUVWdEN3OUlidmhyMk9zNGYzSGRQU2YrOHFkRlBGNVdwUEoxenRaYW1LNS9LWmhGRVhDNi9kM0hJYUtQN0RpdUNzNWI1bUppTUVWYTBzR3J0TmhTZW8xNmVPQ0xrVkFGc05kSDA1aHJNZXRld3pwL3ZHcG1OelFLYmY4b2t6ODV2VEZieUZiNnZuUXZidkxMZi9wWDZWLzdHc3RXTEJkd3cyTDdKWE1LOTJpSkI0NzgrSTkvRlhUdmJUNEdtUStLWkdlT2hMYjkvR25GbEJxWVFvOWxNcUwxT2x4TENDUnMxQmNrd2Q4cGZIeUtNUDkyRmpsMUsrbmIzUnF4SFFpaE15MHlUSEhCZVdaZlg4K1JjRms2czNTV0RRRzhKb3BvdHI2TnVNZlVOWlRnU055MFY1Z1lidFBHemgrcUNPbWk0elU2R0xyQkFldnVWS0RPVVprd0dDcU1HWWtOOWM5VXh5UGJ6bUVqUmR3S3hLcUp4YmsvMENiTDArY2trc01RVGp1UTRITGhPN2NyNk5uRnFCajFWN1F6ZkhGaklkMW1KMFdwdk5scStwbnFlckF3bjY3VE11WGJBa0FFOTJwcFNxT1lud0M2QUlBQVFUKyt3U1lCcVB1UDFuWGZYa3A0a1NxNjZOZXV6NlErdWFaWTJOQUFBSUdJYkl3NjVGbmdmNGNnK3Y0bzFnSEN0cEpxY1RXaFFFRzcyNTJqVS9yTk1wZUU0N0d0R2UwRWFoM0dTYmI0dVpmNkhjRy8zbHdSQ0xmNkVVaks2WGkwdEMyV2o2R0xIeWExelYrQTRBVStKKys1elkxZG5FOTk4T1lFZStmN3RtRU1ZbHh2S1czYk1iL2RpZm1nYjVhYi92bFo2NUhKRjU0VVZ3SmJ0NldVSFFTMkVGRDBTWWVXTnhjQkwwRFVvd1NnMGNxMksyZjh5L0o2ckZCMUNQTnBOdEhnOGNTSlVTemt0aDlESUtPSTFzbkRUbEZnR2xxTitKYzl4NDZ4NlpMS3VaanA1QWNhYmdxTzdkU0Q5dkhsMldtU1FhekJFTWxtQ28rQmFrR1RqSVhLcWdYVzVrRUsxTzgxTlZWcWIrTTlKbjFJQ1pIcVp1VURGaFlObkxEVFNYUU0xSmJFSnpkMkVNTGxlTm45RlhTUy9mMjNSdTVqcTNIM1R3OTNlTEwxaDVQNm9peFdoMGNGZnN0QnA3YkxtR2ZFRkpud0tlcnJpS1A3MVVLYkNwNnU0WUVrWHFvdEh1TnZNR3NzdUhpQkV4M2dScXFmTktReVM3amdqcGFENkx3SC9IeDlITWZyQUZkbHBvV0Z4anhydkJQQlVZTXNaK0loOHY2KzJUYTBRTlRzV2phdEpPdEhoQjhJRDk4Ky91Y2c3SkRNL3dUWExQQ3lSTFJwdHdaSGJ2WUNZR3c2c3hvWFNxZ09kTDc0TkNTem1WSXJzSWhvQ0hWWEN6K2Z5L1dldWUzaEN4MWxNb3B2TmMzOS92Y0QvUlREalBYR25uYVBNLzNHNFJGWTVGWDNpQ25GRUJLMUYzL0p0MVhTNmxHdGRtTkRkN0x5Rmt2akxxc3ZiWUtUelB5VFFTcERQM0o3VTdtMlFsUDJyTnZQd1locmtkYlFyTmFibUUyTlU0MXhyOXc5b25SelFJY2NQSS9ST0EyY3ZwYkFESGxTNzJvbTN4L0pEcFNSeVUyK0pEdC8zSUFucEhLbzFxckJuRUYyY29zWHQ4cTBILzNTLzFtb0plYmtjOGdIc0lpR0twT2dVQ25CaXhVeWF4SVlNc2UvdVo5NUpseVhQMXJJaHFrSWhDOFZodldXMUh4RUc3TkNIZ1NJaEd5eUpHRVdKcnV1SmRNWEpyTzl2Nko0KzNKVTNyMVFvRnk0bU5zSXlSYXY0Nno4Q3ZNUlBsSCt5eXpTazE1cmtkUFNmdUR5NkpCclIvcFA2emthcTV6Zk5BUFhFUDZmRXJoQ1paRFFybENzQ3RTbDExUHVjSG5GYll5WUpoMVQzZ3phS3ZVZ0xHemYxR2pyd3ZCRmttbExLZ1V2ZHpnaTkwODBjZEp6Wi9ST0xpL01GVklldm95dFVONFZSYjAxekZqV2laMUxvSG1hV25YOHVwUnlINnI1dnVuaEY2Ykx5ckZkMk9xc2pDYUpjZjA3UWZKZkw5TkRVbnhHN1llQWl2WXhvYTJnM2xpS2U1MGxEdXVjUUExNGxZMmJjNGRvM0Qvd2lXMzJOSSt5VFhlZGhkUHlhK3A3YmhkWm9IaytueE5pbSt2VjBnM0dPMVh0cU1oN1VHNlJ0aCt3aVV2S3FZN0MxcVhSUlpKd3dhemhjK0NIYjlrQzBYOTFjc1gwL3E0WitUczNFYnN4N0tIWC9SeXNKZXNRY2RENFVTRXpSby9IdVM2dTBUZC8zblQwWlRmbzlrcUNyNmJlQzMwaW1QOUFnQUJCUDc3QXo2alNaNktPUWw2eHM2ZmRUZHMzcnBaSlVHZGhkOGtaRFRxcTBsMzNNQmM0Ti9ubGFIc1dPT3hpbm1SYVJkdWFTZUpzaWJpWkt3UFNQNTdlWlRyc1d5MXk3YVVoZE56d0tqWXp6SGQzTThnSHg2a2ZwVGZucVZ1VVhRd0l2NFVab0hRK0NrYUZ2d3FtZmZDd3JDZUxrNkVjTEo2eXV5QWxIYmpwS3FlY3F1Nk5YU2VQR1FhMmV4NVdtSU5CaUxOY1FZR1BidE5uSVczMWMvSGpBQkNLeHRRWUlJYnA5am1zaXNZYkxyb2MrdE5zaHpsazlDaGFNenk4Um9vdXpOQVVSL0I3MDFOZC9EVDdpc3F0UHU0UFpGNTRHYnI2ZDBOS3d6eStoTmM0UVptL3pWbkVqZTVYTFkycXl1YjBkV3hVTHZPM0VuRlhrbHFNL0ZQWXA2SVE2Z1dxNHpyWXM2dTN2ZnNtZ016V2lNZ3lmaVJhQTMrWWRLaGJWc0lSVHh6T1VwSW9aYkl1QVRJTHc1RXpLRjJuRVRTZ2VYYjVtR09xdzJiZkU3UHJkMnY0dndzSlZvWkc5bEcwcUlVMUhFdjc3cTFYTTdLc1pUb2NxaklSMFQ0SHkxT3Q3VWJVZldzVjlvdkdWenBjUnlWSWxEVHVaL2JTcGhia3hLSXNpT0RVWnZKSWxodlhKZ1ZRczE5Q2ZMMGhycTFkZ2tCTnJIR0hrK0ZPMTViYjJMekVEclNBSFFONVNOV3hlVk1EbTNkNTloeTM3ckU2cjhIVVdyTHZ3b0Z4NnEvc081amt3NlRVMlRiWjFSbWp2RENXeS8weUNWSGdrZXpqSU5LbGRYRFZKTzdDa3NyTlY5WHBBYjQvclFqLzcxOUNCN05pcjhUdHhPUVF3UnArd01WaEh0QndBaW9tRlI1N0NsY3Q0ZmxmZUs3Wis4RVhUS0szQzVveWxwOUhONElIKy92bkpybWNOc0g2V2RxYkxrcFVtbjJJamtlVmVDYzV3RXRIQVZLMWxRczZQVFhzZG9CVCtoRGJqWUYybUp0WmNrL2UzUkp4N2V4RFVwdzhxRWVxK2hvaTE1czU4VHFQSy9pSGwzQkhlTWZNWTZCbmo5UG5Qa2NFQXpudXU4b2RTYkVydlpoUlJBT0FxTFBEZ25MeFdERjJXYjBMdEQ2aEJRelYraG1ucStpa1pCOEtSNHo0SDhNOUkrMkI4bDcyL1hDVm5Ma3JiWkZLdzlObFlhMVcxUUFLSko1VEc5NEJId1E4SkVpQWpoTXFmMDRHaGtLU245SVh1VnEwNVJGVmVZN0k3blRzTVNSZ0NSSVc2eUJPcC81VGZwL0trQnVuYUJIOGpTUEd5NTVnVUJxVHpZbGtVdjR0ekl2a28wMUVyeExsMmJUclNxU2Q0KzNLR3NjN09zc0RlMUhUL053eXplSHRWQWprUnFwOUYzeHRjTGFnemR4OVBkWDFpeUVFeWVrMFVwdnE3VkVnMExUU3lLSGo1YmM4Zzc2dXlWQ0Y2VTFkSEgrMVFyZFRTVCtrY213MXNzTzdENWxVdzlyWE84WHF1eFdHZ2dZVDM2U3dCak4zeFE1cVRyV3lJWE5jWUxQeFlnVmpFZjR1eGxLaGNMQll3Tjg2NXFRcTRIMjlZL2wrTkVsY3hOV3VBM3pDdjlkSTVpNzBlNUEyaXZFR01hVHVtRTkrT0lGNE1yYzkrcUJmVmFtbUpQclF2MnRHVUxHcUJ3MWRLcEdCT29MVHhLeGNPOVVESkMxTnNqTEJUU2xQQVcvR3ppcW9JUVdSTFFCM1gweUhGSHZJRGNDQUFFRS92c0RaWnhOb1Q4OUIvM3lXSUFyTkFyV2VSNmlkbnd6bUZKU0lRUmlZWkl2UUJxVlc5d1RRVkVaemtlZDZVL0drMGhOeTcxZWpMQ0lNMHJSelBuL1RZYlU0ZW9PL0VuQVFQK29JK3BlK2I4TTF4eXFFNDh2T3UrSWYyY1lncUZ5TURtVk52R0V4MDNoRzZwWXdqN3ZDcWFkSkNDb1B4akUwdm01ZGswU3RSWE45di9jRU1Ec0Rpd2dybjdSNUtKeVpOcHN1UVU0MTF0NUlsZXdIWC9XeWt6V1IzM3ZNK1FlM0Y5ak5sYjg2VkYxMTVlZ2haZ21xNlFUNkZ1eHlEN0JCWi9EYmp4czkzbUNKekVJSnJiNEE3VW1nWlJQYnNKa1BxeUJOUWYvdjdnMmNhTXFwOU1Qams4UUFJaWRCZXBVRVFSb0hhTW91Sk1VcGJQdnBIS3o4NldHQnZnS3RIZGFPVFA1Y3c5OW9MMlQxdE9PQ2I4eTY4Y2c5OE91WEdBWEh5M1dsZU5rcWxHUWxpUmZsWTI2ajhmc1VSb0UwNnJIR0srY2NzNVZGUXA5dkp2bEF1MXJtUnozL280aEJCR002Z3RBRXpHc05SZHhyYm5GWklNdG1icWhzMnNCZzR1bURoTGhaRG1pak1GUDRyTzVTRTZpU0ZzYStxVHY3SjhNdDRoMmlFU3NiZWIvQ3BDYkZKbTVUQTNPVWZSL0V1M3UrM1lpbEJMYkpodFZPalJHQXJNS0c2OVFnS3BHQ1habWc1MEpMSkxiTStOaUN6blBaZmQyZHRGc3JKMFoyaUZBRERlRmw2TGJ2S2ZyR3NWRFZRWUlpU01VazNkU0NRTEhIQnBoWGp2UUNQZmh1WXYxRUgxa0FIUTY4SnlPZDRzR2lKRVFDaXYzVG5ZV016YVphRjVRbHdDSzZ3MFoxd0VWL0M5MzJaQUFSYjlTNWZxV0lzUjNIbkxXVUE4M0k2TElHSjBPQ1lFai83OUVnMURaSjFpUVRwRmxETXEzMDlZdk1ZMXM2NThqS0VMNThaaDV1WnhxSE96NkF2ZmZlTjRzWXFCR2xFSkpLcGV4cEEvV2g1aExqeDFuVCthRHJGUVY1MWNUc1ROUU1LZWpwdXkvd04vMnhOUkx1WVZtMFVFQ0RZSUVCcFVRaFRRMUkwcHl6TVlPcXhBNjA4U2lyZVIxZ0g3TXdhOHRBUXhQKy9CcXljMC9URGN4bW1mTTR6OUE3QTVCSWsya05CSW8rN29VK0orY0lLRDlJWXpGeThDUHM3SUVNZGlpOTJYd0VSSFdaZGUzS2FNWVBIUzFrd0taT3VBS2h6Vi9hbS9HSkFob01zL3ZiYThiNkJBU0VhWTZlcVgvZ29oeC9mdGppUzFTbStRajVkQzN5WFV2SFNSSldYWVlKMTREbktSeFBGb1p0eU4zazRQeVRRejBpazVheHdmSjlGSkg3Tk9hRVJyM1FkU3o0QWswdWtJWnRLeXJhMlI5VmMyd3Mva29SdlZBSnpoTnFjek40M09iUi9XZmZkSHJoNGtkTTlCR3U1NXhXUFdSbUs4M1dvdVVHUmhiRis4QitMdXNHZHpSa3EwODEzVVVBSkFEZ0JEWkZTd0xiem9WK2ViQk5rc1ZMN294b0ZJdzFKaVpXVnVzOWJjM1RxMTJ2YWEwTy9weWx4dlM1MUE3VitIejN6SU5FZ2pKekJKY210M0RVQStjREJiYjhpRmtYMFNzWEVOTUZCV3YxSzRxaDdlWkc1YW5VclhGRjVIaTgwKzA0emc2Q3VOVnRIUFp2Smc3b0p2ZFlYN2hORFdOZUtPUTdBSUFBUVQrK3dRSDVwRU93eDZXd0pzZno1R0VYaWJVREZ1a3YxN1grR0RSbE9RU0piOEJENnNmbUhIRXYyUjRiNHZ2czdGRndJQ2kzVWxZUTVkUHlDZUEwR0ZmWFE4SE51WWNodEswemxoQlc4NjBhQXdKU212bm5vQ0tvQ0UzUVhMQ0RKZ0FHYmFLUmc2WkVWc3BIRkxnZy9uMVFUMzdPMHZoTkZIZ1FEdzRNVzM0cTNIRmNQVVBJRHNBekVQbE1SYjkvSktHOGd2dVA0RW8yZTIzaElDZHlhUGo4MEErbkszYjl4eW9hVE1RWUlCQ0hCTG4yWjRvVG9XalRLVUFVWFhVNHVDZ1FWT3IzN2FhRnRScldOWnFacmc1aDFrM3JOejRPRnVLZ1JQRys3Rys4WGxpTFpsK1lQTDJta25wMmhoSVRtOUM5dnFsaG1zVno4bFRuWkxscDlYZXJQd2ZqQzVseTkwS3NBSUljZVZIZm5uUXJQMEp6VDRUNmZ5c1hrRU1GTC9NUkZCSDNaOW5qRmNOdk5pVC80dXhtNWNTOEdoc0RuK3pNNXErWmJRWUU0YXEvNEt0bVhiY2FtNldLZlAvVmlRSDczYVdMeVZvOWIvY1Nsa1VlbGozQ1JjSlpqNWRJTnVKUEdqVzdCUTJmTm5OTnkra0F5Ym11Tmc0ekxwSmpIanZwcWQwbng2cUZVL3JDd0JZaGpiaytlenFCTlJqSHdNUXg0cXZHcVJKTUE2ckNia09rRXdPVTF3SDBSRE9ra01hOTZDSTBtaXNaS0lUL0NyVnFJejk4SlRLK0ZvNENVdWFQcDdyaU53SzV6R1hvUEg4MU56TmduaVhhQkFPSU5ZdmczRlhmWEs5RVRGeHZMWWpESzNLNVVhem0zSVltRjc3NCtsWFdmWDc5cDBOaDlsSmg3RFJ0OXhWY2g4dWdlZ2VDeVE1K24ybEh2VEcySkwzZE1pQm9iUDdJWXN4dmFWNTVIY1k4MXRENXNpQ01ZbUlIQmRYbWcxb1BmbjZac09GdFJCZUJtVzNHQ1dtbmJhWGN4dUt1a3orNnU4aDZ4KytPejh3OGlaMG5xdnQwclI5UzhIa2FJMFdNcE5JRmIxRzUyTWhmMFl4aVBGODRqMGFyUndYaklYNTIxM09UM0hoS1dhaWJzdy9ZcU1NRVlBNStTQ2ZjakcvZEh4WlRNclYxRU1UTk5aRjZsd0FoQm9IK1ZRbTlnRFVzL2l1dHB6bVgyblNDckR4ZEk5RUg3WFBHT0Q0Qkd5bXJOYWVKOWhOQ2h2bUNGT051cHhpK0xRUzcvUFJ2cFZTQnVJTGlPWVlrSVc3R01nS1FtZHRPRUJhblFZaVNJRGlQRWFxVVBBRXJRbTIyd2lkKzhjMGhuNTVtZ2dTcTNEZnM0OE03eEZlUEVOdDl6RDlMQ3o5TndBOVlOcDBZNlp0Ym9ZNnJib1lCZCs2RXpJMm11MnBYNU9jUUtuZ2NWNXlCUGs5dTJiSkhLSUdIYnFzT2ZMOU5oS0hBcEVlWXVjQVM2dUQ1b003WkJjdGRFUkF3RWo3QitGcHdWL2lqZDhpbTcvUnltT28yWGg1cEowbkxJZURRRXpKaWwrblZJWXp4b2YzRkwvMC9OUkZmNmdmbllzREg5RjJRSjNQbjhtbnFFT3J5eXZMRjRuQlo0VVRFVE53VG4xaFJNbk41WTFPRWFLaHhDRVlCOVN5TFc5cWFLMHJadG53Sk43Rlp5aTF5aVRVQkkwUGJqTTVmZjZpV0RkV0I1d0xsVDliOEo1UDdwdEEydEEyTWZvaDJkRUFqT3lqdGpjTlBxN29hNzZNQWdBQkJQNzdBVjlxZ25Yc01FTVcxMmx3T0V4aUE4UlN5b1ZSdzZ2NnIzQWl1UG1iQlJnWXBYZm84VmUrK0U0TkdEdGFaeWpodjQxZlc0QjdKdndaOG1lSHNPY29zdUF0azRkQlg1bSt3VUgyTkdOVDVGVEVmQXhkeDVsa2ZPcjduamMyS3FlZkpnUis5aURjb0ozT0E4Vm80QitseFRRbk0zNEtGVFJ4THhxZXVZOTRMbDcvNnVVSW5jVDJEZS9veWRyVjB3WERzU3JxUkV4ZE1hcmEwTG8yL2RNZ3Q2ZSthZTZjcDRrWVpRQmpCaVptVGpIT0o3ZE9xVllEOXNCMXJQQlczVFY0QjFPTlZ5ZXpRcE4ySVJnVHcvenpiY1R4OCs2SXNHaUh3cWgwTjQwendQL1k5NlcrZEtoa3NCcXgvV3VWZ1FvVUdYYXFOTXlxWk4yOGY4UWdnT25KeUxUem1PZ2V5WFc3VDVYMFRJajVielF0RWdtKzQ4Tzg4NGZXYldRMnk1dXhJeHZtdVduUXhRRGNTVkx5WGpZNlpvc0RUNmVwZFJTUVFpU21iVFY2dHA1SkJYSzZKRVpqZjFvUUlrcncwQ2hySXFWcVhGa0xCcHBYM0p5L2ZYbkUxTkhLbzdmUTFhUGVmUE9yMFBtTEVORWpCSUFtb1M5Q1RyaVc1bEd6dVhwaFB6RW11aUtxYy9JcFUwd2JldDhFZ1dSMkVCMWxCU081bmNjYlVhV0xpb204eFJYVi9Mbm52TEdkOUJBVkxRSEE2bStNWmtmRkk4MVQ3MytVWHVPQVlzaEJkWGhJeTJkZlo5TkNDQm11dFZFcVJuMTk1YlV4ejZ0aXNrSmVlaDR2QmZXZmhKU003b1pFeVJYMHBVTzJtRFNYSVJPNkt3bWxabTFiQi84b1R6bDIzbmc2TDRickZPU1BrWG9JY2RFZmg1aHU3NkxIeWpNT1ZuaVBCcE5KUXJUS3YxdzRpYTJQLy9MNDhCcGs2Z3VQMENtcldvOHUzR0J5RDR2NDdpaWhKQ01jZU96eFZiZ1dtd2FjbkRtbVI0QkxIVU8vSHQvWElscVc2eklTS2d0RHFOdS9YZWkwVDJKMXAvZURTbkpYZlRZZzZZcVc4c1BWRUd0RXdUZFYzTmVqNU5hQXpGRmx3NnB4b25CYUx6SndRY2FhZC9GUFhNeG04R01EM0tEV3kzcWlBQ21wQW5XaWRERG5YR05vVDdwWHRja3JzekVWRGpMR09iSUVEdHp5K0xqS3JpUnp3cDQxeE54bFc4SW10RU1jSlVVNC9mU3BmMzBkNUdiaVozTU41TlVSN2k5N1JSM3E4MDhEM2IycWxnaG9hR0t4eXdhTDJQcWRHUHlGc3hneVRrZEtKbFBja3BQb252a2IwQVEvblk5aUJleVJHMjdYOTI3WksrZ3BFSFVabHcwdUJ1bmJvei8vZldvNnNPd3N0SVltN2Z2aFlmQWNrcEJkbHAxWWpPUytNTGpQTlMrL3FwOEJRNGExN0hVUjNoRERTbjNqOEhadWhCb042MTROMWttbmEzRWNGSk5JaThoejkxckp2ZzVTQmRhc2NvN3lnS1UxdGRJQ2pleFRkQUw0citQNVN1b2ZuYUJaSDB5eUU2d21ycHZtbEg0cVlXMnpsY1MydzhQd0dLdHEyOHZUM3U2VlpGeUN4QzJ1V3lack1lOGpIVWxNLy9FSXg5Kzh0bVFRMHVTSHNYNXVRVUZhSm5tWXdUYWxIVGVUWThiUlFaK3p5clVLd1J4ZU1qcG1HYXBkVmFxb3FqcjdLdDllcTc5VHI5Q0l5TFZrR2dwd3M3MENBQUVFL3ZzRExtRWk0QVM3QS9qT0V2cTV2cm9ZaUtJUDRtbDJQWWN6b0dKSjd4bUgzVDF1OTd6ZVpnM1ExTW1qMUJvM3ZQRm10VHN6ZVRoTTdmR0VXZURZMCtJQ09qSUs4b0plRmdRa055WW5JUmVodTBUcFJiMGUySUZWMVB5b1NPMGZoSHdjOXNnTXlVU01pbDUraHpHNEJFamMreDdFaFViUjFpZnNYelFGY01nTGNJME9LbmxtTWJra0hwOTcwYmV0RjVEN21odWpRZTVNT29xV2xobUxaR2JiTUN0Zk0zdmI3VHdEKzFRc1l1OFZManN0em9Qc2pqc2VtNXdMcW5ET2tnRVkwdkJWUHpXUzQzOEY0akZyK1hxR2FrR3djNnNFRjIxRDI0QjR2ZFZCaDl2MFlsNEJ4U1k3QTg5eHpqSkVxWUcxTEwrcWFGMWs2QWVOLzBFTGJ6bGYwQitsQWZJM2xUK2NDSDY1ZEFwMkc3OVM5SXU3OEFiSVQ4UEo0c1NoNUk1aEdnWml0YS9SWGQxWWszSHNVYXRpYmpVRHVsQWVoQklOQUV0c1hRamVqYTJtUllrdGlZQlR2c3FLaGUrc0ZYcGJ4a2F4dE10clhHZGdlSDhHQ1NQYUNtVjdlY3NwRGN1VUZiUDlyUkFiQkRpSGxOMmJLWlYwWmI3ZTNFcWx1ZUlHQmExYi9CRjE1eDRsQTFRaWVjdk04SmNhY2FSa1hnTGlDcEJkckdIdEFvdjhieDE5UlBMMWNLdzB4OEpGaUlJSi9waURHbzhnT3NXU01lbHpwQjRUaSs0MHN4ZGZXeWZ1V0ZSOHhHc1ZsNHRrbmJsZHJpQWVwQWY3bno2aE9uM3hrZnliK3VBZWNXTVVhaXVGeXArZjA5Vys2L3VvTVVvSUpwbzBmb1JBcGo2ams4UmZUSHZERit6K3ZRUmRwcTIzanlDd0lMdy9nSkxkZFZhZjNScjZJU1pKWEJBVUd2UU9oamtPNDdIbWxGNDB4cC9Qck5ONWZiZnlleFUxaDhqdVFJNVBYR25CU0pYTUp6cXV4ZUVXU24zSldMeFE1bVdIYVdxdWNpb0tKNWQ1aTRJU2ltU2JCbkdSemJIbExoQ1BEcmJjMmVrL0R4VW5vTEJzeDFzZEZoRTdqWElsa0Z0aWozSjBIMG44eHp4N0xpT0YrTVZGd3B4dHNzZ3ptVnNSUGhucXVNQU9FNnltVHIveStWSmxzMm1HS2R1WXM4UkVQMW5HTmw0VGlwRFc4T3I3SkZ0LzlvQ2huNHFvSVpzRjlGalBISVd1UExFWFBNaWd0a3hpMVJNdTh5NW5yQVVUSlo3cEl2TFhwNVhlNFRNWXZnQ3hKNkh1cFZMeDhKWUlyUG5RREN0UXA4MTVYRDFodnVOQW1DU01qSEY1SFFmUm9vQU9oWVE5eWlxMUtLSVdZSW9COUpxVlh1VGUyT0JudWRodEpxN1lUd1VxQTNQMVlta2F1ci9kYU9OS3Z4OEFTUnhkZEpLcXpVWncrQVFzbWRWZE92cWVIZHU4QmZsZnpQVGdpKzM1WENITHpaaVdXL2prSjdoQTYxd2lMY2Z4QVZyNzQycWN4NzlONFdudHBzY2lXQkN0a21YeDY5dU0yblVLOUkwUzlBUkYrUXczOCs4bUNGQitXQ012dndBT1hIdlQ5QmtjUmFYN003bmVLa1hPVTV0aENyMEJiMFVMYjZMZVJScGZXUENFenNYOHZBc1BjWVRUdDdjOU9JYlRQWkFQWTd0c3V6cndWYWEvMEZKRXduS25TVUVHN25xbXR1ZEVtZHVSUklMSWhyZFZNR0diT0FJQUFRVCsrd0FYQVBxczJKN21CZnBsVjJWU1FuS1B6aDJocWFCczNsSGJEZ1lDWXQ2Z1pWZ1lWT09jZTFLMTFzaWcvZlE0bG1MbnFsWlZvd0h4djJqSHlSL1dTQU1jZFRXcm9RdFMzRm53SFM4dnlsS0dUa0Rza3ZlVWJxRDVtMHBCblcrdjFRNnU5bkZsVTViUXlXeDhScWs0ckxzZy9XeTRab1R0TFUvTllaMS8rLzE1aC9VNjJTdnlaMnB2TW1JQWxJVTg5d0gwcml2TEFybjdtUWd3U0xPYWNOa2kwMkxZb1lSTjRFekNnZVA5c3l1NG95RmZ4Q2hPNk5KM0dINFJhNlFUTGZUcGlFVTY5ZFRIZ3ZLWnhGNjhvemVxdGpiK1N1RnhWMHdsRm1UZlZxUXhKVW9YdWZTdlVYWEYzRHR5bVl3OTRkcmhuVVFNTUFaWENIUUFUaURMOXlJY0pZYzB5WWxxbG0xUE1hMldZUG1oZGhtUU9Wand6QTZYcDBna1lOY0J5Z1RlTXpBWVdmbzFDenRyUjUxM2pTRTc2dTdBM0E4d2d5M2ExdjNoQUVkMXRnVU9yTnRqNGVseTBZMkYrV2hyeVJCUTBzMlI0dVRnSmR0elZSVTB5WHhPWDU2MkVCeUpFNisyRWg4S0phOS9PcDg2czRDaFVJcDJFMFJsd284VlNmbSs2QW1Rb1QwRjFsK3ZSaEVoOEJDc0hJWDBJQTBFeXhFc2UveEFYTUg4Tmt5STRLSW1jS3ZXamhWT0hjOVBKWW41ci8wRExSOFJVMUdYTE9rYVRZNm5kbTZ4K2VLWHdZK3p5aWRXRkRXdmc5UEdlWUVmdndxa00xVlZjVFk0YitjZm5nOFcwV0plRkFhdy91SE5kSFdHUkhGelM3b0NPbWF1NEl2QnU2TUw2aERmeEVrb3ZZWHh5WERERCszanBxdEk5aVFSWkRZU3NpRlBYZk9WTnpmdWFqMHNRdDgxNnlqS0ZLZG1IaHErN0N6T3UrZnBoaCs4aE5JTi9yRlNHTGVYVU1XRm5mdkhobjFlK09vVkhWSDMzOWZQRU0vK1VKRDBVK1lwOGdUUnRmQVI4d0pla2krWjJNaFpXNEJFVTBqVTVCTVFYbVJremRVQk5pZTZxNmhNOVk0SVVUbFdZcGV4MGZYVFRWR3p0ZEFlamM2OUZEVTg2RE00L0d0K0FsQTVPQ1U4U1ZvcUw3cWxjc1NaV0VuOC9CVDhiR29qUFB6RXZxTVZXUEMvcGUvcEl5bVJqSCtvWnpkdE1Gd28vVzJxMUREWjZCeTFub0JTbVpFWlh3Sit4cGRoVmxDUnBvanppTkdhNnNJRC9yam0xQUh1OUlJSHUrNDRXV0dZY2R4K24zM1MzaWF6ckY4Y2x5U251dDlkRUl4cTErSERvcC9oSENjYmhMUGVrMjZqenFmS3IrQ0VlR0U1ZWtsWkttK295Q1lFMDJ5RzJGN0IxZjN4WnFHME1CVjhWZkVNa0pYTlFxalFqalkwVjdiMWZra0hpWnR6YVhqb2pnR2RyZFY4clJWNXdWbE9vNVJNcWJqVlNheW9ncmpBWExLejQvRmJNRElKa0Q3Wmd6cUM0dnFicTFheXBpdEtSb28ySW1qVGhKRUQ4VmVhQnh4U1d5L1RxUmhwSW5YVVc0R2FEenB3R0ptOFJDQVl6SlFWWmwwRlkzcjBvc3RnSE53TCtjZUNHaWd2R1h3Z3RTVjJoaWF3UmVyak5MQWV3d29FZmZRcDVadmgyTVJvV1FZRUlON1FiUFhkV0tXUDhZZ09id3g2ZHJBazQxUkMzRTRuaFVlNFByTFJBZ0FCQlA3N0FKV1YwOFhqWTdxYU9QQ05YVWJtL3hGZy9Rc3I1bURhRE00QjJiQk83NzBiWUE0cnR4bHhMMS9yYVo5dUQ3dENCd1dqYnViQjNvWk1rTlRBdmZidjRlSERQcEtjdWozVHBaZHk5cFNSRVMyNHVpTEtGL2g0L0hHWlZSckJneVFlbHF1YUhpb2FxNHAra0NCMWRjRUxWR2xVWTFnYnQxWWtLczlhL0FYUGZxODdseEtLc2s5ZlRUVEd3SjB4QjhQUEErT0pMV2VMNTVDMDlyWUM4MjdQU0p6NVpac1pPcmdabFgxRWRmYkIrQVhlOTlMaW5jS0gvcFVrSWNmd3c2cVJtUGxtWENVVUJERTZOdDYxdUFqaHIrVElpK2pPaXNFZmVjV3hyUncyMEczRnM0aUIyWi9PV1lENmNjT1o3cENWWTB4Z1VvQWU3WVpsMDJzeXIxMEMzSGcxcnNvVVhRVlk5TFRIWjJraGF4VCt5V2x0L2lZd0tQeUFmR2xRU3VQUzljY25HZnJrdnlNeDBXR2tnUit5OTVXb3ArVW05MDBCNnMyM0x5WFNtWEczMmNrb2ZQTHRWVTl5SmFSWUh0RkF1MVZEV0VRNWpNZ2gzK3VCRk1MSEphd3FFcUxTaWJTWi9ONlFtNWNIa0ZhSERzMkNQZmRvb2dvdzI4ZDQ5M2gzY282NWNibVpXc2lsaStUc2dZUllJR051cHRDeXF3YnFTalpKemZva2QwK3FxSFJ4SHVtRUhTY1NQQS9ubnIyemZ5QnU1MVQyem9vdUw0bmJFU3BKd24wSkFhM0tWeW9zNWlzM3R4OUZmSUNsU2F4Z3AwbWpaazRUS0p2cUFmVDUya0daT3FCSmVEay8yWHhhcW1CbjBmbzZNNzllaWVWbjZ3L1pBdEdYeU0zZnlwYnVrMGxMd3hzOEo2bE5PdEphNDhhRmxlbE4xZDRpdWh5eEtQTnRGcEVtc0xON2JNRGtOMFVZVTJEOSt4Umd5cU85ZGhzZEJ3UGU1b1V2SmhUZTB6NE5Qbm1sWDd2bjFNRy9idUFHQkNCN1FQaE9ORFdETU03N2RVVGtKejI3NWhtOWQ2UGtUNkNGb013Tk5hNFhqaWZ0MDNPQWQ1Q1F5WjdrcE15dVNtWWxLSlMzMzEwbjRtWUdHZ1VoTmNSR1Y2VTZDWDFEc3ZmV2Jvc0dSR3BMUTU1QjlMVVVXazVDdHd5OU1oSTV3V2h5UkxxUThPaTBnSzYwdWFLYTA5Ny82MlZGaFdYLzdPbmNlaEhKK05lTVBldG1BdkFhYlJCTnJmSE9aaGF1cG1PbVZ1amxuSkdGQU9aTk5KQXpqRzdwVzQ3QUFRNEVpQlh5Z0d4eGxTNlZKVytpMmYzNWhWOVRzRWpycUw2YmtEVGpycXVKVmF3Uk5iQzZnT3Z1SU5UNzNGdmM4a1N6VDZSSzBTOUR2SWNONzhudmFSclRWT3hzVG9QdDM1b2taRXZwVDgzc1hmeUZkYVUrcEZ5bXpNd2E3dkxXMkFZVWUwZnhJbzhQYVErM0dRbGhoejVOd2NJcTZ0RThuM2IrTzhsb0kzbW05ZTZ2d1FxTEZ6dDdCMm5xWW82b3pRK3JRT0M4TTluMXhOTm5CZ2EzQVVsREFiNE9NT0JxRkVJb0ljeGxaNWVRWWVzM1hoR29mMStvZms4ZVFoTmVNUGx0SmVLc0g4aloyVXZOSW01OEovMml6ZGI5ejQyNFpWd3paQ2p1Tm9jL2podG1STlhnb2NCRGNSRnZaRjZqNXhBVlJQMEJQU1JaYmlXSmgyNTlQZkpCdHRZRVpQcXk4c2t5bExvQ0FBRUUvdnNBTCtvNEkwSC9VaG9rdVpyZmVpN2hxVUloK2J3b0t4QnZENWxSNUhXQnlDWEFmclBsaVlPTlhKNEJaak16SStHYjhmMnJyRTllN0pzS0I3WGRxa0l6MTB0ckFWaGxCa3l5WDZLWkR0VWRHQWpRQWFlV0NPQTlwbzVXMXJiaGJVdk11UGlSNWwrdXhQbXY5SHRrQ1ZoNGJvcEFmL3d0K0QxYkxob1ZKbFNuYlZCdFd3NHZUendMMG5XMXhHckRQODZ2eDVxWTRMeW50Wmg4bXNsNFQ3TTEyRGpkQlFWTXBiRGxsNURMVUdiM2lzZDBJaE1hcW9EQ3pQZzFKcHpSR1hnWUlYbnZpZjFNeHgvNUN0b2tBYVlzZ2I2enpyMXRRUzFlTk5hRkk4M2cyTXN0SFVuOEFMUURrZStTQzZ4bE5tZ0s5RFQ5R1BIc3YrdDBXeEdwd051YUxaQzVhSjJ2SFJMK3ArOWxzQVBVaitPTldNcm1GZmdlb1ZlZkk0ZkcxQzR3WUwzNm93bFBsTFRGSlg4dHM5Y0FrTVRzR3dzSUpVTmUvMStqMldzb1FtNEFjWUI0Nm01NzcwUHlSQ0tPdXljTjJrRDkyQ3R2bVBVa2RBbzM4dlRiUWNHVFphTCtHMEo5cDJ5TWZMNGwrdkFNd1NBUldmdGRQT1I0Y3p0TWwwRFNicGlSOGlETHFvenJrTWlNNHFLTnIyYXRwL04wOUlnaFc0RUw1SXFnUWlNSGVQTlc0UFZmVUV4Y0l2bTh4bWloN1czZURoZjJlblI3bXlDTWtTc0l2di8xYzh2SVVtUEVld3J5MENKcVNNeE5hcGJPWFZrVWViNDNMLzI0YWdrSFloTVRNdXp0M1ZFa0dCd2JVZldCRTZENjFnM3hJOGdJNkNCenU4dTI4ODhiVmFOZ0NYTHZTVlZ4djV6M1dXOFZldnBqblFiTjZUZm5jTEM4TTk1bXpiOWczd0NzYlJiUStab2dZSlgvUHlKNWtvenRmQitTZnJTK0l0NXF5OU1taSttQ295UzNlY3l3RmVIVVlxaytmd1VrcFk2MkZNRi9MVG1MRG94eTRvM1lWbTdQZmtNT2Q2aGRQTzRCVnpmWnhHTGMyN2tLR0hYNVVWdGp4SlpCakhDekgvWUFNSTUvR2pjS3V0M21YU1dwMlRFNEFHemQyUmVuZHczMDkyL1B6TzJPZG1qeUZLOWZvTVNTQmNPYkJOYUFoUG1nUWswVW9OU0U0ay8vRUVQcEVXSmtmbkdWR3prOW4wUENPZUo5RktCQ2JDM3FhQUVUSXZaUEc5clg0WTJUK0gvUFVvV0taMlcxR0QvV0p3TXdoeDZhUFhEcGNDRFd6NUJXeGdNYWRJTWhoMHNaS2NRczY4QmxQSVJrVW9oZG0rd2pIRHpId0hnOUswNzJIUEY2bWpPcHFOOUJBRzQxa0xZM29CZS8vQjBmejI1M2tXanZ2NFB4UUt6TU9XRjFPNzBVb2tFZ0pXV3Uxak5odTIyVE94bnJPOUt1NktiWTlIdm1FWlNHNTVmeVBncjI3bWxqaEpIQzhlbjllb1d6TDQ4MGFJTy9GQVc4ejdUenVjL3hCT1dFSko5bzRnelVOMVBQdGdVYWJYMDRqN3IwNEhIYmFYdXFabFd0a3NFbXdEQUpuWk5NTi9LTDRMc1ZWZHBnU1gyVk1QQ2RaWEhDQTBINEFmNjhZc2FSV2c0RDBZc2J5TFNncDdUbkFvZyt1RUgxS3M4alZ2UmtseEJEakxiZWQwcEQvaHZGUGhUMG1PV01pT3AwYVcxSExnWGRsa01hR3U5TXRZNW96QUlBQVFUKyt3TDgyN01XVkVmODFhd2tsTUZXYXBFQ3NQVVNYU0NVQUhpNjFoc2lNem1mdWQ0WDdJVFlYdk5sNlRFOWVDb3UzYlY1eUcxQTZNOHRINFdHMEVsMFlxVUJTQVdIVGMzRTFraktWNnYrdWF0MGpWRUFLNTZBMmVQSUVzUm9RcnlmenlPbGduYUVnNGtvZGxLTDNFYUZPNGh5KzB6M2JMa3dxeTB2MnZqc3libjg2dkRkK0FwSnllNW15Q2xCYXNBMjI5WVJheGhDRHVzSjFCMTBoM29neVlrYjloKzlJRUl5Y1FrSzBwcGdRcWIrcUhZWUprdzRpcUtIQ1VQaGtuWnA2NWhmSkZvNXpLcmg1V200eWh6MmkvQ09UR2NKdW5OVGk2dE96ZHFMNndSbXVPUEphYnV2b24wWEhDNmhGeGR5QnNlTnJMOHlFdCtucjJjRDRmK1RDeCtlZGRyTGdXL1lYYVdwK1ZvUys1bXNDUUpJZXB3VmFPR1lxRzg1OXl2UDNHVG5XZWtsUnRENGZ0WXpiRjJBVFpEc1NXUmhPUHFEZVdpTkU1SExpNklaVmdSdUJNMC8xN0dmaUZDRFFtY1pucEdlSnpSUzVidlI0aGwzTmljaG1qMUwvQWhvaTNBRGFSM1VYQTdyeWs4aDd4aDdZRWRDY0tNUm9OczFqbEJpZzk0Rng5eWJ4VEFGejlpNmpIUHU0dFVIMFN4STg0NlQ3czRQK0Rlay9IcVlqQzI1MkJ3OHlSTHdtWnpDY3hsQ29ORkg4N3VWYTdiTE1HZXV1aWpMcEdlL0prT09Ocm9XU25OaEtQVnUzNC9IYWx4dWk3TlNMcXdLL3BMM3pxbzNrVit2bmNEK1lqZ2lpZXloemE2VlQzdWV0UkVQZmtsV3AvYlZBNnpod0lBOG5QNXVoc1JrU1p3ajI3OE5aSnZDZjZxZk85VVBsUVVXT202cll4SHRBNHNERncxTWVwRVdyM255c1dkQkIwYmlXOTNDbzBvVnJMWm5IanlRZklLN0M1WHg2Z2ZtRklGNHl1K3ZqZS9XcEZZbVRTZDVzWlhrTXp6OTE3U1MxWHVReGNNSzR6K0lLeTZjK282djZtNDRDMXoram1sMy9BbWk5RUZlakRPUlk1UWZ0UkFNME5TNTJwYUlWWDA2aFQ3T3VmQjZZVzdXMDJJTFZoUXlKTzBkclEwZHM4ZndQNjNScWlLNkNKQXZ5eUs5WmN5VFZtbE1ISUtoTGFkYnR4MUphRitOL1Z4UXR6T09tYnNEN3NxUDNPQ3FUdEtFTG1FanFRQmxoK25JMjlUWWdZUTRHTFJhNE5YN1VMRU9PTE9xN2hrSVc1U1NLaTR1dFltbkFyYno0UXI4SzZUbUNpUHhPWlNDSVlIbWtTczN6c2dpd1BZckJVay93UEQvQWZSVzVFT3g4MkpzK3VVNE4vRHROWE1EMWFlQ2dxZmc3K3pZSHV1MDd5VG1nVld5bGRucWlLS3ArL01LczRZdFBZM0k4Y1g3QjlGbmJEUTNFQzVsaWJRQ2x6MXE5Z2NpUVNRZ2w0b2kvV2h4ei9Sd01sWmJ2VFJOTHRaZTZpZ0g3bXNtUVdOK1A5Y2lSSWtOWG9KQndyazFza1JFcXo1aS9vZDF4aVhqWXNScU14Qitldm9qbEt5eTNzVnk1TUxmaHVjbEVveTRjQjhqNmNZK2ZyVk9vM0UrUUs0Z21LRGdBbzV1V2ptc2tuYUZrcWRaNXJlYWhJdjFRNkZtQTJDK3YrOWI3bEtidktlV1d5eW9DeDVKb0hiNTlPUm5obDUyRDlQLzVFN1hEWmFITHRER0FnQUJCUDc3QXpPK3pmcEMxZno3RU92cFdUVlFIVDRSQ2xPNkRVeEVObWpuQldTY3dtWHQvWlJlaFJBUXZpanU2QS9IR0Z5U3VZVSs5YUFOaDlMN00wMkY1b0VCRlMzVnJibmpXVnFlNmYwb0swQkhKTHV1SUlhcEY2bEVXSGI2NWRtUUhlaUhZZURLSzVvdzhEYVpZSjhGRzJobVNOUXkrcU5VaFBsVFByNEcwOWNQQXNkZ09jSVZxbkF1SjZJTlhKTGtITnF1OEVGWlVlN3lpUjlMSEZnMThMTmtYOGJLdFEydUdoMVBubjZLVFFNZTRodWNreUNFZmd4N2pQUlptOXBTblNKT1FvY200c0M5M21vVGtWZXduRytpRVRUck9xVXlmOTJERXV6OFJFQmVYdXZhV01IUmpqeERLUTFJc3lQeGJMbEt0eWQ0NGxvNXcxQ05NTWxUTGlLZUdTRHYvcmJRdzR2Y3hUbzVFYzVCZUduRzBHQ1FvV0ZoQUswQ1drVE9pNG1RYzdPOVQ4TERJT2p3QjdRVEh5Nkh2K29DMDdkckRJcWJmT3RpbDVPV2pjT0lWNy9QRWNHaWtnaFljVklzN2x0RlRYeGhFdFFNNHNuTEppZWxCOURsTnFWR3c5ZTl6TC9IR2I2b3lKSUpDejd6UEZ2MWhjcnRnbDRyUkNLM05qd0cxd21Zc04zSGN3ZW5hQTVKRm1JZFozeUMzWWR1RmRGTFRNYkVxZXlKSXBrVFJiNFVYaFFyVEpKbzhvamxkMTc4eVVRajRxMzFScjh6VElqdUE5RFVTL1Y0V2I5SmtmU20rdmxGVjk3Uzl5NTBpYmdLNERzSTI3VDBpdnFhK3NzWk55a3hWQmgwNktzUUZ2L2hzdXBZb3luVjdyY0t4Q0FnNjM4cGJ2SEtEa1R5dUFMRWV4ZUFlNCsyU3c2WFVGT3g0RS9NVDB1a0cvM0J2Ujl4RENTUXhEWDJlL0pQUDdHbmNsNGVDRWs1RTByUXVNU1RQdU1UTEdjZVRMN1ByOGFmY1RRVTIrZGVKK05iOG5XODY4RmQvQnlMRG96UGtLUllSb3BhN0NnSCtTRmk1TFlaTEhxWEtNazF3TDRQbW9xN1BoRUtnMzF4SzZqUnhJbTJXNWFjdlR6dzE1ZTByWFl6bTZHN3M4LzFQUkNMUXFRazIyMXE2Q21xSTByUTZBY2tvcDlvVFZkZFpKbjdIYVVIdzZFYS80eUJPamhKU1V1RW9GMy9zMFQ3WFJyK3lKM2FjWVhZOXFlb2N2WE9hbk5aZ3o2RFE1NjhuVlppbTcvYmZLa3dDaHQ4NU81aGtHRitvejNOclUxREIwMW04OHlQSXRxNHhnNVQxZGx4NXhBd0p0cll6M0tkOFNhSmRZanFHYzlQZG5mVDIzZ2NEMWcwczFFNFlFUEdsaUMwQk9JOW9kVkdieVVJVWdSM0dYa1Z2aGVaS3dBYnVYWDZ1eGh4QThHMG9KV2xmSUt5Q0FhRS9RMFpxQzZNbVVTRTEwOE55K0xtSitCVFhwbUFqcG4zdSttcWh2RE5UeFlhVnhsUlpGSUdKZGxoa21zUnVrQzVwejhVSWpaZzJ3dG5PSjNMOUtONlU2dzFtWjBMWGFUYTlLTUZwR2JIYmg5OUhvWUxYbmV5d0hIK2EzcC85NFhsQjFVMlE3SVppTzY1SlBEeEZma3FHNi9lZW8yOEQrWHRYMjlKQUFOUjhXK0kwZVcxU05FQzBQaHVIOUc3VzZ0c09IOXkwdlZra010ZEx0VDVEZHlvdkxkcE1BVkJvRnd0RGhjcjNId0VrMzJtbXYzLzBGaWdyQ1FDQUFFRS92c0RSUjNHSTVHN0FQMmRKeGhDd2R6VVFHNVpRREVDU2hJc2hzbUN1aDVjYkNKMTRrMXdMR2xaNmNDWnpadWhRQ0Z1NnZtUi93MzNwVmdjNFhxYjJxeVBFZWNZMzZXbzhTZTJ6QzhXZi9vVjEvbUJtcHN3OVVINW0yYlFad1FNc1N1MTFYWnBSTjVKcXBDNk1ZcldzV1hEbDAzMVEvZitCMllTWURzVTFKVDI2NmNLMlJrT3VXbEFlb0tRRGU0MjRPMVFwMnRmQW1XVUpsMG4xQzRhZkRMbGcwUDJlR3NNYmdDd1Q4ZFljTFdxSUJaaGlKS1lOcWtPbGh2ZC9ZMHg4N0JHamM4NzIyTXFsWmdsTEp2a1pIU096bi9FYnBERUpuS3JlOEhGdWVlbDY3V0dwdHhaMHBJeklTdTJSQlk4cVB0NDZLNlpsN0ZUOFZhancvSnVSRkxJRXEvRGUrTVZ2ckFMMHA2WjZtNFJ4d0IrUFFDUjBZQjBSNFlrYlVXY3ZhbDRUblRVRGZZMGdtRWlZbFE5WFZUZjJ1ZnpHV29Wc09URkM4aHRGNFVqcWgrK05oam9XM2Mycmxyd1VnYjJtVFVUemJScXQycXB5K3Y0M283VG9BZk5mVysxa3dmTzhYSHJxQWNhdTMwSU9FeG05bDVNNHJuQitMNUp2ZWFOWTBUNmxuc21uaFp3N0RKSExDcXB5NjZHWFlUR0lSVm9zeXd2c1VqcFkvbVEyL05STTM1L0pldFVLSElKd2g3cnI3b3FWS0Z0V21YblZpbmtYUFZTRGJnUnl6Z3dOZHhhSlBYSmhZZ0tkaXZNdytNOE5KS2R3bDRRM3BrZEs0ZDdxTWNybFBjNzZ1UkFrSmg0dmMva0I2NCtJZ2Fwa1BZS2U4RXUvK0RzK1JQKytkWWMxM1Q1aktTb0RzbERORng5L1ZMUmt0UkgxNGJZTDd1S3JFeXoxRUdJSEl1OXRseGJoK01ZdzViWThTMWY3UytGam96SE9NbnJRSEtWcDg0KzRKREtDcDRwNWNDZTBrNGlyejdYdmhZQzk3R3BNM0VFYURieXlQbEdSazZEN0dydGloZ2hZdXYxWGtVcG90SmxjcHYvYkw1eCs4WFVWNTZDM3VnVkxqbk9sR0R6Tm1RTmtTNGVkWnZuMTNURWlEN1BGOHVkUnhla0I4dmlKWWZBSlZCeVR4RllucDFsYjVvMzNuWnlVUk5GQmlnQXZOUGM0RjBvb1ZzdXVHZThsTytCQjBHVEhnaFBsNlZxeUI1VkRsUUlHaHNtVDdSYmkvRXE1bFpHbUc3MldkK0ErS2daM1UzWnV4aVJ5Zi95cDJVdTgraDRDbTBoOUduSWxQVS83MWR6T3NJZ2dhMlM2dHBlcnhjS1hxNWwxUG80SC9JbXhVSW9lNEQwdC9OOU90RG9YMUxIdCtCQkROZU5ZMW1lM1FSeEw0UnA0bnpRMzhCdThSYnRhVUhvWDl5dlQyZ21aOXp5NDVpUEZaOUI4MEJQT04yVWxxV2V6eFNjTXlka2ZSaW9SRkwwMTAvdkQ2ZFFMOUREdzhrRUtHbm1OcmQzSTM3ZUtSQWREQTRlbUhKOElLd25VNDdJa3BPa1ZRRVpJNzU3S0JqVkQwMGkxeEU4elFrWjZ1Z2JCYzRHU1A0L0Y1bnNFRmtzbks4OE5hVG00RkhkOHkyOHJISGtUSUI0WDNQKzU0aGc1eERWZzBISTRHSlRjTkdxVTJOS3l6MDdqK2JCUFhhYTFmdXQxMVZhRDF3bmlFOFBNNG55bENWNGx6ZDV1MFRrR3duQmh4RXVkSHZPcjhCdU53SUFBUVQrK3dKQ2ZRTmNxOEp0M3BVa2d6eTRCZUNrZkxJcGxzUVZmZFUxbGlrd0VVSEIxU0doRm9DM0xYdmU2VG5yZEtPTml4NjV1aCtLSUlLNlZJV0UrRzg1em1FYzFDZUNZdW1tZWpvdnlIMGk2d0V4OHFrUyttUUVRSmZFNnBwelBPTTdUaXd0NUt3cnNJbnVPOE03US96V1pvVjNUUmZYLzBseFJjekJYc1h3NVA5ZHVxb05NTnpQdlZyd1lPTkpMNkJ3aEZjK0JWL2EyQ0pUQmRIM0lpVkk1SU9WWXlXU0xMaC9oSWo4amp1a2xwdFBlZTE4bXhRc3JnaUR3d3A0RlJnOEFnRzdjTUFBQTM3T0F6QzlKS2t0RGpMRG9VMkdlRk9Tald6ZDZwemx2amFEaS9INlUyZi9tVDNVMXk2djZ4WmpxNDZxb3ZXem85VGVIYXNLTVNjNm56SHFrOEFsdUQyYjZMQ3RCQnBpYmZOWHQ3VDBMNWt1TVFDME9uRzMxell0bFR5WTUzVm9HcVVFR2JRSnhJUU9SZHZlME9MLzRpaFVLdkdKbXFxSGlrNmU4OC9xSXl4ZG13cmxIekhGU0o4dmJxUEx2YzE2a0FDL3l2SFMrMVFvZzhIdmFvNWR5ejU2c2wzb2Vvem1xRmlUQUszK3VJTytzOFlIUVRFa1RNSFZSZVVjQjArZFVsa1c4ekU5Y29sVEU5aSt3N01zSVRlVnNzMXJUTWZEa2ZJNGpLQmViNnl3S3J1R0hraEdwUXE3M0lmNDFack1adUN2NTBHMGVNckhpRy84TGhyN0piUldRYVViTTl6d3ozZFFuaUs0LzdkaUhhQkEzd0xheVZ6aTlyQU5pWUhSQmdWTEoyN0w2K2Fva3MzL1BxbjdSWXBRQ0JiYkpJRzJyZ1lEdWJqK1J3Qi8yZGxiM0pqdnJEUG5TVjF0NlIwdVBFZ2QwSW8zYmI0WWhFcUhUUENYL1FOMnZHTk9LSnh0ZUcwMGRUcDBuM3Z6eTcvZ0x3cUpDYVR6MXk0RU1tSnJsQzU0MEw0L2hjZjlwMXFRcjYyS1kxSkJhbHFzd2dIaU1PVzhyeVB6cGdodVdGVnVwWVlTL2w3a2ZKdmt0czJMVXBISU1PMGZWbS8yWUNVZTlMS3ZIazZYRWtqUld1WGx6YWdMWUtxMVFuWEloci9zeDJSenlGckRXdFZFeGRWaUdaS1dWZ2FxYXJ3Y09uLzB1eEdOaDdmYndnMVA1MUR2Y0hOOUxhZFUyRloyWUdza0YrTHNNRzBvUDkzTVJ2TnRRa29xNHRXT1UyZmE3U0I4MjB2UzBpUXVjbzBWbU9Rd29QdVhxTVZjU1N3T2Y5RmY1anhtZFVaeVZPUUhISURhTjBCSFVySndLbUdvS2lhUGZnaExhK05ZUnd3bjVLbFFqQ2hqUS96RGFqdDI4NHZxeE5UMW9HM0p2d3B0NHZYS0JPSnB5T0lRM1BBY3Q1aGYvajl5ak5sbkZSenhmdm1kb0c4b0wyOXdUQkltcEFXQXgxbldyTE9nQVozOWEvcEVub0ZFckxhcGVMdkJSY25aZy9UNDB1MS9UV3o3enUxK2FFUno1S0wzbHVhSTJ6US9tZXZQakV2N1pvcVNqb2oxMGVVN2JTNDlleVNQdUV5Z1dkQVRacHpwZlBmMU9sN3lOWkI5emhVOG5Sd2pYMFRTSXpKMEM3NDFXSG5ucmwwSXdQeWlidU9yL2ZPam43Zm1oSlV5N0hSZ3Z1Yk16ZEkrSEtIdDhqUnpJdysvam5udHd3c0pIenJhNHcvUFFTQXU5RDRJbE0vRlBhdkMxZ29pQWdBQkJQNzdBUnIxdDErazNUcGRVei9Ed2tXdkcxcW9tR0lORHVHVmpKZVkrRE1WdXRJOENkZEsxblBCMnZWRklYQXZaMU5ka2E2U1FVYzFKaXdSSXdHWEVjSjhwSWJpVE1zeDB0d09mTjJSM1FpY3EyU2hQRjFqeGpYM0FZbmtaN3hUU01LbWRsR3M5MG5sY0VmZ1BLZ0JWYUxDcjBONDNlYTBaOGsxMi9Qbm1wWW5ZeUhuZnRuS1k4QXZLam1LVXhsYUt3aG0vQU9STEVXa1ZrSVJRL1E3VitiR2NNWFUwZS9ud0E0eEhPSFZDZ2h0Skk2aFZZbHVlL1EwOEFoYW5RNUxOdGRwb2F2Z2pXczZoVjdxdExKTkFpTnRsa0w1bWNYczBTUlc1WExMTHZqZzE0SDNoRU1tZTdNYkxueWw1dmszYmd1cklHbHpadEh4N3o1UlBidGVZcVU5bWdSNDFGR2xkSGRuVmhkaWRFRENqc2lmVXFEcTEvQUVqQzBJWm9aMnhraFpnS2F2T0pUNUUyeWdsd0ROYXlVaEJ4OGhsREplUTY4QjZHVUlUSFlsM3hrUVNjeUtjYkdBMTdpQUZsU3RXQmQ0TGlMeGZVcEo0dk9OSFBoTkFQVmlTRXVIa05pZGkyS2c1R003dUJNRFpzTnNhUEdESnVyNnRad3ZrMWR2RVBGTXY0NXZzME4wWWZrTWtJclY5aTZCeTZ3cmsveXFuaVFlMFhYQXlzM2E2L2hqREJkV25pSXVrSkJJd0JzWnhLVC9OQythTDBsU2VQcnhEM0FaVFBIZUxWVDlrZkV0SzlzQytWUDh4UDhpYUtlN0xWWVdJTDJycXhvNXZMUloyT0J5NmJVZ3hDaXdCYU42dEd6TVdzN3dPd05KajhOTi9JUGdGNWlBSk5RdjE2SnNWdGh5Y1QwTmpBR3d3bFdEWS9sQVMyaEZjS21NblA0ekJLSk1OQzhrUDhNNkRpeXpJVUYvYkZmUmhWR2RVYVEzQ2p6Vm5JK2I0d3VZQlQ2SjZtQVlwdGI4OGhKV1lKb0w2RDF6ZXdTc0Q4czdQNzdCYkRnWlBMcUkrdndaODRKbytFNTF4MWcydklPQUFVdWRzS2FMdjdPS1BIT2dOYTdwbTZwaFlRYlgwMzB2MnBrVXRUZ2M0bEdaRTY5TlRjejZLK1Y0ckxuOCtqbVdKTW5HMDFTZ2FPY3E5VFdVSUY5R2pjQ1lBYWdLaGhZaktzY2VveWpmbGRuTWJlM3QyMFNQcDIweW85VGl0ekRWZGtPQjZQRmVmNGxGR1ZkSkhxazd4Mk9STktmbE1rdmJNajNwLzFETk54cUdEUW9CQ1VQMXp0QnMwZUl5RmhVb2hFTU5SVGh0eVQwTjY2VU5QYlIyQlVjVC83a2twa0lxbEFXQjBJZHljamQ0RW9hVVNvc0ZieHpaS3V6YjJsRG42VUxaWEhmNGxKWFdaNXJPOGl2MHhpNHBBQk45Y1B3cVRscEkxVnVKcEpvdE92cEpQdjNvWGUvN1ZLQ01LQmFvQ2Z0RnRtL1MxWWU4LzBSaEFiMWJ2QkFwbzkvdFVjM3oyQlBSWXRkUXpybFZ5M0NwcDNuOHlBTmFmc0EwYzJVbXFtZmZaZjNIV0h3a2pDdjh0MzY4djZvRDJiYzlZcG9RUWtGdkZXNTkrcjVmRVIzSTVtK2M2SWRRaDVCazlMYlBNVjF2M2VqWlprL29hcTBHajBrMmZqYkx2dmQ2OVBsM2MxRmM1WUlQZTF3cFNFeVM0d3Q1bGdITXQzMHE1cXVFUHNEb1N0b29Gam1YYmtPMUpZNmRsYmJ2S3ZiWUtmRUNBQUVFL3ZzQUJmVlJDYnFEdWRUaGVnN0NoTUgzYk9VSE5nbHhKVVlvK3F0aUhRNzFOUy9MMHd2cmtSWFg5K2J3Rll0dllDdVVHRFc4a3pEY2tBVnA5dThsMjRIbU04ZStMUzhVNjlXZ1BtZ1dPdDZWeUVaNXByTzJhcy8xRnlrRTdHbWkxUW8zZVNkQXd1MnRBNEtpMzlnL1VnTW1TNHo0eFo0Y1hUUkI3WUYzQzlaS1dRclQ1ZmYxOEdEVzlOcGcwM29WTUVJUHV4aThRL0RIbVBhaVZWZFFLVzE2VXJZdkg3VFBFeEI5eFo0UHJkdGl6T09vaEhIOW9oUWlFNm40MGhKMDkxZEE3YnR1L21RMkF5R0c5U0RVeThRZEhJdmdCRi8vWjFjazVjc2pSY002TXIwNTgzd1J3d2VYRFQxRkdwMkg3ZDRNMUYyc2JTaUtGeDdQbDljbnZEc3BkNXZVaG8vM2ZCNUh3TWxNOUwzK0FNZDl1eHBsSE0vNjNSbzYyMGJxQkJDWFd5OTMyTks0S1p3d0xRb2pVcE5MU2JCN1FwWGo1YUpuWHByL3VoZWpXSHlQdExDSGtBOUQ4SURSVWR2MUNudEtNRzJTWkdKTzR4aUsrRDREbEsyZDBCMm13K2picng0QVIrZzZHODdxRGxqZmRXK0xGUlp1VDA3R0oxLzlIR2phTGh0SHV3M1RyRnJHS1htT09nc1ZjR054TzRlc0ZWalFUcGI3SVJ4MytDMjdjMjNQSUpOaXZEd1pHdlFIN1J2SHMxd3BneTd3dVVSUWdGYU1Henk3S2lmNEFDS0tQUUNGUXdWc2JIamRXaExHS2tLck9oejBmczJVWGJrZlNBRHRKN0cvNWFpc1dNTk5QSnRvWWY5bXU2YlNpTlJsNnRacUN0aW1PTll3aHZMdUlJMGtEaHhoRzNqVDd1S2JQSXlJSG5yZWIxYlRSQlgrbkwrWUwxUC9VbExucnhnRkoxazdUYUR0MUlLd0ExQWNjekFLYWZBMEhwdzQ4Y2lBTkhzSmQ3R1d4cWlMR3BmZndkQkxUek1tYy9neGNONkIzOUlERGhnMTQybW1zSTNBZDhRRnp3VktBNi9QcS9POXoyK2FNWjJxVE1LTndlc0NGVm1Ja1FldkR6SVhxSEVvTkFpaHVVU1kxWExmcDMzUEtqYm1IYnl0SXovWSs3d0pERHJTcFZveVBZRHdENzY0MW0xblgvc3VrNVBFckpFU3hQdWFEZnhLQ1JrRExtMUwzaEwxVTVod0VPMW4yY3AxUzh2SEpJKzhkaUxBL0s0SFlHY1h0SmRNai8vaUQzQkp3MkxUdndNOS9hNWY4aklkaDZ4cldJREFRUFVBMmJWNWloTWlPOENEMnpjcVRqZ0cvNlY1NHZWUDFXTjFYVDlrNDBSMFA0Y1MxMUdNbFAzMkJOS0FVMHAwTEo3a3dEeHZ5VmNySXVOVllSV25jSjlob1JNdmRxU0tJSzRkVEN2TWVBbjRXQ05EOGdkT2kwTnA5d0VsYVQwc3VtOHgrNGI4TXl3eStKZUhSR3hqQWp3SncyaU9Zb052ZjhPSjZQM1FwTER2RW92VkxzaWlQWm02NXlHcFYzbXZVL25MU1k1M1crYUM4OXl2NnNDYnJvSkZ1cHIxL0F6VmJoK0lxcEdHZlRhdmJIZFpIbWJsbmFQMTB4NnBHMndSRzJBRHU2MEhwaUVNR3hYUW1vS0NJZHk3bzBuN3pnWTZjd01STnEzcGk3dUJIUkUwalFRb29kYXdhRkRLT29GMHhCdVNXZFJQMGtYUkZ1RGhONzcyRjlLRlNKendIenpaRHdJQUFRVCsrd1FMUUsvbFBxRDBLVE1tUy9ZOHBpZlI3c0Z2Tk4rcllpRm1sd3QxUWxlYlhUVVVzRE9tRlpZOU1QUmV1L0YxVGRRdzZZa0ZDZDU1Ym8vOWpmUXVjdDIyNCtxRXBtRVZyV1R5cCsxNmpuOEl0OUIzNHM5K1FjbFZ4SnNCeGkrY2F1bmNTdUo5MzU5R1dVMEQ4Zm80SWN2ZGhjbDY0N2x1R3RXMytFVytzUDJ1bU5nZFBycGltQWtHS2Z0RXR5akk0a2hXQ1BpTkQ4anIxV0xpMUtYK0tWWXNac1pnYmc3RDBnQ2piV0x3Rm9ORkJONitvMVQyUlJOVVRWMkR5M09VdEpWT1A3cGZ0WlpWak9mb2k1bmM2dlR6cGoyWS9OS0tqYjI1dzNZcXQ5YmFsOVg0ZEt3VzNxeFYvTUJDdjlMRExRK2xEZENXZFpCTmhIbi9SSkpuS2tqcnBjWHN6cXExUlhrRFY1Mzh2NWEyNmJ0Z2FtVHZiRjV1ajJwZ3YvU2xNdm4rZVhlcFRIeWo5VU4xblNHbjc4dFZsU1BLdm5HZVJJcURORGc5SWVPN2V0MXQxdUlIQVlVTkd4Rng4UE5sRVhoN1ljNElocjBndlBKUVE0cFJNcGZVNHlKKzJ3VEY5WitSeEJwaFQ4Z3BsRnBLdFBmck9zRGtsRnhZcmYycldlRVpIV09hOGx4SUwzRUhPbzcxcnEyMGswNXpVMG9NbXJ2U3FybElyRU1PK1RYc2toOXVuVXJLaUV5V01GQVI3N2ZxVXZnaHdLRWx1L2NhU3d1Zzl2M0k5Q1pGWnRhZC9mbzQxWU45eHorckRCeFFMYlBzaW1hcjdlU2wzTGxsbEhnME43TUNWaDV5T2F3YVVTUGpKNlNuUCtzNUFXOW1oZ0tPTjZ6WkxIc3ZSNlVSeEJJYXJKQ2d4WHBSemVaVXVGcGt3cmxFQlNjUTA0YlhtZGNaODdqZmxsQ1V6Rzd1aHh6c1BGQnlkamhJZ2c5Rk8yYWNNRVVTRFA4Z2ZlU3E5LzluU1pMY2tPaGNLZDRHU3NQVndBY1E0Zlk5dXlSTlFFcXZ3YlREMnY2a2c3WDNPT2QreXBOZkNiMSs2empmUnNKSno5ZmFSRzRLQlF2S2QzM2c0R1FKdS9LTUZub1JmUWlaaVVzTjZEUnI0THRLL3EvZ0ZjZHlsSHIxNE1JODh3R3A4RjhtRmVBd3V1akhYVTFRelpCbG9SK2lxTVVSVmJhREZxYWNacDFoSTY3WWRzSHljVlB6WnFFa3FQVHJNV0ZpYjZIenV3Z2pSYkxvakN4NDFtTXR2N1ovTEo5L1JKZnlxdUhFWU1VdDNhZ2NMYXlDT2lZam1UamwvakNjUmVFRXBVbUJFS1VaK1pvRGtnb1BqMEI2NjZSeUdwZ21PbUVUVmsvOFF5NnZlZVc4Qnhkc2l0NjA1SVU0dGtvN1lCQlgwbHNNZDVaRXdHa28wcjF5bXRFMzNLQm1IT0pOaGhXQXd3WHd1TGZGdTZTZ3hQU0FsQmhDTnViUVJQOFozaFRBT2krYXN4U2lrWGl3ZGYwejEvQUZSdkxNQ1VZeWNHdGxmNnc3S3FLL0xuR1hnSHBrZkh3anExaFBjelJOcmdPeHZNMlZoWS9WcGdFNEJWYTJPcm8yWVUrd3ROVjVORGdtRWRmVkNDVUlyc3R4QXJGN3FLRTJSNklMeXUzNGJkcnVDN0V2bnpxQVFUYWxFNU0rd1FZa09XUDkxSUtSQ000YUtydnlsNTFUeHN1Ny9lU0xoOFdCdm5wMHl4NnBHWGQxUHdjb2RSOFkxSlVOODFrV0N0TXdBZ0FCQlA3N0FYOWxFdVp4NVRSOUpqNVZ3UUxxMHRKck5QSHdHaWtRMnZnMnBSOTcxdWlCejNKalhwdGg4aytKT05Lb002WjJqRWZvUk92c0J3KzVqNE5xUmtIQTlhcVlabWczK0QzdkhHaHZZNFFWRndncmhxcG9GcmIvUDV1cFQrR1NQd3djT0p4RGZjc2c3c2l2RTJjc29HdlZSZEFkOGFLTUpIWDNuV21tMG1WbzZpK3BLOEJLZmt4TXNKZGJDY2dUWjZtbktqTmlyd0xqSGpNSEhGK0dSa1JLeGRJNVB2bXc4c1FSTmJXY3NJbWtMZGtuZXluWkMvNjdxZGVxMFl2SnFnWkJ6VDJRUHI5dm93dUFsTTNhdmRZckhLYWt1THkrSnRHSzh4MEV0aGYzUExVL0RRZ2RQdDBRcFZEaXc0WlJ6WHNFczBFcmZKajlHbURGd1hKS2UwaGp0aEJ3MnNSYm1XWXpxNkpWdngyVExXTFBPNE91Q2lrUGZneXNYOThqUnFLSHg2VFpJS3h2MFQ4OThpQlFvT1BxUTA3dkRtRENJVG9HK2srQkFzRzY5NlY0UTZmVjVoVm9BbDN0aDBLMVBKbnlKeVA0R3pnckV1OFRGZGNTOUFyVUFBUGRDb3RqQUtMU2wxWU1MVi94OE5oK01SRENKVm8wempxMWpJUkpnbHpzUXRpVjhIRG1GN0VuTHZVNEE0VVlkMnYwQ1dMSzljTDBQVEtZU25NN2t1cnYrazZqTUE0aHFyVkV4UWNWbzRmUmplZXhaWVdRdkJ4eG9iVkJ5VzcxRlpIbDZYM3hIUSswcEJnV0gzQ001MU1zNHkxc2lXQ01rTkVrOFE4NmZudndRY3NoVTgydGg2L2JwZ0VrRjcrRTloWWliVWg3aUhMTnlUSzFhb0g2Q1ljOWwwbFByZVQxdys4R1grR3ZIZGVIYnBYM1Vsb0tPRkg0Sk5CdGlNdTM2VEFOK1BMRVZVd1BRa3J6cHpnSFRuT2VIZU0xWEVpLytCRUlWcVdSenFBbnNqL2ZSSXFhNTg4NGNvL3A0YVp3ZFBwSjRZNk8wSXZ3NTFKNVFZeDcraTMvNHpLc2xQZ2w0b00xckc4Z2VUMm9WWXJRNTdlYkIyclN5K3JJenZ5K0VkYkZ1MDNqOG9NQ3BGN1c0SmFDU0dJTEtkRVVkYWtLTEcwUHZjVEpVMURmUEh6cGw5cHJsSk1DQk8zdHp6THgyVmFOSjJpak5GeUZDY0w5UFU0TzN2SnJ5b0habExURkladjd5eDIrbk1iV0wrNjZPNXFoRWlZRHBudG9aak9ra2dmb0h3T2EzbFhWbzVJTXhDU3VzUkVSMVBIWDlYVldkTjE0eXdrVGoyMkdCU0NnK2k5QTVxN2lUb2Q2ZktyNFFjZFgvT21kWEFaNFUvMFNYKy9kS05MelNNZzBBdklXL0g4R2RNMk02VlJ6MkNZeWVxKzNyb0x5S3NoekpCU2JxVkhZdExzOVg3dm9yL2FzRmYyTGRMaWZiY29jRkp4NTVwT0IxM0JacEdLRy9IbGgra1grNjFSM0VZYnBQK0hpdGl0Z2I5dUoyc0VuYXlVRzd0TkxTY2sxaGVOVEx0TkFac011SDBKaGg4Y3JlNS9wNVBFVm1GZlF3N2NJb3JiOC8vUjhiN0JieWZrNHZXTEx0ZitPWDI1L25HdHZXUFZkcFEzRzdFbk1CZDIxSkRNN0ErSVcvTHJUa3JSM0dpRSs2SkViT2kzYnovRkVGdWhxL2dvYmxOdUw2dWtRTFBLUmlsRDZrM2Q4QVBIUktKdjlhMWpDMUlTbkJuVDB4THdpczh3Q0FBRUUvdnNFcXZqM0s2VEdWcmFLZWIwcE5uUWRPNTl4eVRYb1ZwTnRQeDJ0Y0RuQ0U3YzEwb0RKRXQ1b0Y2ekpZNmtydUJWbVJ1U1ZmSUNLQks5ZlNFUVlBVmNnb3hydExMbzcyUEhDTHk4RHB0VUxDNWVvRm1UREtyTnp6NnNkL0dUTVJWWFZoaGNNK3JObisrd0lSazNIb1lkaDlCV3cyS3dkeDEvaHZvUjZHa01lLzdwclJLZi80Tk9YbEpTamVpcHN2cmg0M2ZSRFl6TnE5bVlYUDJQWE9YazI0cDZxNzZNdXUxS1FST1pUWTh4QU13SzdJUmt3MUpHOGdTb2NtT3VDb3cwSCtkckJxVHZXSFFGODcyTjJGRStvTkl4ZXdvNW10TjYwejZncUdVYmI2ZVpHNkRNR0QzbUZSTHJmakVXZ0s0ZmlKOUJYV3BtR2lIeEsxLzkrUDREeitLcStGVGJXZHBROStzTnRFVXVmRWRsUk1lWnhxNldaYkJuL3FDY25nZXRhN1B1SVo1NUhWMTdIVVJvSjN0NW9VSkVTdDBHcDBiZ2U3dHh5QkY4RG9JejBnMThxTnExZDgzL0o4ckhGMU1QTmN0c2lnL3dTQWtTUmttWjlhWUxqSTYwbmRUbUpnR2hxeitKdDkwZzZHNllkS3N4aklwQlhhY0FxbmJmWkQ4ZkhtV1ZJU1Irei9FTldtRmMrMXFtSFRvVVhkNml0VzRVRS9sTnoxS05WNjcvbTlEWDEyQ1plcWIyVUtGZ0ROcHJEMlNXb00yTmJaNXlMMkw4TDJ1TzQ5SS9TeC9kRDNZTzVWcTJWM2ZROUplS0MxZ3RQTzRodVdvTWNpdnV3QmgzYk4yRW9FQUJuZjZmaHJqcVBTRlYxYk1ONnhvYjBrVHFvY251K3ZDaXNaT0ZEQkhKM3hScVFmUENRN0M0cGdnOWFqYUpCSHhmeGJYT0lyTjFkOHByRkZ6RHhEUEFsQlpBTVZaOGhoMzc2RDJSNzBUdFRWV2pXdEhHdG94QUVJQkI4RC90amc5QkRSZnpkWFBiQ3poSnRwaEVaN3J1SUNlbXcvY3lCWFVxZ0tOS2M0SkdTY21YbHJoTWhiaUZHWE8zKzdTL3RlblMzUEN4Z2xJb3A5TmNyOTVIY2RQUmtEc3pYTjNtTVBGWDM5SVFKWXhCWHlpRDVGSVZLQjExM0ppOVh2YWtydFUyTnVONHN5RWN2dTdvWHZWZ0tORFB6VGFxcHNmMWk3UkhtcXdtVDJqaHY2d2J5cnFsYnE3TUZibzQya2s3Snh1cHdSb2xEemFFY0pQTHBSRVEybmZvdEFMWGwrTDNmbXdKL0l6cjBSL2syaDVCQS85MEF3Wkh3bytDck8zRlQyV0lzc3Q5TDBKTDNQUDFhb0htYmFjOGpIdVlpSGFxQ2djNm5DaXhzeVJWSWpNdjQvb3Q5MHBsdlhDQnJoaG8zSXJHOG5SdEFXNXZ4MFc1Y0NDTVNTUkhleUNHRUQ1b2V1SGxNSVpySTltR0p4KzJrVStYMWtvR1k0aGxzcFNTMXY4Q3pleXRQUkVWSHh5d2JTbnQ1S1Vjd1NTYURMNkx5clMzcExheFJhcFp6RGRCMlhMRDZBVXFwQ1NwRFU3bk9zSXBTWVYyUHVaVG5WTGF1WUZ0MW9YaTRhTFRVcWJHamZ3eWpzUXNjRnRTbFJLalZ2UTNnbXQyazBZUkp3WjlaT09PLzVsVzZlZ3d5VkVOM1ZmNzBYekVLV2daMWNJRVJhU0RYbCtvTHlEV3JiUHRsaEMyYmZ5cnlkMU9xc2pBVUplLzB5d2Z6ZkNwTkgwbllHd0lBQVFUKyt3UHdYS2lWK1d2Ujd4V3E2MVkwQ0dWUEw1THpHRnJmbVRrc09oeklMODNwZ3Y3RjNCVy9SOU83U2tyend1OWpCM3hUbXZhckF2WkFqeC80L2lWL0V5RzQ2UFArL3dRamdMdlk3ay9hZk1TeHhycTZLejJ0NGdEZ2t0enQ2bEI5R2FZR2syUkNuNjA3UXNDbzd6WE5xdFlFUVF2TkVxQndybFJCa0NJMkFNczRORjQ4enI4Uk9BbWc1eGFsdERYZFV6TEpVZUlnaXNpN0RvNktid24reG9PZkpEY1czZ05aL0VId2hWa2tYRFJvcTJoMzg4RE40Q1RuV2FHZFdDU3huWG1LYVFsdXRTZndzb3ppcGF5RlNQMTdRNVJJc1RPMXdMWS9oZmx6d2FqYno3cmR5OCsvSCtLa2NKU1RucjV1dlhTWElqc1VlSUdpK0hvYWRmeC9tY3pDTjdEQ0xwbUVrTEpYeXA2QWEzYmRwTEtlWDZ1VE5YeWVXV1JsMlR0NXRXS0NCZy9OQ1FZb1BWTk5Cb1dlMVFQSEJRQm9LOXhRUm9LMnA1VG1XQ3VxYk9Ib0d1dkFzaDNsazlDR2FHM3lJQnJhdTU5QVJ4ODA3eVpOVFBEZjdzWXFtZnZ6UFhkNTcyYjY2ZWNOU0F3MStuWmNpQWE2LzI5bjVUYzJYQjgyQVN2RzBmV3hoYnZjM01ERk1FbGRNOUpQQXA0RlE3MFdXNHdJWWptdVEvZDhtblF6akNNWHlXU1JUdzNqWVpLaHJGc29SZUJ6RGtwUW9YSElQd1E1TDA1RTBhRUFuTXJTTE9WLzVoQ09ydzA4ZkVUUGY5MmI0aDRzY1ZxNkcvOUcwNkt1MU5Vdlo3cTFYSUhLckpSTmNvUElORVJWSC94T2hMVWpVVytzNTlycEdVSHBDaHhISW1EVE81OGRTdkpibkJJeXNoR0RzcHNhSWxodmk1aXBRaUI5bmZKemh0MjFpd252TnNyR2FVOWZPOWhiODJLREVQVFNlSFQ5NVhSV1llVkhEbXJkb05nMjN4SEVpcjl0VVpqTGhBcmp4eWkvUmU2aGt4YVRBbVRQWjBWbTMvRDJXd0gwRkNWV2d1S3pmSU1hbGVURGhwTy9DbHNybmwvcnBHWDRUYlRkLzhOOVhCNFVpaGtUaGhOSFE0aHBhd09zaEVKQk9naWttSTU1UmlrQnQ5M2wzdUlWWjBNRWFqSXQzQ3BvcEZyZ0hLc0ltTytCbkRYbW5OdDM2VHBxMnJtMVVnTDJLam1PVlV1Y2lBSHZIUHRLcEZTczZMelhIZHFDVCt4RFNEWU4ycFZ0aE1tbmUzMUp0cmMyRFFCdzBhSGhxd05vWlY3eDU3ZnFkYStSSGtEQkh1UGpNUUNCc2o5MW5Fb2NqZ3pQdWxnb01TYS9ycXhoSlJCdUFyWFAxUWtFeFp6Rk0yYmZMcUg2alJUYlZ5Sm1hcThLa1gxOGJSNE40RllNU1kreUI4OTcrL1huVnNQazhyYXBLNFJOa0lZOVd5RUFBNUpaVEt4NHVIem04TlVpTkRpQnFSdzRqeGxiU2lGSVcrV3UwOUJGSWVhckl6alR3OFJ4Z1BoSXQ2eGZPc2I1QmZvekttdHVmS0RoOHFhUFZTNURnY3RxNVRaMGtUdjQ2RExja2tVMTBMeXNsMFRURUNwemQwMjNnMnRpN0JNc1N1MU5UOWh3OHpma3RTZ2pBaG9VOUp2eDFzSi9nL3B4dnZkLzFuZUU4Q2ZyMGJKdnlyVVJnMXpUcGlMZGp6UGNxUTVrdXpoQ0NxWGFkUGYrVGdwNFRVYitmOGwxMXJZT0FnQUJCUDc3QWdPMVhCanJUbGNqamlxcTI1OFZGNkdOK3QxMG9rZjlETWNEM05FM0dlL1hlYjVLUU94UDVoekNNcy9JaEM5dGpGTkpGcFJZWHFzTDkyb2lvdXJSSGFZSUJXbkRMY01FVDEwWjdDZGtnZXNRRTZvcDRoWitWZDA3emlVQXRhRCswTXVTa0szYW5INU9hZmJpcjI0Y25QbkZWeWc0VTlYNWpJQWZLMUhOUThuTiswUmlrQmZTTDBoanB0UlRHYktIS0MwWjhybXNQYllNaVhvMTdzRW1PYVJ1SDN6RWdXSmZ1ZEx2dmhXRUxCeWJMZ2lIanNtUFNEMkVIUExSRVM0akRPbTNEUmlOaDZpM080MEhLMlNPaXVnL1VrVEllYjB1OEpyaEE1cVJMYnBWRU1zSkF5K0xBc053aSt2eE9sUTZyQlFodUNlWE9CeVNDQkFnNVo2VXVsRHRYTzJSOTJIbExJWHFqalpqSWRPNE8yQ3FPSS8wclhpbzB1Z0RRcUh0TitXYUs0ak9vTS8yb3Y0aGRCUGQwRmdjdFlLUFhqcTJUajloYklrOU4rNy9IcVVFN0hXZmlydGgwQUVwdnlmejdPSHI5WEh5T0NrcVVYY3kzOWNFUEpGaUZiOUwxRWNjWWIwck1NOEVRQnJlRktDQWZWSnBOY0Fjb0F4ZlBEY0ZDQmtYRmlKTVdwNGZYN0dEb3ZnZTdJdXJNbXFTdGVSUFZmRTdxaWptcUFaUS9YVGloUlphYjZlMUk5UEk1QlFrbE1iSHFSalFlNEN6QWh2YjNYMUdpbWpQY2M3dGttTEo4bklMYVlQb1pGQ0x6VnY1NWVZTjVOTmhXcitwZ0s0OEFoOTNpdGFMQWhiNy8vNU5RY2h5b0RtRVc0Tzc3bmFkdEQybStCWHFScmFTYStQOHZ0R0hpanllVjdTR2ZIZnpHMndIM1ZCU3NXRkZDUVI3RXBkdy9sMS9HWHJadnlpbUNmVHRvS1J6WFg2b2R6N3A1Vjh2TGV3WCttazFoSm1KRTZ4WnJiNUovVi9Zd05xQ2JBV0VCRGdyYWJZWjBnMlpiMXZ0ZmlwbDBKQ3ZmR2tDS0tOSnJ3OVVUczFIQnRBelFzRm5NZDBoUzFmaFovdmRtcnd2czNqSnQ2Wk1McktDbWVXbFdubXlDbXdJREZkeVBDbWQydFZudmIzeDFjUGZyOWtaS3VzUzBuRXZGSnRzdEVhQ3hlK2dMUVVZVk5EdVFKTjg1Y1RHRkljUnpuRldLN2ZxdmZNY05GcGxiZyt3bHpFTFVETFJJeGIzRnppZ0NybGw4bWtNcW1pemdCYlZlY3pqbDhMbjRUZ3NnRWRQNUZPMy9Ed3BzRGcxWXNocTBNNEhwMFFtemdCRnlLUXR4bkVQWHJZNHJEMWROVGI0MFVoZG5sVVNPR1BVNkVEc0JCYWNKUDRFeUQwVzVMbWVtV1VsNEpTQUNPZC9reTByL0plVmlMTkpUTVkxbWNEMEU5SkM0djJRRVIyYjVmaGM3c2tHQ25sa1N3aWxSWDV2NE0xUWtvQUcwamthc1VwaDZ3VmxYNGsvSmRQOVZHbm90NUVueUsycVBKT044WUhrRVQ4ZTV1MWVqQlljTXlmUldBMU9QczhlZjJDSE1RQ3pPbXF6dW45QkFvWElBSHptb0JFelRXb3crZENaWGZEV0FzWDBGSkdyaHVmOW1BS3hYOHVQeTk3NnM4Uk1COHBLVG1pZ2E4UWsyK1U3TTJzd25oNXp3QnVZTU8ydFlpR1JqS3Q3TlplNXRJT3JCenlqZno0UEhleXloVGJoTXQvZjBtNkpidHNDQUFFRS92c0MvdUw5aVhhYmJVdk5jeXNoY2hHc25URXNESEcwVEd3ZG5QYmJobGUvZnlvVWFIcjhaUXNDcUplZHhCWmFubUZBTHM4ZGE4ZFFZemUzZDRKZnpJK2ZoVHF4Z25BWlRoaGttTTI3ei8vN2lsMXRJY1FpeUxLdWJ3SExjWUlpajljMStpa0dzcWJoOGEwSmphbHVLZFJ4L2hoWXRWYm5RSDhBRlpTN25wcFZJcGV2ME5uYmhTRUMwYm1Nb2daWHMxWSs5OFJrbG1VSDZaRjl4alVIaTV1QXo3UFhuQ1k5Q3U2WTlWN2dBZmdha09TVkkySDBxcXVnbVBmRThKd24wOFRGeHEvd3dNVkNNZ1JzY0t4UG5ZVEFGcHVieEMrOXU1VkVIOUwrenFZb3I4NU10c1FKNkdzNW5wQU1ocUdrUVg3Qzhaamd6cXVLbUE2dEVSWXB3MUpVZ3gyUXFSZ2I3TnJodGxFcFFEODQzVzJNR2pSK1lmVXJsdEVBM3dhbE1VejlNWHByOGdDWDJZRU8yYjFvOVlCMGk3ZUY0YS9hbkQ1eWJONXNwMzdieUM1RSt4VWw4WjYyVG9TanlmWXBabjdVT0xENVFYeTRmQWk4Rm81cisrQUY5KzBvUjA4YnpCSDREMXYvZ2VMR0RSSTM4YzFpVTVteTNLWDJERW4wMnZHUXJiaGtvRmQrYk50dTJJVlR2NUp5cDcyOTZQekRQVjlsenQzdjF5c0lVT1dwZ1BtT1hQM2JoZTRUNmdvalhsc01UNy8zUkFkSEZNNVhqTUVOazlpMi8yU3hsWmVKMENGUE1YOUhwL2UrTnoybkV4UVlSSUxxcTFEY1B0VnJLVDdQVkNTK3NGeVdVU1d2WElEb2haMzRlcEsrbFF0VEJtUmRZTnVuaTdqV2RPNWdmSSsybE1BbnBOU3VFczZOcWVOSjloQXU1akIwZ3ZHMXdsUGJzL3h5aHVqa3pMQmpCSHI0QndNS3g2dXZpVjVENkIrcjVia3FrR3ZUZElIVTBjNVJ3RVBIZk9hSUdXaXFBTnJTQWlwQ3FPLzlaWDI2K054eENrc01hOGZyRzBIdDdZL01PZkhkcE96TkV6dlJhSFkva3hndGc0bFh5alpEZHZPWjgzS1lJOHp6QUVha20zd0tkcFBtNC9YZ21mTjc5blVOeWRuYnJSZlJLOXdRN0ZJTVA5ZFVDLzh4dTMzVFBJUXRrNUpDZEFDQlQ1U2lWWW5BTU9ZSTVJb0Eyd3NDNXZLQ0pvbkRIQVI0amcwdk1WTDZOY1B0dGVwZUJzd3lLdGVibWJZcFAvMnovRXkreGlZaEl4LzBPelF3ZUNiMXQ1SHRUclErUlhqazhZMmtFb3RJd0wySTU5Y2g1RWI4aU1nODR6Mkg0ZXc3alUwYTIvWktPWEh0ZThGQUVmd3dlMUlNWnpuKytiUkxCREYwcGZpWVFjcFViZUVUa21reC94MXYyaHBTZ1gwbVIxV3N5K1ZSVjV4ZGtYSTdSSlNFaFBMUmloZFRHRkFhQ213UHJKcnAycll5RUxBTUx6bXZ1dDVrV2llTExvclJXcFgrQmo4TFhPWTJrR1RReHVlaVFnQnRORURnV25BVjVzQk5XTStocmlKV01zdTJlZC9ydS80MGVFbTltb3lVY2N0NXN5UTljbWF6UEtWK1dqQUtMRHI5YndESVlFTjBOaURLekhRNkhycTFEeUpBVURJYnZnYldoZ01qTW5mZzJHUXQ2MlhZeDJZeEhFd0dqTHBZT1JXMzRVZTI0WHFCNmRwTFM1OU9PWU5uci9RdHdldlBBSnY3T3VHOHdRSUFBUVQrK3dJSmpvR2pWZGNxNEF4NXhMTnRqa0VBeXVzT1R5TW5PUmhGZ3V3cGhLdVRIQXRJekc5VFR3bHhOSDlTQ1R2Zmp2S0h2WVMrekpybzFtcUhCV0FHa1E5VzdoVW5YUXRjMThkRGJuL1BGNER2ZHl0eS8zZ0VDNFk0VXJNKzhRU0xwanRCQjFRNXVmN1pteUVJaGNDcWxmZzQ0ZS8xS3RRVXkwa2dNM3l0S2FKMEYrTnJ3WGdwVTRjQVdhdWxMVVE4S1JpNlhpY05Fc3ZtWkdEMERCRmFPWVJkUkFGeUliOUhvZ0xmUDhzRVo5NUZzYU5VRXNoTzF6YVI4TEErSlI5T29IR3VCT2JnYWU4ZDhuNXArMmt1TkJrZ1VMeHMyZXl6UzBSSFhSa1ZTaTlENDQ5QzFGSkRRSmZBMWs5ZkcwNmJrOXFvckJraVM0dk9ZNTVXU1pXaS9TVjRyU2RwQVA4VGptUU1KY1c3SVkzSDNGdGFhM1d3cG0xZEl4YXp2YXB6RGc4eXRKZXltZkJaN1Y5VEt1QVMrVTFOeU9rWHhCSFE3ZGNOVzMrR0NDa25ETWR6NUlSY1Y1dzFiaUpRaHVKRzJ2VUNRemt6dHV2UEZRM0cvZGFyRVZHRE9OU2psOVJCWldFT3hnRFdBZHF0WEJvVDdLYjBkOEVFL2tmdmhoSTdYS25mVFdYSDR4NGprT3I1NjAzdy95dkEvQXF0dWJoeHV5YmdJY1F4NjAxZnh1RElRaXB4bTQwYkU1YU1FdmF3cWxIdHMxMklBcGprb3NpYzV4U3JJdEpqV3RQWlJ4RG1NSUppS2F6ZkdZNXBtSUw3bnNtUDFXRHFVK25YKzNFL3prYkljeWVSbTRKREhFYVlmdHJpR3hBN3dwM04rSFMvQVF5c0doeXV2WkZGYWx6WVhHNzRyYUJIL0xZUXZWMkF1OWVhd1E3Yk1qQ2JkOFRGLzM1VkdPMFpKcEc5cms0b1pHamZRQ3NLcVpCVXR4enJSbVY1Zzl2YjIrZGRPNUhNY0gwa0ZPaVh2dU13TkRWRTkrNG44QUQzeUg1S3haK1lHZ1VUZmxnbWMxUVVVdGdicGd5ZElERzFtelh6RFBmZUJYczRnc0VRVjhjUElyUkMrVzJXVmJkVks4N3JveW8zRzU3aUJOTEN6UnJkMUdtWXk4a2ova0Y4eGh4YVBudzVPb29EcnJvM25RMGs1Q2puUzFHQ1Bxc0JtTk9ja0hKOFNMdWVZRjJ3TFRvSlJaS3NidjlURXIxVVIwcGEyMlYvRTJvdWlMQnBEbDA5ZktJMi80NmN1TG0zdFdkMHNJUEl6S2YrR0svbk54cmhnbWkrSG1MZmRaRFdOYi9QUlRNQ29Qa3FmME5JQ0w0RWQxVkVMNzUxTVRGVmlZNUVqYis5NXBYSlRCMGJ4MVNLOGM5TStkSXZpQkx5SE5vMXVFTVhSL1BUQ2N5TnI4Q0N0MkdTYVN3V3JDRWF5N2kyYVgxY1BJUzlBV2M2ZDJHTXc1L3gxRnNhTkxRYTMyQTlNOE5xa04yTzdmYjVnVXEyeThaVVcxMkRINmlMdXE3TFdPQUhsMGxEQ3Z3dERXdzRXSk9oM0ZnMGlHOGoyc2d4YnVrWHg3NUpQNVEzSGo2S2ZlV05GcU5Gb1diY3RJak8xbmM3UkZsQkw5aHBpekRhQUg0RW02WlZBMGlvWlAwYUNOSnE4WGg4MWZHdDBBZGMvUExUQW9EK29SbGM3MisrbEJPajBEdWhkcVVhUzR3dGN5K0oxdnczWTVrTHM1d3VibXNMc0dHVktYTllWMVF3bVdKb1JGYlRRcWpLQWdBQkJQNzdBUVFIUTQwYzhLd2NyT1dvd0llWVJ0UmxVTlFmNGxHRVc3b0RpVDQ2YUVpRTVlT3l0eWNCT2hSUnhnMUNyMlVFem1FWE4wczVSR1E1Z0EwQitza1pjTCs5RkxyLzBVNFl5NEpwanhPVE45L3FEUUh1Tko3ZWt3NVdvbUZ6K3BQZTNmUWl0OHpicFhhcGNCb1FiZnR3S3VEemtQMTJzRjMrMVNLc05CVmhwdWRsNHJ5dVlkdCtIVkJLalpLUWg1am1iVU01THZURkR3ZFEwZnZ4TktTenFja0E3MGtFWllXQ0R0OTR0YWs5bnRCek54VXEyYm95RThBSVBmRHdvQWhJR2ZlbERScVhseFI5eXd6RDl1M0xHN0xCS0R2VUNBcjJIUVZnL2dEa0tyczkreDZIM0tVZm5aOWR5eXlsd29mZllaajhPclJEMTZubFBDZFZQd0ZQcXZ1RXZXU0wwd3lOcmZMRStUR3FmYU5UOG1QblJQMXQ4UzkzTzRkSkVJQ3Z2dnUzR1lDRDNwbDFydkc2cGhTSnRjM3NmRzRFSk9SQlVjRjFSejZ5MjBXU1doVDk0K1ZjWTI1SXVzdE5CNlZzcWtSekh1Z1A1OS8wN2pELzBSWDVGRUQ3N3Vjc096anFldlkzRzNxU3hnL2tadmVNZ0FnV0lYWnRzTG53Q0xwbHdlZVR3NTA4N08yU3lueE05WEd1UUdRTkxUeTAvY0JDOEpSZDF4TUN5Z2Vxb09NUlVTcERQM2ZTb2FQeXU0NHpSUk1MWnFmQURQeUVrQU9aUGRSUEt5eENPLzI2THdNY2lHQWxObVRlQnhkRHg4ak9FVmFGZHVLNHlGSDZjaTFzVkc3aEhOVlgzU0RQUVhtaVlBYy92N0x0QlkyZW5VUmtTZ0xRdG1iNXpzbE5PU2VuRm9HTk9QZHBnUG81T2FDQnJXdVRyUTIvd3FWZGY4TFlzMGNmWUZSVlU1cGp0WUpjWmJ1Ukd5RE0wcjBUZlFXOTg0NEFLLzhLSlhLMk5rbVF0ZnhVdUhVK0dqbHZyb0ZhVllpN1RDTm1ZUWJ0Vmh0UzBnSmtwUTNhRkRoZmRuUnJjeE5XTUpxWTBIQWF3L0xaTHozUWJJM3AwcWFtQ1A0c2JOa1lxdXFLNCttMURrZ2xNSHVOVUVwayt6TVNIRzk4bU43R2JvZXdUOC9NalEvb25ac3hZODc1bGxYaWY5eUIydlk2ejR0cjVoMEt2U0h4RlVSRDVlb3JqVlFITHFQTWo2bzk4cWpuWGpBY2RmTk5WcUp1RGNndFZMQ25QY3NES1p1V1k5VFA0VGJxbjg3d1dFVkpuQ1VnYW5MUjQvOFo1NGdqTWk1SkZzMVhZNjNWMlQ3djdsdGJ2Slh1V1FSMkRCTkliTW5BMzR3L1d3dlFlNFlBdDc3OHYvcEpya2I2RUhSMkNqRTlNQTVwaXUvVjA0TjluSDNNQm81T1d0cnJDcWVORjZYR1MvcWdEa0hMK0JlcEJhSWNsTWZ2M09zdnFpbnFLNXFnMVFURFFXRTM3L3VHZUFjN01BdktUMFV3ekNiMDBZQW9UR0dPaWdwUnd0aFFTREV3OUVEMmNzbUZsMTRicDR3QW42ZXBqSGl3eGpvWWxwYXEweVdzMXcxOTE4bWV6SFZoRUpZbUVZNm5KbE9lM0ZkWnI1SXVRQ2JBeDJ6TXdNaVdHQjFHRmJQYm43TGNkZS9VdjJUZXJPaUVUNUFnK1ZsWmtDOGZrMUVZVHg5TTBNYm9QTHgyT21nczd2Q0luemZyZFJxWkpBM1V5SDhLTnNaaXhESzFSdGVZanhuVE02Z0NBQUVFL3ZzQS85V2RyRlNDMWNBTXNsM2p4MXZNTWtTUWRkblhPbW5pazV1MFZtbW0rMHBaaWhZaXJOTkJrY2J4VHBveEhEeGJQdE0wR0JjaUFkUklnYWNQaVhDZW1XRkVleGhzbEZwbWF3VmpldDJpbUdBcjNCWDVrb0laS0RjWmVTQmRKVCtHajdDSzZqWTBaQjcxQ3Q5OVhpbnVtNzNZdzJoaUJyUWdxdEJGOWFaWXVZOWlpSjF2OVhycnNHSGp0RUtQVHUrRjZiamlzaUVYNWZxYzJJL20vdnJGVisxU0YzSzV6dE9oLzZEbzNxL2JwZ2JzWXFHZ2cxZ3RWRGFjRFZKWTFqK2dGUFRmbGhUbk1WYnZvLzd4VDJoQnlSSFdsUVAyZGNXcmdBdlEzRGJ3V1Mrdnl2ZUdIMEN2a2lTVXpLQjVtemRCZ0cvMjFYeXVGM0dqVTF2UUNXek5ScEU0a0x1dC9XKzR5b1QvTFhMTi81M2YreHA1dGZWVDJSN3lhbXJMTWdFQWFZWE05OVgwSENzYkFvbjdkd2gvU0UrYTc5a2gwM3ZZUzRSVTRQUENOZU9uczhPNGt5RUR4QlpPRmRKeUdGQVJ0S1FGTFRUcFRFWEc5VmJIdGZKenhIcTg2amNkdHVMK1J1RTdWN0FsZjJUaFZ0VXg3a3B2dVgydkUzVWkzRGx5dzR3SzRXWGhlMFJuTUY1WEZIVFJUc3ZMUXlMaEpWMDBGb2tLbGl4UFY2MDhZR21oUFJrbE9VTHczUTYvcDhVa290ZWp5cERlblRBUldSYzFzVHNVUjdCMzZpRTM2dlBBNkErMGcrZmE5ZjB5QVBKMXRBV1lyQXBqUmVtSDBZZUYzR2pLeWU5UVVzMUE0bUhneHR1WFZWRTBxbnhnWDVtMlNoeDFFK20yTEIvYUpYWi9nNThXc3lPaEo0cXRFeTlsem8vdFNTRytad2tab2ZjRkFWL0hSbGtoMlJBY0hLUDBDUTM2eTBFc0kvdzZYR0g4UFV3UzRQNG0vcXRTam5wT2hzOC9KVy81OGYyM0xWd1JTMUgvTEFrYW9vNzdkdWl4Z3VLSndiNnphU2ZXRkJLdmd0T1JlWUlmVmdxMk13UlZQRGFuYjVVZjRBK1YwVGRlTVFhdC92UE5YSFdGUkpsejdicHdPaXl1V0l2b3Uvb0xOeENHeFBJb1JvWFh5WlhEVE8zQXBxOUkvU1N6WkJRU0xDRitYUmVWQnpjVmFtTXNNTjhRNjRqS2NxZHZIa1MrVWl5ZnU3M3BhUi9saEFRTk83RUJHR21YdThYNG5YbkhObjBZK0tBVlpWRlUzMlBQQ00rMVVMRDBkdVl1OG1iUjJQRE04MUplMFM4LzJNUlpNWUJxVTNMVUlSTlRYdFprWnRYVU52SzYrS2p1OVVZSUNUbm1Zc214cS9XUVRVNnpuTkRUalVlOWN6V3Y2S0k0a0dzM0FqQTVUaVZIU1Z3cXNyb3JjbCtaVEVudS9GUDhaR3BFUENiRWhxTnhXSm0vQis5V0kwK1JZSCttWjExdEFWejAvY2lxSkRBcjZOaTFQSURZbVVnWjBnS2l4cmhoUkZESnBsYnpmZEYyNnZFRHM3alUxRUh1TVlKS3U0ODRPR0hnY1p4K2VuMzIzdXl6TWwrL2x4V244ZCttRURCcW11RWVvanpoU0NmcGhDL2VvbTVCenB2S1MrQmtlTFE1M0VuQUtzbW9SaWFiMDkyRzlGNjgxVm54QmFHYk1LWjhQUEd3a0VETjk2ajlqdkkwaTdaNGZrTUhBWnMzYVlUb1JnRnhyVUo4YWhXOXdUaE9kSlI0cVFJQUFRVCsrd0RhZGljNzJXalZlV1AxYjYrN0N2MFhKWHVUYVZSaS9hanJEODlBZDd3RDJmYkVFbWVQQm13QjBrT2V2dFl3R0dxR1FyZ2haV1V4bDRoaDBqZUJFVGwvVHFoR1R4VkNtRjdzK1o4bG1xejN5QmJaR00ydWJxTW5mcUk2MXNMUGZMaUlYT3hrdE82M2h5U084V2FTMWQraHNVTWNFYjVrTUtNeEVBQkU5d0hFSkNkdXRva2didmc5NUVFeDFreGtscko3eVNtVW1KV3AwNmJqTkxvZ09IaU5iRWF0LzhaZ0ZBdm01c0hhV2M0UzJiOU9DNzNuWU5JcnJCbGJMN1RybzUvakQveENIQVdaYnFyQktZYmFrREhBSnZiaDRRRERuNUpzdXQzVDBwZDk5bjZSUHkyaHVxN0tBZmdHL08rWjFCcGJnMjRlc0t2Tkhta2ExWXIya0w5MVBzSGFWQmhVVWxqbHQ4VWtVODlnL0NqUG9xOUhsNW1LRFU4dVRWckdqNTFzQjgzUCt1T3JMZUdMdHBEMDlob0NDVzZnU0l6NVU1dVpPckVaTG4ySmRZZkJvUVVUOXo3aW5zSzAvdllrYk1mR3cxS1JFZmxXWEVzVTlUR3NOb2ExYUFndnIrREk4dWpSaW1BZkVzV3hyWTgya20wYnM2eUJUWjl5V2YvNm5NUFo3azZWVTB6L1VyY2U4b1oyMDA0eVQxMSszUDAxMGNxY1hXZFkxTFJVWjY4aEJSVHl5ZjV0OFNicUtJS0FVbW1kU3NuU0k4ZHRHYm5rNmlOSTBmeWtVeCtNOTQybzVlVlE5MndCUHMwQ0wzVFNlM0V0MlhRb3hQSStWV1p5NDZTWkhqVkF5RlduV0tvNWxjaU0zenFCRjhJQ0pZSXEzS0kxaVErWmg5N2lteU1ITDFZRkRrZUM2UGRqb2d3d0VjZUg5eWgzbjQ3TWNiT1pKc2c1aXhIc0VJUk5JQXh1MXRDOXEvTHFpamJselQwa2pVOFlxRDF4R09sekhZNFM4QStBbnNlenlpQS81K2IyNUlyNUw3L2JuQ3Iyd2pVSnhLMWxWOFFzcml1NHQ4RkZpWUNDU1ZOZ3hFbTlacUlUNUpzaUFhSDV0VUZMT3M1Sjd6bm4yZGRhUldDdDBjMDZiYjllaVYxblNnLzBBdHFYSE0xbXloenVVMGxBdy9vOEk2bDNPaGhhVDhaTWxUVk5SZDREdWp1eGx2TWhGc2NtOWJPTWJQVGtqa1VJVTg3OTN4UUJ5aUc5YUJ2a0J4ZmVIWVhHSmpyZVNENnBQdktsaTdzQzFFaS9LK0M3QkN4N3VQaVlORzJEaHM2UWRZN2tCajA1NWtPOThhT3hUeXFGVHN6TE5TMFhuU2ZhMDN1QVNwRG95UmJrVk13aFNnd2x0SlRhMzdrbk0yYm5HZ29oTmNUMlY5bzZsSDJuc2liV09vc2tSTTlMWnA1VTlFb1VGMDYzdDdlOVl4SkJ3Znh5SExyRDhNUzBncTQ5dVZxYUJkNzE2N0ZGTEdVUTdJSGNsaEdkK0oyTXR1dlBBaEFhVEJEMnJTUE94eFpmcGltbUdPakFuRDJGa2VaNU5Jd3pmbTUyVzUzQVVnNnlpT3J5VDJ5aWxVcVZ1MjlFMldYNSsxOWhzSnpyQ0w2VGtNUGozS3NaVlpNUmRiRDRnQS91bjlUODNGTGNVVVR1VDVOS3lTL1V2TFlOdjhtcGFWTFRsK3l4VHFUdGxwcW5aTjdwY00zL1hVcUZLYVd2cEUybU1NeW03bjdXMUFhcmUvdnhnWTh6YVpPM2JRbkRoMk5OZzhKdTZ2czhBZ0FCQlA3N0FJN3h5ZjBhaGNrdmN6VFhnN3dVUXJ4WHRIMjVQUEYxNVpJazVtakhETFkzZ005ckJjdHQ5amcrdWxqZ25OdWVlMVJtaGEya3dSUEFwUW56aytVM2NJdGh1MjlWVW1ES2ZUVXdDcDFXY2NJRHIvakYvdWhpZjVIekRyalJteHNPdEpHblVPZm9pR200MXZVRXo0dFdyMlJNRUVtTWQ5NzJTcWYrNmNWWUZLZVkySXd4NmdGcG9FZWxCUTJXNEJyRjd6aTEvMmhQTHp3NDdVSCtVb1VrWVpwcmVpWGh6MEswK1pvb29CQkpEOFpSbFhWaHlPZkFsck1maWFLTlFaNHFaZ0l6QnVGZThmaXJqVThBN0swSzRyVXVxazR6Smt2bUFXSmxPMHczWHl1WmROVmtHT1RRTDZkVENBczlySTVTMXRiaGQwc2x1UHlScTErQ3hQNnZhWHNMQ1RONHpJbzlmNjB0YXoySkx2TVZWMVNuYlFSdE5BN2pUeXdMYm5WYXhNSERSYzRSeCtHWXc3eld0Yko4THNtRFR4czFXRGdJQmU1TTA3Q2hsemZMdDJiT2lvZDBveE1zcXFEQ0xQZ2ZKalRSV25qMklhRHZpdjJleDNQNUt0b1VBZDBzT2I3YXpobHRRQzMwTk5DRmZzMmoyS2N0R0VraEFFOERzKzlvQy9KbFkyamg5S3I5clBIcHZ6TjBzaEdzd0tXYW01RGZhSFN2RVJLS3AvdGxyd05rajkrTmRjcjdGZHdlSWxlYkkzbkdOaTY1WUpqNndnblVsQ25GNlgrSHM5SUF1c1NDRzhjSWRrTTYveCtqOVdzRlFxZ0FTb0F4NnBKN1YwTW9SRkdPcWlkQTJ0SDlweXY5bURja2FBb0Y4bG5idXNIM1pUTCtIMEtIcDR5TXFMN3ArczRNRnlCUFdhMWRiT1QzYzc5TUZFQUZiditSTWlEWnFsN3Juc2p5NHNDTkFHWmpwNHQwMTRqNVc5VUxiWXFFUWowSGMvT1o0QUJmOEV6U0lzSzhDR2phN2RMZWVSZmFlbGw3bENCTWtlWUkzZi8wYzlYSW1tUFllNDN5TnlKQlNGQk51WlkwWFFVVU03NUdML1c0WGdsc1lua1RsK3ozM1lva1VSeElVUjZCOUtDRjFyRHhHY2dlNkZaenlzdXk4MW9iVUtQUUNlZnY3MVVJdndUM28yOUVlaTVqNndZSjZXSG5wN0M5TTRCbVpiOXYzK0dzdkJZSStSSWdRcFV0UCs1NXZZeDdmRGlTVmJTT0l2RnE4ZE9SaTdlQ2lTU2hlZG13TmVFRllnSStrZ1dpcFJ5MmtjSDhMYVNMWUl5STRqYlkrMjV4Zmk0TzlhaHlQQlVCY3pkb3hPcmNmTG54R0NMNW1Gc3p4RGxCdEhCdEgyOEFSSTU3R3VFS2hkM3hYZG1wSkRIdkFPbmRPQmZ1ZCtEMGpXL2d6TmlPeUdoL0ZMeGZMc1RpQmN5YnJkWWJoSmFndlUyYm9EQ0V3aytORUtycFRXSXhmajJWNnpsaW55bkMvdUpFRlBKQ0hDMlVhUE1UYWZieEc3ZlhpSTJjK0hMUDhvV2FaeTIxY1Q4Tkp6Y3craDdkUFJmcG1TRGR6M1ZXL0FNK2RKOGgxMHZXS2Vzc3JjRFRQRnhrTDRnRm13WWp6RHlOd05ROW9FN2VITkI2c0RPY3FHUkJPMjUwa0lRM09CZWovSllmbm03UWtTcnYxNE9SUUduTXBtR3dPeEVVdzBGTEpkT3VXak81dTl5VFJ4bUlPM091TzZabjlDWG1kNVNaNTMveTJRclc3dTFqMFpFQ0FBRUUvdnNFdEhGVTlMUlZxbHYzNDZzbmJENmNLTTd1eHZ0aVk0QS9IeUtHelk5R01vZU11YXVBTjBSOHYycitaM1dMSmFPSVJOQWU0SkZyK0NOQnJBeXhKZlFkM1BtRzRTMzNxME53T0dlVmRvWithazR0Y1dsQUVpQnY4K2tDYjY2OE9Ya0hmWVZXU0xsQ05NUTZpem5BSkdheXNySjVteU9KVWhSNlFHVHFwK0lMR0J5QmR1LzB0ODUrWGcycjgvQnZUaElOdG9jeDBEZjh4TFBBVkJKajl6c0xsSHdBQWRqOGVBT1poMWJFQmVxaHRSdHozenFmR3Q2Y09IcllQdk56L3BBOTRpcTkzVGg1NEcwVjZNQUJINFVYYklaMENhVnJkZHl3L3ArMW1sNzNEL2lWdVQ1MGxaT2dLOVNBL09ON0VxZG9Zcno0M0wvQVFMemZoUlhsT0IvVGt5bU5qS25YOXdWMklia2JxMXgzVkNXSXdPWDhCVUJYK0N0Sk9QTzdwZkVNWEE3K3BLSlZOUmlKQTBZSlRoMDFoMWJ6dFltWTMvWUVvMEpTWDUwS0RVUVVRdjBqRzBLU0p1djQxS0t6Q1hMaDAwWjg2OHBmWGxwMXpJMWZXWm5rM2ZUMmEvRGlFN1FKQnRiRWkvNmkrS2RjNitobWZlT3lkQjJ2VERldEhDNHMzM0hQd2orTkhiL1Nna1dxbDloTjRidDRBOGRGc2thWnBCbklYVkF5b1ZCRit4cDg4NUVEdGM4VnNlR0ZxS1pkY3ZManJxem5tZWtPUmlUNFBOYWdiUDZZMmhHNjJvenNZdnFxUUxXTmRYaTZpN3dualpuQkJLdy9IcXpHb2tlYm15b2ovbmFEMnpUeDVSZzRQaTE3TmpZaHl6MThxcFcxRjNBRjNvOE51dS9XNFdNaHZ4aUxaU1pDUm9CYW9LT29NMURDVUtiWFlLci94UzBleE5oYmpLb05PQTVZMFU1aTJzdGxoMGhvcURlNy9IMllqQzFXMktnOEFSSU55YnpDUS9EcUpQZEgxREhzYTcvTDYyQ1h1c2Q2RlpXVkp1ZU8vMTFDckNoaFVmVmVob1RIVkljYzJUVUdtS3l5L3NCbWxLcnprZVd2cXpscDdBZ2lIT3czelV5VjRCTi9ieWJwVzVwT21XeURSckMyem91OGQvN0cra1JrWnVpZ3d4eEJVNXRRZjBHZkxrcFBsYlFXblc3c1kxSHRzOTR2RjEwNlZuNHdyN0Eva3NKQkIrU2FMTjJYbzhjN1VoazVIaWVRellJZ0MzbVEyQWN3Rkh0dnYrOGxmU2JXTGxhbFRXZDVLNVZxMW4vOTJINCsxWmpucHcveTQ3V0lFaTVabktDdlhtNHNWN2orODJrQy9NS2lMVUVBTFFZYk4rN3cwS05XbU5RajJpN09nbjBIaFFxa1JUY3haeHpXQjJLdmwveHErKzB5YzdNZE16bDBQMVBScXRvQTU1Y3ZIQ0xpWlZWOC9jNGNVbU00M2FjV3hjVkovbDh6L2Q2R0NqTVhWSERhSWJvbjNCR3FhTkwvblc5SkgrYTJoOHZJZ3k3dEs0NVovZmExTlRQN3plRXlPT2lxaHRLMnFJQ0cwUzZwQmhsZjdUZUU0UlZraytHUUNnZFZJWlQ3SVkxaWhDc256aFVpdC9iTkJjYy8zZXhnajh0V0UwT1B0TzlYeC9PUWtUanR5RHowMVR1Q3Z0cSs3MEtqM3V1R0NUL21OVlZOdGdZRThGWGVGNWQ1dG9ZaFBjdFBRY1VNQjl0bklUUm9FUGxsSXJTZTBwaTNkbVVJUVVVYytZcW1nQUlBQVFUKyt3Tkl2Tmg3TjJIeGEzeTZFcmtvUDM4aTBHQkJDd000cXN1Vm8vUlRQelVxbmU1ZG50cjRvOWFra3NjMkh6MGVOUXZjZC9QQU0vNGFlb3YzcHVXT1ZVRkQ0eGs5N3NBa1MvRWUrU3Nidjk3RGpVOFByTzJHYjFvQTRsRlliN2ZSaTdYcTBkblFMbTdRMFgxYjJHeUZmN1RTK21UMHk4RXVsdmxxM0xpOEJXbHNCUmlnTkMycUYvVGNld1JUZmVLYVlQL0ZXSTZzN3ZNcHgwdENxL3hpRUZycGNEV0ZIZTRSOGxNd0RSMUVXbWlFQmJ1Y3ptWFAvYVJlMnhDM3ZoZnVSUSt2R0l5U1ZZVVc5YllOLzlMaU0zU0ZwNEY5RmF2VnFibFJXUk9lVHYwRUsvaEg1YnRySVB5cCthbHdXT3I2ZWRrckhTU0hrT0RGSzhBd3REWk1ZT29GZldoY1NBb3lkNk5EaE1aVC9yNmUwd0lQdU1kK09Wa1ZFWEF2SjlnTlRaS2FIQ1N1UTBHb1VUWHlLQjlvSEZjMVc3TTFYd1hLZ0ExSEd0WlA3WDRWVFJBZWZSdUprOWFFU2d3N2pCTlovZG9iblg1T1Q0ZFg0bDY5Vm1vV2tTS3diRy80RVdUckw2VitmemlESSt5N1JOSmUwT3VpV0xYUkRqeGhLWGxJSmlQVmJNaEtMU2NsNGlRNS9sQm5NRGxUUkNLc0dSTHZscmJmdzN2YzNEcXJFUWhCcjJsQTBOeVFKV0Z1QUhJQzJFVEppMWFReTdQM1R5RERxdWgzQjd3VGJDNUp2OThDL2JlUkRNaWJhZXREbDlLV1g4TklWM25QbThFZmt1ZFlWVkp6N20xRjNYemhFczhNZ01sb0pnbWw2dEEvTmlCRzl0Zm56TDdIT2I0MHlDd0pKejRxUExEMVlNcUhna3dyc1NJSU5pTUc5UW5Qc0RuSFpRZWZhRUJKNTJLK1o3V0NnWWMrRlVkTEhjWThxZUNKZzVtWFJaSVVKUlRrVEExb1A0aThkMnY4VlVRejRwajFlNy9iVElUdURkQXBTOXA0YWI5YWtXbW13Zms5VnkzU3RTN1FpU2NLQVR0dDIwUDBjL3I2K3ZFWjR5bmJWTlYwWnF1b0ZsdmhSdW9BbzZyVlE3ZjZ4RlFnam44cGJqREtEa1RFdU1iRXF4ZGdlM1MyQlE2eVVLaXh1RTlBVCtTa28vMm52VHR4T0NUanhMTDJDUEs1UDFHbmhsNHNDSmc1Y1VvOXVNV1RkdU9RTExvZWM3NGtyNm1melRSdzIzQmV4K1AxOHQyOEk4RlMvRlNMVFl3SWtPVllRWW9CN0k4SG1DRkU1TFFaazNwMUtEWTFLNzRJbWgrN1hCSFBneWh4R0toR3hOTzI4NWIxdmYzdzE1ZkRyVWd6bzZGMXMySDFjQkM2UXVNa2VtMXU2RXVxZTBvWTZOQWs4NTkrVGFOZDhabVdIUTBIZXFIYS95NkJ4emlWU1FpRUExMVFzMzc3N2hwenlIYmFVSVhZOWkrb2lmVUhhdHhaNUQ1S1ErdTh4bGJubSt6YkRLblZDZzU4S2U3OWtMeCswejNIcmZwRGMwM2Q4OFdQMWRyOHhtcFRTZG1iNXpVd3Q5b096MmlkQlNhM2RSN3FSTTg2ZGd6VHYzaUJENUUwblZHZVlFZkc3Q0I4QkFFOTVOVmhiM1lJQVFScUdWb1ZLeGNBSzd3YlBYWGR1MU54TThGaW9BZWxyWUtsQ055RUJnMVpxTWVNOTBScTE1ME5VZUxMSjA1VHFKbVpqcDMzNmVseWhqRE4zUlpQVnl4UkFnQUJCUDc3QW9CWUFxdU5jdFZ3TThaSXQwbFM5amp1L1plZ05vV3J3WlZwaVZSZG4yeE9iYm1wM2w4L0F1d3Vkc29yS0g1QjlpOU1ZeTg3NXd1Rmh4RU0xUmpjVHUwa3RyODJkcDJuVS8zcnYrWW9ZdXVMOURDenN3VE1tN0JQQ0dLYjJBUUJhekNZVXQ2bVl5akhlc3VjRTJWeEhxZ200Mnlvbm1acFVHNVlKQ3BlbWtxQzRpUHgwZE5NOGZBZzV4ekVTMTVKcFhlb0pYK01JYm1sY1czdVVYcERPMUVEeVB2YWVvN3hHcXZUcHh6UnB6R1gyL3Q2RE5DSityUHNBcFc2cXRFdy9BK0hHRUNRY21HNVFQSFRsOU1CRFp5SnhqdXJDdmlPM1V5UlpkR0x1MllOSUsxOUN5VnhWYTRZM09Rc1RUenpvMkVOVmtFWS9QU2ZLNk1yUlhtUHRWQUYwMlh4cjRHcGN5ZGk1RWZkcUNzQzQ5dlZBTlZNR2hYcW44NENGbnI3OFJIdW15Q2c5TEE1N0xYbXZXN2piaHFvbmJkSXV5NDViOHF4aXlqR2VKUlUwOGNEem5wa3hkb3pQWndkTlRaZ1RPU1hxNlhxZWhFeUxrUldaQVdJNjRiUE5HN2ZibHlTYklVVTgwaXpkK1Z1L2RWTDJjVjMvZFM3ZHpBRGVQNzJNTytZZ2dUR0JCQzBwYkVpdHNCSjJSNmMrTktyUitBeGpmR3ZCdk03dHRwaVNxQUMxWnZPNzBQOENkUmJCMjNsaElLRGRFN0Z2bDNYT3VLMVpLSWtHMVJRZmlLeEE4MW1EcWdOZC9mYkNKb1NJWlFONkFqcEJoWWpncXY2eUVDbnBjcVRFam1iN2ZlZWxsNGR2Q1lONTVrMnovU3hHNFhKZW1pNDAwWFVuSzlNTks1TFNxb3VkNFJDRGZYZDlhTkhucU5DQlJRWFN2bHhSa2toQ1VhcXhSWTV2eVp5cjhrVEY3SERtaEtORzZBOWNhTGtBY3NtWDBpcFdBNVhmTkxOb25ucWU2SWtWcFN5VENwdzBJQkQ1akRuTXhyL1RnMGtnVTJhRFQzV3BFekZEVEJhdnJubzNZc1JKUU5TZjRQRGFXRzhjOW1lYmxScjZPU1NzTldOYWdjSXY1OU1XUTE3dDUweitvYWhyQ09RclJrYXcwTm1OWmdQbWJLaElzS2VBVXZQQkhkNDBDTHoxSTRDR0Z4bXAxRkFxNXRNekZ5d0JCc0lWZmpQRENpOENmdTV1RHU1UGpaVWk2R2FYb1ZSbWlZWWZIVngrOVptd0t3MjZJRUxTRmpoLzBnWDlHTXdDZlVPUm9SYmhzeVExaUFYRWFnSTN4dXdSVGI5c2xNWHB6UmVncDJyY21GeWliMy9PWkYxYWdjOVE2YlUxWTdNM3NkUXVCL1lyUkF3U3JqS3BmcnVTZndwZWlYRWZLSnl6RGlpazA4Q1MrcHA3b21kVGhNSVpvR2tyYUQvVmpnaHhmUDlPWXBxaWxvUUNtSEZxODdWcWozekdzMVlUMmpDODJGVWVoU1VNL3pKQUYrRTFBTkVEclB0dE9FbWRnTDhJNmhYaVJVYnQ1N2Z2Ym90VGVjdTY5K0RIUXUyb3pqcG9LZ2paZmh1WGFNOTY0a1pHQ3B6UVJjeHVrTzV0Vm1ZRTFaRlBGaTJQTnFWdTlKSERxcTNRMklHeDNyZHRSZExaM2FPbFo0TTlDUXFYM3REMzNRL1ZMdlp2Q2tkdFM3N0Z6c1YxTDFlK1RUSUgxRnVvN1V6QXNpaHRWSlIyTFF0TERLS3lUTy9sTjhWbmE1dUVOVkVEcFlDQUFFRS92c0FPUWJGWjRZbzY1Rk91dmtxOHNpcnpFUlR0ZUhoQUNtYllTT2JkWUM3Ym13ODVuT2hyejA1Z1VtZ1lMYjY5bGNTNDk4bjZ2eGRLYnZ0RFNDQVhLcGx6UEtSSlI2OW56ZU5NNmZheFI4blpBTEpncWdZcEswUkxLdWVvdHRHVFNxUDFsVWp2OHlaREFoN00xcE45SlFEN09MMi9nd3lXMStxOVowQTgyWVlzeWd0VzdDZXVSbmZzMlZvZ09XelFjbHJWZXBxbFg2cnArcjB5R2NDK0tqNDlrR0ZCQ0Z0bHZqUHpnNHBLL0xrREVRT0FENm56bkNLNDFGY0pFQ2JQWGRORXJKUTd4MHB1ZXREdVBRNWZWUUJ6LzMyOEtxSVp0NnJYVGwzSUJaYmdVRWlYdmVZbzYyeDZGZ1dpa3ZMaXk5U2dvNkVRUXFHRk5KUElnUWk2UnA4TzJ5OC94TG1UT04yLytHcmFRVndMUThVNE1wOHZtNStiQTFtN1JNUmdVTXFURCtvSGg4MzFYNTQ1aE1CakVtbkVjY2E2dlBXakY2RFIwZlVUQ0N4blY2MDdXcmplNkZsZUI0T1JPVE9wV2dCKzhYd1JSMEhia2ZUMFNZYVg3OGVJTjVQWEdzL1pETXZOSW1IMG8yU3hmeUliT2ZmQ1RSYWtyMXZ3dDc3bjYybmhiMlhsSWdkRjF0ZnhsUndZc3BsaVRMby9XNEl2M0hLNnVSSCtzcEJMUHpNUEszeWRyRmloNmpFRitXUWIrRHk3U0MzMDV0ZzlZU3o2eGl5cTZRM3hlQTVzZWt5L0JVd2hIRmFLd0hnOG5MK1Z2clJEQzBuYjlIdjA4ZVFKR3FCUWYzNldzTFZPTy9HRUZXNmdGTThlQ2o3YVNadmxkTnVMVXlpWHdTcTV5R3N0a05OdlZsMnFTOGhjMXRvZk5HVXNkTzlLVUFRbVE3WUthNmtaK3U4UFIva3pUd2ZrclM2dVJNUWhTQ05LaTYvQW1aVUFvekpQdWlOaGRySkRabEd0K1RXclFza1NKTENNYlNETlpIRUJTMyszUjlzeDI2VVVtWkNocFF5TVc4Q0M3MnErdTJYOGlXTDNHRXV0dkNIVTIyNlZ3L1hwZTBpc3pZbWpIMzdYVEFGMUcvbm1ZY0c0c1VaRDVkb0w4ODZSMWVBQ0NMUkZLQm5DMVUyazh6UkxoWHRXR0tpNnNlMDdrc05xdWsxcE90endVV21ZVnY2RGNYQTdWcUtGY0RxRXNWNkh5WFJ4dXJDclNHS1hRZWVYelUxbDJDdExBMjlFWnJldW5QSER4WXVkdEJNMzVoZDdYekxKUnJmSmJoTjNqRTZrcU82T1NKc1VkUngyaUF0eVA0d0wxN3BXdTl3SkhkZWhVMEp0WnB2OGt6Q24vdGp2OE5VQTlhQ1luUm5yWU1GempyRzFjdHJLZFlKWHM0SHk4K0lQL2NNWFFCV2tReFE3ZU5yamtIdTh5M2FwQ3p0bVZxblV1K3AxeXN2TjZMVXhwdXdkQ2FMd0V3NERlNXAwTGlwVUw4WHdZZUJsdlQvMURodElCNjRScktMZGRveHFaakRWZk5JNkFvVUZvNjlsbWc5WUQrbjFYUTdHZHFRUnRQQU0wNnI2bUlacS9Ya2JXOGIzcEJuWXV1SzExYzZpa1A1WVd4QldCV2x1aXcxMFVQOGZ2eGthME45U2NjTXhhQmJRSzRKclI2R0hHRnhzcGVyVlpubmlzVGlVM2dsbjJTRnd2NUozL3M0NU9sdHBSNmdnck5NVHlYaFlhUXYxSXNiVjFMSmF5TUhXcmQ3VmM3NHVRSUFBUVQrK3dOUUpBZDJpUE15SDM0U0habUNrOTFyQ0pwS2RKdzMzRFUvQW8yTzR2d3RRRlE0MUxuZjFtMXh4T00zaitkNStpVjFYSGdaRWxHUFFaeUd5THNFYTh6bjBlSDRwV2ZlNDRiYmRxbTI4TDJ1ZWpBRm54cVhVSnVOTkRib1NpWlphNVlHRFJJTksyY1p2K3BEWFFOTmZQZjBUeTlqUy96S2djTnhXNnllM09QSDBmWko5ZDZtZnZNdFNPK2FhNFM5TmRDdGxEanRsTGU1SUJ0TmJwV1JYbFhCV2d0NFpaeUkvR0s3aHJ5WWN5dllPYmRuZXQ0dkxUWWhkcVlYSjZOQjk2VFNTNkw0WkFyUURNTWdNbkhLVytHbnZicVlrcTBER1lweCs4SjRMTjRTdmppS2k0aEhVT29SMlRNUkw5YkMvdWVYRmxTM0prZWJrNlkyUWphOGcxb0hqN2FzeXJlVjdDY3VkalJ2dXU0SW5GN2pFVG5FaDk3NzZneC9iS2VvcDJWU0w0REU2aUVIRGNCc29IaU9LMU9LRGdkYWE3aXZxTm95cUZJdlRQUVpHR3RTa1Y0a0Y2UTc0Q3BFdnIwK0QwWHJOMjJGdnlaSTNkOG1LWXVaeG0ybVBVZitjRklrNWdnRjVuWXFWbXRZR04wbEhaREoxY3NjdTZpTkVkSmNMUTlxYUtiSDdXckhkSUhTZVhTNUZSZ25Xb3l1bnlOR2cvVVNiRGNjZVJxQVc5L1RRRzZtQ3NPcW5NZmdrczBDQVVzWjZ3SHhFWTRYSkRMditWMDJyZFRxQlR3YytUZnBhWVJCWVdQdU1XMEZGaDhrcnRvT2I1NklVcHUxN202b1UzcHpVL1piZ04xZFV0TjROS0dzVHRrVkQrSHJZRnlnRGZCOGpHMnJ1bnMyc25QRy9RTUdXMHAzTHkzMmtZRTZxM0dhQjFoSHVPNVM0dEdQMmJaNmhJWENXTzJzSTVRcS8vdXo4bVkxVkZ0Y0hIaEFQQnpWR2c2Qjd6WmJtTk90R3pXa1lRTHpoNDR2TUM1Q0VSb08rTHgxNmF0RWlCL0xvcWg1S0IwNVQ0QlJCeitNVjY4R3Q2M05BWTQ3dG5aVDJvRytzeEt4RThkV2NiS3ZVWmJ3cHVqMTBkYTFRZjV1OXh2cHIrd1Z2WGdGNlU5cnI2RGV2QXAzTXl4ZnFneW5VL3ZnY2ZGTlJHR0xaUTJUSkFpWjFEd0swVHlXVWhWbjdBVEhPYTEwc3gxaVVNWExDZFIzL1NHeGxqZ3IvQUc3RWdycDdmd0hJcEo5TXFMTERtbzgxMjU0TXdyWjdmN3FwdDFGYW5RejE3MWYxMS81MjV0dkFqclBtbnIxZ3pFWHgwUkRkUUNvN2xyblB6VURnWmM4dWkxMjV1SHJ6ZEgxR1hHVGdmNXdCaGhHUGZZbjhEZWZaWFpoRFBDTW5uNnd6ZEwvZjQzeHhsNFlOc2k4UG5LT1ZobTh6VEk0cGtVbUJzb0wzYVlUSGIyZXBPcjJHOTBDZFl3ZDV2M1h6eXNudlNnZno1dHgyclhPUUdGNmM2Qzd5M25NVUUrbDdaWDRmbEZFK0ozdUxUcThPa2xIeEIyUDdQV1dDOGZ4N1BwRnloWkxHUkdRbEVnakxaSTJRYW9JMHd2bVpJM3ZmRFVqVmdmOEtCTmppSGdyWXJDMEZOU3BsQ3pENVRpZ3p2RTNoajZjZEI3N1JLWWVkM0lnMWtVRXdrOW5KY3B1aTNnMEwzeVA3TzZLNjZuazQyRFhGZ29zYzZ2OFo4MFNWYkNiTGpjdDZEWDNjWFh5SjlWS0I3bVptMFRrQWdBQkJQNzdBSDFpajIvSHcrbm9YdER4c01VU05kWFh5RzA5RTdwNEliUlhSSzh2K2RkSkJYY0M1cS96ZXE4M3dEU3VGa1hIbWliOHVOVWpIM0txS1ladk5rNXNrbG1qWnBXZG5mVzRIb0ViVEJId1lCKzdkZ2UxSWV3YmQ5QUNnbEVoTXJ0M1NURE9Ham9hQTZjMmd1bkZ1N3NkNnpTK0JEQ2hPN0NDVUJjNlhIUWlHeDVaMmsrWVJaMFcwT0U0dnFJWEdJVW5uSklmcHRsNEJXNVJKYnBwdVRQaE93NXZoRkwzVXVYRE5tcHhoa2JrK3VGaThRNFdOYUhMU2d0RGtSblhtZVpTRlM5djhTdU9HUCs4ekRCUGtFcHAvKytXMjFEbUlzZThMWEVVUmRYR1BoUVdjZDdBeUZaNURMT09hbEQxMlNsaDdGMmlnZ3BzZWRCQTdPM0VBek9pM05na1V0c20rWXkxeFdjY3dEU0w3Wk4zRDliUVdkblQvL2NWOE5qV1F0clcwd3dWajBKUXU5YThBUEFmbUNxaTExZGNLWDU2TzdZWEgwN1BZQkNCeGVRUGJkc3h6SzZvTm5IWm9yY2lzNmtVMGpkMFIxZWQ3U2R1aEdUVUE3YUcxaUJueXlvZEM0dDhCRjMvREZkcDVkWWpGc09GTXJ3NW5ud1R3eUtYRGoxMkduMkhsZDVyMUVxc1R5akJGekhQMzlkYnZNOHAxcHZRaHJqM3doNXd3R1ZNTEwxSkFFSjlwUnFPSE9QNmNCcS8yMy9xaHhDblc3WjNjZEp3S1Jrd0d3cWJVdWxMeUxDNFFqM2plS0piWG1iL2V4Zk5XUHVQLzdBT2tCUkRLWUJwVWJqMVNYdk1NQ0tTOFdJazR3R0tLejZFbElHZGV4MGx3dy9ibHg0blJ3VTYwYzc2RGlmZlMyOXpGYU51Zms0UUo0TDlJV2pQTG81SGtnMTlyRTdHWFhtMk9yMFYybU9RTzhlc0ZWaCtUbEQ3aGh3dytBQzdpbTNaSU81aXBqeUVHa3dIclJ0UXMxNHB0eTc3dWZKUUtWYUtHM0M3K1Nld0FNMktYQURoUThSc2ZuaDlXcVBHcWtMOE9nZjBPYzBNWFVNZndRQmtKMWUvNktqOVdNeE44WnNSWVdKbTJhYjhpQ1ZsSGRaUENqbW1KOVpvaGdudTVvMWJEcWhoRUhoeTd1bWJaSXdESGpMZXhGWWJSQkgra2I5Y0w0ai9PMUs0cjBRRnQxbVlUWDN0dUlLa0EyTWN5ekNvYVE4MHlKejk4WEtBdzN1RmQrNld2YWdTR28zZmFkRDlUNkFtay9oS2NEYUI1TktPRG9RMUgya2lzQnZBa2NSR3oxeEs2cS8wcTJDOW1tL3FNVE9xc2NML3diNEN1bG5aa2F1dkVqS1pxSzRvTWdnOXVWR1lPSEpTcDJ6UGNUYitIWmF0UWovMyswY0phRHErcGJneVRZQ1hEekM0UTIzMFgvZ3VucE5NcktzU2V2c2ZEZVpLOXhtRUxtdEwrQklHVTFsd05PMHIyUkYxTk12YUpMdThnaUpFL05rSEFHZmd0QmhNS1A5cUQzeEpQR0tzdjFNOVA2Nmo4bWNkdDZ5SFdMSEEwUFhHMmZ0NWpoTlFPKytETXplTlRpNEdjNldrNHNKUGJHTTBYZU5relVSNlB4SVNIbEVmbE52MjdOTDBVN2QwdVo3YndJbHYwbGY1SXNoVkJ4V1FjUHBoSGhNd2RqR0toYTdnVExMTXFnbFZXTk5ET3dlOWk5cHBQUUdBYWNRc1oyL0grM0w4dnl3SitIaUgzbXdyQXE0SnBHZ0NBQUVFL3ZzQUw3VFdDVW9KY1R2YVQ3K3JNSGVwZ2VyeWEvem9ZOTE4czdzdEs4V2szbnB4cXdHVXBLVGZZVmtwZlRhNEt1Yzd5N0xhVkFDQW9nUm9XOWc0Y0lFYU1OdUpLbUVod0d3Z2ZwYlZzdHpkUmNiUVRYK09YenRGZ1ZnaHhxRTV1TWkwTUF5NHVoWThsN2ZNYTlqRHRUZkM3OFMwMlVKNmY5VS9Uc1dkT1JHRHhhMEVvY0xHOE1TRTZGODVVQzh0emxxUERwdEZySEVRMEFDWitIWkZVaXNuV2FGblhoNUcwN3VOdDFBYTcvSmdzdnFaVUh1VklRQndSVE9tTEcxN0Z2OXpzUWUzd0NNMzlVbjFRSmZDSnZqT2ZLMG00bGtvQ1FpeHZXcG5nc0pjdXdPWGJPVFEyVHd5bGFXNmdMNWJMdDYvMU5HWmRNeCtuVmFHeklCSkkrL3V5ZmJhMHZIM1g4eHI3TlVZVHNTa1I3eGxWS2hxZHl4Yk5ZdU9WRDRVdDR5Q1hUMkFKRFFSNXJUWklJbURWNEtwSzhNbnQ2MEJITFRhYmlwRXJKUE5sdzRrOFFjUkxvYU90S3A4a0lUSXlaTlZhQnhRQ1hqQ3ljTlZHWUxENFFBSFRzTmlCMEpJQ09tMW9GMXJRbDhXTjVuRHpUMXorZzVPOEREWnpaeWFPYVZjYVZucUM1RXNjZHRSblhsa29raFdHMFd2d0dOT1FCUnlQa1ZhWStKSUJBQkxCMkcyRXNJL0lMTnN6MWc4KzZLNGVlOEZRajFaRGU1MUhwc2EwMkZJcCtVSVAzTFg1emc4ZWxnbDVuemIyVGM1ZjIveXIyekF5T3h6dThpZGp0dzVJZWhtWWcrckxVazFNUnV5WFZSNGdUS2wvelFDQUF1eVA5K2lFeWJZZzFSWUo1MWpyNEc2STZjQW5PT1o0djNHK2ZyRUgvRkhib0pnSUdyMHd6ZnY1bW9zUmlaODlobXU1VURaU0tzU0Y3UlN2b3pDdnZPNi96Nk9Xa25ERm82d29sYzVuN21kdFpkSDdnL2UzK1gxb2IyRmJMamtlU05GMVdDSFFyZDdKKy9aUWxlYTBKUjd4NEVtSUZvaHVqMy9nTmdsOFRrTWZxVEwvcFhLK0ZUK0cxZEVyNzlvNVRENERSVUpmdTJZM2lybEF2Wlo0cWRSSFZBb0NhM1FQVncveFY3Mjl4eUNoTEI5aDhKVUM0VGNXR3RJRFhjRTZEWUxFOENUa2s2c01EMjhJczFMdFN1aGhtOEYyOHZXZGE4UkJWbTVDQjNBY1pyQlVJWjJUb2J2R2tZazlDSFUyUVd0ajZYSEVrTzl6OGJlbDlKcXlYWHdvbjd6MGQwWTJBQmI5aEFrb1QxWkJZRVNCcGEwVHcxeTBLQng4alJEN2ZMQTkyZmhoVGxTcitPa090Vk9VUzJTTkRmOW9YVFhrZXFpSmdIMUxlTk9tSXk2WTFPOCttZ0xHWjJ2dGFuQ1VNRk9EOWZXQVM1YWs2ZjN3SGNJdzI3M2Z0WmdmTkZuVThEOTFrZnpMaytHMGM5Y1FYTWZaZFErcTMxTXN3NlVjeGFOZE9nQzBWM2F0ckl5SDB3ZkVzWDJUSU5IRW5LTGpxZFhZcW5FV00xOVVNeHNqWU9jeWRIYk54RHhsWGVFVHZicGErWWhJMUg1ZW1HSFBNQkRFOXY5bXhLL1VsSUdvd2I0cmJuT0lIakdpSHRHUGJlLzZNcXVRdnM4MEZ2TFVndXlValRwMG82MFA5ZnNFT1djVlEzR3hYK05KZDFTd3hiTFNQdXpDdTI0TExhNEg3Nmt0WUZMR1FJQUFRVCsrd01IUGZNbWs2ZXoweGd1N05RcVVvSEV4MDBjV0c1MHVvZGkyVXBzL2lsNVUvYVZYbERIZEZlNFpIZTRzM3F2REEzOXdQYjdLSG9rMURzWDNacmpnZ0MzOFZ1UnN0dVVGWXFPMElTdmczaTFHeXZpZDhodkhKTDNUeVVYbnloaGZURDBqeG5aVndGMEZBT3JDenN0UmpzQjFTNXBOUEFsdDFncS8zUGRmU0ZiVmJrVjlkNW9uNnBQcTlsZ2VuZXp2Zno2aG9xbkxnSjc3eUExZ3hzU2lhbE1ydHFTRVlvT3hlSFVOSkxJNnhkYVh6dWUxS2UrMTF5K1I3Z2Q2K0M3bnNFak1aNG4rVWZaYk9RTFd4d1pTT0NpZTZwQjg3aXdmalhoTEhvSFJwK3lzaDc0YTZMOGl6WWtxNy9CR3R6VEU5dVc3TE1zL0pLM3FtcTl4Ym9scjNCQy94c0MzV0pBdnFCYUdrWFVESW9MOUxabE9XUDhjQ0l3QlhhNHRrWVd0UVFCamFIMm9hTHVpcDdrcnY0NjNtNlcxVUh1MXdCZUZ0ZjVMT0FEcXBjaStjUk8vdm5zclYyVVBmSk9hSnAzSUxhV292ZFk1emZyR0diYy9RUmt4WlVUQmlEMFNCY0dZYjFuTU0yaTExMGo2TGpxdzlXOVd4ZlpCc3l6bWZvUWtXMFczTEpXb1UxWmFCVHhna2FmM3FXRStSS3M4VCtWaDlQUzlGWXJGTWhFQWdtcUJpcEtQbHp5ei9YU2ZZSkZodTMyT3l5L2I0ZkR4bHJCcEYvRTJqeEpGZkVSZm5SL2RsaUZjRGpaR3UwT0wzS3RNM1k4SGJTTlBBMGFwUS9pSVMzcyt2ZnFiQjVCR05oMHZjVjNZbHY0MHJtNkZqcmthR0o0QnRrKzdsOVNZWnIrTVJ0a0NkQVJqb3RKbnNPaXBFcGNQa2RINkM2MkVHWThtNUJmYTRYMkw5OENzU3lyVkJUa0FZOEs5MUJiSkhzYzBPS0czaWh4V2lHTXBaU2F6eU1lZThINUQrMnZlalJoS01ETlA3Z1J4WXpsK3Q3QWNxYTk5dytkVWZQQkRNS1FUWHJKQkJBbTFLbnR0c1RUZ2FzSk1KU2F4aUpWSEVWeGdvNVBsYW95NWdranhEdjc5UFh5MnIzYjFBZGppQVV6K3NOdWVqUnNJOUxpd05KYzZQYWZaVzR4ZWxxd1kya1gzRG1wTit0N2tRN09IaDNtVFZKQlNIWWtxM0pkN3VNWnRJYzVMbnRsTDNvTW9Lb21tS2F1L3E5L2NTUCtabWpWRjZWS1g5OVZBZjJKMFlFWnJsOEYzdjlWWnp3NlJQQ2hFdjhZMk9KNEZKL1g1K3ptUWFid3FBWnpiTkZ6RnQvUm8zUFh5OWw0UEMvWWMwNjRDL0lvQzgzcmpIclltNlRaTjFmWVNNWkhQWFNOU2ZubHVlRGhlRVFZd0tSWWtFMUhiVDlqRXdzMFp4L0N6ekxEem5nbDdUN3YxOVBtRjk3TjVqcUd1YUhmUTQ4VTZxRTNjT0RtMnhzUE05eWhELytvWUc4eHRPTitIRmdYcTYwVEpDWGJ3enZYeG0xVndMcXZaempKMmRud3RxUEZaalk5RUVJMWcxYkQ3dkd0d0xBWnk0bXdKYlpmcXBpd1E2SnNmOUtNVUF1NUZwYjJQUmpUY2U0cTNkTU5sN245RkliVStKQkhyMkdJc05yRW14akNhVDZDeXNxdnpCQjBrdUhUSGMyZ1ZWVEg3dHcwNXZXK2tyRmRaempjY0l3aHFLOGtweTdaYktiZHRqUXB2bXhDUVI2RkkrOGlBZ0FCQlA3N0FFTkJvWS9iRWhXNDVVSlQzaDF4M05CNWJpSVFveGQ2cHZBa1loejQxTnVkbGZmZE00TkthYnRBakxxbG8xVFlPZnVvQ09jOFV2MmNVQXI2NStPem40dWt2MjBINUdpektrU3NmUDhEVHBTWnlmTHQ3R0d6QzBVaWxxTUxWcUZ6cU85YzZQdmFXcWxhSWZ5QnQ1cEt4c2cxYWxGZlNuWFJsSVBoWTgwM0RoeGVBQURSc2JleWVDL0xWVzFxdEVoUmxGNEozQjRTS1ljSmJTTlJuQldnbUZscjFyWjJ4blVMTnNOclNNa3lxZ01iNFVuNERtNFVtWTVOSnFiMmQ2OGdXU0RhVjYwRklDeHgrYUR6ZFdKWHZwblNPbW01RHV0SzVlTW03dGEyVllJSDhpb3hGN1IwSHRnMm5sSkx6TllvUjRlaWU1d3A4TXM1QWFPQjhJeXI0bTZIVElmUDBHSHBQdmQrYzE3MkRDelloWkdoLzVZaDk2YXhBYktSMFJ6MkM3RDBuOE1QLzFlczV6TFhvdGRKWURUY25xbHErano1V1hGcUZLdUhpUStqOUxYTDF0c2ZKKyt5ODZTci9ZeHd6aFE0Zk50eE1lNmNXbXpkdVI5eVNmMFJockNsVWZ3Yk5MOWlLOW9SWlNyY1VhdWtteS85VE01NURMa0phTVlsT3hRV0lNTEdhZ3FHbmdQZUY5Rk43STRIeVdhQkZhUWZhRWxwcXhyL0w0eUhzUk1PdUExVWhEc08vMFJzN0JpYUZJcy9XditXcnVXSDg4OEI3OVdXcWdubGRJeHhPWVkvUXNTL3VQcWtyVXRzRk1SMTJPaTRPamVqN25XVVJtM2loZ3BsN2tuWkV0cUFrZzVaZ3RTVVEraXQvZVBMcUtwcFh5RXpRc2Z3QXVOVzBrckRjV0ovZ3ozdDNzMlVXREg5Y2pmTXdUbjFaQXlCK29NaVhyRUhjUEVoM2FBaEltS082a0FGaVc5Q1MwWWsvU0xCRDFnSU9rUnk0S1JHeDhOYWJuWEdpUWlDZ3B5d2ZZT3pGN2hNZ2dBV0NaZTRGWmphMjg3YkMxNnRNV2J6RmNrT1gvODZTckZoVTJxa250WktMak9HYzB0U3ZDR3crNFdYdGhhNUMvQXgzL1psYktJSFg1azFWcGtYNWFLT0NRMVd1OXRIV2kxQnJVbTlYSjBKcWFRME4rREtMVDVrbWtSYjRaZk1PNzU2aTl1RDdzbkpqL0lnMVI5L2RTbEEydk84OURsdXIxVVdCdGNyTUhkMVd0VjdGbXFZMVhXRldEREhOcUN2anl6WVJsNlpFb2tNeW93UmZMTmVqaEdPQ2Fqb3RwcEVkWGRWcTVGYy9iNGVwWXd0bk15bEdvR3pBSUR5Yk1RMzNvSXhLeWMweUx6ZnltUWdPcGJsd1Jya0RML2MySGZJdU9naVhZL2hJT0pVcFh0WkFLd28xeDQvQ3lUVVg5aFFoYVlYUkJDRXBwelhDZGVQU0xOSTc3b1ZTd0Ftd0l1VDc4RVV0Y2V6UVY2WFhqWmozT3lCNFJ5MTNkcUZIY25aZDc1OS9kZTZJa0crVjJ0dVVnek1HVnZyWU5GZ0RnYVg2d2Q1bjBtVnNuejFWcElQdmpib2VtaUpYdUVaQkpZczlRelVhSlBVWEVkekpLTk5od0lwYW1qOTcvVWpCMHhoZEdMLzJMWmE2R1ArSEx5enN0MHVPZUZ1dHJzcVZsTDd5TWUwekdBeG51K0dldW5Ob1puTTNBdTNlZTQvcmtpMjRBL29OTkd6UFc5c1NlSEdQMWE1YTFjTERpc3BzaWw2Yk5BQ0FBRUUvdnNFdElIV0RLNEROcCtCamx4a3Y1eERRcGZ6QWVkVUEvbU9oVnRkK256VTYrOUtaa2FveXVuUWxtbGlIbDJTdndNdkswWEgrMzNmVC8vSk82S3FiSm56UndKSmxsVDhZd2tvRDFMMGx3OWl1RTQ2bmd6dnlQV0VjOU1LVkREYm5iMjhVSlAyQWV1SW5xWU1JTkx4bEFKdjhEVEVCaVA2andtTGY3dnVpbmZ3VW9sZHVTN3ZUTmYzU2dScWhYQnhDdTFVS2hWTXhRWW13Y2xkQ0hqSmE4dWYrYWswaFZOdVhuMzhpaVlPYmRZRUpDbnhLTzdPbkorYm5zNlpmdGI2OTh6NGI5WEcyZSthOXdEcDlmWSt4MHNqOFZWTGhSWnc1My96bDFzcGdXWENQbmVHaU5WOW5wdXdHYVN1K2h1cjdDSDUwcHJlMzB6aVVZVTh0a3NpTHVsU0hSelNIZWYwWjNuWUtKNTBxZzFKcnhvTzRpYTJRb2NoMXlXOWpSTy93akxudE02S080WG42U0ZUeGYzbHdqZkhieXpHYW1lSE9ERStDZjZxeWc3a2FYQW1aUDFnMmMraFNOdktoVE0vY1d5VzJESTgyQVZEbERsV3VwSHJXMDlPcnZhck14enNON3h2a0VwTHBJVXpFQ2lNdm16Z0c4UW4xRFh3RWhWRVZjK0VNTnREdXp4VGJEOFRtRTMwNEZPK00yZHNZNnh4WERuRXhyK2dtVEZhM29nYU13VFBJWUhLYkM4dVExNHNZejlzU2gwV2J0dDNWaHo4WHRuMVAxek1jMTFvQi8yNEpQNkRkTExpSyszVXJyYzRseDZvSmM5WVFGQ2VCQTYyb2k2R1ZaaGhOMWpSZ29mQk15MXhKaERFRk1HeVRjR3ZtL3dZUG9DWngyS2hSd1BnUTdjcC9XcEJnaWlxd3ovcTZiNVcvTUxZS0JmYjN1VlhncnJnNUxOQTFoOEpkQ1ZiUk0yenI3Q2ljcDdyeWt6SFRRY21OVUFQUGVYK0dYaTlYRTNQQmVWKzJuRm5TY2RXR3N5WkxvMVM1NC9Sc3ozZnlEWHpyOWlYY1dlZStQNFVyQmlGY21SWFpUeDFXMHRjRDA3dGRpNDAyRVNxR2VXTGRxRDQvVzlIRUF1WElKbTVWR0VjYWU5ZldsYjVWNUxIVHozYXBEWjlUWGs1aEQ3Q0ZxTDBwZTFjbEd3RGd5QnJqUkhyanY5UGttUEozamtzb0ZCd1dlTEhpeDIxdkxlYmd2UmRWQnpiOHlIRlF3SktUaXZtanFVeFhDdzdrbEdvc0cxTnRRaFJkdEN1VlgrZVR0YlRLRUFlYUxDQ1ZoVHBUaW5HSzFLbTZzVHJ0d09JRXdNemN5cUNkdnY3M1JibWI1TERYVzcweXlXSjBuWWtLcmJHNmliNGNJblc4UGlUbW5Wc2t0UDJZbzNZODRSRE43bkJtNjZQYVczNStTVVVOTGtTSUQvcVVpY0RQL0Fjb3lyVU9kTUJhckp5MXptY25HZytERFU0dXh1bmVnVytOOUc3L3pJMkhoM2lkVkQvcndQS3MrK2JDQi9RZWRHMlVDUkJKSXVOZncydERuSUVxdDVkK3c0RW44VGVKYjBSYUxIenhMRUVmQ2hxUmlzREhOdks5eFlLanNSTXRrTktWOEhQVm5rZXVIaXlPNE5peGRLcVcrSHpyVjY1UVo0eFNtQnhSSjQvVTdIbmwwSFdIT1VYeUd1d1FPUkEzbXViUnhhdVNDeEFNK28xSC9FTEwwZmFibzAzbXgwLzBCeDhBK3VjeUlLZGNGUDNNUG81UG1BcWdCTVJpUUlBQVFUKyt3S3lCYUJmS3ovbDAxRlVIZWpva1IvSXdLcXBrM0h4SE9UMFAvem1XbDRBRmxzemg5SFhEWHcrM1I3ellDa3gwTE5qYXBpNmprR0toVW9BVGVidUVSbE5ZVEREMEdSZG1OYTh4UVlVTGF0MjV3S1lmTEc3eTVETHB2ckV4SDBIUUVxZ2FHMXJsaVJkNVFRenN6RGNIaHJBWEppODdkbGlLcEZScTNRMXNibFZnd1FIVzZQNFByTWR2N0s3Tm9BeUtkOG5iaTl1TEFNVFhMcnJ0RmZGamlHcTRaOWlGMVdOMWQwR29rRDlBY2UrM0ZBM3NPOW5lWk5LR2V4TDV0M0MrczhqaFA1dEJGT2RGaHhZRzZzMDl6Z2lEZXEzSFJVSVAya0lMWUVFNUYwUTdMVmtwdXMxRXdvcEVCWk9WVkk3QXlYdXRRVCtJOHVLa1BmYUIzN3NhWHZpVTI3dW5QM0YvQ2g0VTV6NU1ZQ2dLeDNOU2NtSCsxbGlWUmQ3TDJOalBkVHVHWm1IaXkwRjhuZXNqclpJaVNnMVBNSGNPWkZ1YTN5TGdTUmZITkpvdnJHRTdSeGVMaW1Iek1tbVNCZUVhZkpLRVk4anN1a1dEYTJOemFneE81c0g5MlNLaXVNL1FFVC9lU291dnBwMEE1Q1JYN3A5RVBnSnhDL3pBdk53VWV2ZU9sWTZyaFFSdUhpWG5oeHVDTndnOUo2ZXVzVHQ5KzNxOThibHRvVW9qc1Zqa05OQk85MnFMNDlKclc2bzlPZ1JRcXJ0SytYeEswVE85czlPb3BnaFp4UFMwQlljTTRMSlhwNjIzRCttYkhzOWllNEtIbGtFcFhYMGlxeGhhQUhpdjBuek9PSDk5UWJ5WENuaVVSb3lUdGNJUEdkaUpyK3IxTDRjbGIwSE1OZ0VRQm9wRkk2QXgxTE9OYm9jc3d6TFBHTUZCaG1GRmtGTVBKN05YeENEWVBnVDdQYXJyMnBFdFloUHMvRjhxdGZtWmdibi9lWGlFaGF4YjIyMStkTmg1RVlrU2NiM3FYelE0b0RBQW1UYjVIM1dpcnZQSE00YWt1N0o4SEl5YVVUb2MxQjZ6VXI1VytiLzVNSmhKTCt1Z0lNOHN4K1lpZ1NMNXhZYi8wSk4vTWpOb0gyRWNJTVY3a09ka1QzVStGenFMTGIvYTRYOFF0RTBpcjJlRzdUcWZMYnpubXlpM2V0UytXSFVDZTU3SzVjdC9qTi9Nbm9LdjVLbTgvVE1vR1J6YUg2dWQ2RHAzMS91TFNrWGJHbEVoQXlKdkt5Q3JkUkpMVjg0d0lHQ1R3V1JCR2dyRnJZcTBrZVpBbHRKZnRabHlwQitmTFlDMTZPTnI0UlVJczJLQnNJelZjRmVNZXNoUEZkR1o3M2RYcndWczFMSmRhWkxMcTJDSStYeVd1R3lhV3kwREVOeXpDbDcyc2hub0wxdTFRL2ZCOWt6S3RjUzhISExGTTFzUlVaa3hkQ2daQVc0VkVEdTE1TXc1YlRHdTRmQnpsdFdlN2ZodlJFY1hWcjViaXF3VnpIYVVMalJzeFlpRjlxZ2Ria0o4cUlNbTJoemdDUFZpOHdWbDJmbmVqaDRnSVpQUjFOdS9BTXA2VGhSWWdocWhNNlJwNkVtelFBZHlMb3RESEY4WGtNNHp6MmpOUTc0bGtnb25wTVM1Mk1nNkRqc2RSWkFKQzhFOHoxTDVIK2VIbVZRNE15QW9lZVlrejRyakpjd2lGWko2c2FxbVhqMGxkSi80aytRS1IwSjVjQmNHY21IQ2hGa0NnaG9SVWR2ZDgzYmtpNEdsamwrc1lkaEFnQUJCUDc3QWs1YStZdDlpaHhhWVA3d1A1RmNnVGJ2WkpUR082SUFBRE0wZXVESWNHRG1hMDErejFDdVRWWjd5N2g1TGV1NS92aDRBTDJDakxKeDFubThKR2R5YWJPL3BVeGE0Z3JHT3NodkxzaEFReHMycU1vVGRBQWUxN1Y4SXFSUUdoc3NCb2FHMlNOQmR6VFlEUzJLWmNQSGZER2ZUTnFNZlZqN0ZhSGhMN1pKZW9YcG1FdkxuOVE1cm1jbzlLdkJROC81bTE4NjZyd04vdVQ5akhicmJWZk5CaXZKY211c0RqRXVEQ2EwTDJ6aG5HRGJMVmU5Zjg4VXVIckNaVTBDR1pjSnhLbGFoR0dFTGlrZFBjZDZZME8zZklMMXpJK2ZVRHJXZ3NBWmZ4aGhtSWU3Q3YvTGltQnROTVROeURPdVN3RUxjYVlpQXRjWSt2Y0cxNll5OGZnSno2bWFLZFZ4SUJoNXRmUG4wWDk1RmQrNzBKb0FJdHl2c3RsQmhRRUNTYm14b2dGWGlGWnA5K05rRjJXMTZXTjk5aldoaXpHQXg3UDRuT0U5anU3MzlWamc0UGdJa1BtVkptRUdxb0NnaVBkZThEMG5zTVF0eGlqd2JzWEFNanhzYzZ5NG5hSEFwWnNOeEZtOUtaV3FId0grWHFhTXI2cE1pY1NUNkxVNTA1RHlodE9rNG43dThmN2dHcXR5bUlpdGFCWkp3OHRVdFIzb3FjZ2JzZHJ3dHFBcDV6L1AzVGlNOGpSb1lWTXI1ZEdpMzlPbFpreFFNVzlyRXdDZTJTUU9IYjJVOWVOMFJyZmw0WFBhdWo1bWJJOXNGbjZneU0xRStoVmw4UkMySDRUcXlUc3BGWDZmT0ozNTBYeWpmTkc4bW81RSs2NEZCZTE4UjlnYmNCSFZEOHIveitKK0RVRTM1YzJ3VTlxeTM2V3hETEQwVWZFUXJaWmtvMWVMYkI1dWpJVTN2K3h5UWIzSDZDRERaVjhtenJidk1TdFlVRGFwQWZuRVhJVGI5TzZGNm84akUxdWxUMTczMVFjN0ZPQlhROEUrazN1MnYyVEVsZnVKZHlIQU1lbEg0L2VQTjNDbmx4UkVSRXJxVmxBNlBxVnJuejc5Vk5lKzRGd29VZDZ2c29ESmhidjQvNUlubFlGVHltU3VZQW1uOExpbmRCTmdOSTk2bEljbjd0UjlFaStONnVOcTlyd3VXREIvZ2xhMWYxTXNzNVp5b2VqK3pLSmorbnI0QjBnS2FxdHNpZFZENEI5dDVUOHF2V3RTZEJuVTM4NDF3Qi9ISmVidUdmNnE1ZG96QWhkQ3IrOG1aWU82ZmR4WUNsZ01qc2V1RzEvdFFJK0dPZjdkWU96dkUwM1I4M2JxazB3dEJZbTZ5bzVEclBPNzgwV1lrTXdxQUtXa0szeEVkdVhteXZWOW1RNTd3SFdieVVQYnVoZVJLNzhRN1ZLNVA3UlViLzgrdTUzVEU0UVdrNzVDR1FBRFR5S2lOWWx4TURnSWtJbzgyLzhDalBLeUpyN0RtZ1RoanNndkFGSXZOZnJ0dityN0JuMHl4OWNpbVQwcHovMHovUFcrcXlieEl6TDBtVFNyZU0zMWpaRmNUdDQrQ0hocDhWMmtxWXVNd0ZLSTBkZC81Qkg4UWNnSjQxK0hXT3h6amVrYWt2WnVPYWJ0OHNIckVjVXdnRkpMWjNQKzdiVGVCTlowbXZpS1FmeFVNT0dVa2tjeGNSMmcycUZTaDMwN1I3cXNYK1ZFVitsZHZuSytSTDZFMnZMdGlqaFR3RkM2Q21RUHBKb0YyZzh5ajdCa0wwZXZWZDRDQUFFRS92c0NDSU1IcUxHNmdzdVc0UHlYbUVOdS9HOE5YemdBazMzY3VUUW9iOUxhZkRFMzZjakhSMG5hbEdNZVVJcEQ1UndXZTBXSlpzZTBsczR5ZDJCRWVFRWgySVdMck5vVmZrcWIwRlhyU0dKa2Z4cUgwZ1R4OW54MDhZWFF5bHgwOHJNQ2FQNitHYmJ2MWI0eEV3VFF2cUV5cFp4TGdpMjJMNmpXRVRmNm1ZR3pheTdDYXdpd281WDdjemhYUFRCYVlvOUU3TlBEcUZVSlFvSHdWYlFxeGd4K3hGTnR4RUhPeXM4T29pUGJPU2hGanV3ZGhKaVRCZ3Yxek9oVERnazNORDlTWFR2c2pvaUhGSVM5ekpib1BtbzFCZWdHNFEvQzdoa25Id3NKMXlCRDhYOENGODN2b1N0MC94UUU4NFlGVWljK1hBUVRwbkpCZzFTMHVTblo4U0ZiaGR5cUJ2amQ0U3IxNmRURXk0UWdHbnkzS2VwMHArUFB3WnNwOG9laFdiMmxkRVJDS2M2Nk95ZFJFaC9tVW1BOERBaGFQSVFMUkJKeUE3Ky9vdGZmQ3N2cVo3NUZmcU0zRXRkT3FEYnI4TjgrVXgrM29NT3VQT1lBYVNZZDEzNWUrKzR1Y2htWFVOdHNmT3c4U3k1SFFSa09TaWxEaEk5ZDFJaERGWmNZMWhoZkFVNklreGlvUFJrNlN3ak93WjVVU2ZpaU1DVzRyWDVwYi8rVmpna01xc1hMSVhuSGZsc0JhN2V3MDIySUk2V3oyYXJpRHBNeVFKZmRtWWRaN1YrVEtob1NQRTFieUs4WDlCRUQ3YVVONVgvOENNRW5yc2NuNVBOYzZweVJibjlRVnVLMzJuSUNGRGxvdG1yUEp3MXAvU0dyT1ZHdU9NdWpnOVJuWllnTzRBQjNBYkt0akJvUTdIbjBIOEZQL3A3djFoSkFYTHpmTW1YVTQrc2prZW9BNngvd2lpdVQvSW10SUxoRHU2SGdNOFE0NjR4ZjArQUFRczV4NkkxR0UreU1tUFlOcXBIdDlsMGRBdi9rRWNqSzUwQ3JLOUwxV243WlR4Q1NNTFZpRHF4SkdUMXBRNExBbnZxUDVtQm9VLzNYbkhGU3p0TEkwaWNabTRORFpFYllmdkRpYnhDMXdpbk5sM1JVQVhlczdoeEN2ZDFGaGx5eFhQZjRWYUNyL05FUXdsMXd1L3lhd1E0bE1wYWJsOFRnL3lOVlhlMklKdlc5SlU3SFpNcmZEQ3NQcVRaVXhoekdScFI1VWRzQzJ4SmR4WkU2Y0lNa2llaGh2bTR3TnpVSjkrQW41QUNoeUhoS281OGtHcllUYTFoNGMyZ1VsZGpKcGpHZFNUSHptOEx6ci9jVUJZRTRDOEVaVnhrUE9iVFYrWitXamJmNks3WHJFU3FFRzR6aUh0TG16Wm5kZUdsSnk1QWp4MEhFeHFWYTJYeE5Pc3NEKzdwY25Va2s4eWlLUzh5Q0lLdEttS3VjUEhKc1NMeWVEVjNpTFFRSkdKSjBicEJUZ2IxWFI5ZGFrMlU1RTU0dWxyQkJEcFU5TWFMTC8xS2NPTGt1dFRKMG9vTlZ6QUQreHE4Mk41M2hrbWpGSGtEZkhaQlZOYzNQV1ROZm9HWXE1VU1IQ0I0RStsVVdMNHgxVnpGV2lTTkU1YjlMNXV2Sjd4M1Z4MmFLbU0rMCtSd3ZGeEtYSEhnMW9rTlhSMzdUVXN4VXJ5T0NYbUdsYVpBV2ZTSE95OCsyNlgwTlBPSzlCR2RYZC9DTU5KOUExSFlhbDdRMjMyYzluc09ma01TT2FmYU1nVU8yUHNacVd3SUFBUVQrK3dONmd4Tm1uVzltZUhmR2ZZT2svYjNreDFMaE4zYWwyNzVsVW1LZlh3aXJ2RGxxL3RSL25JQm1oR1B2ZEZVWnFlQk5FcUNsL0pVTmhVTTdGNkhidkl2RXNmbjdUSHd2R051SWdJYTMvVW8vUkcwYmZhVkNyekdSMU9MMVhJKytHVVo1UXNVd3RrQUZUUlRMNURPREZyZm1leUpjSWNGRUl5T0hLcGZqZWRzK0JMMUJ5cWY4bTN3ZmdpM3haaWVLWTNDUWFlTDZ3dlNOeGdtOVdweGNVeDJxS2NTQUs2bGgvUTVDQmF4eGtiV2tNUHp5Tko0ZUtDVlhPQW9oYlA2RkdHdmp3ZEVUcEUwS0piZHFqaTJTUGVjcUVjOVBjNkg2R0UzeWhhZFlzMG9OcnFMRUJlaG9vUXdXY3JOT1ZoUnUrVXRYeWIxOERKYlhhK3lhcjZ5Y2UrY1BhZjU3SSs0QjNzU3Z2M2tpTHBtZU84UnRiQzdEQlcrNHkvVWVGaG9ZNExmZGpjWkJlZ1Q1TVBUZUlpcmNrTm5ueXhBdUFhWFg4ekR3TVJuRUdrdkd3dzA2dnNSaUVRUmVNSnA4c094UVJjU1lsbVQwdnhpakV3aVE4ZzA2czZUN2cyQ0J6SU1HOW1FT0RFUC9NZ1hENkF6SEJQQjFHaHFsWnNSV2oyRm1nQjJBL3V6SnNFdU9RU0NuVnIzTk5mVmtyZ3BUdFBtRklIMzNNS0h1UXZHUXhmUEtUR0RhOTFMa3BNRjZOVEtVbkhNaVlEMTZsakd6T3R0NFNDL3dZb1hOWCtZajRoTDFOMXZ1eWZhQ29GY3lrZ1RYU2h3RFBzN3R5emxEVFkrRXlRdk80T0ZlQWpERWZVei9wMjdyemZZWFZ6UTVhdkxWVlZXMFBUMUwwanFzUFZ1cE9Vd2hVaEx4TFBsUzlmeGFtY09DckdJNmZJVlVBZGNLTHZxWWRmY291ekdRTnpKSEsyME9JcWs2dDI2RkNYL2JNZVVjbFFFZ2ppbitQdmpjRTZFbEdCcFVxUmY4VTVMVlhGc05ONmI5S1E0ZlpVWVpkejdTV1VmNXZRVmViOS9qbENmbHEyaGErQUYvZ29PQU5RSEpndjZWcFcrTzB5QXdqTXNxVlJTRjNWT24rUFRlNUhuRHlOSmJ0UXRmdWNlNUgrRE05ME9EbUpZSmNpYXJGaFQxN2VEd3JtL3ltQURXMTVBdHRyQXMzT3JRUE04NVV4aDQ1d3RaTS80N0wxU1FlRzNpVmhMWVZaRTNRQ1hkVG84azlvUmtKOXJhNFVrVVgvTHJ4dkNmREptd0JXRzZ5Y1JaTVIxSytnTDVvMlNoNERkSlBkNWc5bm43bUJuQzlTa0Y4MDZoVWZKRFhTcTBsK09RR1U4S1hyYlNmMlpmUytnS1dnOHhCb1Y0TGhSRFVodWJCZHprU3RlNE1JM2k2Ti9Ec1JvWFdLU2RWUmRDMzJQdWRlMkRNWVIxM3RJejd6MnZ1VS9WTGlyODVPQllYVjBJWTZqODZieUx4ZWlrUEVrZ1AreWNuOS94N3U1SnBwdStaL1kwNHZxa2ZpZnM2eFNKWEdyVEMyVUtlakxQMTJzRjF0ZEZJQ1dGWVNGTFZ3VC9zSkx1NlNHKzdiQ3BpWlVxdi9MY1pmL1Vjc21Zek9WdUp2ZXdPSWVncXJYV3p3VmNuQlFQREsrc1VSVVF3Z0RPUnNFM2JxME90K1dSS0h1UE0xcjNzOXpCUHNhVFdPNjFENkg1Vi9NUTJLY2lrZ3lVNGlYN05NczZCRnZDRWttZmh1SWh5Tlo2bFl2K1dzWW5KcFh1QWdBQkJQNzdBMGpTZXByV3JDRDRjRHNJT0JURUR6SUQ3YkcrZkV2RmxUNUo3K3Z4dVAyRDVMVGpXaVlCQ0RHMUdXYVFDMVhCZDFPQUZpdXhsRlVvSnl0QWUrVXQvZHVCcVk3Rm5XVWJ0MzhSenZhZjR6dm9SYVdBWHhwZmMveElKckxLUFN4QlhBOVVEUE1DWUpjMWZTYVJKVEdXeFBkbjF0cGJ5SFJYSEh1clRkVlZwdzZPN3EzeFl6b0Nydk5PeGpuZEtpQ0U0alFOalNMQXcrWkFiTVVpRHcxODI2ZW5tSlV2UFlXWnQ3NW9wUlNQL3E4aGpObUZudDNyR1QwWk0zSzlYUHZUcnR1QldSVG9xSDM1aE42N21OSGpjMWM0SndORC93RGx5SzgyQUt6eTd6TCtkcGpPUDJDbVJhdFVGeGFuZ2Q3ZFZFRTA2L3MrV1U4SU0zcEhBZXF0MVlmcnVmMUV0R3BrRTUrSW1Sb3piRktaV0JTY1VZL2hXeVM5cUJ0eGM2YmJ5bk5hZ0M1RGZMSHM3NlFHY3VBYnRxS3piUUl2SVN0RVFVRE4vSk4vUHJCd05TekF1NFIyWkVMVmtRckhvZlcyNmRmdFFBZFhuYmlJTGZOVGdPMXBRY0ltWmJXUmdaWWFKbGVXQ2pHa3EzTWw2YW9MeS9GTEoyRkVySm44L3NwbEp6dzhacFRGekMrQVZDTTliVWN1bFBieWdPQnhmQlBveWZrQ0pRQWNHRmFrT055SEM1QjhlekpJSGF2bDlHQTlIQnRRMjFEeG1qN0Q0M2JiWVUydnQwbGxYdHN1dkJKbmJLTG1FNkRWeGhJUGVvQ2g0U1N6RllDUjArUklPcnplMUpOVEl0REdSYmpaWEp5bzF0UjM3cjE4RTZmTGd1UFpRTWlHNWdkSzRtUlg2RzlFNTQwNFMxV0VLTkt6TVBxdnJnSFVEczhYcjFxc2dPSW5QaDR1TXNLWm9zTWs2bnhrdm9vNHhmNXdtRFN6R1JLUUpuL0g1Z21ycTNhYzZNZmVwZDVrZFJjLy83VE8rQnZkMnpGZEc0d21VMHkyc2VFU2o5M1I1Ui9aanBQQlpVWnpsait1a0F0dVg1SDRTcGplcWRjeEhWL01rWDF6UjA0UHliOTFuTU9YVHk4UzdxQlVSTGNieS9mZy9VSUJMcXBBNVRndlhnQ1JuNGxmSXJZTG84NVVQT0tVK3ZURzBsMFNqb3ZzOG5XS3RSek5QdTZxS3JHcmc3M28yUXFpSGpTN1FkVFRXUXljRWdlSTRjM1k0d1NsSmFGSk1aak0vdUU4ZjhWZVYrVDdpdGVydzh1RStoR3pTMFVhd0FieDVFc041RFlLMm1oeW9mOTYzLzl2eUc5UnNLZGJuOFk5MDBDNlVSc1EwM1lQdjZWcmIyNFc2MGFZYno0R2Vtbk95Vk1Sc1ZSaGQ2RXVZMW1sQ0o5SXVLSGdPek9zbFJJRkhrSEhnZ0pVRmpxNjBLRXhPc2tpZHQ3eklSVzQ3ZVdpd1NLTkE1ckdNNzVPNEl3M0wyWXR2RVVlVTh0Ymo4TDAzdnp5V0JaVkRMY2tmdWpHNzJLaUtEK1Iwd2hyeVVZTjI0ZGg3TU8vbXU5b1pnUkVlbWZlTDkzbFNEVlh3bDNyTE55SGhOVHdFYU96Q2RrUTFhd1ZiL00weXNQampsOWhqOE9UMlV2VHo1eUFRYlpMcXNqdm9mY1ZYUllkQWNmRktNcHV5OGJrZzlodWNJMlU0UVhsMFdtMnZ1SmIyVlBOVTlLdk14Uk9VQTE3cXRpck85ZHYxZmhxcXJFTG5HZU9FNWhaYldSdy9IRUNBQUVFL3ZzQTJ2WXZJeFRIR1YvT0tkSVlFc0JuUFFxUkNIbFBqSnArSDNiWW5TUlNTN0lENnZwUHpxSTZTamU3WlVTb1pWMzc4bUd0bk9ZSUVaTXl3Mm5jMnhtTGt5SjFTdmlORDlTZnMvd3ZVdnhScGU2VGs5TEpXdFErdHBlL2hxa0RVcUdYZTdIYnBDR1dINmRtM2pKd092OGFTa1VwdHE4UVRWNHdQYWF4ZmpyVUlhdjUrL1NCcVRPQ2sxMXRKc1BQWStlRDZtN2grNlhhNUNlNTJiZlZQMlBNYjFlN3pQMmVKYkNUNFZTUi9lbnI4Yy9pZDhzREd2YkhFcmVQY0d5QjBneWVLOWE1R0V1R2c3aGVaYUF4Y29oTDByMkJ6am14VHNsR1Z4V05tQVhzS3A4Rm1zVDNJaGJPR1BpdXdxT3pmdG82cXNJR2ZMYUkyK3hydEhDM255UW44U2FTRXQ4aXNZVWNINzZBTUsweHBnQUI5MTNFR1NkdnRpa2dKZmkrNUpJeHRFemZscDk3WGlsQW1JZXBpS2FaTkJZZ2pYaVZiTFd0VWNiVEZIM205Y0VSV2RNUzFML0dDN1RuUU5KQXJEUmJrN1FBb3dMakFmenJIR0NaUXFyWUtlVGFVekdiSmpEaCt3QzhuNHRzMXQxajBoVjlSWDZhUDJ5aFVLNWJBUVlHYnUvQTFKMWJMRzRVc0wvTmlXbEoxZUwyYnI5QVB0VGErUmhnVXEvbGRjWDZVNkJnNENqL29yMUhjcGtmRGZvdTUxckFqenhzMTgxdStwK3I4T0ZXdGxmMFR4cXVDYUtnUzR6VFU5cVpnYkhsTGhLSkZJZHVvWElUUFQ3R25uMjAzdlpjYkNERzIxTGRFU3BXSlVzaTllZXM5WVlEYU5JditPRG84b3pSQ21DUkVzdXg3SStka2ljYnBheGdUUnB5TVAvam5GalowVTdxVTUvL2NMZDY4clIyNVU0WlR4NStlLzJSMGF5Y1NHY1kxUDFVejY5bUJVcnkwLzQ3OFpicThvSTVVc21kQnNsR0kxRnR6YmtONnJCSSt2d0hVK21NL28xUjVjUlF0R3d6UGljQ3ZuUXFlL1V0QjNSRXhMWSt4R1ozNHorWjJEWHl5RlduVnFvTmxjcU15RHFwRng4Q1NJSjkzSXMxbVE4eGg4RGl4aU5zTDhvRjhrZG42THhqa2d6TUVRR0hxU2kzbi9ETTA3TnJKc1k1Y1JFTEVGbE5Nd3hOMWo2OUxmSS9pcWZsT3ozNWplUVlDVDNrR01sekFJNFE4SkdBRzhlRXlpMC9PdVorNU9qNTZiL3puTy8yQmpXdXhIdGxac1RXcnRTNHJjRmFpYjJDTVZQWXhBeTlEYUtCNUJraWRxRXN0WWhMSDg0eDc3L24xdGZHUldxdEZjMzRiYjFlU2wyU1NpWDBIZG8rSEZ0bVdCeStVNkpBUGZwekk0UjN0aGdMVDRsTWh6VWVSWGtEdUR0eGxzWWhJTWZhOVhLTS9QU2VqbHdJWDg0bTMxUUJ3aUdlYU1qa3JoZUpIVHJHbmpyZVNPV3B1UEluaThVQ3hVZ1RLdys3d2l6c3VCT1luVzFtaHRtUW9ZN2xCbW81c2tNcDhXaXhueXA2VGsvTEVTMGpuWnJhZEh2TVNpN29OUllLVklBaEFndzZ0SlhhRnJrRU0wSG5Jd3JnTldQMlpkcVZsRFNuNUNaUE9qOGt4TTlkWmlWVXgwcDhGMFMzRHJjWVkweEJOUHgvSExqRExzUnlncEU5T0ZyaEJUMzF6TEdTTFA0UUpvRU1sa1NkL3AzSXRnN1BxeERnVEFJQUFRVCsrd0c0ODQ1cGIvNlVUbG1YR09WWDZnSldVeWdGTzFIWFF1Q0J4cEx0VXFadEhSTzhROGIwM0FjZk1za2ZveUtaZURkbUZMdlg1dWhRcnhSY2lhbFMxNXJIM0ljaUNFb1RaQXFaTUJqU3pNenp0RldmYnhEeFNUUEVGaC9EWGlYN0Z6cm9qRjhIK21kdWtnRVYrMGNCYXdnVGx6cmhFRnNQWE9hSWduYU9kcXlITE9hemlQUno2amNRWlhUT0NBTkFmMWN1Rk1YN3phSG4rSW1NQlFBTFdVTU9Oa21vYSs2YjJ6dmQ1Zlg0OEZibWNYNDFwTkM5dWV5MXlrc2hpemR6S1dMYlh0SkdOTGplNXk5UU1JNDNBUlhneEVER2ZVZDhNUC8xOFROYkt1TkNRTk1oR3JqaFdYd0RTemtFdXZVTGNEbVJxR2xXVnZZbVFqaFhxeG1BN3JPYkRMVi9xeHpCUzVwREsrcXQ2RERuODgreDFiNE1nTjJLNnlsbWIwU2s2VzFuTzVlNEpsaUFPdndYaHoxam5ubkNqSmdQWSszbXQ4U1ZaRXFQMHNzSTdIT3ZRaWFGVEthYlpWS0xOUmc0emd3N0lsMklEY0c4M01KY2Z2SWZMMmtJRENEVTR2bUJDR3orK0VHWXlUeldWUmZWeFBCNFBVczVBSEEweTJSdlk5ejNXVXBIQmlweUpTdFBMb1hMaGhTRzMxUHg1N1FOdmNyYXdmTUtvdUZ4TG1IYzM0aTh6bjIweTYwQWpjSGZhZml5aS9FdWNGUEg2MFZRVVp5N3NoNzFZdS85V0tUUnBPM1AxVmZ0RlphdHkzdXpBR1E5RmdlWE85Q0kxVnVsRlAwZ0FJWi94UWk3TzJYQ1prWUdsT2IrNWVrOGpJMmh6clBUSmU3OVVPRGdadmZiekpBRWltM1REeWw1ZFdWNnVEZXZraThaalQrLyt3RHZma2VaeTFVL3c0Zkp5VUY1Ny9NRDczbzZmOW1BTXN3V1p1cm5KUUZwdERDa0VZOGM5R2NVSnc2L1psZlptOVZBUFdLSkNUazh2bWZjRmVaZTRPa0lNOXF3Q1EwLzlIRnp3S2xIdStUbVVMTTBSVEdKUEVoRUpqMld0dnJOZ3NIdmt5ZTFaNDhzTVpBemF5TE9OZkVvdFZHZU5YZ2FLUDFWSTIxSUlVTmRkU1o1TG11QlRaYkpIUzFLcEZPK0hYWkd5dXZJTFMzYU5Dd214U0tVTVNJTkRpV2pxSXMwZENwdVgvNlJkR0t2UzlETzczcGNySTNwVis3U1ZOTHpOZ1FZR2NyeG4vd0lDK0JtdWlYek5WTFlrVGtPYnZndXB0MERTdk1hWCt5MCtSa0ZlTURrTUV4VS80aEJ3TUlaR0JwM1NodXRLeWwrUGZON1d1cStMczJ4ck5Kbnlyd2ZsT3B1aUQxZXJKdGMyNUNybnJ0MmFKZHRIMDRoL0JXcG01cEFKb3VtcDBUYnduWU1ucVJjcDluV3FHSHZRbnc4VGNvbnlWYUxPZ3NiTXF5UGtBV050M3VYMmpoVzFaejhZeXVnSnNiKytBVHF5VkN6bFB3czRzME1qVkdnVW9xLzcwdmdVeE1tWkZmay9kYXVjL1E3T0ROc2hCaEVsaUNlQVJwVFduY3lGSmdIWnFZUHA0NFJwNkVuZ2ZVMEk3c2sxeklNSnAwV0N2Z1E3VlJqTTlBV3NNVzBTZlVGMGFoTm4yY0FFMHNoNk9tblVQU25yd3dtS0o1cnk1VlA2K21rb25vRmluUFpKeHhkUk9na3dJaUgxUEJWdWpFbDBqNkRuS1FiOGZRVzJPR2lBZ0FCQlA3N0FXTVMxN0pjeTd1SUFaaUJqc3I2Uk4vcVhrQlQ1LzlzNkJvcmJzNXpnTmM0YnFuY0dVcnQyb1JDRld5VE0wVUNCLzBoT2Z2aGpXcUVHaWROMDl1QnVDZ1N4Ky9kTjN6VnkrRVRtWTkzNzBWYlBaQUZPSXJJQXNsd1phb29ENzZSaE5DTE1JWSt5TzQxTFUyc0l4emtKdXRuNFJtMkR5SEV5NTJZV3d5SXlFQTZvVUJpK0E4aW43WDBtUGQyTlVSTWtMVDU1NmJQcUVKY2E0dzNxaXIzWTd2V2JGdGNqYzZUeGpaaXg0RG5VT25YK0tXYzdTZU0zM20xTncwUnlHcFlUWFNrQjZOUFJQRWVrTXFwaTlaQjEvVDhWSlNPY0pDNDRRbnZnWi9KSkRDUzJvWWpqVDB0dldsYkVuSlovT216YjNhOEl5cWJmVnRXS3Zac05NazZQQ3hiSkl3a3VsWmVnek9Kb3liQllERHEvYUpreXduUXAyRmlYMmorc3cxZzRueUtNdGNJbjBCWmZ6YzN4S1NJbVJ4Rnovd0wxR3YrQVhEOHZwdjFQbld0Q3VxdThhdXg2RHI5UmJpakhIci9QcFZ6eEVvcjR1SzlpVGhDWWV0clB1ZzRPUjQ1aHdqM1hySnJBV3ZTUVNndVFUVU9ENnVWN2o0cjM4NlNyOVFOL0NoN2xhY0VZbUw5OENwZHpWM2YzaFU0Y3hQVERQNlZqQ0J2T0FWeElUWWJnMFgxZCt5SVErWE55MXBYRmJJT09IVzcydkhUWEFqK0tZNjFiSzZaOUVaZVR2NEhsajhZdGVHWUlPYUdJQmxTejUyMjlHRVUrSWZ5R3hwcXk3bzQxTjJ6UW5MQjAzZDg3aU9BWGhNL3RJMXdXVktnZjdEdnh2b1RpclFNQk9VSVl0TXF4T2pvOWNNd2ZYNC9MK2ZCVEFBaTJDNkdNcEhQVVQ5Y2JhS3QyRy8rVFBJUU5idFlBMnBGUzBieWRUMlJ2VkM5dzN0bDRlSys4OFFEVWVPU0RKZmQxS2FXY3VmajZ3eWdHOElPTm90ME12QzRBeUJxMnJMdmFZd2ZZbHVxM3hreEVCL0FXYngxaHNuQmVxaWpWK3ZHZkFldm15aGVablpVMys3eHNEMFcwUGo2QVBpbXkzTEoyTjc4RXh5WVFzMnRJblhXUEtrV3YvS3pCOHA3VVpOYWY2Yy9NenM4dGFZSWlmLy9FQzNQeEYxYmdqSENPSEs4bVU0bURaVFBZOXdMcUUyN0loMllqRzVXVjdrL3FqTmxFSTBSUXp4a3MvY3cxT2lGNjhzazN6aVhIY2R4Z1NCbmRPZTUvM0ZDMVNoclVkbjhZNFJxVkZzdTNUVVR5UG15UnNCL3VldjBWc2hEMDdtRUpsMDVIQ2tIZCtVeXFlS2RGM3BPVy9HOElyeGdSbGIybFpENlVZUEdCa1FzczcrZytHN3VvbDNQU0VFSTNnbWliclNSblU4T2IxRkJvSUV2YVYxSTRGUmN1WUVldUJWQmp1UkNMTlRNb01mRk5zUTVoQ3ZqbWY1Y08wek4yRk13S250MERtLzI3K09XQ1dvTWtLYnhFRnhxalRTbjlzY2oycGluYWJGNVVlUXZ4ckpqSU5LbEpmY3NmYmhWbjJFQ2lzL0RJa0xzandhNTJGNVB0cU5oWTdVamxDN0pMU1lIN3dveGpudm8yaXRkbTJyeW5md0wrN0xUSmJOTlRJbDAzMVAvcWtyUThNYTJ1aFhpekloRS9SVnBSMk0zTk9rZHprVmo2S3N1SjA5ZkNrVHozM0E3SVNzcll6S3lhTGJHclc4Q0FBRUUvdnNDcXVyLzIrNGI5UDZLVDZQaGtTZG52UkszUFh6ZjFrdzlhN0t3Zkl6dVBKNWpqTWlMeGVxS09KY2hFV0FvVnVveHB0RmZPZlZtdkJSL0s3bmZwMWJuYkZoa2NHVTB1d2s1amRCbDFpOVVzNTdSV01zMHpMSzBqekhSdVRNT3hjQVVkdnFsbXNQTVo1UlBSZ05sMDlZSG1kMEE5VW93TnVvMjZ6bmlzbWVKamdjT2NncXZrMEYrbXZtOXNvVDc3Q0hYODBpV1JDUW5xc2srQk5RQUY0SWxORTh6akdzYmdyY1RWQk14ODF4Mlk0S0FKNkQweHJ0OTJ6STZCcnNTZWxMdEdxaWJXdTRPK1JHUFZUTmRXNVU2V253dVRpZTZNdVJnbytGU3E0Nzh3RGNrZWdFWWNIWDlnME8zbWU5MVNYNllaWDF3d2licXZJOXVLR0w5WEhUT3dFeXQ1QUxhcFhDem9zLzYzR1FoZ3JGN3hKZGZTeElPTStXRDBnNVBOdXRwU2pndktVdVJ6SFo0R3hvQyt4UjJIbEdFOW1NUy9PRzJsZTRiLzdHSS9FWktxYWV1NUxkT2lHZ0lrWmE5b3VqandxNWNFUjJWVzdaQ2cwSEFWc0thNjFxbTBVM3VkaXgwdExERXJTK0l5ZElzZHozbHJlbnBPRFJ3Mk05bXgwVlpleEFFVXRnQ0JVNmRmUFFGdlk0K3JEWlpTVlpQcXI5QmtDZlFsZjFHRTRQci9reWtOYjNGRndOM1V6a2tjM0F2LzdRWmJMakd4OXZMWDhiZitCaVRkQ3BORFkwdllpU2g1K29rWGVvczg5dVhORzRJU2lDQlBibUxlNzhUc3Btd2ZCTEJIRmM2Rms3NlduRlBXT3RITjMxZnJPMmJ3OGtMc0x3UDJyTGFaYUVsSmdpcGczR3J3MTZjSW5ld2FFUjJFcHozU2lFS3dBV1FFblB4MFZacXY5UnNkUkFVSEwyeS9QMEJ6RUFqU1JnUnhmclZLYmhncVBjaUJLN2x4Rk0vUm1YakpGZkNXM2FPSnFra0ZTeVlkaEIwRDV2ZGx2UXBTYktmeTdZNTFkaEErZFluVys3VmxPRjhEK0owaFNka2RjYllnK09JdEgvaTV0Nnh1c21YT205a1FxbGNJQ1V1bDB2dkhtOERzd0VxVkljalp1dVM1SGRBWmNoNG14ZENydXpuZnVWa0RNUzExQUxzdXlOZlJISE9CalFsdFY2OHlMR3F1Rm9Rc2p1Nk45OEYwNTVGOXdDZ2d1S0tHQVVBdHVZNStIV05aRFVOSU4zajdHV3VoendlWm55YU9ISW1zc0taaUd3N2d3eTd5ck9hN2hRR3dDaXdXdkExUGdDQnZBa1RVMkFpN3lERUVLb0I1SnRjT0FKbkMzTVVCNmhsMHQrNU9EQzhhcEx2anZ0UDZmeUJiU3FaaEJuRjFjTVRvbzRjVjYyb0kyeXQ2NXdIb3dqWXpPbGNIQnBXUFM0Z2NMbFM2UldsR1JjQW1LTGIza05uYk41STJSVnROazEvd2JoV0haWXpTQW5WUURFSUhuaGxEWk1xb2VnYVJ0OUJ6WEY1bXI0NEF2Mi9ReU1FdUo4enpodGZnZDZGVU5DQkRTemJnclVMNkVyeWhWS2tibWtFQWpWcDM5NHhKUG40UE9mb0Fkd0ZpemVRanQ5NmphUjNxTkRGMzhQM1IxTUN0ZlcrZmkwVi9LVXhKUGlxdy91T0hCays2VE1qdHVxV3RCajl6c2lpbmJxL0lpT1RWNEJQRlRzL3AybXd5T3dITEpud1ZEWkRodkFtN01NT3MvNDRsUUlBQVFUKyt3UllBN1lPcnVtLzRicDJtZndtQkQySmttRzVKNUc5R1RoZk1SVExZNE1ZQy9KbkFPU3c4NFJscUc0QytZVHI0VTVZS2dnckJTbXdRNHh3ckRhOFZuTlpWYmFiMmhqWUtFZGcwdklvQVFZRVd1aTFyWjhqZHU1dW9BeVdXNHRmbDBNNE5KRWRMOW5qS1dXMXA4WjNyK25Vbnk3RU5GZ2ZpQ1VLdFNRQ1BBUUdVdnZZU00zTFM5REpKS0dRMzB0UmJHNU9LbTBPOFlCN0F0SjJsdFYyTSt0aW1qT1dpZlBDazVmTE83U3JQVWorUk53ZW9NdDJNQStwSXFpZFNsY3Urc3Frek5hSE15L29PR0lkakgvMmg4YjlRQmhUVGkrZzhJdnhkdWpTamNZM05sMHNxdXNaOU4remV3UkJtNTFQTTkreGVmd0JpMEpFVXVHbUFNcFNBTHljK0dYTEhqY1BsbXppbnBPNFlvS21lcUkxYlVwam9rZmNYdFB1OFFvZzdoeXZ0NEZKVVNURkpXbE5RN21tWmtqdW5ucW5Pd2tEMmZ1YWVtTHhWQWtTcWtreE1ERnUyMk5kcmRCNitzWXdwWldycWw4VFpDNGRHQTJRQUdINFdzR0Z5ckR1RGJTT1NEdUVDaEQzdWt6eEtzMkxReU1LbkNPb0p5VzBBWG9ZcUdxUlRZVHp1MkV2WEpKYnNpSUhITjRyeDNtbEI0eFVhTnhucnpTcDV5ZjFSQ1N6Rml1NFRWRUM5ZFVMR29YcVQ4NHlLSWY3SkJIRm14bWdOaUFibnA4UjVtN3ZqcEtvaHhJR015WTVCeXl3V3pMR0Z5cFFEUlVyWG5xQXhWMmFHcHpHRmFxaVFhb1NXUkhxS3NWdUxucFdHYVFONnkvUGJtN1hxemlTTFRtbk1CQ3p1ZVV6ZlpOTDZjWHpwVUs3bURBbnpxbklGeGY2Z2lMRzQrY1IwRWNpbWNEeTJaeEhFWjRFMGRreDNrVVZCclU4a2RwSFN2UUNYSnV5N3pEbXE5VHZCd3JsVUlLdnFUbkZpYktKaVZVMUM2SmlRL3RRbVNKZHZxcG16cWdWeUwvYnRvSzFJVVdjMS91RkJrQWpEcXZwck5RaStTY3FFc09sei9aWnoyMGQ3WkdxNTc0MkYvVE4yZlRKTERQMzAwaUtSU0FrTk8yMUc0cjJ3elJDdEVuRjlmVkhOcU1EQmQrS3BQbU1Sb0VodDIrSHhSb0xnQ0ZJWjlnM3FXNG5tam5mVmhLOUJ2UlRudWlxWHhzUDdkYnhyL1ROQStmZGU3ZXVTcFRwVEdwd0Zjd0U1ajVJU2tXYldHb2tvazA2RGRPTmJFd0FVd080NTZrRDNhTWJld05wZnl2RFM3U0ljOEh6TFFqQldlMlNRZFZNckxRSU9ORFZXWlBJZFh6VGxUcWhxaXdBY0lhbEM0VEZOVHdQSmJJM0lnaWVEa3UrU3QyeDB5SU1rMUVDTW5tcnAzTVdZSnY0ZDFnN2hCc0ZWZi9QSmloV0poaTVZRHVwUGpZSmswRllYbVpSQ2R5b2ZQK2tnOWFvdDdFMmhvRmdHZWRmQ0VqZEsrem5hUFVBRTlsYklZTWora1Y1QTlGQjM4emRIVFpuUVIzcUo0WTdkaVdwUnRqcHhBTExTU3JoYWlWdHVTN0dxbWpTSE1mL1JleklPNENBWjR2S3VGK21naHNwbnlVeWZNTEZ6TmVsRzRDTUs2aVI3bCtkUEJLcXNKdlAvRmU0OXBwQlp2TytPVzFxUEM0NUcvR01KczZTcWlmOVo4MGhUOGpDTVN4WWYxY09xUHpIUlBHRUFnQUJCUDc3QkNIVjVOSWxTaHN0Ym0zbU5WWWVFOWJvU25iVVNuVjlwc00zRnZIclYwNUVlL3dqQmQ2bjNVc1hDREVxcXN0WkMrZFViQ2FkRFZ2T1UyNVE5WW9BbHJoUnprSmZFRGtSMU9Fczc5Q1BiKzhvNFlIZjVlcEl6Z3NONmJBQ2U5aWhNb0k4ZjBvODV4UGZHTXIvS0JlOUlBMFRYL0FLM1RxbUZJSk4zcmVPRHJTdkFQU1NhQ3ljTkhjTmVkVHpTZDJLVnh1ZUdKaFdnaFhOdmswWFQzeklIL3NXZUlCc1NaZi9Dc1J5TjJmV2dGZVZseDlzMC9jeXJJN3AvYXNLNHg2ZDZ1c0R2MXJrTzI3UStobndBbmNvVS9jc3l0Wmp1RUo2bU92TE5oTHV6ZHg3OGJtNHp3S3FsTjI5dDBPWlh3Y2drUU1hTTRqamFOUmx5RjVUNlNTdlFjRWlPdTZwMXU3ZCs3TStCR0ZwdytrMzlIRVBzLzNnWC8wMXEzRXYzcXdsb2R6aDVZQ2hnM09mQ1NsbVBUbkN1VXV0QkdrL1Awa1hERndzay9UQ1lTaUNqU1I3NDkySlFLMUs5Y1Q1TGtoVFlxTktXRk9CZDhRTDNRdUd3RjdPMEhiT1dMNE5CVXF3Nzc2TEJPR3BLYnBRcm44eENqWU1RZ1ZhQlg2NmVKekZnc3B6NkhoWVpkVngySWl1a0JkRnp2RHk0WU40cUlQdWcvRjYzK1J3aGpGMFdBWmRnbjBQZ1oySUZtNm9zYUwxYjJrRVlUQ1F1ZTlsWE5PckxSSlpNVDd2RklPVU9PVG1RMExBQlhSNmNTRkFZZmlNdlRlTXFWK3R4OWlzQVNMSDc5eTlhWEV3TFlxSVN4bkp1WlMydHJqN2pCVDQ0WDlqQW9HbHVkZVJ0c3dmcHc4dGI4MUErU0plVVh6QnQ3U05CbW8rT1NrSGl2YnEwOSs5bG5ubVB0TzRiQUVSWXZXbG1EajZzdXZ4bC9OUXZPQXg1VUhXaklXRzBrQzFyakxTZDBKOW1zbWVYZnJYNXo1OVBrOFlyaU5FRXBVZlJ6V3pHSkxIQ1FwRHpWU0hnSDNXbmUvOUF3amtEcE10SWNYSHJHa0xFcGMxc1NPY1BZMW5Qc0VFTWgwdmdaVEpRS2hIOXFKSE1HcGlrUkNxak5lMno5K296MXhqRVE2VktwcTVTVXU0UWw1cnFJTHM4bytBVmRqSUliMjlqNndPQzdpRnpIMEFmZWVkbW90YzJtYzdvZXFmTWQxZER4WmplT1pEZGxEaGF4UVR5S0EwMHVjTHBpdTNPQ3djVTQ4UVp3T2E5TWZxVGpMY1dlMVh4bHM1S0VkTTNQeHcrTGYxMkN2Q3V4SUptUlJQUjEvS3p4Qy9MUE1UdGIwdGFqbXdERXZyMlk2M1pyUFh1OEFtUXJWb0Zzb1JjcE9CV3htQXRaajVPZy9SVWNGeitHZ2h3R2NrOEhxZTl2akw5bW5xWkVHczAwQzdPRElyWjBabDMwMzhWVWFRMUxEbE5Ud01nOHU5M0pJVUp1UjcxZmlmenFWbmxyVmRIVzZkeCt3OWFzUWRpbXo2N1NJa29Ya3pUcVlEN0Y4NmYwc2xSZE9Kd3plcFdpOVBDODlvRnVrbS93T3plQUJSNkIyQUZSZGN4dVN3NlF4aUFRbHc3RDh2WUR1RmRZSE1kQ0dFUlRSbGJFSXF5SDgrNWZLZHdraXN6U3pvMVFKZm9QVVg2VkdrWTFRYzFTMlpFam1TckQzYlVxaXBDeDVBcVhacytSVU8zMkRKTFhrUzRKRHdtRE83emVvd0dBVm9lZDhDQUFFRS92c0J0WnZrdFgwUjZHMjZoRGJhaTREK2dJZE8zL0pMMU1MVXFuSDU4bWdKQ1VIWThZTDh6MDhGT09aMUtrT0xucUpGRmUvQ0FIWmwyZ2ZRQUhGbDZjZXVRUlpoK2VoYTlSL0hPd2xiWTlGV2QxMkUrTERENDh1Q1F4eUNkMHVhVzhHM0psV2RlbVkvZVVzTWx3SmVac0Y4OUZqc05oMThDT1ZHL3dlNms0cEZ1Z2ltQTJGTG9uaHA2TVUvWWRrQVhwQW5KWm9xY1VkL2JGdW1sWVp6REtRYUswQ28yeTkzQTl1SjV1UXRrZE5WaUxKdTNXUmo2aitUMjg3a0syblVwQklTbWsyTXlIR3A1RXBhZmhZOVpNSXIwNnNBRkpEWEdNUFVqWWlCM3VIekxRYlRoSDdOV0ZkU2VsQ0F6VzB2WWVyTU1QQ1ZMZEVnTXJxVU1FclpLYTYyVjY1M0VwcWZ0TCszRGE4cHF1bXUrMURxK3l3ZG52dTZPL2p6NnpOK2N1T1JnWnhPaUE3SXlCZjRYMmlyRDNKVGEraXhIbVZyUm1KYnRIdjBMSGdOQ200QzBJckZRYnI2SFVZMTNuRzZJdy9tS2VTVS9TUmNIcFlUUnRhdEtwVllWclR1RXVGSEt2cWZsTXZvUnp5VWFKbWo0YklpWHdPOHhWNVJUQjdJbGJZam9nRlcwU3Fkc0dubUlSNURqN1BtUVNTOUNIU09jK3pPUmg2L0dRS1RXamltV1AyeDdGZ0ZNTC9uMUwvcHdjNjRISitUcitjWW5XUFFqdVZQcWNsZFlFbTlHeTFHL0I2L1lxOUJaOFlLWDVrWURJajQ2Mi96V3VOVXg3Nmt0MDd1SUJIRzFJbE5Gb3hYaTROZ1lFSGc3UnFnc3pjeE5KekxSbC9ndVRyZHhKY1diRUJNUzd2NGZHNkt3cWF1RWJySjlENVVlcnQ4d3FzM3d6VzJ3R0hoTEkvcU1qMi8vc2dCZXJNVWo5dzVOdWNBZEZBdkFTSElHQWFzRnVtVTViZHNDNWpxUEFsR0JRbVU4a1U2OUNiWmtQd1R6Yk40Y3p4ZWZoWDhMbzQ5MERST3pVQUlLVk1uc1VTZzZsK3ZkdndjL3pjRmVCMTU5Q2NKaWtjWkZ4bzk4dkxEQUpLSkdPcnh4bjJtVU9zOU9XOWZTTEtqeGJIMng2UDBJRXB2M0tUUDMxMXJ6S3pzcUlrV1cwNHN1Qk5wS0loNkZzZG45Mm1UZURkMUVESUlHaDBNV09VUmxLRDFCOC9PdndjRzlKWXVvYzhBWWFldm1UWWJaVFVCOHpYT0dZSzBFcjgzc1VCMDhTNWJZZXRrVHhVZUthczIrenZSWjd4aHEvY1l3UzRzTDFyd1AydUg1enpBOTRWWWM2UjQ3L2pGMVBGVmxiV3lwMVBzOVo4UzVMaU91SmNBRGorY3ZpZVdkZmV6YkczdXpOcVVTOU85QlZTZlhMbkR5eUE1SzF5WEJDSlBKTUd4S3pUay9NRi9zZkZNMG5GWS9jT01LM3N1eVRTbm5Qb1NOd2tFbmNYWGNNOWFKUXRrR2NFWStrNTVuWFNtNFlYOFZ0ZXYzRGVEbTlhY2FwNERJMVpJZzVSZVZtVXNvaFM1U3cvR2xwbEZ6Z3d6R1dNQ2pWeGtxb05Ba01vRjFPMFhxZWx3UHF5MTZMSFlXWjhuR3VXeHprblBKSS9oVXpxUFFEdVcyNW4vTW9vZDNkZzdlS0Q2RzE3aERoZ3EydHR2bExFS29rais3cTVoUE5YbjU0dFdWaXdwc0tNdHFZUWxWU0ttRDRGUjg4TzQyOUVoekZhUHp3SUFBUVQrK3dPaWpEU202UjZ2QjlPZ1hPQnNFTHZKZk8vay9ydUFobGs4SmtWTVV5NjBHOUZ1aXpVYlRRdlhROUxQTWhxOFpmMkF6bElVeXhSVmJjaWg4SVdqVVBaRTYvdVFTWFhaYzlEZHdCWmxkRStNRzE0TWhuZ0JGTE03bkZzd0VQR0R5UUpzeFhsdmFtTGhGUWhRZVl5dzh2b0VFNGs5T2oyWlFPelNRZ0t1NWZZTmNaY0lDZ3Y5NUNRTlBsWTYzaW13bktGc3ljS0l6ZkNMQ1c2STZqUlFxSEY1eFhDbm92Vk5IL05QanFrYU1XYkZCNktpL1lOeW16aDMzbWc0SlduSjA1cUZ2b2RzS3dyWjdxckF1eEhGNWtuSXN3Z29KRDAva1N5eFNraGVyN2h0M3Y5ejI0RGtsak53aTRsS3NPWXpIY054NExqbTZiWjFtY1NKMkdqeEphY1VsVy96WGgzN1o3U1puMnNQZU9aWEdKa0YvOTVQdWtWYVhpaDVPNGlvNlNsQzdaYUJkaE0xTXBnTVBPWHJqYmJHU093NDZBaitsK2tqQnBrNGJTYlVES1dzOXlNTUh4V2N0SzRtL1lUbVJiK1crUTRTaTdheFNRUW5EREUwYTh2UDFOTmtaekZMeEpBOXpHb3c3Z3NxdDZkSWc3Qyt4NUtTa2E2b2ViOHBiZ2J5VndZTTVlY3I4RmdrUll3ZlF5azVLbXRCSFY3Ly9Da096YWozYzRlMytTWkk3KzVoamp3cGRLSi9XbWVab2tCZTJHcjZxNEIwQW1jWW9VVVl3Vmc3cmJYWHVOM1VPcU9nd3NLMVhPRmk1V2dFYUVuNkg0Mm42MENZcG54dkRpNnFLNVpncXB4U0g0SjZPYldjRHJ4ODl2dzJER3o2TzNrSmx1QkYxeWh0WUREVklyelhubnJJUjZuTE40YWtGTXFaMVRVZnZnZzJQbXpkNW9tSkdoYVBEWlVJVTh2UDF6UTVXN3IxWU9QWDh4bndwb1lyd0g0TW9DTDdBb0h3NWx5VDRFSDdQZHRxMEdrRFJQNkVwZ0xaR04vdnpXcFVIWmRITmZMb0gzV0Rwb3Z5aExEcTJycElLM29XbDVJU2JJWEZDSGdUUUUwcnRhQlVFNUx1WXFXdVpYNnk2OHh0S2tXZDVOR1dWVjV5ZjhrSVJtTExUdFc5MkZWdmJ1Y0lLVFpiUHRXUlJzZVZwNFZrVlhhRjl3VWFYNVVKbjhZamlVWUJlSHpod2s5MmJ0VGo2ZDRuUU5HZERFL29BNmx4ODZOcjZrelhaZEtTR2tmUThMWmpHL2x1OVVqTWJtTHFhK1RnZHNSUWwrRmIwZmgyQ1VoeDdCSWFPQkp0NzBaNFpKL2VXNGJXZGdNZmEzTWs4M3BVUll4ZTN3VVlCaCtOWjZRdWlWeUxUMmppZzhrUUhBK2h0SnpSZ044UlBJd0tic2hmcWZRTEJza3E3bjFJWCtKZmJPRE9VbzNpUDVNZ2Z5SUd2KzFad0JsYVI0WUFDdUlORkt3UVBaajBDajA2TXpGdE0zeXZET0ViRm5vTmVTeERXOEkrQ05KZlNSaHFORllMM08vM1ZuTi9VV2xFejZKZGZnK3Y1UU95SEsvZlBkTjFaa3k3Yk9kQ0QwbXEzZFRiL3VkK2xBZDc3bWN5ZlBhZ2FkVE5NNDdMbGtDaWN0VUk0eERnS2pMYU43ZUJOZ1ZxWGdsbThzSTY0VkpJRTF2MXkrUUZYZlpJdGZIY3BsM0p5MTJGZGdSbU1uVlVPcFJ4ck9yUjdxRHFwQ2lzL3JuUS9OTFRzWm1pRWFHR1RvTWpueHpoQWdBQkJQNzdBUUpsbmo1b0dCZDF6aGNyWXdmZ1Erejg2UUswMDlYZWxrYmc5YXAxY1FZYzN3aWFsYWpYeEIzL2F5K01DNTh4TS9KZGJsaHdSMGk2MjNTY1lVbm4waXZtNWxwWm9qYkVSamFNTGowSi93aFY1L1QvdEdDbi9NaVV5NGU2Qk00bEw0K2l5dmZSRTVFaTI5RGlPMEtIWmQ1ZlBFMVdQVjVWcGdOcGMrRUhLcEZmTTlOTDhVdjJLWjM4cFZGNWpzdmZrc0g5Sm8wbGVrQ0xVQnRlbXcyUTZrNUdWbEhxVDdydXd2TCtCbktueStsUXlCSUdzWGVzM2lQRk00ZmVjN1UrbmxsZk8ycW5FOWZ6R2pWYXlHaG9IRGJnQ0J4Q2tHdlRFTVpHbmtKOVhjQnBNbDZWY0gvMG5UclRqNW5HdGZuWmdTRGhQd0tYOXpyd3VlYXUzNGUyeEVIMzZRZnE1ZytYRjNDMm5QenMxRTdJcWNPR0tON3pxdjFXN0ZQQ2lXOXR6S2pPamdyNTRkZnJHbVBVaS9jb3JxYTF1ZWl4RVUvdk53ZWxNVjBZY1FWZkREdU1tRXVuaXNuaGlNNzF5aExNdkY5SU85UC9OcUc0K1hLNVBxclNXS0t0TWV3M200Y2hGQUo3cWlhWmxVaGYxZ1U4VkdQVjZ5bmxRcGRPeWN6K1RocTJxVjV3ZVcrNzFmaWNCSTI2VnVQa25VWnVuZE9oNUtnQkxQcHM5VHBNUDloNEw4NmgxMkU3RW91ekVCU2crVldKbGpqU1NYTDAzTmZYWnZxbFo2UHNmaTRnTFd6WkRydytRUDBvYlorUTdpWGZVeFdSVDNBVkNvT0hqbnplQWxRZUNBTU9vSGE5ZEJDUWVSL2RRYmxlaksrRk0rSnVBSytGTCtKcVdGQ0Nqcjlyeksxa1JBWWlON3NSZURabGZ6cHFWZGd1encxRjRTaGxoN2ZBWWdqV1VRbmRuNk1LYXN3SmwxUWI4Q0JHY3FRZXFrZHBXRjJZeHl2ZTRLRkNrRktKeU5QS1BZWmo1c1RmQ0ZnNEJvNXFYdnl0R3hMQTl3SHlaL21tbzhidFR3SXN0QUM5YlpZS2RyQlIxajNHKzYreHF5SDhoTU9LOU81dXgrWW1NZTc4S0VGZGNkVlFoeTdRdkF5dlBmMlhtK2NMNGVVeWtCcjJWNGdkK3ZnMzRvZnlnV0ZnWU9ySCtQaEVxaU52VS94OFkveUZkYWZjVnhJU3hOTkhhYXZBajhaOFBseW5XWFZYYk04dTNvQmxvRnlGY2pSNDMzZXJGUmViZkJtT09GckJtRS9tQXQ0VmQySW5pYmZ3OGZKa0h1SjRvTWtpcFRERzkrc2tJTEZ4cFJ5ZzBSM3JYMmZvN2JrNFdmR1NOeGM4TFFscEdsOFZzVDBSaFlFMHBSelp4ZURlMWJqNHF4aGIvY2hiT1c0M3VDU0E1Vk9tOVFLYWlsZjJqajFoRFQ3Wmpsb2FNV0RNTVFDWk5pa2hEOXBkTXp0Vm5TQnVUNTAxK1FIVXhib0dPamxuZTlRdkw2a0tzQmc4dUlTa2RCWDdqU0pwRFBnSkJhK09iQkVIdTYzQ0xyVDZDUEdiNFFOdTY5Z2VCTFVnNGJ5YWFpODEzbmNrMkVmdDRZL1ZzcEdNUGFyY1JWSExnSFNqY0FEZ3RFWHYvRUxoemdkcld5YmVyY3U5cE9aQUQ5dWdvVWxIVDdVTEdyM3NvNmZYNDd2ZFFISzRYS09qcW1RbFRnejNUYklWVEIvVXZVckprK1FkelB1QWN4UExoVE9SZzBRZGJ3QXpDM2tXM20wTkhxSUNBQUVFL3ZzRHpXdVRSWFFjamhjQXJVUWt4OXNWT3dERzhWVkV1aUZuWDhrLzJSZTI0c1Z4Tm1rUVlEWHlWcHZ1QnEzS3NMUExnN0FqdGptcWpMQjVvdUIvUkl5dkM2Z1dvZmJHR0ZweDVpbzUweFdYUWYydmhyNzRKMGYrWVZTd3ZjVGJHRDVwVm9KK3lxVE14M1RCNFI4ZE1xQ2ZWT1R1L1RTZDlWbVNvVjBzT0Z4d3VpSGRyL3FuOE5rZnBtKzJKaW0vYkc5QlNvVnc3OGZabDdLc2s4U3pTeGp5N0RrcWtZRXZ4L3NjTUc0V3VpNWltMHFSL3FwNUdmWmZYaG5IVGxlbFpOaTRHWHJlREJYOWR2WjJLSklrVXpzMzNadmplZ0JkOGZXUnA5dW9GVEtPR1lSSGc4aTFJU3NJZDA5dnY1SjFUMjBYblNpSmZYUDBlUm5EVjhSMG5RT25DOVl0UGpzTDFUSnBDdkFFdDZncVVuTnhmU05iMUxuVTlXUm8wNnJacTF0Z21YZmx2YmY2MTRySkxrVjdMU0RHZzZnU3ZhbmhyakdTTG9wUnhRWFVvWksxNndoYVZqc1IxRlMrc1Z5dFJ3MGRrZUJTbmdBalBwNU8rVzNaUWVURFc0c1ppT0I4ZS9CQjFyZ2ZmbWJoeVhwQlJzaXlReDZzYTViOGJUWXpxMWZCeHR5SEU5S1dOclBJL09XMzMycFN4YndscG5CTS8yQUNzMklWdm4xYTVVWEhETElMeGJaS09WZjhJeUlXQmJ1NFJFYnF0ZjRCcnFIdW9RanVpcDYzcnNjNk9tNDExVmZ1bHdDNUZoSDVRK0NIcW84aW5NUW8vaHJzUjEwOFBXaE9tcHJ2SU9TVzlmY3Y1d3ZyVDJZbS9kcGs5NVh1Qmk3MElCYzZZWk5uajgyLzE2c2pvYmowdzAyOTZoZXRCb0N6Zi9yTGtkc1dIYkoyb1hoWnloU3lndCtmaDZYKytYK3NZVC90aHk3UzhWYlNGUHRFa1FtN0JrbEtvRndkejRmU2M0SURodG4yeUN6cWI3ekRvMXJjcEtqRVl6d2lGU1FSKzNROGRrV0ZlRGhnR25FT1hITDlNMm84V3JRK1BQQWFKQTk4SVZuc0NmZmxiR3BCdWRnc3ZTRjNJbHRyMHRxNm16cWphS3A0OU5uWjdvNVNGSm9JTVFKa29OQU5qbnhKSThPYnBLTmMvVWZKNkNhMi9tWXJtL0JmallYTUx6NENBQ3lwVkpIa21vL1U5ME5iMlh1OTBJaUdHQ2cxV2oyTVVwUzF6NThlZ01GdEQ2U3ZRelF2S0ViTmtyamF4VGZsZk43QWNxSzlxUTlWVVZYQmRjSnpUUm5KV0JELzFLanR2c1NRZ1NvSkFaUVR4dk5WTlVVZ2duNVB5S3JTNWhZakh6dUs5THJ5WWIxNDFCUmpDUVUvK2tCdUt6U0lJL0xpYU5MdTZCbWZTVzd1ZXVDd0cybFUzR3FwZGVzcmthSE9zQjF1VGZCQmVIWXBxMTlkaE9PdXRIWTVLbnZrTHg4TUZhcXNtUDZ1OHErT2NYWCtNV2l6RnlOS3d0KzdBZTJKR1lIdHJyMEY4UC8vWjRBNllmQnJFbmdZeCtMcUZJelhHK3drUWFyd1VnYWJiSEJ6N2Q5UW8valh2OWtwUEhYWTJFN0pDNHNvN3Mzd2pDTFlTcVNETno3WXdjWmVQVkNOV1BreXVaTGhwMFFZd0YxWW1FMWViWmhqVHd2WVowbkMzektpenZvbGdENXAxOHJtdWQ2UjVxMkdyS0dMUTRBVVJxRjJjTjdtM2h0SE13cWhhditaWUFJQUFRVCsrd0NCeWVkM1hIMmoxNEVpazc1MWF6eFNWOHhEVytoZzlHRGZCZ2JydUhuMVNjcXlDZlVMa215K2RlaW9hQ0plTXhsZGxxVDFRTlEwazVSY25YT0ZveE9IdWltOGFKVHZ1eVBKVEhkMGh2OXl0c25vMFA1SnZNU3lKQzdrNGJpMnNpcUJVaS9JMzdRV1lHR2VNWVloNmVtaGM4eitDMko1RHorV1NNN2duK2p4MFE4OU8yelE0UTAvc0xsT1Y1ME9EeW1sS2Y5c01rUFRvWUhiVlJVSzVmZFRGQjIvM0tKNUdDSVpvM2g2Y2ZEcVlydjQ4ZHZBbGZyZDE0UHZhWXBBQUxvUW83bllJL3V6Q0cwOEV2MThVTy82NHVPSG56eWtnRzNsNU5tendrUW9mTGtETTVUanlhbnRmbUZPQ3l3aUxxT1JWaXB6RnUrYTZHRGFUYW1HSVJHQmdKcEN4bmMxSUZHT1NsclJoNFBQWXlZM1FCemxBRW5SMjdlN2VQZkwzMjM2dEYxUnVsN3UzTUFTMTRmSGJVTlJIUlZRbUxCckQ3Wml4a2tMdzhQUlNJMHk3QVBlNFVING1tNEptVWxOcjZaTmQ2VWdaQ0JNVjVJRmlDd0YrY0x6UTJMTHZpelM5R25rRG5oS3Z1TTk3bWUyTUlKdzhsb3hsTFJFSHNjMnJGTEJ6TkFvTklmRWV4b3A3TXNjQVZDQkJZeW80Z3FINEljWDBMbnBmUGRYYytmMmppeFpoUVNod0piZDkwMnhxTEoxMFFUMkJMQkNuN0FQWFZldjUvdlg1TmVDWUo3YzJhbDkralQ1b0hFNUZMeUhEdzlVOUJuTDI5dnBKNGV5bktSUS9WOXdyeFFXZk9WeHErN1JXaXpkU3gvWFNZOFJEN0RyVWJjYis3OEZLMUlSdnlvdFVVQ2t0aS9HVEJoNWlia0FhRWdsYmhRQUlIREduQXBBbms3ZWt0RnY3TThISVdhMkZaNGZYMG1icTdmL3lZeEpzZlVPdHcwTmhISU9oVVErN05LYXk0dGdXbjZXZitWdDgxZ0JETlZlcWpubEs0elhPY3cvTjhRdnVCV2tna3QwRk4xMWdPZ2VPazZqbEhWeFJ1VGlHd29BN3BuWkh0cVVrdkpaRXRRR1E1T3RjZU5CcUh0cGVDRnJRcUx3Rk9ORzB0akRtMktoZzYvdC9NMlpXTnY5Z1RlUHdSbjFqZ3hsK2k0aW1iRnljTHdoTzZDaUlnZU9ZVUJ0aWVKQ0VVYVIvY2ZCbkZpSk9rNXlEcVRyeDZwYWxIWHlpUzJDYVp6aGZUZXpsN2drZ3VJV3I1ZEtGVjNhNWM2cUN4U3Q2V2FiRmRrT29QOXFTbU5ocDJxL25wOUtIVFAxY3lOU2JTSC8rM1NYeXhiOUM2WXh1L2JuYkVjSG9wbGdWcDRYREtMcENSbFdNZHVpV294Qm0wbDhYSGNKU2FTTE54ckttajQ2bXNGYjNwZTVPOEo2cE51VDdzREpKdkx3MVJKL1ppbTIycnU4MnpsbXIxVVdPZGVITUZaMUZ0VVFGc0NZc1hYdldPekh3S0RpajZmWVpWNlJFaEFNbUl6emZDdGUvQkczQ2FybzNacHlkZkZWMEpHNS9jd2VKb3lSbkhDbGNZR0pBSTd5Zk1RLzNrWXhNU2VFeURqZkRHUnlPdlhsUXhxM0RQZmM4SGN6dUdRaVRJK3ZJUGhVejN1WkFMc29peDdYQzdmVVlkZzNoUlVYM3hBSnB0SFhvOWRrU001SWNycmtTMFltYW92bTcva1VOOGZQUWF1WHJ6YTQzRXVCMGh3aTNTS0ZBZ0FCQlA3N0FNd3pZQ0RaVXM3dzlOZ3UrL1Q4T0V1M0NmeGdXUTJHUGdrQnJlOGdQVlZ1RjRyWXBrWk9EcXBCdXZldUdHRk9Rd0tOSlArb21JRkpmNllVQ3BYOGpTaEVHL2hqOVZFVTlRK25mdWcxWFIwcEpZN0dGcERTMEZYMjN6Tkp1TFdPRHd3YTFuZ3BObk0raWRFVGRrZ3hZc2FjRzQ0cWFTYTRobCtVQkJld0JRRG4rSUdjVjV1cHg5dzgvRlFNcTBkVWJMM0h2SDJoOXhWM2lxVlFTMlFtczYrQjNHVWZXWE9USUFuM0NYTXpmTVMvT1BpdHhtWGYyZ3pKcVZQY2h1d1ordnQrM3YzS0pwRFBkYU54VEJoc1MrNmdUeENTbjFGU0EvT2dxM2FVVS9GcWRoSkdOUGNEMDZCT3l3NlBGRFNJOS9zeGltQnRQOWplUFNwMVIxY3RmQm5BTGwvd1MyTG5WODVjMXRyZEF0ZFJnbm1MYnE2VWYvL3pBNTNJWUFkOFRXQjQxanBxaUJNbzFtUUg2VGZLS2YvTTJNV2VKb0ZZTytnMGJJZ3V2dDZXZWdqQ2JIelM4K2J5Q3YwMEY5anVzbWpTMyt4UTV1MnlMZFh3cVRmaVhPbUZLVXZoQUxkSDdrNStnVzN0ZW1vWHVkK3pWVko0Y3dZK0Z1ZTJPYnJoc0pCM210R2JTWm12YUhVVUhPSmx4MmZPdXRvMDA5WXRVWUhLWHdCQ0g1TjBQaXd5MjZRNnR3SGxmT1hDbTd0bFAwZVF1T1RwUkRFcGNwUUpFaG82Z2xTWC9PTWJ1Q2hqeWtpdnhDcVhlcnkrVTVYZUoxTWEwY2hVODRiSVI3WnhUYnM4YzdsWDdQdjFZL0hqaWJ4SGxCcmxla05vRG5CRDQ2UmM3OWNWVHdRaW1wYTZNaWdpcGhCN1BmMDM0NjZqeXpQeVdQU1ZtSk0zSlFJbmpONFZJeXVOOVZ2cE8yNnV5UlRmMXAvRnBSQkxFekJGS1lwS3VSSTlMa0JPUVYzV2g3QVloZG1uWXAyd1dqMnZPeEtTOGRyYzBYNm1NRUlUa3cveE5UMlpaVithUUZJTytlTk04QmRjRFJ0dlkxMjVlU2o4L0JCTlVSUnhqVEhaODVEeUxJYjNHRmhLaDlsb01QdUl4U3lWWDc3RjhsTFlLdkl5WitFOEw2TEU1aFVRa05EL0c0dGUreTFqY3hMSzZzWnA4cVQ5VFNua0NrQzBXRUdiVFNXdFN2ckhzdWdrVThyRUJNaStqVGhKZjNLSHZRNkU2YWZxZXJRbDAvTW5iazlKTlRybHEvcU1ScVZ3U3BXRWtNelJmVXlpbGVSRW1sY3ArSDRiY2J2VjBaMXpNRDM2NFg1RUZPR3lpM2ZtakdXR2l6ZDZFLzlTUWp3YkZxVWxCR2lNMWRmSGNXM0FIb2cwT1Z2WGYrYllBYm9XWEhaODNxdktTZkVIc0xYM2lnWUY4WnZiazZ2cXJ0MU55RUlhTmhndmN6N2ZaWkRnNWJaMWZkbExqYUcwbDY2OEdvMzQ1RVgyaGwxSGQ3SUpCNUlBUytMd0RUemdjTjJDNUIrd1REVG0yTGFhclR6YlowZnlueEhsSFlPMzMrRmVia0tGeHlFbytPNGVJZlB6KzlibXFJMmJRNzZCbmxiRytTWHNScThLVGs0eWttNGxDanlmczFGTE1RQkhEcS91T3FYeTBmTzZqUmJqeFpXTDNDNnBrNVZZK0ROdktqNEZUMExDS3dHRkVMTUNnTUpwSDJoZVNvZitsMzhud2k4Y29mTC9wV2pKL2lqTjRodXdrU2FBS3BRQ0FBRUUvdnNEQUR4WDZoaDA5d1IxcXlTY09MUS8vbkpZdXc0Z0pFVmZXVDlRb20wcHEyc1JCczNPRkRJbUZvNlMzWStwcytMUEltTVVNdHNERWtTSFJBOXlLcTNVdGp4VWdUK0VZL1Vjc1FJMFBpRkF2MFU4RFE3S3YxWW5wWEIvZndzanFDMWNqV1d3SW5kT2lQUnRYdmZ1TzYvdXF6WTFhM1hsQ2xRWTB4azVkT0hOQW8rcVE0Yi92blQyaFJydDE5RHZHRDFaNHFjdnhSMExnTm9xS1lML2IveFFYVklidHNuMm1LK2FmZE9JOFZmK1dSUmVub2NHSXFJcktxUVBEYUVCRTFoRUtnUXEyTXdqRHBuUW0wZDlMMmhRV2F5N3lFWGZhL2h2Nmx1b2NCdms5elI5TDh4WXllUTJkOUllTnNybWZlNHc3Q2tHRTJ4cFNvejlQSGRib0x2MGJqL2JRaXhQaUZEalhLZ2RqdTg0a0p1QnhBd3FlRG1YZVh5dTNlcFhSZDZrQ1ZsRlFtcnZEaExIQjI5Y2FOY1d0dXp2aWhjbDA3QWczajRxeXd3aFFsMlVvOENKZGJVbURsZGJXR0xlVFZGQlI4NVU4cWsvbStSYmFrdWFLQ0dnYlV6S29hY25PcUFpSXZMMkk1djhVRGNDRTEzdi9KQU5kNFlxT3c5L1NKTkdQeW55N1lhdVVQS0NRb0kvMTk3czZJQWJKVjZkYS9HL3drNS8zYVlrdVZpMC9QSUdxZ3c5RFA2YUFaVWdzZXFOZUtNL1VwQ1hNSjBOdkpxdEhZVzJyVVp1VzhVcExpMGdOYmZ5TGVTbzJqbGxaS3NMNDJiWUNnWnlMak80LytaVW12UTRUQmFYZFBrNEVEQVprbitRaTYzMGFWeXIydXY2RDk2d2RVSUgzekNVNGpSbk5YY1lGTUJERjl3RXZsdEI5VE5SYkxPNGkwK1lkR1FSZnl1eVpWYWlkK3pWK3B1Z2RBTmlFeExyd3FGTWgvdzBESGVtY2Y1Uis3TUpKdHAzb2pSaytSWC9QSnhFRVA3aUdWazFUYmhNallPYWVaVDl5RHFuSDRqNGpyUFI3cVVId0lwQlJYMnRzMEZXeU43Tkd5bHZPdHUzNmtZb04rNGFOVXVDSjBkeXVNN0pQby91UVppQklPWmpSZmpNdVRIYjhYN3VtRzg4UE9EZ3B1enRrc3k2eWdic1FuWVJyRytYU0dxcFYwdWZMaEtCYzFyRmN2UU9qSDhodFlJbTRIMSs0ZXcrWTJiZ2YvTXFFZjc1bm0wRkZ0OG1pQW5RVldmNVFZT3h6ZEN6R3B3NkFiNkRNN252Y2tJNTVzc1NGMHMzRSsvaFRIOTgzanlqTkFFSUM4UHFUUFJhbG92NGpsbkVLekxjOGZuZ3BWem1BMktPa25UUU13WXY3VHZMVTZuZVlQZmY0ZWozQXE3allCWTBVSDB0S1ozeWhGZHgzNldKWThURk1YQ21DUmxSWmgwbE5EekF4RU1kLzkzLy9XTUdSMTNNZkphSWVkb2xHYmpSckY4emk5ZDMvOWZrc0x0Y29KMmVXdjdWa2VveW16clQ2cXBiOXR5S0ltK1VIK1VNb1RCSWV3UXBTS1F3K2ptT04ydU10WkVDNDdDUWpwNXNQVHBjVm9uL0Q1a0lSVnB6WFc1Y3hsTlRYYlFIRHR5SVd1akJGTWVORHdvVXNaUlRXd1NUdndKWXpqZEYxSTRvWWQ1a005RUg4c0pBQXlWdTJmQk1DN0YzdFErNjFOTWZNSmVaMTEwRXNFNkxaenp4WFR3R1VKWndLeTRTNlFHbm83K1N5QUlBQVFUKyt3TDVmWC9INVNLa1BYN1BJRE50OVhPcmkvR1FNcHlacmF2MXpZdU5rRnc5M2tNSU5HbmhYWnlwNm95RlVnZlJ6WDlTRWQ1QllRbjFYNjFZc25NSzZUT1MzbTYwcGl2eTRldkF4Uk9BMmt1U2M1THQ1TjdrMXFlYTE0b0cvT013TEpUWVIzWnhnS0F4b1R5SExEdkh1clZmdGtRSjZhQytocjRCdmovYWFlMmVPRHJBczdyMlpFcWtkd1gzRHo2UDYyUlZSd1JWRlU0TCtUaDlLaHl0WU1Ud1dKR09nVDN2VHBSeU8rUUFjek9XZWwvSTAyQS9hN0orS0ZDdlRhZDdnN2hqTFlxNVJmaURBQ3VDSExJcTFqTzhiR2ZzYVQyL3gwelI0cWJHMU1nZExtaEFEaHRTcU84VDJnQWoxL3Q4TDZUYUdwOHNnWWFsMlV4QkNqVFpEVGVLUXNQYWZDT2ZNZHJSZllmN042SDRMM3RKa1lXOG1KVEx1OVJTcm04bzA2dFpReTM1eTE4MTZqVU5DT1Q5akcvcmlGZnBCa2pKeTJ0OUR2VXVBaWE2THluaDMyQ2dMWjY5Y00rcnVKUENiVTBmR1hjSkFha2doUGVFSmlsTVBXUjZGa082Zk0vMTI0OVpVS2pXYXNBSmZ6Umgzb2VKQ2tQTHZtQzJORVROMWpOM1M2MEx0YVozQWxnWWp2ZWcxMGN5aVBnVno5MmFMZFdlSUFaNVFmTUUwVFY1M3Q4ZzBDRUE4Tnluc2lOQjZRRkFTUXF4VVFHamlBOXAzK01hRndtMWptTnY5ckNoOHpGeHg4TDQ3dUhianBUM25GalE0SVlJU2ZrakpuUUdDSUNOaUxsZUNEMjhzTUF0b0NoNmJ2L0FQenk2YzFlNDlLSFZwYXdOdFZtOEtiK3FmQUVmWHJhTTk2b01pYnlUWTdWeTA2SHl3ZFByNG5idStQNU1Hbmh5UTRqU2FQRkpQY3VzdGRUbzJzaG5zV3p3d3FCRzU5L1Bremh1OG9KbzBsUGM1Vldpek5PQVpzeFF1MjlURTVTZTJDUTVIVlNVVitPd1J0M2x6WFBLdXI1bTk0OE5GbEtnTnMwQitoQmxzQkF3SHl6cUNEc1VGWWlmWTUwbjBmcWpHTkczbXJCRVdLN0xCYjE4dHRpQmNIUFZmc3JyejZ4KzdFRmo1WEd3NmRyNjMwcXhDYkRaVVZnUVNKWjlvekNMSng0SmpBdzN3ZXdlUVdmSGxpRGNaVkVtNXJaWE1kaFlwamJDQVFQRWg0UW85RjJGL284aEUrV2w1RjVQMWVvN0NPQzNRNXMrY1h0QXYwWEVXL3NqZCszQS9lbFo0NFdQa0hBTWwzNUVuMHJEVml3NlpLWENuM3o5cE5jZTRQa29VZDd4c2xqSjdMdWQvK29uaG9HcHlndXVEd25LOEcrbmZ4TUZOREY2NFlkeDdsTjljaStjNm5ocXNyd1FXSmwvVEZiMWYxZ3MxWll6b1ZiK0JLS0wrazc0N1VoM2FqOXMyTlY3NEF0dDFqOTZ2UU5TRHhtOTMzUTFqaCtPSlJ6dXUvNTM1UlF6YUJlL3IyQW1hSVA2ZmU5WWdWZ01qc2l1YWwvQVFKaUd2UDVZWVBEdk1FMDM4K2pxYUV4Q0JaeTY3STdmckR1N0JFV21rQVFxaUtXVUs0RkVFK1hEeWo5OWxRNnJ3TTJiNjBPeHVvaVJWci9tN2R1NUw3VExiM0krT3AyaEV3RVdHTDRRR2V3RElTSUlOUnB4akRnTWtKZzgyZitTakt1eWk3NE5ta2poNHNpaUFLQXZxUHFSdncvN0FnQUJCUDc3QUJVRHNZeVBPd0Z1NTNlYis0VUd0RzVPaFFkdDJVTWdBTUxZRk1meElQN1hadXBWeFl0VmticFlNTUoyUzlxenJjbTEyQkJET1NWN1FwZXBieHB0dVJOcEN0c2dSYXRhTGZFa2RsVHVPZW56bDBFZlgxbVYzOFVUQlRQbllBVlNaM1JYNHN4ZThpQ016SHdWYWxWK09xbzMxb2FXd29xUlhZaVBldkhmZ1NJOUhJZ1hndndUK21ZY1BJSmZrNURTcVJUS0pNUGMvODRYa1A0cnp0aHR5TGpDN1ZFdHo1R3N2TDJqWlF6UFhLUmRhZXpkb3F6YzRkbHlGOEovc0tjODljRVh1S0plL0Rud0kzcElIbCsrZTFlSEhLTTFFdllBdmtqN3lSNXVwMmVKYitHMlJEazAwVE1CZkRScUk5dDNLYnc4MlgvMXpVZmk0N2ZwclJodm5WcUtpLzY0TGZrRmIwRm9scWVWQmQvdTVmU2hzMER5UVMwMmN0SWtZaWFXOEV1Vkx1c1QrdkFFT2ZKL0lnQUFoVkpRdWc5RDNuNkh6SEZsUFZvcmpMWGdPaElnR1BOc011c05SdngwZXB2TVdFRC9NeTZzRDNvZ0p1WDdnekg0elJTWTNsVEtxcUhZRlFXbFg1c2NZVGdnWWtUMTNUazUxa1NSVEw5bzhhdk1KSEFaaUFid09ZbklSU0oxSUN2bjk4bEtqMHZadUo5MUdoM0VLcCtDYy9lbFdGb09kR2JlcVRRRWhzQ2NNdXkxcllEZDNZOWFwN0NNU0ZaaE5VUVp1N2FUK2ExMXJBMnNFeDRTMEorSDZhWXY3WC8vOFM2VjQzdU55UEJPOEYrcUc0ekd5VjhheHR2cjhaTWtBME5pbTgya3ZxalVZUTFUZ0FGN2tmOHZJNXV4eXl5aDZLc2VOeVI0Nk5rVmtvMkRpRmJRbzAvY1NvUDN2cllmMkxiaG4wTWRyTXlCa3FNWVlzWVFLZnhSeG9aWEdOOWZtNVBCMk9xdEplZ2VRcXNlOXNYekR4UlRIK09pbzBzUDI0N0dodldYTUYzdW1GZWhoS3VvcmdUemxlWDE5VGwyRXdqWllBRVVrci9wVDFvQlo5eFlNK0d5eFAyR21YckRvVkF4WXU4Yjh0Rm53WXg2SDZPaXFKbXNaUzlhU0VTMzIraFFGRkg2SlpGSDBBV0RWNHZueFkzU1RDZFhVZVNVTnowaHFsYWp5ZDJBd1BiVDRTSmxvQ1NFem5IM0QyS1d1TEFFTHhLTWZUMHY3QmJkMmhrcnh4RnlBazZMbm5JTnVlbTMzbGJkWEJYOXd3ZE94aHp6RENvaDRmQ1pjMGtJdzBLWlRyMHJucU4yeHpiaFgrSjYvZG5lQTV3bVB2bkx6Y0NEWHNrK2NBMGVlL0dqRFRkV2JpZ05BajhvRmlNZDZZekMwZ3U5RndWQ0ZXM1ZiS1hTVWhRTUpQRVhKN21scWZCdGVhbC9WTGszYkZjMTZJWjJWejI4UkpFeXpVVWpCU2hTUytNMjFnZjZiSTVNbUtqZ3BSV2RxTWxzT0NZbE1UVmFRMnREZWlGUHZqL0ZjRVJvWU9oSEtOdUN6VXpSYzJyT1dQRktqOHAyVVcvcFFpUmMydlFKZnFubmJMTTBzSmp2cjV5VFVLbS9IUTdONEZQSXV3UDlUNFdPb21HZi94VXc4OUJYYTU2VGdhYXJ2LzQ0U2NsRms2Y3NIeURhdm5STDNBeXZVM3paQVdYSGtZcjFoaE1HSmdMakVjWXlsTmVFTTRKSmIwcUNadXd5d2JBQnZIM3JVcnd3b2o5NCs4UTRRdGNDQUFFRS92c0RnZjhSSTdUaXU2UVNKeW5yRkltWGFsQUwrUXFKTW52WHN3V3oxNFFndTRYUUlkdFhMUDkza3VMcEdiNWdzSGlKVFNvcThvQmxhOVN0eVl6TWdXNkg5MUE0UmFEZHRhTFBvRndYRkZZTTlLeTlGUWpDZjg1NHdkZHVNQTV4NWFRby80K2tXalN6U3NFRHhndFlwYlh5b2ROWElCQkhwM1dTWlpRZEpRdzBWenF6Vy9FUytwL200bjNJaDNwRWkyQmFMU2ZUbFNvaDZSSFNuYmRtRDNmNGZZeWtTTDJoeDRuaEpuWnMyNTlscjJJc1g4aXJXemw3L3JSL0k0QnBoSGp2MFZXWXFhdE52S0N5L1BrTngwTVVGLy9ib1l2WXNRMzdjM3htR0FPSVFvYnUvZVEvMW0zTmZhVkMxREY5MUhiMUs0OEVHUzU1bjhYOXRuMEZEQlJtNUxTRDNMZk5leVpjUU1GaUkwK0hSWmMyZWRBK2E3Mjd5bWo4QzN4SmdxcngwaWRNWS9DUXJlSjh3dU9OVlFuTld2bGNLaDBNS2JLQUZLbmIvU1ZDT0t4OWthdWs5L3pRTkFJZWVTV2pPQklobi81NkdESGpQOUZncEI0S083ZlJqcStTN09lekVSZFBkcUhwR0o3eW1LZTNzd3NOT0tJdkJXeG9GUXlkY2p4T1F4VFUrYnBYL3IyL0RLdlhET3pGcndpY29PZm9hZEo3Mk82RDNveXZHSG53THZHZUo4UWFiSlREUVc5Vnl6UWVreHJPNEVQZENjWmtlZ2I1bVBTVElxUGMrTmxKeTcwdTZxVVU4d253aFJuSEdvREduZzNWdmw1aUFnUUlNTWg4UnV3M1JRS1krbVM1djhlajVRakc4ckk2YWFSYWc2bUJ2WVA0OXNRT1hrUDlNazNESmd3dEJCcDFhQnJYWm1WVzVXRzVnQWFBcE95aXNMV09paUFVVmsvTi92VW1yZ1pUNlBsb0lGSDNVYUY4UWdPUXp2TjNUR3phYUZJTHBBVjZZaktObkJNaVpEMFpsaUN6c2R0dlNCVHd6b1hIWDNJam9oTEdOMUR1Ly9acm9Kc3l3UVFGU2lvRFJzNXd5eE5EOFkrd3laVE8vdUUxQXFmRU4wek5wdy9yMi9hcFY1dzVZZkpwVldPMG9EME0wcldzdGx1aE9Uc2hNaEtBTEJOUzJmeE5tWW1DOW1JVmZOaFVQZGV6THZ1WXAvZXF1eWlRQ3pJVEs5OE9pYW5ZdDdDRlVuK0pNZUljV1FGVWpyUCtOUGdRRXpzbDh4cEpxYTM4MXBLV1hOY040YVpzS1gwZllFYnVkK1RTNTBlNXZYbGVaOSt4bEgvbEEyZ2krSWwvNUlOQU5WZkpJZjVTcFhxT2t5Q3dqSEVxMVJSTTNmbW5aZlNNNUFyRExkSVV0ZVpmek1lVkgzM01tVU5WbUJBSitTWnFGckgxRXVCN3J1cnlxQUFqMTlNdEc3QVEzTHZRdnM4bFUvWjRzQXVxTTBrN1ZGU0dlRHppWUJJbVZZYzNCU1hXVGdva0hvU3FKOXphWDBtSVg5bnJJUERNREQyd2RtSDF5ZlpaUkIyUStvRDVpR1RCNE9aSk05Nm45cjM3K3hsWDlZSUZ0azZnVVJCRGF5b3dsM2FReFUrZlh2ZlNWR1p0UzBrS0V3OVhCclY0UHhROVVpT2IrOXhQU2phNC80Mlg2TFREWWhwQVdCMmRNQmM1MysvdTFlMGlNUmwxYk5KTTc1eXZyVTllTGlqOG9lQlZYVnNJdktqczZhbUxjZWcyUE5JZ3J1d0huLzN4bE81bnBnSUFBUVQrK3dLd0xmZ0dqcnVyR0dIYmVuMm1IeW5kVXhNUVNxbnVnc1pkc0h2cjVsdHNGYktDdVpMcndSeExVMTJ3bWs5ZngyMmEwdVlHZzRWMzhLckNXaDYrb2FYanhzNjdmYVdjVFkyTWVrUUhnbEJpdm5MVkZPb0g4UlJIMlBGbnRqeFQ1a0lqbjhmdXpGd3NoVU15emVXY25GL2JSazlGSXhZNFZIK1BWK09BYjIwVDh4VkFmbGhTK3VqdEVKckFIeTh5Z3NiclNuUnExc3NTYTZUc0d2YXBOV1ZOSE45czNia1FCTDR5TjFqaTFVMlpwN2F3dXY0aEg4UEIwZlh6THEzcHVrcW4xenNFa1hYRkdLZlFPRitBekIxYnlRYmM3d3VBZ0kxTjlPTC83eFBTQ3Z1dHloTkJFWnBZWEtDREhyVTIyTzhjc1lnb1l2dXBLVVl3WXAzbWtNTjlsVGk1RUZZTFNxbE1rOGdkMVIxTWlCK2JUQ1RGTlN0SERGSy9uWHRHei8rL3hrZkl3a2FZalRQalROMXdkcXYyRC96MjYxS29WTUUrV0U3ekdiYzVvblZJenJpc1UzTEFVeERBVG1zRCtJeXRVL0toak1nS1ZhYllNNGdVYUQ3SlFob0JZbWNma2JMeU1nbTNCTUlTTDlQM2doR1Z6d0RrMnc1cU1UdWh2Unc4eU80VGJIZmk5clVOMzJoRUlzcHpCUzN2NnhTd3c4YmVsM05lZEtRMEJLdG92ZXpGa2dTSHRYRmFmZnZrNUMzaU9ac0MrYVhBbHcvbXVRTTJITlhXK3Q5cXZUVGVtdHg2UURvcUFGd0FGaUl4UXJielVISzZ1bmFsdVZub0R6TS9pYnJBOUw4TlpoakNhcWk0ZXo4cnlQR3NmaTRKZEs0STN4cjBFVVNFY28rd0daV2l6ZGhhb2ZZU1QvbnNCWU5pUEFtQmJCRFlkSGoxcFliNElFNVFHSFpEeGY1T1NaL2tzNXFaQ3k1eFM0ajF1NkNoUW9OM2syenhOcHVWMlB6OThmLzl2eXBueDdwTVlrOU42OUJJeFU3NjRUNVF6aG9OMkFSeCtKLzVMcDNyMGpVNnVhRzZxUGVBOVRXeXpNYTlSQS9UMlZOYUgvbjMrdGxRU0ZLWVpQSFlOazVVVHJDdlNRSjhtS2wxcGEyMjYxL25CL0ZraFpyZ0M5Rlk3cm9rUHhQTUQvWmZ2ZVZaQ3l6OTB3dENmSkRZWmx6SmdodG5xK2htYlVVSS90RE0xMWlXenpXaUFXTHZPa2M2aW11WXVvY25NTWtNY0dCTUkrUG1yU0d6RVNoMEdPOVJVVHZOSEN1Y25NckpKV0RlTEVuMHYrOVB6cEFJZSs2L2xxcjFWNi9ucXRUT00rNnpKYllGZjY5OHQrM255UWVMT0ViT3plZ3I3VmdPQTZub3pkNnlINU5VMWU3U2VwM2dxMUk3M1RGSnZ1WUhoWWVhSVJ0OEVqNGZKMzFac2EvbExoQUlQV3lwbjQ3eGVyYXd6c3ZPNDc3TUp0Uy9ndFJtUGE4M0IraTRBTTlGVlRRenc5QTErMXBhcmR2cm5mSHpUa29UalNlUXY5VDVkdEVvTFVpK05Wb2hnd3lTQW9hSG1BcHhuVWRRamp5aUhFVkZzWWtGNEh1MGh6VUs0ODRvbktoVTBMWHQ5NkNQWWpGTnRVZmE4QUxxalBxMmtSNmMranVEQ0JaWUZNeEpibEI0OVdZLzRpR1VTUXE4ODN5a3IvSXdDcVlwMVNlNzJFS0dCdURmbWF4WUdtSXVKMFZ0dmNMVUdMdFl2VHFhbjUweEplekZyV3NFQWdBQkJQNzdBSGU0dGllbXhRakZUaFBhRCt6QzJleHJFNHFkZzJhYzJkaWg1ZVVaYW9teU1DbG5hQm1mM25yc1Qzb1JFU1BZbXVOMFg4enlMalExR0FyS2dMa0NBRHFabGRFV3Z3VGtRUVFqSCtBN1k2Smw2NVZ1TkFYayswL0ZQeC9FZlYzZ0phVEhkWHlQUkFRT3ZSaThUTHMwQ1g4ZHVGSXU5M0wya1V3NEJlRVRQWTNNZTVLdi9yc21XQXlTUkpqK0dNaElEdDJyS2VCSTJsc3YyQlRaR1N2T2w5SjZFaWxuVWdvS0NLWlBwcHBlSDJyWUppU1NTdzBEQmZvd3ppbzZiRGZFWlF5b2MxMXA4bW10VCthWEVTNHl4R2t4MngyTFFpS1JTdnFOTXRTeHN5SXZqdnc1cGRhVCtOSWNXdW8rTlpjK2hqc0RONkdmZTUzYk1TR1lIN2htVnpJaE9uUWFWa1VqdG1nUVQxNldQWEt4Q0RvUklRMzVjL1RWcWN5Q3hsM3lKbHJQTitjQzZrUGhQYVVzNUJHNXM3Y0FQelhNVTFjNXpIU2VlckNDNFlxUkErbG84YnppSDh0OUduTEg2cmZmY0NtQkNBeEdLNGU1NFV2cmc5OWViS0I1Y2dWTFliMHV6cUN4QnNtVFZ3bU5nZ1ZWS2xzRlFjVFVJam5PZC9pbXdnNnp1dHFucXQ0R3Q3YmsydzFycW5EN24zd25nU2FSRW1NaU40VmlIM0tBMzYzQ3Bvb0I5VjFDR1Vkdmh5blFKZXUrWlpMU3RMTGZ3NTlVWHE5QUZZZVlpQkdaUXhZeGpUdVZ6TFg2VVNQVHVuM3Y5ZEVSQTlPSDFFVEd6TFE2UUdGQUh6VEprN3dBZmdLSEFScnJMMkRYUXVuWXN1VExVMXliK1RBbysvUzhxSXZGMW9oamFoWE1SVmVhNTJ3YVVCOWJJQVlCYmt2QW1aM3VMRThVTXI4TmlUNUpzdUl3Ym01QUE5UXgrZjFnYXErcmRWWDZLcUJ4NENuL0c3M2xjdmNmTmZyQjV4UEFGandTMXo5dWM1K1c4UEpXc1ZlY1Q5V3VFcUtWUzZIVFR0b0pnZTdsNlJLWEZCMXVqSEloUFpqR3RYMXAzdkpja0NCUTJ3ZmRNaXFOSmJJaTdlZE85WXNEVzlMYytJdm8zNHpoQ29hUm1zdlE3RE9kcmllZXBYOWdIUnFLTVByakQxZ1gwZWZxM0ovb2NMVjZJN1NVNVRVWk5SNnBlOXVSdGF4aVNPOFlJdjBHejJ0bUVrcjAwd0U3WlpaWjhpWTVKOG16Qmx4RzhGRk56Y0FOUmJETitrd0hLK2xoL21kUldjUlV0TkV6anlkZHZvY3FNZlhTQjJGRUJMYlR4STEzZkQ5UDJOWHl3RlVmVnRJTnFjcGN5SUdwbGgrSlNOSjlib3VvbWQ0eENNRHJ4dHhzRGNyTDh2Tm5VTHh5a3RITXhnRmpxV2kzRC9EYjA0TnJsTWFiY2NFTFhWbnpNK2xONXo2R0xUOC9ycWVnTzZqNVNlUUlDVVRrQnNsK0FJRVFxNUhBRzJxRTdDMVNPamQrb09qUzZVYnptTytYQnVDdWxYdHdacmZXc2RUVXJYWmF0NzJ6TVJUWWtnenFEWnFCTVJuMmRuQXN4WWdzSDB3eFpyK1YxcnJHdTJyS0ZkWDRMYjM4U3RDU015WFZIZkUrZVZ2Z1dBTytScUlxUFNoelNvVDV0aUlMOUlrYWg4QWU2M2tXdU01eG1zYWVJTTdhN1hKNy9LcWVuVnp4WDRvbSsxUWN3bDJlN3Nnb3JrbUo3VG9Dbm0vZU0rVUNBQUVFL3ZzQm8xYUVEK3JKTnJNQy9IcmlQUXpvVVpGUzJyL0RTNXRUQVNhZVYrYjlGSzR4OU9ZNEFHejhHS3VXWEo2VkdwTmF6VEowbUc1bSt3L1Fqc1NuUHlmTjlic2pGaVE4TWtjbStoYUorQi90QVdOZDBIZXdnYlFOOVZiUmFVMDRaOFFUZXlGODZlRlFhcWZjRENNb21HdUlsYnJyY2FUSGVnQ0t2Tm51SFBWRURDVEJpRG5VNkZWcU1XVFN3NFBqcEZyeGh4YnY0VmFObVRpMWIyeVVGRm43R0JsWCtnSXRVd0FGMmxIRlFuT0JDSkpZVWtCdHpSTStROHYwV2dkV01zWWZ5U0lvZUIxbXRyczI1a05RQ0JTRmllTlNCcG9FM0NnaUwwcWRaRDJaeHhodHpGenpZbFhxYjhyeDdqTVFGblREbkNYREYvSG9zVjlRK2lKdStRSE0rMDhCWFFqaGwyL2hUVnZEWE5tSXpYYW1kaXVIOStZa2lBTnp1RGNSWlZmT2JBTnZmeXd1ZmNWcnpXZm5jNGxvQmJjTHJFTXZOcE9vYSs2dDI0RGRzdldxOEdEbUluNmJwRks5eit6b3lvQWhaRGZ0S1RUYlFOTGtOQUhlRnk5cU1LODNIeFZkeEdmR3dVYzVNS0gxM1RNM0traENzdFAxR3FqaG4zeXpTMG9FVnZWMGNLV1IzbWtkVmhZbVFEaGxxNE9BOTdPUkRBeC9vaHdPUzRCRGFPb1A2RlhuTWM4TTFUWU1rdDFjNjNObURrUTA2WWRuUzVlekptK0FJUHpIaDJSajUzblJqTWtQZnUzN3QzV1ZpVXFGMGdNSUVuTytRbDZGWnFhMlpiZUxCeGdpenRrN2gxMVFEVzI4Vk1JNGZvQWZKMmxpRFA3VTkvbkhDT3IramtFMnlXL1drQmZ3eENSNG0wc3NBTGMwNVdTT1kvRDNvVXB6QnNweW5pdk1MaEhMYnhSdTMwZnh2N1JDdmFIYWwvT1pvbVJ4bjJISTMvVzg0WDJ1eTkwQWxzRU9hVDZ5elBHM2NQTEg5RVdTVWJLN3ZSNHdZbWo5bjZSNXBOelAzVmRIRmQ2dGtudU1BRTQ5WndmY080V0lrRnUwRkFBZ000Ykl4Y203cEdYYlp1VUdnZVpXNWFjOHlJMU56dVRUKys1bFVOVGdOUGVWekpvRVJXMTREM3g1SG1Va3VBaXYyQytaalU2L0hBQ3lmaEdaSTFWRHcxL0ova0Z5NzVzRFMzcHFmNzZBeU16WFpxZm5tUUZYdFB1a1pvOGU5RndVOFE0S1pvclpJOVd2UFhhSnhqblp2c2JjUU9hbTRCUUlGdHFoQ1JnL3JuRTl3QmxIUCtSclVIYzBRakg0UE54RVREM2d0b2JOZnNIV2s5SzFzWTh5TVZZelV5TE5OZGtvSWxGNk5Yd2FRUDBWSTd0SUNrT2dkUjE1bldzZVRZekp2UzBMcElLK29YWXh5cGpJb0MyeU5JOG1vQ0xBTVpJTlJ5VXhxSmMwOHlwa1g2dVJzR0p5UzYzT1YzckpyRFBwNHU2VVZMenpnQVRNR2JMeDhQemdDd1ptekNYS05jM1lBem16YnVJdXBkMVFTdUlhT2V5ZitYTUZXY0FhTUo5VXM0Zzd3TTRab3hwL1N2MnRQU2szUGNaNzl1cDhMdWl4L3RLbnlvMGZaT29HaUdSZW9KdHUyd21yMDdzTWFHTnQ1VTZSL0FHcEVwckpKcFNtN0VSRnduOE0xcVNhcHhuV0tHRi9Rc3c4ZjhxRXlmbUxsd3VUTWhlUFlnV3B0NjJYMXppSzFkMzhiU3NvSmdJQUFRVCsrd0d5YVNJQmFYU1FiNW52VXBhQWF1MlFXL0Z4WEJ5TnI2ZkR4NERhaGFjK3NTUlJQUy90c3A4Z2lhWHI5MVo5cjFYSVllYUs4Y05mUXNpUEdyazdYcE8yajJIaHRRNlVJY2sySmdmdmlERUFlK0xhTDEyMmFvZWRYQXMvc2s4bDkwMTJpV2pmK1AveFNnVHd1N1o4RmJITWFFU2FGV05IVlRlQzZYbk9VbVBlcTJRbjUxL0VSUFRmZXp2bksxaGpXYkltdG1PdGlDZ1d4SEpjNHJ0b0FhMkJFY3BIUkNUcWZFQWc1NzFzMGhybWJ1UnozOWRMYmhUYzVVcTQyc05DNzJ6Q000d0NSZjFBT1UvaGFXb1hHdXhOcGRzWXVOWVN2TzgwTjlyVjFlR0dtWGQzeGtXdVBZMEZHNHJVQWpCd2Y2cEhEM2lSd05Cbk1IQSswdTRGTFlLc2poem9KakZuYWhsb0QvakVVNTBnV3ptSTdVRHNvUnRpUGcrQW4vWDBtZmVHTmMxTTFMVEU1OXZQbDBJL2ExbzNtaXI5WXpiV08xczlqZk9UbWpaR3g1WG5WdWtZK0JXY3h5ZnIzMSsxZ2cyenlDbFltblRHQndwUEhmRXVrQzZwTjlaNjE5bjg2WlR1Y0dHNElRbWJnVS9KL3pCbjJpQWpaVDNjdmJaYk1ISisvTjJ6LzNiYkkxT2JObHYzS2toc01NbHVQR2RiQVl6dXV0VmV3RE1pb3luQmVERHEvZGxrN3dtU3B4VmlHV2lhczh4ZzZudzdNcGtJMlVBZGY1dzMwYVN6bWRKRnpQd2IxRHYrSTNCdnZrYjEyM1VmQ20ydTlxdUM2SVg5WUxpckhJdi9BWlgzeEdncm9lS2dpVGhDTE90MlBtVTRCaDZNaDF2M1dySjJBVHpTbHlqS1FVME9TS3RBN29nckZzNjByNXdOM3loNWxVb0VzMktIOFBOZFRGMGUzakU0RmhQVERMS1ZvU0RNT0o1eFZ6WTVnenIxTU95NFE1N05FMXBKRlFRT0MzVXQydGpUNkFoc0tjeTFpYTVLOUs5ZVYvNnRsalFZL3VFQklHbUdEaGtFejFHMmhXRUMrTi95S3hxNHkzUTRRdDFjUXQzQlgzZm03b0NBdnhNMXRCbHdZRktsZjEvdkp2cWRpdllNNGVXT1lqc3F6T2h0OVhBd1lINFdMNi9CN1FEZjJGdUdUSkVBVVg5Y1VLSkQyQ0grOS9MZU5aVllhbW9EUzZUeUFqMWR2WmU5Qm50VDRTcStKOFFBVVlLU2VwZmsxS21XRE9jbzY2K2c4TUxFTmtCMHJ2Qy9BMkZxYkxKb2FZSWZ5RnNnMy9FeGZ4L0VXWDkxTk1uTmVtMmpFK3Q2Zkg2dk5pak9acTVVZnU1aHNCc1dkZmdpQUh1bUkzSUUyRWY4eXh4ZFFpdXQ0M1ZUUEI0V2lmSStCODU3UnBPVWY2NC9YVHZYdFRVSWgvL2VFQS9QTmwzNGd2VEN2SExxbWRBbTNwVGdZL29MNDAyaUlzMllkbTVHVnpZLzlUTkRFTjhSTkR5NnN6WXdOdWdWNjl3azRUaG1IZE54Q1NDRGRENjUxWEZNMVI1clA5bmhZK0ZxSVZ1QzNVOFRxUG5aUmxaLy8rdUVWblZEbHJrS0p0bzU3eW1vZDZreUJ1TDRGNjVPSlBGMUlrUmc4RllXbGV2NnlvTWJCbE1zbDcrditGL3VrMTB1U1BvSWVRbDhibm1SQUUrNGI5QkIwNEhqYVdkSU9GUWN1UXNlMVJVbWppMUNCdFNrb09ERnpzUUJoSnpqbHY0Mk93UE5BZ0FCQlA3N0Fvd2VNR1h5a3c2aFNScDIzMi9ObG5sOHZnc0NkNytDSTBtNGZ6TUZHOXVCRElVYzBCZ05tdHYydFFUb1cvTERVaGx1RVFRWE5aUGZ0akV5K1c4ODB1alczQWVMTUpESDM1V05ObmNTMEUzZkpmZm5VdzYxbjc1R0xTZjhkREgyK0tQRGtJN2tHVWZwZUNNcTZsSzBhLzFueUMyZEJiK25Jd2hYeDAvT08yeW5nTERLN0lVc3p2Q3FOak9HQ1NiQnczK3p6RGpacWxmL2l1NUg5SlNLSUtPQWtjWm5IeElFUGZqZkdFejlhOFd3N1l6MFBDcGo5c2l4eFNLS1hwZDZFVkVvaStydXBuZGZPUFUvdkd4L203bEJwNGJuSlZnQ2NMazBYQWxialkxbDNTOVlzL2JSODhzdnpDKzB3VEg3dWRzT0xNREdkdWFsbU1PMVowQlBHQVB1MDhNSCt0MGw5YWt3QnVwVjY4cmlvR2Z4anUwT3pncXhrN1IrZWZrL3NxLzdYeUYrOHg2V0lDU0hxdmsrNjlSR0YxSWxzMDhKakdJYnE3ZXJWRUl4RGx5Rlk3YUEyNkRCeG9COXRUS0FCalVTVjFJcEdnU2JMZTdUK1oyUHh6T1RXeGs2L1h4alRyYTYxK1Nob3p0U0M0Nkx3TmNrd3dFNmNGZjlva01MbVZ0MUozN1paVjl3aGliQ3ZGQnVxMkxkWE1UT2ZrejI1QWphclhEam9vdjZLR1NiZ2dkN3ZwZkRTL0VPQWVYUzBwZFBSdXNzU29ZditFdHF6TVY0bWhwZis1ZDJFMUdxOWpZU0J1R2psVHNiWnJIMi9NeEtSS2VGNUJWT2JXZ0JrWVM5UU9naXdqOWNLaDFPV3k5Q3ZrRk9Wa3lhSkZybjBlL3V6U3pCdE16RUNTK3h5Vm9zK3ozWnJXN3BtVFJpMk9obU1FWEVlMzBFS2RqQkJXeWRVL1FWdmVrK1hUWnZTZEZQY0w4V2tMTFFqLzJoRTlqclZrd3BOWmpGeEFOdlU3RWtiWEJOL3lFWjZMaDZ4NG5MZWNhMStBS1R3eXArRFpVdmZTUkE1endrNE9wSDg4S1hobTdJU21tQjlybVJlK01UenBrRWZNekJHMWViRmpUNnczRWlXTHhId24wdnJQYWJtTWxMc0ZVUFJiTEJaY2tsaEFnMGcvQ3J3RjZISXZHd0NVU3pFalQzanlHTXdFeVEvWFBlMGJOcU85VDhkYzhVRGIxVy9NSUJBa0MvU2NFUkZQb0hLZDVnWXZjL0JGUGw3Vk1zUm5QalFsZXJXNFNPbzZrK0ZhQ1lleENrRHhYZEVmVHRTYjZmeGJaTDFaZEFFOWFGVzBEVmxlRjJEK04wZ3llVmRmZll4T09BdEJQaUV0NG51dlNYTUc4RlFzUmNaQ1d1bHhqdkdXOUFzNDhxZW9lUVpzV1MzbmVrWlhCNFl4ZEtycHpueCtVYURJSzFhUUl5dXdwZmZIRnNCZ2dsR1Y2VXlEU3FTRm9Ec3JDNmh0L28weUJGSGdCTGd0YUtEQVU2dGtrNUNYVVhaQk1ObU4wbzdLZXVxRHp6WnNXYVozSUtzbEtaQUd5NGc2Szdwck5XN21rR3d5aTJXalUxUFFEbXZHQVR0bUJwN3hqRUdhbzA1QXBjb1FMa0M3UVVNcWpKMGxHNU1UQjVhanZ2SnZ1bjZRK0I0Q3JSaEt6Rm5NT2NvbkljbksyT0l6R3RPSnhsbzdUWTd1bGJIS3BXaXk2OGNGRlNuaFVrR1FBQWw2TGczdE5uR2Q1bDJkSnQvazFsd1NsV0FwYStTRGJWdFRFQ0FBRUUvdnNEOU94RkNSUm0xMHRYQUxGQ0wzamZmZEZyWlFTSnhtd0M0aDFPUUNnSjArOCtJaW9PN0I3MEpDWTBlRWo2S0JzOUlUQ3lLSmhUTi9tMU85aWFCTjlLY21nWGdlMHdCdzFLV0J3eHNicStJSHJpL1lGZS95L296RXFKZ0pnSDBsSkJEcFhMS2RkZWo4MjJYdXYyNDN1SWtoTmVzTEd5aFZoSkhTOWVrb00zbFNxdDRyZFlhUzVIQ2xJL1pGS1ZXaHY4RDFIcUNORDZjZXhxMG9xOExMSzVvcjhibys1UHdIbDkzSUJwL0hoNzR3NHNTWjlBSXY2dUtPMk5WMUk2ZGlMTFU0QjJ2YTk3T09Xd3ZKam5rSE5iZVJIb1VwQmxMUUdaSGpuNUp0Tnd0ZFdOdFZueVNhMEh1cFVaSWMrOEExS1c4MlZMbUs4MW5GSTFXWmV5UVhHbjJsZFI2S2lBYk1OMGExaVRQU083NWRXZlB4RnFFUDRBTkR5WUEyc1VYU3NqVkhwbmdqVk5wV1U2RitDSEV2ZmduU3hlejZ6QU5sOS9XTGUzaUlvSlBOMlhLMjRKYnQ2Z2pnZy94UjM5VGZaYTFIQk13VjJTMWdFZVljaldsUkg4Wit6blJiYTdWQWN6cHppMjgxVTVPT1UwcHdrU3lFOHV3UWd2ZDlpWWhzNGkrbmVmZmxUTlFZc2V4YVAreE5WazB6Zzl6YnV4L0oxQUMxemVoNzBBZEc0eEZaMjVVTW0wVjdwWThtOERxMVlqYWVyckJyam04b0xSSlBNWHVVU1FVYVBIMXUvbGVMR2E2dzdyT0cyWWliSkpIeVU5ZHlaZlZDTndBRFF3dEtKNzMrbWl1dStWVVZ5ZGQwckF4UHZQbmxmdHdwT2N2Q3IyY0c3MzhnWXRiVGtTMXZzQUN2VCtER1lPaURYTEVWbk9PSFk5aXpxL09hNmg5WWIxRVkvRndhRDlsZkdSSEtCeGtUdG1nVlI5K2tNblFScThDam5vTS9KRThDUmEyL2hBdzZZTWRHSVlLcEwvVVpXNE9pVmlNaHdoQWFoMC9wNGkrYld3bXNjRHpPMFhUQVNXUS9qd3ZGOGxiY0Naa2hwVmprSEZMeHJTOEwxV29jd0JuZW4vSUlkVi95b3U1VTBzeFBGN2IrUG5wQWdiSzY2ZUp4YjNpZUk1VUp1Zi9hdnduM3Aza0M0WFU3QVFYcTd5eGZjM20zOFBlMUVzc0pDaFVmUkM2YnpmTVVEcjkrZnJDbzB6dnVoWUpjOS9Td2ZzWVRQYWxBVUxTaGFiRUFHUlJWQWp5OWlZVFdGbEFMZHI1dUdJa0YxcjF1MC9xQUpHRmNzc3hiTm5NeGFuTkVpbU9ZTGVpSFg5WmNWVmszbURLdmxzSVQxWUFEcUUzZDNGdlNSR0IzUEYwanFUS2VidHFseENDdkVVdmU1dFFmemlWMlNIMEhZcXQvU3FReWJnWVBWQ3BKeTNaSjV2Q1RKaWJTVDRrc2xNL3Jjelo0QWt6RVpuWWl2RktnMFZtazZHTmZyMjRUTTFzdWljODRxNVk5dkdaRkhoLzB2STQ4Z2kvSEgxYWRPZXgwSlppd1piQmhLSVBPc2orTmxqODJ4Wm5kQUhWbENyMEVGUWJpcURLSzNNOHNLaHBkMGZWaHBHRjZWN01mZmJLTFF6WWY0Nks0VHNtMXJ4bGorWUZrV052Q1ViRGU5TFI5UnFYMHpzZEJFK3RVSXZhbVltY0dtZng5ek1nTjhrdFUvbWZ3TWtDTytrTXVkTVJpNXJZTDZxNWs4N29ySUFyazFMQVlES2UwQnRhUUlBQVFUKyt3T1N6YW1LUmJXTUNPWkUvVXI0Y3B0MTJCOWVkM1JRQnMzZmlGTkdnbndzOG9JVzVMUGpKdUJVNW0wSS9zdkIzWkYzeldlZitvVkJVVnRxeDYzbTZHcm9NWGcyT1dzSFVwbFFmVzVMK1d6djlxcDVNMkNMZ1Z2dkdic0dDWFM1REJTQjV6YWJKLzNZSkFlbEtCb1RHbXZNRGRNTms0Vk5ZcDNOSldmNWUzcE1PZ2pIRnVPOVUvL2dxUEowSFRxRXhnRlZDRkdaWmVyNUdlQTdJUVlhY2hYc0ZLYmxMR3psOVVsWm54aXNmTk84QUVNRzU0MzJiTGdrbnRpKzNGOHNnSiticWt2RUNMNXJZUmlPNUhpL1duOWpPMWJvYU9kZiswQmt1MDg4Rk4vWTdoUi9tdUhuSmNuTGp3MEx4OGtwZnNXZU9zR0JSS2RhaHppWENBeGtGYUFEVkhHVUVoMmtHZjZ4TU56VU9rb3F6aHF4c3l6MzZzdElwWFdkVXg4UlJKTmNMaEtXQ0RuMVRiQlF4OGRKNDc0Z3BEUEVnWW9sK0h2Ti9Kd0Qwc1dVRWc3VlhXbmdkREpzZFJ4WWpOMzV5TE41bzFHRWdVeUYrS0NJMVgwZU84RHdmc25MSFhwU252WlIxejUzMmVtdkNzVFpBOVhsR2h5emx5eXAvQXFFSTFTQ1dmb0tUdFNRWWVQbE1Qb0V1VkpqYkhUbEtoNElwQWFkSHhHeHBhMUtPb05aM3Mzbi85NDdsZ0JOZTI0dlR5cU4zd0gvL3VBQkZMZmM4Mk1oeTJ4Y3J5dy95RFhHTDhSMEVkZmZYaSszY2NyRzBEN3djVWlXUXVxWGNIejVXOStEVG1aRWNLdy9aZzVpT3hta0Z3cTlUNHZjTjVjMW1LOHhFU0t1MkthVi9DcW5tWVV2OXUzdmhqYkRLUEY0czRNbGhNSER6WlNPMHFSd2dkVWcxdE9yL0FqSUR6MHZSYTZvcE0vaEtPci9OUUpDWXdNbTRaZHNWcTNxTkhsblZGejRyRmo0TldCL0tyNms3ZHpKREJpeFdPOHRJOC9kaDJ2d0xCN01mbHZLeTRCNEZ4SXJ2VGVYUGxOTzVkK3ZPZDErL0JqT285SEpXUDBlZHFTWlRtZWVhTVVPZ2pYdHRSWnd6TmNPc0h4R3ovKzNMc0pvblE2azN2Yy84bGxaUzN1OXBFK1VQSHNESzNFbGF3cWFjWGJyZm5xNEEvK3hqU2R3a1kvREdUWC9GUUFGS2V5RDRwNHU3QWZoVE5tVTVYT08xcGZWRGp0Vk51Q1ZGZ1ViNUxoRll6Mzl0cTVQbG5DbWJHZTd1bys2L1JSa1pvcytRakdYQXZtdU84UFlwSmYvVDlmTkVYRjRFd0lQK2EvblFEYVB6c3hnWW1nYXptMVFiYUJ2bTZSNlBMdFpMTU1ObGIySnQ4dVNCdU14TEFsS1JVN2t4djVOWEExNDRJTyt4U2VTUjlOa0VHLzhYTjhoSUVodnNTcHoxTld6Vm8yV25qNU1hcjIzek1KYVZ4UGFsbGRDb1RzNmh5TU9IYWM5MXlQWk5TVXVhQVRsZ3FtRnF5ZDhNNjI2WmhYWmpPd0JrWHQ2eGZYKzFwcHdrU0diejBoL25tNC9vdGt6bTBoanBXalkvUHBIcysvTlpUblFVTEhteTNnM1FBN3FhdDdBR2lCZCtkTEtnZjdDNHdwbWIzMGRBQ2J6SkIyTDU0VGxvNjBLd3pjSTJIWHJ3c1NuT0d5b0tFdlBhOXhFOWhQZ09WbjZzMlQ1NWJMMlRpaXhHK3ptUEtpQlVzTlY5N21POTVHU0FnQUJCUDc3QVFycG8zV0JUbmlkU3FZaGhWRldPYTk3TjdLYnM1eC9udEFqaTBnMGxGdFdPeXl3RkhkTEVNWldtUmZPelRPZll4K04vV1RwZ3hXUWVBV0Y3Zk9wR1hDd3JJM284Tml1bjRBYXlMSDZTWmdrbmVGT091bEF2cGFIbWNReS9CMTQyT2w0bWZveFhsWU83aXFNMncyVTJBcDZTTUx1OFdFRTFjTG4vbFpOTEFtd1BpMkRoTzVWYmFaOGdUTHpmN2lYMFozTThJOFBZajRDNjMwbDZMRzZielp2aThuK3lJY2QzN2RMaGNKNHFqSDUxbWlvQ2JMWXZJTEp6L2NGT2VhUUt1S0w2S0phRmFiQ0NYYnMycHpRcjNIVDZRR3VJaGI2K1poYVBoOXJPeGRiSU5FQmQyYUVQTEFUNDB1Q3JCeUFkK21hYmNGQ0poR2R6R2FIZVR3TXl3STRaaWw4WGxnVU5oMTh5K1YzLzRpNmE0cU91Z2VtcFdHbm9uWnByY1dxWWZNQXE1QjFKU2dxWFVkVGJJaW1aWWJDRExzYTFFQTEyOGgzbnR0TzV2MHRqZE11aUNSdXFHUTQ2dHVUck02Z0s3alV0UktzbWdxTWFuR1Q1UHBhYWhhK1pLa3JLYXVWRkNyWDVjUElqYkdCWU9GOExjL1QrWDZtV0RaUzUxRHB6YWd2ZGVvV01ObVZTdEdUTWlPVUtFb2ZLZkMyeGE0M0VyR2Z4TC9QRFRjcHFlbVgrK2pxSWl3dm5zSzY2UGlKNjlWK09lT1NnZVZPNEE3RHlHYjRmbWhZRDlKVFMrajlIZ1ZyekdJWnRCejBLM2h0Q2o4Qy9JcXdRZHY2M0VadzNtdTZYQTg5S1VPVUVpUVdIaEVUU3RZUEt1VlljclQ2RXJkSGkvckZsRExvUnp5cmFCaWpLN0oxWDdPOHcxNUNUTHJJdExZZW9sbFcvaXBac0NIbU14NGFqMkhtQ0NSL0NNdU84dXdmUnZHL3B3TG5XZ0dtQXYxbTdHY0Z4NytuMU83cFM4N2xIQ3FUZE9kV25WdlE0dVU2cVRCZDdFbDZHOUJHd1I0RVlvMUJIOFlnWHlZWWVJaWM2Mmp6dU9PMHg3Q2tKRTZJSUgzRzVJbmdGajlYaklNWFlNemdyUnJtczJZeFg1enBSalRnaGpwR3hKOFdXRUJGUzYzNC8yN2N3Z2V1bzdxeTlNbFVsN3VId3NvMzl6WHN3UG5oYm84bE1pSy93OGpmZW5JVVV0eGNObzBBeGxEdEFVZklaUVpURnRDVWtyY2VDNWpxQ2dsRkJVS1VNVVhkOURqWk92d2R6ZHQ0Z1R4OGZ0LzhvSTRJMEd4T3YwQ3ZLWmtuajBSSDZzcXZpdnoxLzk4Ri94MTA5TTRKVUVkWUZ4QTlSdkxNQU1hSjBlcjN4a1dtOSt1Rk9ZWmZHN0pweGJIMk1LTnBJUEZ2YzZRVzMyZHJPcXpRcUZNVzBrN1R1RVZwa29nekZtQm5HV2xiZVA1MXlES2tHb2tNN2VVeWxCNzFlODhTdi8wR2Y1WUtvWmdBT3FjT21WSWJQelZuODYvT1ZZS3lFcDAzODBDMjhiTmIxdXVPVDJNZTJLdmYrd25SUmJ6d3E0TVltaTR5TDVUd05HdTQ1MmJBRjRWdGN6eDQvL2lrMUJSVllMWFVwenZzOTU4NDVKV09NSmZjRHZTY3BpZkdkY0N6aG0zeHpNK1VMZE43QldPZldMblZ5N0E1bEZ3ekJHQlBSOEU3SzF6a1BNR25zVlpNMkhFRi9aU00xbnNXeVF5bk12cFpONG9FMjhWNmNDdGFLd3NDQUFFRS92c0M0ZGtOOTZCTm9JelA2d00zUVZYL002dGxXMHYremZPbHlyTHV2YlgwME9XM2s5SWwxWmx3K3g1c29saVpaWjNYcXNlL0lDTzI4TU1udjdIbldxdFdEM2N5eTk1NWJhZVJ0VEg4QU1zZXQ4aG4xVzU5c0RUei9Ldy9TUitxWTVjMjFPcWVBdnlqTmtLL0xTRFpNQldRUk90YzQ1RzZjcDhZOERicnkvRHpOL2NlQzZ5My82dGcyajNHZjVVaXFBc3dheEVKN0VwSGpzSmJUdG1jYnAwSWo4OTFDd01WYys1MkY4OERZTm5PdnZoNWhxNnJGQ2cxbjVWSDMxaDc4Mi9tcUU2dkJ5U2M4blNVWG53aUw0L3RTSFYybWNPUm03NTFsWlZESHE4S0xuZFFrTUtNaW1UMmRNUEJES3drYmtoSzhkc1NEU0ZHRVRIUldubzlGNjh5bGdiVU5nZTIwVkVsMkdjS1lFc0dVZFV3bzBFYVc1VkU1dlQyWGVLU1ZpMTZvTlJWa1ZGRGpmWFd5NWhQQW9ET3p2a0tROHZqS3VxZlljN01BWFpEWjVNS2FmYktJNStVc0JsTTZVWlRIZXBGd1kxNTdNbCtJcmVtTVNWQ0JKWE8wYW5kanh6RHpJZ3NzemN2eGZZR3R1bzRRUWhMeGJaYndTQVQ4ZXE1YkgxWUdRVHZWQjFiZkJjQXJpNW5vOUgzNW9URk1iL1FvRXRKelIwMnJOcWh5YXk5VkoydmM4N1ZRQzFuTUlpMGxlREhLNVBaMnpsTGVkeW1sRnUvTnVhWloxUFduTUNoUDFRSjBmS082cEpDbjVUaVVuQVpnMDJTdmdxU3p2ZW0yb0F5cGhUcVZrS0xLMjlrdnVMWjFObmNEVnNMUTZYQi84VXRkQTF1M1Y1NWYyUUNEUEVvelZ0MVBxKzgxdE1UUUJScjB2dHdTQlFlVS8rZTM3TlNzbFJYWDBzQmpXVVlHQUJ2R3FPUFBWTzgydWU1VUZiOXRQdTY3NDlvTWpFZXlGS3RUVmFQRVkxNzJDbnhkVDI2YXprckN3cGdCeStEdUdEaGk1YkpHN2U2UTY5TVZyYUt4b2VvYVJSSWNFZ0tIUnBZc3pnSUU2VzIvYnpkd0lBbGR6YVVpcU1IN2hGQjdDRGx0RW5IWDc4S09oOVN2OXVhUGdUU1Q3c3pBS1ZtS1drOCtzTTIxWGlBN25WVklCRVA3R0Q5VXp4WkFjL3Y4a3BXR09RVG5wVHVsZjltYVFTN3RjMUMyeG9Sbm9jSXBVOHpPWW5WSkZyU1lWNnZJZCtXWGk5Z2JKSWhtMHY4S2gydTg4TUhWb3JwSmgrVFRJYXFjWXFXdVZlYTdnUHJWaklpZzJXZGY5RjRSTFgxN1dNTEY1TG45UStyZDRGV1FXMXlZYWlNN3VtT2lmVTFwalJRaWV5Z2xiWGVIeVNjZGVkeFgrcjdqNlZnenVkaUlNeTBSd3JZaUVndTFoVHJzazBJMCt0bDJBZzZrQzI4eGw5L0E3RVN0cnkxbmJIQS8rL2h4S1dtR0lGdGhsaDF5R1Z4MjUzV2pzZTQxOWtURUUrdi9FN2NJcitPcTZlMGFER0hPcDJHOTdoQ0V5VVkrOVVxQURjZVlpdml3ei9Vc1liTFJHdVpGcDVRUWxzL0M1N2JOL3JyZXZSWGZhT2tLMHRCcTVmZDhSRmxMY2JCbitlNWY0THVsS1M2Vy9SMmVjTWhDbW9ua3dJdUlJMTVPMTZtNW9uUmNTWTFFak5hK3N5YkpWM3NIMUk5b1BYNEhnT0t0bmlUKzBDTmpIZng4TXNlSTBVNGdnSUFBUVQrK3dQNXdCZ3Awc3J1QXkyMjR1TlBmemQxNXd1aUVqWTBuRHB4aXBUdW9wUzlGbXI4bHlEVmpUc3NoaTQvMldmVytKbUZnU2grR28wT3RnY0YvcU9WalB4aVJKaGJrOEFiSjZrM05WUUQwdlQ2cTZyZFV3NHBsNmFFM2g3YlBnZjBZZGh0anpqaUFJMXRQSGtnQXUwc21EMHZlQmJzSEp5cjBPa1QrU3lPR3YxUjBVcS96SDJ6dnF1MnEvT1VIZHNqcFAzQ2NNWHJHQm5ZQ2M4cHNqSnh2Lzg5MnEyWXN0empHZWxQNVFQd1F1MWxyclV2UTFzaUZ2TzNGOWlsejhhNldFRGwwakQ0aFEyQXRzeG9rd09lQzJ5d1ZuNWpuMzBpYnJ0K3A1eHV6RFNrWVA3M1J3czBMVFc2eFhydTJRcjU4VmdBTUVwMzJYUUl6dExCRHJnOUExbWtCcExqSVlvbGV4TC9LcXl3ckQ5bllXQXh3TG1VRlpvbHZVV0M5Z0lKYkRhaldrd1pFd3FhaWNibkFGTU1kNU1PSmhIZHZnS2dYRUlpUDdIcEtOd0ZHVmVOb1IrQXNEa013M2YvMG1peHBsVXZJTUh6TW5yQTVCdmlRZWIwU3UrQ0pVK2hOZ1d1aURKSXJaTkpqZjBGcXZtSnJ0VGNXRjZQNUdRUXBPYWozVkVRaThEclRBM3hrWnFDZSt2akZHU1hlTEIzdlRFZlBCUlUrOUdXejdDT1VqU1dpRlBBbDJOVWpBWHR1cEJaMVNQRWVYeHJ1Y0JIbTBLNVlkVzVNaksyamh3eXBFNnRZWUZDMVZKYkJOR1FSVWdpME9xZUl5MWNWU1VxaHlVYUI0UDYrYVZQUFNQSFRZOUhTWTJZS3Fid0dhbGlkRyt0MnVlenh3bzlGdnk0bi9hc2Nud2p2UTh3MnRYc1ZHYVhDd1Qyck5mdHRQODJrSU50RmluVzNIWjQzR0VFQ2tqaFdSeUsveis5b3FtZjVBMTIrMUIrVndLMC90bk5xeTRkeUNQM1ZMemtLb0hDVmUyNEZtWHRZUWJvZkFWU0k0OGpxRGZIU0xQTmp5dW5OdVJFM1pocStWZjBiMEZnYW5kd3NGb0ZsTDV5cDFLMjFIeHNsd2FOY3lkbkdqKzVMV2lPSW5qMFM0MkRKRjA4Sy9kNENrVEhKT2VONTgxUzlNZm1VK0g3cWFVL05rOFhaOFF5Ukp5L3dVays4S3RXUDI0Unpqb2E3UlE0MGFkRUQrb3hZZXZ3WTBoQnVFOExVQzEySnU1eXpodEdHNFpMMjlqNzIxKzNLd3p0cmgwaUtMRloxQW1uTmpUWjN0aDVmVHlGVytLWE8xRUUrUGQ4b2h3QjNwZnI4MTdaWks3c0EwUUpnY3grS0VOQWJ2dzZWZlpCQjRYWnZJNENCOXcrdjlGeTJKUW40NGVscmg4WmJaQUdySGZFRXpzSkxuSnNqUTdaamZ5VklhYzZxTnJqOEk0K1ZMN0RwWm4vbmhrWWNGaDRGSU43NkJLY1JURktQeXBOUmVxNUt1R0JHbUl6b0FRckc0VXZEQ1c4NUJRa0dqemJDMW5FUWp4dHRJcy9lNWJuYnhFZVpMeURXYzR0N0RMMVk2MmxDT2gxZ3lkSEoyVG5mV3lMSWV3SmJQQkRSYVJhWHdtTU5CanZHV0s0WDNJK09QaTI3QUNrZlZONnFDK2lNK1lONGw4VlF1aSs1YlN6aDl1Zm9vNDdJVkt4TXpuWXNuanNUb0pSQk1wMVRwc29kNEZlOHp0dUF3dmtZbU1DdlF6VnJPWGMzVjB3bEtaYlBIU2lITU1rQWdBQkJQNzdBbnhENG92aVIxWDJQZGgzNHdtdHpLZ2drRGp0VWpCQ2VYNEFBemQxd2E3Mmc4akZkL0FoSnlwYm9NVXIySC9Kai9UbDJ6NUFKRytKaXhpZlZPQXFkcnRLTUY0cG9ZcjNSdGNMUFhnNVZQTVhremFMTy8rRjduOXVzY1dNV09NN0xYYTJMSU5laFA3WFErd2ZZMEtqUHl4SDBJODlJYXZuL2lMcGNzYkdrL01STHB2R0k2RjZITWFjREtYQnRVY2EzeXRYWG5uVXpFZEVRNllhcEZ6c0xBQUd1V0p6ajE0MEtXaUpLMGJyZ0tQbkNoeFUwbXVQR1lWU1UyYlNJOFdtMTNtbjFvWUhYZjR2cGk5WWY4bWpkRkdNOFUxdVQ2MzVxMzdMbEUzcHNNUklxZWlNWVFtdmRPOUV6Z3YzNzNHSmRab1J3K2IybDlDTXRvZFd4T1dYeFpDVFhCYTAxT0lBc054djFJWVRWdzAxQUlRVERLbUZuZG9FRGZEM09YZm0rUU96SG55bVE1NGIwdFpxaEJodldkZnEvTVBvQkpRcFhLTlJqYkt1WCtyc0hvckhuRTF5ekhYQkZsY3FEa0Vlbnd1TUN3aG9zbWZFa1Jvb2JFeDJsNXN2V25IMk1WalhaMkZCQmI4djVQcTRuT1hvRmVlZ2xJZ1NNYXo5dUg3TGNmTFovemtKK1VBR0xpVFNYNno0cjV3SFZjbVQrWVZlQkxuYStHZzVQOFBxZk5Gc29OWUZrVERFNTk0WE5xeFJ0V3JxOG45L3VnemR2aGNlMmp2SHMwZ0pGVzhUbTloc1VyNUU5K0tNVEVHcG9COCs4MlMrQzd2aWo5c3AyQ3NxM3ZyZGN4YWNVQ3kvT2lqTlRVNWx2TGN6bmo5eXZZTTZTeEZ3SGdYN0RYRk1ZcURteTcwbXJZK3lKQlorNWJYQ1lNV3BDSWd5RGMvMnU2QmMrV0N0TXhOdmJ3d3dpb0dlbXpJK2JWM0YvdEV0MVViNDNvM0twK1cxd3p4UnZ4dnVCckFiMXU2ZnAxcVcvMmpMd01PMDJ2ekxaOCtCTjRSYTQ3bmdHMXdacWUvSEdkSGNWL1Y0NHN0eVRaUG1JclkrZUYxUWhiWGltQVZGeDZtbDNIZEpSakhkWkxvZUJ0MEFyc0JEelU0ZDZsUkpkTk1QaXdIaE5ydkp1enF2eXhrKzVKWjlFaityb0YxQTRSUjJOcXVQTFdERHRzbXhRczk2VzVnV29pZjBocjYxL1dPNnV3REtKY2tHMGhielVtWmFoRlhnKzZqeE9oM3puWkVmZmtXLzY0c2FWdFNlM3A3QU5BOWpQRjQ4TEJrMzRvaDdNR2Q4TzNPWG1oOEFyTElVQWtjc0h3NWQ0c0t0TEV3RS9zeVI2VExQam0wc3h1cWtsNE9uamYxRjE0M0RlajZ0VjZ5cUJyU1U5dThhb2dKKzZTNFJGbFhuNkxlRlRPY2J5di9BeW1sOHpOczJJNWhHcXZqZExTWG41WkhaeDJEaXNjQzhsMTJLaVFTL3lpRkdFT3ZXOXhLQ2o1QUZkS3JoUjV3M0xQcXBVZ01RVlE0SWNoZmdmT1dMdTQvdWVJZFRwMTJKVE94b1ZjcVdYK0RkTFovZjNJYm9uM0pxVWdRK0FnQWVOdGo1UzFIdzZZV1J1eDZISCtrYVJKMjg5TUxKc1IxMjVuMEM2SGNvMDRiRFcybXVuUVFGTFhEOXoxelNSa3pYRWdqT2FOUlJBekhaOEVnclZyUEt4VnlzNGtJTVlZQXcyR1hRaktpNWJDR3dCcVVTZUI4K0FVZitRT2VMbkVpcENDVUNBQUVFL3ZzQ2Rvc1pBdkpkZkd2MnB4VDR1UTJYY3ZVcXJXT2s3MmZtbExyNDlRR3hrQ1ludXNEak1tMDl3a2dtSHcrVHVXcWVQdDBCV21RRjhCYW9scjl5TzA0UG92VHdQaW5HZ3pIOGpMMVFJeERQUy9XS3ZiYXFlTjZmY1lxTEtsQkpLOHUxYnMyNnFJYXNpR0sxbk1UYjJYV2l0cGpydllhbDcrYi9FbjBhZUlVODNkTFlVRXhHd1JSNWxMNUZkNmFrbXllTW8vVllKRjJ6R1FYS1RCWkt6MTM1cy9KOXU2YVR2bDMxR2xGbXF4c0xNaWVRMDIwbFRwUHo3RGhvNHo3WVlhZEdWU0hDOFYyMEIwczNWY0JEblZvN1B2NjBaY1gvUjZIWHMyR3pjRVo3MmdQVjk3bmRsNHoxcnMrTlhwNFhNYXU1UWlIYjhjdlY3LzYrY2cwY2tnbFppYjdDSExpdkw5YUU5RlRQYW4yZHRRZHdjbHJDNDY2djgyZWNmSCttRm9odHJUbEN6SC93VnZmNXhjVWlaeXZUODV3YTZacUVSb3FkT2NoOHNyYy85TkxIeFp1cnBWOGMweEZKMzBuQWNHNUNQR1ZuckZSc1dXN0VjS3pwVTBRQ3Y1a0hneVhZanlFdytYQTkvaUt3Rk1ETUQ4THlyQmtIOVd3elhGa2ZyaTN4RzB3Z01FTng5aURDTkRIOUtQSDV4VFl6Mzg0aUJocUhqTUxTYXV3RXdJWU9mN1QzV2tGdVVuaEFSc29hRysxTGdIQitPRkg3eE1wTFpSQ0hVYUhNTGlCai9TRTBRZm9IdjFlU1J5LzZGWWs3Y0JqQ25vKytpUmpFSU9ZOUE1c3J3VGJ3elRKb210OHpxUHRYSXFDRWNBQXdxWmVyM0R2Ykl6MGhLWGhXdTd6aEJFdTZaRkhmclQ3NVl2MGpwN051YngwT3NHNlozTDNsQ1dVL3V3MzBzZmpBVXFMRHM5bEpPbDVlSG9rRDNQdG90SUN1NkZ3aFpxVUhpNWx3MnhVeVIxZ1lkVHVmOVpOK214WTFReCt0UFJSeDgrOCtuU1RtUTg0eTY0Y293WnZMKytSeHo0S3A5QW93eFpURE9TQlBZYjJxNXg3cUNSSU9LbnU4T1V6TmJPRCttYitBb1k4ckVreDRWWWxTbE5OOER4MlAvY3BlcnJjZTAvY2RKd09OcTYyK2tMdzRKUGtoQkRPdXA2cUN1N21jNTdvOC85UW9lVlpLQk8wQk1seUtzZ3N6QkRHTU5mQjBVZDhKdHZJN1B4ZmlUYkEzdlllWW80a0VCVUpvTndsQ2ZQY2hMMGRyMm56TVRsaFFicThUcnBaVHNFbXBOenFLVzVqbmREVW5YZkoyeXlXd2hORU85QUxaVnprMlZSVlJ3ZjZoZDZCbUs4cjhHekVhdmFOWE83a0NzVjc1UTByUlFCR25KT3lEMVMreU83RzdYV25MUkFEdTR3dkFDbGtveTRyZkZGUmV6WDNNMFB0SmtDUUNSaDhIM3R5cWczZGlPSDZWZnVvZ0pwMlhQdFFsckhYdE82RUVoREo5TFQ2eUFxMHc2dzNwTDJLMDdES052d2d6YkJpcXJIc25MQlp0eWMyd0lYYmNwTVUvVDlWRmJaTGxVK25weUZKL1UrZ1EvZ3RFWnFqQVB5WDNPeVpzMDI4SGRlSjNWdmg3ZVlFWjR6QUVhRjYrTTJJMDEreXZ6OVUvcHpLZWRIUHc5VEhGdzhZZXh6VEZpSUExSVl5M2FRNUxyQk92OUhjbnpOcWZwMzdRK3JUYkZyNFZqOVRJaDFJS1FsREZuM3JVb1FJQUFRVCsrd0NLa2tsTFNQRDJQTHR3WllKVEgvUk1EK1ovdGxTdHFOdElSNTZmVStVbGcrbmZuRjU2UWhuSFVDakI3dFloamZOQjFuaW9VcHNJdmo2ZWM4WXNKUWRHN3dvMlRqYVM5eVg3UERXeklrdEVBSmNPU3U1Z3BYTFIxYnE1RnRmRkM0c3NMcXFUTEZnYU16TXFzZ1VMUXBzcmFJVkdzL3VBQVdsSGFHeEsvdjZjZjhyQ3B4eXA4aitscThsd0tFN2lVckEySmhncVhjeE9ZRmpaek02WjlNQXVDdlJYT08rM3V2eUFXUktHTHduNXJmWWdoMVVZRjdqWW5FYmJEa2hCU3ZjOUdFMU80Z0tvSk5Lb3BJSDlmNFVVTkpVSGpjUkVmZmgyOWJjVW5BKzNmdlUxeEIwckpadkd2NUJLMEhiMmh6Ty91QkdPcHd4WDFtY3BzSE9laWVnVEMwZzlZcEdjTVk2OGFiYTRMMThnQk51d2h3Q3krTTJjSFpzdHg4WTh2bFJRcXc5VVNMMjV2Q09oRGhWMWl2WlE0R1M4czZ1QnBHVUtXUnlUY2dsNkNjZ3pTY1NaT0dhdDVtVkYyanJKcTFQQmhnc1pEdnZvM3BqS0lKQlhkZnh4R2hnUVMrQ2dIeEQ0bjVGU05mT01xMGVVa3ZFT2RqNUd3ZmVZMDk1T1dnN3RGRHVJSHZ0d2lySnRzZGkxUFZ4MWxsZS9mUHZBYmwvNFM1dm5zYzdrMWlQZCs5Y1RncCtMR2E0N2YwM3pLSjN3WUpGODFtQWMxa0pxK3hQLzF2MEg3RGVTS2YzTXc4VkZKc0JZU3VqT2JNc3VHOTRQZWhYQ0tYeGQ4Mnp5d3YwaUYxdnVSMmdFMzl4UXpPMS9MYnJ3OERkZlhER0YwRXZOQUN0SHgwNTNnVGZ0QW1xRnVYcXozMUlUY3lBK2FPZUlPZExoWFpBaW1pK2JkcG02YUNZVWJPSSt4MVBPbE5wZzB6b3RtSUdrWDZKQ01KT1hQa2d5YktSMHQyL2xMZVhZbS94bEJrYzV1TzNwdkRFWWN2MEovQnFLZ2dPWGh1T1d1RWhqbFVoSnhOMlhrTHdCVTFmZU1WUFkwYmxVaTRZcVIrSnh0YnVoYzhSWGcvdnBZNy9qWHJ4L2xJdmxQRU5DRGgxREFxUUM3L01WUVFUYW1wdTY4Q2c3cGc1NzIvM2w0OGlqV0RPb1dKS1ZLcE9OSldBblBkNXFJeE9OUUZzZU81NnVBaFFoMW92RmVCQVNFM0ZGbFlwS3VlbzlCMEQ4UWNqV0ZiRHZoZEtuQ1oyNldsMnZVaEp1OFlmY3hINldNRVFUaVEvZE5hNlpKMStTUUZZT2NPTzE4RDFjQ3h2c1l5bTVtQ2c4L0xSTnpSUndqZG5aZEpDbExCcjM4MWplaDROb2J2djV4WUNWaUw1dzhxTFk2L0s1WjJBOFFLS0Q1cHdRL05Dckc3eGVIeTAyYzJQS1VNYWM4cnI5SXlrZ0NzKzA3MEdYVFdxdHN2cG1za01rQ2NwSUJMUytTRGpMZjh5SFJnN2k2Um5xTGJSbzB5d25TRS9mTlVybDYvcmFScnh3bTVYc2tHelJaMHhwbFc1RVNWZnErSWtiaTdzTTBjUnovajBHNFlSRWllR1FpNmZtMldWRmkycDZLZi8xUXMwYjE2VjNCSE9NSE5ld2NZdkF0NGlIT1R6WGFPWWlBZEVXejNiMzNuZktFUEZWc0svMzl3Wkg4ZWZiU0t0b3JoZE5Ta0xSTnJRdjN6NW1aVFhnTGJabmZadExQS0crbDR1OEI0M0w1TEgyYjExb2R3RUpBZ0FCQlA3N0Fib1VVTVN3YkN4TkdTcjFjcEdrUUQ5ZUtQWWNTNjlxNHdXeUFqZjRDMmNOQkM2QVpWdFFpcm9iZFhWSXZ6WUg0YWFpeFlsT2dQWUR2a0ROVUprNTVXclpCUVU2b3Zxd2lNRWxCZkJQaDQzc3BQS1M4bU9NQ2VxVDk4UFMxRVJIWkpaekhZd2J2dktrQ2pleDdwVEI4ekd3Mm1QRmtQT3IzSk5rUHFTNnFrbUVZT1VpSEExY3VSMzEwOUwxckhLZUZEQnNIMWd0WnRLU3FsRjJHaDJUQytybGpRQVZtR0p6NllZdzVFUElLY3BBRGpTQnowQzVsc3MxOXlEYTAzTWdHTTFBMmIwcERqNzdkaE4zS2pLaHNkejgveUx2WmVuODJxNlZldTluaEMxc0xzVUxrSG4yVjJ6TnN6cFV2TDRqTS85ejBQV2lUUk9pbHgvcWR4WTJBZnRiU0pJY3Zra2pvZCs2bDA3K3htb3lReHIxNEEvNjFjSmU0aXZuaVI3dm03QWJnek9BQ2tKQTl6STRIYXNhMlM2OFA4U1hnSkhuaXBuWjdkVzFTMkovZ3hXbWJsOFVGZG1RNUJFbkFxWXdNcTBQK0VkV2ExSllUYi9vNlhDNWFCNU5EYmNGSmNlYlhUSVdsQUE2UUw3Y1RDTHNZSVprbkxEYlBtMkl5OVRzNHMzaEVlWjU2djhNeGk2OWNTd1FSRFM1dUdJYUJpOWFUZlp0N25pOWhiQ0JybDFmdEUrVFJUQmZWKzZkUU5MVUl3WjZKd0tiN3hhVmZGNWpzdDNDYmpUSk1tTFNFK2lFcTZUYVA4WFhCOGJuV3RRRlJBR1l1eEs0cnBlSTdYVDBlN3JVdDYvSit3UlQrRlR1OXhaS1FxMVA5MlZpWWtjSnFZVzhQbElkQUQ4YzZzalJYR3d4Q0dDdzM3bEFPM0FPaUhzdWFKbS9nNGdJT1k2OVllNnB5Q0J4NXhYVVBaS3pMQkhwMll6UzhPUnRlcjFGaXNacXdzN2kzbVIwVldSU0ZYb3ZkclNlUmQ5WTM0eEEyaVlIMVVQRDZKWjY2bHZDa2pBaG9WdUw1VWtqWDhseTloWkQ0dDNob0wwVmsvTTdPOW1sTGN2dDcxbzR1a0hWbk1OSnluNitxelo0d0FVZ2JKdVYwYmo3K1RiM2tPaWR0ZUtKdzR1N0xHZ2YyTXZqT3JoZDZUUXR5TE5yMXROdmpSNlc0bWt5ajltQm9uYmNvUVNSMFo1WlZOeXFiaUI3VXV6eGYvNkw5TXJqZU1hY0NqUHdOeTg4eU4xNXVsTVFJRVF5bzl0M3lwRkdiZWszd1JPQURESU5YaSs5NExUSVc3SjJxcHlzL0VOYlQzZlN0ZjhZaHRURnRPV2R5cXdFMVVSRGhGRWlNRFptN2w2QWYwNzUrWjhIcmwxd0FNbTdlQ1g1SFRVb0lwQWZIVFNDZXdMZ2tLVjdseHVtU2dhaTVNUVptMjBwYlZZRmFsVW9JenBuUklPTVFDWENEbU1hM2wxYkdFeUo5QUhYbm5tY1I5WmgwY28vYkdVZHdPVktkM2pZNVZRS0c4SjduT2dEaVIwTy9xUGNLRlFUTkVIVjNueFNjbERsQzFrWXVGUmI2MGFwVHZUYzhpZ2FKdVkydVFjYUJxTGZMWFNucis4aDFpckpoVFowd3FKKzlFaXRSYWpjTzlPUmprVGNhdmZwYUZXTHZPQmliVWhyK3E0emxpV2V6dTlvN1A0VXhXMXpLMEtCV2ZzcDdoaVZOZnduRGJmVityeXRXN2lWR2tkZWlyRlp2QkVEcnVpWTVqZXIxRkxwb1h3Q0FBRUUvdnNFQW80NUhDMlpabmN5UGlwak03L0ROM1dRbjdZTG51Q0JEd3gvZnFOcG1zQ3ZtS0ZoaFJENzhBb3crVGVvN2toSlZmeEZuSTVzUEVZd08vb0U3cVJ5QkFmbk81VDU4NmtUTDJmd0w5bVZTbGhKS3BjeXI3SDhpSnVjSnVZbDI1Y3ZSV05UY29RNkpkTkYvZ0JsMEJDdTdOa2hPd2cyN0tpTWJ3eWttRzNabVpKaXEya1ZEdzBZMnFIaW9VOUFvTzRhSFpFUFp5TE8rQUkvNWRNLzhuNHFabTl0M1doMml6OEczVUdzOEdlQ2w0dWNrSk05Um13VXdzdVYzWGFMNmlFQmxnZkNCVVJTTUF3NklrVWZIYTFDc3FOY2xuQ1ozaUNPdlN2N0hHREF4WjUzMzF1U3VxNUd2cVlGZjZlZzEvRTVJWC9CRzVqWVB1eGNuN0l5K3p5WTlzTEhpNlUxLzBiMTRxUTJoaTRuUWV0d2FVaCtwOHNEczA3WUozN05kOXhJbHVJYzY2QWgrUVNSOHZRTDF6alhUZVd0M3NSQ1BGcU9mNzRvbFoxeUZPU0VGcytXRHdEQTA4ekUrTEpEajQ0dkVvNGFHL3JPa3VLMG9UL2lEdVF5dDlNTUZCemlNellXMnVlczI2RFJacnYxOWtqWHZHaEJEdWdvUU8rMHJvY2prZnZERlVQYTBueFdnYW9XWk5zSENzTFoxemVYUWhMYWxpTW9NUTdSTzRmWnc1c2xObnVta2FPODBLQjQwYkhoWXk0N2cvUFp2aTJCeTZqbm16VTFCdzc2Zlc5OWlMYVU2Wm8veXhzOEtoRm5XYnk2QkNtaE4raWd6NTVGY0kycjE1T1NiWjZIejNkYU5pdWdOL2NOSmtKTVlXVC9FWHk2Uk0rMTI5cUtSc1FzTXRtOW52dTgzaWhvRzZXMnBaSzI5a1NSMW81M2J0L1h6T1hZMlV6VU4vNHZvWTBWaUV6NjJqN2twQ2l4YkFaR1FhTUVBMTdLM21EK0xDRUo4UEdieXlOMjl2aEFUZ3I2blUyaldjVzFJaElDOGdtOGppbHZ6RU8yMzZDbW9jSnVSZ1lQNDVUaG5nemNDUDlXYkpEWThSbHQwOVFJMjdrSnZDMjhJOENaSHAxNmpmOEt5a0c2WWxjaDlCQjNycTlleUFmRk1MK0JTNktNS0Zua3dsZEc4YndrWTR4K3ZxRzdJbzNyUTB1WCtJSmwvbmpxUTFIUzJEKzBQUXFzMmRSblRwaG5ib084V2FuTy9nRFhXWmVaZ3Q5MGsvd2k5bFVBekM5TG9mNDdGbXhUcTVTZGJqVTU1bFR2VjM2NkN0MER6U1RLbzc1VHlheExZbEtvTmlZQld2S0RzTExVZXl6aXRBN3BRSWpuWTI3UHFQckJHSUszRlpIMlFFekp6TlZDdGpyNS83WlRmcDJhTTAzbjdIWXl3M0Y0S3pJZ3ZVcEREejF6RkZpT1NOOTk3dTNlSityOHd3ekJ3Vllla21nZDI5cFR5eGFINWl6NmF0aDhIL1FKRDc1Ymp4c29Vdk5KdTBvN2ZPVnM1UHhxTStycW9USzN4cHRzY2MvTlNPYzNYREs4SmVRSy9WeGsrSVdpaTBSeVBwZlJrM1EzTHFkUmg1WjdBVEpicE5iUDhmeEFRQTN4bENHejdQWmYxZXJOTVppcEIyR0RPWm5LUUcvMnJKeitsRDNCNGJKeCsxT2VyMW5mZTNoYkJmR0VWUHNGVERlSEQxalcyelRKQmxaY3pVSkNFVTRQN2VCM1BUOEEyTVlGN3d0MmJNeDZIY1daeklxOWgxMFFqZ0lBQVFUKyt3Q3dOWkZEMDBQeUlSQytqY1cwUktoZ2xrZjEyL2JOVmRHNGFnQllzRXJDeW1sUll1bU9KR1hhYkFtRXFSaHN0elN1bUgrdk9aT2RxWXdkMWMxdFUxeTdlLzF5aFlDaUlwLzNGYXJ6d0ZkTG5vdUI2YXVuL25oSkRFV1NwendmUXRxc2RMemNmYS9HZktvQjM4ZUhpcCtHd3diMUFrc1J2ekoyMTBvemxrbk9TdEptSFRKUXNFQzhXZXRadkFHaW1IZ1Z4RXhDcEJXQXNVaVA5UUdzNXc2Yis0VmJ0T1JPbndlKzJab2djOEw5RkNIeHRQNFJaZ3hWN29zNGtVaFlQTUlQUy9Dem44bW4yR0pEU3lYcFFqU3AyeHJidWZkcFZ0c1RSY2hhQ1BITmRtSHVnZW56bHd3ZmcxbnUzL1lUZWpQS1lPSlNDSFE3NG5sZUVDQ0p6QlFWNjFXOE9uRTN3SVpGd2o2UkY0Z2llcHJmYnlJN0hQQVhTZnloK244Y000SW9rMkRTNkJTNkpPemN4ODc5a0lNckk5aUJ5S1hDZVZHS3oycXNrTDNQWldUUEFLU1ZhWXJkSnF6YjRTMXlKOEw1c0U0OEZzRkh1RFJlS0RtYUkrdElObDhhZThxSEc2TXdFZzBBTUVnRHlRVnV5bWNaYjRxMnFUbVMwWU1CZ1RRckkyeDN2N3lUMlJqMXZrY040emJwVHhqOW5lMktIUDZCTFIwRnVVSDlsbmlWbDk4KzViS2hlVUNjUVRvMkZ0THFZa3VXbFV2Z0x0Z1RuZkM3T1pWLzVBQWdoWnRRaFEvNzNuK0hjWEZVUFM4cnFiV0JPdVlnQy9Nd01yc04vZnlyZXVUTTAwQnhNOHVzcDNwaEpsLzdLREZLemJPWTNGUnhxa25ZNHdYTlg5OGNjVGdaWWpiMUxqbkwxbnlSWjcvRThUZk04M0JZaUhid1pva2hSUk4xMGl2Zzk3NUtLVXZ4dU9OMUVoME9LcHlDb2Zkb1dBc08rMlpLcWRVRWtzQjNNa2kxODRDSTNZOWFEN0F2U0JCaDkwUlF1eGFUeWExTXJOaXN3eDZkMEhPSDU2Wkw3V1QvL3k3VzQ3K040L0I1OEorcTVvd215WW9hU051RDhUQWtaRU9LbTY2a01LZy9ZVEJUM0FHbWtTQXY3cHR5eTNlaGY2dUROLzk0emRrMmtvZURCbFpZb3d2Y2c0T212a0VmQmJhMm4vY2R1OHdPa3BRWUZNYVBLYTlSMFlaZEdLRmZ3cE8yMk1xdE1lZ0hRdU1lb01VK0Q1eFRJK01wb3lRUG9vNElocVdYOFYzN21CQ2grYXNlcm5mendlVWo5U3QyWHdnNVlBUVVpNytrVC9FQktOeFRNd3F5WC8wRm1ZYkQrVkJQWXJVYnFkRkR3WHQ2VUtOTHFIT3NrQyt4U01tMzBPaXNGRVA2LzVGRTBDdURiNHVaeFMzU21pZHFVU2lVR1QyY3FoZWpLTjI1d0ovVHpTTENvSitFbW5FaUQ1K1cxckMrTHhLTWRUMmc3QWpkdVJuUHg3ZHlHVTRjbmxJTktlbDgzdFRkcnhVZ3czQk9NUnlaRElZaEkvRFpjOWdJTEVKQVRvRXJyS1BieHd2aGh1TGkvZExlMjV5U1BpM0x1c0RDWG5NK0xnMjRleWVqM0RjY2JtTU5JVCtYRnMwZDI0eGkwcks5SVFYekZRWFZMNlhxVW5ZTXlQR0JKM2lsTXZDaGVSTi9icm1MYkZJMThvWWdWK1M4L3BFUXpVTWo1Q2dIU3p3MjBnY1NiS2xNNnFobnBaYWRTc2xOT0tvbEFnQUJCUDc3QTM5dUFxWSsyVXNnRnN4MVBkWjJtZlYrOXNKRUlKQ2lnQTJJSzhHVjV2OHpWNmRpdlpmN3YxZHhnaXkyMEtBUEVQWnJGakFpZHNiRi9KL1M5K3RVVEczQVNYSVRlMWVvdFdzLzhqM2JJOTc3Z1U5aE5uTC90WmVudEVaaWUwRHdIVlF3d0RrUjc2TFZvaUkyR2U1c3IwemtuQkN0eWw0eUtEcWhaVlZLVzhHOFJ1eS9xYmR4RnphaTBwbXVCd2ZyL1JhVTFXZGNaNG10SjdTSnV4c1M0Q24rRkMrWDhGQ3ErVGFKRG5zVnM5dXpZWVFjdTFQUVE5djFMTkozM2VJNkdTQmdXbmczVFhVcWJvRGlheEd0MTR4WWdSbUhzbEE3UllEZHZhTEVvQmNYQlZaSzlJQzlHd2huZjNsNEx0Y2JNSkZ4T2FSMy83V2tIelJCU3M0RFdndkNwZkR5WGRQeklPVkhmM1ZmWlJrZGZReGVWL3F6Vy9IYStwam1PbjA4aHhWRTJtQUlMV2pURkNwSzZUdlNRcmRPRDViNHRZeGhTSUtoZ0luMUpxNXNGcDlMcnk4czVzaWdXeHg3NWJRUEk3RnA4bmdVMFFTWW02dEN2TWV5U2ZrUXgrMFUrditxb1NEWStRMjRjMWhtSndQYlF2cnUvK1JiMWhuTlRhWHAxRTE5M25ZdUsxWUUxQzZjbjN2OU9YMFlEQVZtMjdSVjNBTE5uU1lpUU9KaUNVOGhSV2syNWRBeWE0ZTd4R2l0Q3pwSmZLcnIwbEpNVFBEQ3JkSjgzK01tVmN2TlUva2xLbjhNZjdMYkZPcmJkU1hrT0lSOW1hdkY5MEhRQ1FJRWVicWpOUkxzbjloNjRURnpQMGRnOEI0Vk82YlJUcStWN0dlekpoZHhkblRwVUo0TG1LSzNnUXM2T0lBdjVHd0RGZStkSWp6blE1L1V2N3BXL3ArL2pLc2JETGZGUVFpK29QN29DOUlZMkF1RGZZeFJHTkR3OFBGakord2E3NVRNUWR4VkpEU3prODdPN2tNekNXTmsyd1lZbU1xVEM2TzcrTEpKN2IzTzZwa1VId25maFdmSHJvQURucG5WN0Y1U0FzMElGc2pPUmpjM293S0IrblM1Qk1mUjVjN0c4cklYYVl0YU9LbWN2UVA0Tk1Tc1hsejlGazIySnZndHlSb21hSmJYSUdVQTVYNjVJd1lqcElLaStyVWhpaWNVNFUvdy9uTW1Fd2JENkZOb0NsRWlVYzE4aWdOL3pqTjMyR3pkYUNnTHhnVkRZdFNOOEJOOFpMOFpzaUNsc1Zkdm5oVG56bUhIaTNJRW9pZkdnRkJSL3hocjNwc2h3VVFGVkNxSlJnTncxeE54OFJPd1pKU3kvbXcxYjZmTU42ek4xQSs1MjNPcHg1eGtZZmxwTEdPY29Jd001TFY4dGpDaFh6dDVNbHlBTUJOdTJSaE5Jb25xOXJRVjJ0akxQV3V6NVB1dHAyR3FnQ2psQzFvVDhkK0VpWExZdDdBUVVsNkorK0x4V2V0VXRyUGlOUElRbVR0Rzg0WkpmcTAwMXUrVzZ0ZTE0WWhzTG4wTllGZnV4K1QyNXdlNXNIa3daeUd4U1grZEExTWkwNG5QNVBkQUVGY0VJVUpTY25vOWt6aXdTbkVXMVNkTTJQbWFaZXFNR2dyc0xhUVVCT1llekRtVnMzMG9tYVpWZFJBVCtYbHFVTEV2RWc5N0plckVxSHNqZE5QSkc5QVE3N3V0dnFBbC9QYVFzSUtxakVuZlZMQ0dSenkzWVBJbUFZY0VCWHZXcHdwekhvS3EvOXdDQUFFRS92c0N3elhvV3RxdEFPdG44ZGhPbUJOWEoxYS9FZm4xMFJNdEJiNUxXanVENzVLbmhnMllmM0dTUngrT2xhSzVSWFN4aHdXbmU5V0hqZ29oenArYzdGUUR0WWIzU0kvdk1mZTFQZHF2QWlLTUNiYS9Idm42LzRQK0ZyTVVORWxpVVBmMWFUL2lJVXBKNGJ5amZKK3Y0ekR3cHZyVllMdWNRcDBHcmQ5OXJGUWF5eTVkUlRpOW45U1J1d3E5UUpyem5Wd2xnTVZwYTFPd21maCtqaWlyRTJGY2VpeW1FaW5pVXpNUUFLbkpnbVpkRFhzdzVsQnMyYkpydVJEclNSeTNVMW13L0U4eng5Q2F0ZWEzZ3pwM3k2cUNXcmkrVnFYTXhtbTdJYVVtVGNPTU1FUnFndU5pb0hJc0ZMc0hwaFFOMkZ0bmJqd081blVqN01jSHpFNHNHVU53ellXY3AxOWhSbnBGMUJaSVZKbVA2K09oYi9jVHJoVVlmcnhTYU9oQ0VDdkE3aTlqZ2t2ck9YUUYxbm9TNmFSb0dpR3BCV1VpSEw5c1RybDRCTEl5OEZnQTFWV1pkN2JsdWtJaHdNT2cwZjN6c3EzUnV1ZW5xanVsa2NmRmw2Y0ZPSytBSFIxOHlaamNNd3NDZ0NwTmwrSm43MW5TZC9zd3loQkI5WnE1WENhRE9iVXAyTThjQ1lqa1l1MnBTRWJxWWhubTI4TUpsY0M1NFZiUFN1Qk1GY2pHMVM1TU9SL3hUTFRGOWl0eERHaS9PSHVDejdDL1RrZFV3a21ZNmpQU1RCdHc5YXNkRCszMlNWSVpWSkEreEU3TEdRQTVEblhEenFPc3JISmJVMm5BQzJ2eCtFV3QxL0lsakk0S0M2WldNMkVVZ0Q2cVFtb0JQbWM2a1IzeUFRbmhCRFVTczlNRWdrdVZ6Z0FiMndOcW1Ec1N2UzA4TXU0T2JNVGlqTFhRMy9CRUo4cXZCUmp2TnhUcXcwamUwWE83ZEVZMGVxc052U3ZGSkFTZ3RUNWEwZnZTNUJuaUhKdFQrYkRBZVE4eXVWRTJOdFYzK2pOcUlqUUttang2Y1RxUkFJZ0F0U0tSUWlmenMzS1F1dTJsRlZsZkQ4OC9RYnBnOU1NTjV4aEJhdVc0WVQ4anlBU3NnQzZDZEVjSUh4cTdFWGVFM0k4M0dVU2lxTmhQb1RVU3FQbUZCVlppQ1FtbmJMdlkzbmpDcFM3NDlrNGtHSnhEUnY3NVNUamtzWnBkQytaeEFZakV1NmVoY29Oams2dng1WnZEMlBqOVl2OGd2K1pueUxxTllwbE5NTkQ5eFR2NnF6NkZ6dThOQVFTaytDVDVHSjA0MHNRNllLR0xxRWlBQ0RVbXpCaTlydytzMlFOYUcvbnYranRReEZKVFpMYlkzRTY4VHMrdnJRS2FtRjExRUsxODZ6Zm5lZkdxaFZ6Zy85SGE3Z29rNkJQMUR6VmZ1ZVg3QzJ2OXFBc2VmRi9ZUFZ3TGdzeG4wK2lDYlhVSWdOQWYxd3VXUVRWVEFlYnZEMGVvaXJLWTBJY0JNSjBNNG1CK0k5SG1FeUdlRWJ4MGhPL0JVZjNObWl1WG5HdkpNR0FpTEw3MFF1L1J6bGdJb3U2N2xwRDFrSzlscWhQTzNlNmpKZTRGODY4YXR3M24rQWU4T0VYT3d1aU03V2NPbGFudnpWYXliNU12MVJyU0xKMGtxd2c3VGpINHZ2c0hQb2NtSVVCOFREN0NKenBaS2ErY0xsSUltR3lObitmeHJyWkV6anpPNzc0VUp1Sy9IOVNaUFFZMzErallBREZGZVRUQnd3SUFBUVQrK3dOVkRLM2N0cWdYZ2hKYU5adklqbHZQUzFuOEdYdElvcllFSTJVODB2ek9BVndGdjJyOGQxa1NuTkkwK2hTTHZ6a3Y4KzA5UEtBV3NJUUtnbGlFYjN3TmZsZEJBWmRQN0Iya2VCbE1ERmI4cEFPUHovbWNqbE8xZHZpUCt6elNJSFBjaTk1WUdKaUUxMjFwZ0pnc1RTZFNrTU5QR0twRkhPdG5JaHcvOHo5TUQ2NHA5NDNGZGttRGF2aUV3Qm5OZW93NGZYTVphQ0lSYkc4RHdXQVUrUHVpKzU1WkpQZm1oLzZQVEdaRjAwaE5VeitzNU1BWHdxK3o0OCtoTktXUnVzSjVIcDZXZElxWHBhTnR6ZDJjT2pWZDVuKzhSQ0R3OUppRmJDRkFLRGdWV1A3L3ZCVGNWRFRoaEJiQXJmaXN2ME9xRjBOaTJBWFEyVWordldQd2M3U2hxL2RxVzNLYVZ1bnNpUGFrZUlxOExESzVRUmV0U0YzM01RbVJ3bnZDWkFPRXZPelNwWUlrcEU5MlFnTGNtUWliN1luaHlGOHZCdGl4b1h6Y2NoYTNtcWIzWVoybjEwNU8rKzgwVElZTkplWHNBd3hqUmEzZHdsQURWTWc2MnFvMmdKWFlPVVg4QWp5TUY4MDBQbUczakFQM1o2L0lBK2pycEZ0TXlJU25QQk9sMTlONDBSU2M2Y0U5V1JmVWZsUVZVSUIyem9CbzJCSE5JTENDUlNxdzRwMzA0QThQV0lhWEE3YS9XaHRQd0R4L0pYRnYyZC90VHZwYkV5TVR5cm0zeE9TZUtlNjFqTGtPVHhQbVROaldNOVAxSk9hT2wxSzUxWFFXdkF1NUpVeHJhS0ZUdG5jUks0VDFUd1paZDlTRTN3R2J0NCs1bXJSNjF2OFVKaTBNdDJQR3dJcUlIaG9UWFEwa0RDdyt5S1JOcDdZN3dGUFNMTW9obzAwaDlGSnkxblFzS1NUT1JiaHd4dWt3dktjbHlBNEtFVDAzbFBvdmVPbkFIVzZ3ZDVXeitjdHV2WldZNjQwWThFMnE2dzdhM1NMNzVrTEZ3NTFwejFPNEN0bUhSMmkxb0tyYStxMnord2NwSytXMjhSL0xGdExheGZQNXZBUmp2RDYvMThMVWJXRmVzbkZWKzVBdTRnRCtpL29rVjJXQmUwZ0hZM0k1QVBFWTlXTlVtQnhHUXk3YW9sTHZBWHZ0bmRiTE5meFhUZ0cvVS9PbzNMRzFYWFM3MU5aangzNlJtczRWR0dIN0ZRbVplTVg1UmFEOGZlZWR2bjJqVmU4Ukk2VFllYzJ6Q09JWEY3ZFBCb2pYRzI3QjhtVTBkdXpCQUQzN2pQUzJCTE5hYmFYM01ZSkFNRVR3cVFuMW1pVUZBaXNGQ2FPMlc3MU4wUE1jNFlQVFhUak5FdE1NMUxVNXNCaVkraitaa3Y3STFSeGN1NHZGTTZvdW52TEV2U0E0a0xSd3RDV0F0S0oydlYxeHdjbDFXYkFuVU01VW5WdzNWcStDK0QyRldIWHFoUk5RZ3Y2ZDZPMjNrNHJBemVIMjg3TksyZWFZSWZnYVNJekY0UHFKR0tocHRnV0Rod0xVUlNwLzg3dXJvbVFkVWk2Z05BUnVrdDBybnVjc1dORTNvamRoMkZMUUpucmlQOW1FT1JEb0p5SjdqTTZiWlhvTzExS1pKRmpJaEMzZVkyWVRPcDcxV25vaUxISk8xb3FRcHFKWGZ0WEticEVsZjZ0d1dIU2dHbGNxRUZoeHBkZU05YXlrN3g3eVlwOXBHZ01mbmdjUXVuV0srYTN0OUVzRmVnNmNSQW9BQWdBQkJQNzdBb2tuTitPKzhVbUlxNE04ODFTcHFmZVFKWnF5RU5xcEJDcGRTeE1lSW9lSGxONyt2VkhhRlBocG83S2pOcGV0RmJ2N2RNVy9QSEI3YkRrVStCdmJKazQ0c3o0eXpmZUttRGk0aEdlOUZ5eEpmT0ZVWXc0cW5RbHNaaFFNVU5kUFBEb1JsUXJpclhBcWZpSHJVOUVVcVdrd1hXTmRZbzFnZko5UHo5N2pBY0dJZllyaERZbUsydVQ2YkpGZ0pUSDloTnNjeVh1QUxGWE9pK2Vnc3NsQnRGcno0SEpEbnZKN2JLT2QyZlU0U1d0S3VPNEp1aThJUjhKQ0g1MUhCZmRCQjdSbjRqd0FZdThwbk1IWlQ1aHJ4bjMrQ1hjVWF1UUZXUkQ2OFkxUHJ4N2IvSmZpV1d4RUpBUTlxNENFWUVISXlaREJNY3gxRlJDejRBc1lqcDI1eGZuSlU3bzA2cXNRWEFxWU1iZ1AvNHVYZFMyWEd5YUdqVEptTHZUejE3dS9kdWtZZUNBbzJ0b3V5c1dpbGFYcWs0UGtxMExBSW5XNktIYktYa2M4VUpOd0NBdHp0TG1iZ3N5Y2dTMlhBaW16ekJCRFVQaGRiSE54NlN3Rk1iRjhSMGJJcFhPZTNvV1FTd3Q0d2YvLzcxRDdTbldWMHZVRkloZDZId0JDV0tPQVByR2FPRjdFTUU4bzdMMzNjeUY3YlpyUzdRS25wOVBiNTNGLzFxZkR1bFkrYVdYMTZOK1pyblNaaTRVMklNYkxsU0RtTU1icnZyYndrMEw5WWZSeVlOK2tFZUxBbXRsTTZraTF4WGxNLzJmbHpYRmpoenlhbXduc0E3L3RCcFNEYWY0UEFId1BOTzlBbmtzbkFVdVV4cDRNcmJTSHNNSUZEYUUzTVV1cnVWbXNCR2VvaGo2dng0S3RpQ2FMaHJmaE1uTEhSZzlMaG1OdmtaTFJLVCtmOERtaGladlk3aDZkL1hZcGN2Ujc2UXRjRjJxa2lUTDhlNDZyZ3RCbjJ3QURwL29YdTVGendSb3dIV0VBTHRvanAvdFFWemNCMHRMMzdMUDRwSlVEZmxMMVdqUVJKOG41NkY0SDlDd0lsWnl6TFdNTnBlNzRmNThydXZBcUZaNkw1N2NhUXlSSE9RYmR0RUdOUE5BQTJxbHAvZmgrL055dVVwcktYbEhseUQ2QWs3NVBxb2RtL0dNUHRBb0VoY3ZsVzZ5c3pYVTBmaUFvbDhqcGp1ekk3UDViRE1xQitJWXF1YTROM3NEM2JMYy8yWlc3Vi9yQWRUUzRHZW1RcG9KTHlKbXRGcHpLM1hFWkNHMkdHTWIvQVZYSlVSMTFGMGFyOVkxMm5jazV6MEo4YkRFcGN1MU5yUVVOK054bEE5MTluVzUvcWdwbktBbGxhS1gvam5PUEtXNnpkcndKZnVzZWF2eGZxK0hZSGZ0Z2hNU1ZHcFhKNGp3NjhOOEpOZGZ6ZFdZbk55MVQxMGRkbmFoUHV4MUFPemZ1WTJLS2s1UEF5OHJ4VHFMaDZONVlNYmtwYUtQQ29DSlFvNlE4Z01IZ2duM2x6bmZ2MkZQZTVaSTAvWjVhYlZYbTJteWV3SFlWQyt0ZlMrYnRyOWpOTkxCdlVtQUVnU2ttU2V0bjZiOGlYYTNPUjlFUzc4LzZzUXAzMTMyRzhpQVFITVBQOXFoWU9aekxLQVJSOU5ZeWh5NVV4clVUQ3poTzlSaUlpZzdQMVhwWnptWC9TZk40SzQ3c3ZhS2xYMTJneGIrdVd3SDgwRlZobDZlUjllRlBSLzZxR0pRVUJwZGZ3UDhneGdSbXdrTUNBQUVFL3ZzRVVCVUdTemVaTWhYczNFYmhaUzl5MDF3SlA0TUxQbVBWWHAwNDVTSDY3blpnUE5JaHpHVllPcTJvSkVhZ1ZyeEY3NFJ0YlNDV3lncXhwcFh2cjZqN0RETUdPUGlnSkpNaE1IVStSSFIraW5VZzY5VEs1eHZOVStrVGFhOHo0WTZUeVEvcGFrL2l5M3p1Rmd4N0FQamFTK3F5TWVPdW1wTFl3clplWDliVkRZWHJMVjMwVDFFR0ZJTVF0ajZxSXVyVXF1dmowcEFueGFJQWVNVXU0cG5KME9wb291ME5XeGhzcDA0T3J6N0QyNEJ4aFZRK1h5UkdQYzd0NnArM3F1YnJER3RUTVVuSTk2TTI2ZFZmVitGdlhVYmRuZkJjc1kzaDVyOFl5RWMydWthNmlCVUFVNjBzTDR1MkVYZlo2SEUvRFUrMTkxSDZNR3ltRVl2eEhUa2VpODYxUTdTenl5aWFmMmNMVlh2cDlIbmxVc2JlUm1UVWR0TUpyUFJwSVBqckNIZytXVDBtUW1QRVppdmIxQ1B4VVZGbzlLMDZFWDVROG1ibGZFS3NxOFJJQzRYbWtKZVczMEpMelJTV0x5eDF6WnhZN3lUQ3Q0elhSVEtNMGd5VzlVd1hxQm54cHhrWS9OWjR2QncwYXZ5MEZzdTdyU0JOSmVKc3dMTDJHL2ZVdFRDUmY3MklFSGc0d0p2Vm1uQm0waFlGNTRvMEVjZ1ZSREVHRUlvdFEwWERwNmRscWpxaDdjZnNYaHNQUHMzUkgvVlpXekRVSmMycDFMZkVQWUFJTUF4TUNDSUVMK0J6cmpaY0c3Y0lkR0ZoSXVxbjNaVno2eHdEVjJXN2VDYUJXKzhFZzNjK01pbWNta21Gc2dxR0hVWXUzQ1ZaYVZxQWN0bjU2VWNTZ0NxOGtzbkZLcXBFbnpkZjNDQkVaY0lIMWgvZjdibEh0MVlCUmwvYjhsTjRObC9PUjBoL080OXVveEdrQVVCZE85VWNuUmlyNHlraGVEeHdOZG5rNzgwekRlTE5HUUthdGFYVjZuNnM3YmZTMlh5MFdhRG8wYkpzcnZOcXpDKy8rVHNyYlJ5VktpNUUyMXdmY3RvVDluMDQ2b1g4bUh1clptd3NBZis2Z1laUDdrMmdkdTVaZmtNOThvSFBCcXlNYktEOWNFckJ5anl3NmFuR21FMDA2a2ZydG9pcFNtSzBYZWJoOUM4d05kdmNzMTNFL1VCTFRHUHZJY0pNdnF2V3U3SnUxcXRqQTlzR1Z3VjFpSkJYTUpDNEdKN1UxUlZUdXdSTUM2c3ROMEhBNktWc2IxdzVrQnJwaksvKzJEc2Q1NU9nRzR3QjFtRTREalVFMTZ4SVdBWUNLZzNaY3AwMU4zVFVRZ2NKVk4zUmJCL09LSUJldjZiRi84SFpZSDJsS3BEaEpxK2RlSUJOUCtxT3NqdnJwNGdOMkovTjhUY1dkM3dMN1NYZkNkZllUQXNBSUFEbFVHZERWU0dCOXlEZVl5bDU3bFBoMHFSTkpmR0ZBN3krQnExVFVpb2hKN3FKcVUyb0EyZmtDMGEvcEE4b0s2UTN4VEhFTkVEcnJtcXI5K3V6YkhGbzh1VDN5SGRXZy9FUmYyS0FDbi9KUGZPZFRXMThFNDk2Tkg3WWtJV0FLYTZ0TEtaaHZCdkdONEhrb252dExyYnB6dnZmRm1rWVNpdE1RTkZUemg3TWlYeGZOSzlxUmxhVU82NFZRd2J5YWtlUDRRV0Ztejc3TnB3MlZtQUJ2QmtETVpEVVNuRGdHL3FRNDVmU2gxR0ptMlBPVnpiYncrdHBrOS91blFJQUFRVCsrd0txRTc2WU55anVwNHlvS1BOM3hZUm4rd3BmVWs4QW9iZ09vc1dteUZheWFYYkQ0cmFhTlUwOWV1WWRZQ1MycEdudEdGNFpVVFRLQ2tLaGwrUWR0SzB5MmNrWlVVUXhnbm1XTzJFbVFhY05EOXJnN2RIL3JIMmMwcHpRY3ZHY2VZNENNVzg0cEdWT3RIenVMVnY0cWpHTEZyeEZVY3llUWlUS0FCMlhzZUJ0MHcwWi8yVzEwcHYrdEdYUUtZSUNRTDdZTnZ5MVhJd1NNRUR5Y2c3Y1NZQjIwMjlzbHBCOE9BdDZkMUdDV1VuSmYxY0ZsOXVVREM4Y1p4amNtdHYydVFTS1cyakRVQm41RVdBWE5aTWJ0bEl5eDIvMDBoRFdaUWVFTUVUSFRKVStOdXNTKzAzZUpkbm5jUTR4bjM5R1RpZmhkRHIyV0tPZmtIbmt0VWZFZUVZcWIxTERhNmxucnkxZEJVZW5KZ2o2eHk3TzhXd1pnTHpLS1lYa3poNnE3ek1UQ2FUQkdIOWp6S3paMkZlSml1VkhucFFZSUlDQVhzYXRIOHdFTHZoNEdPUDlOY1cwN1FyMEVTb2g5dUt4MVNMR1hnbDZabEZKaS9EdUVIZVZPSlkvQW13Sm0vaEIzWWF0SmNjQ3NybGZYR2hiM28xUDNjbFlwL2JDODdzdnNTK1B3WUg3d3RzNUxHZkdrZWFibUxpMURFQjJHRnZ1U2NNUytqY2xtcWtwQnZGVis4ckFvQkh4bSszc3pybXhLN1RqZVM0L25xOUVYNkIrZ2g0OUlGT0hqZmxaNjloR1psTG1zd0lKdUdKN3ExbXJRVUpoRHR5RlBiYmUyeVRCZzRBdHRTcUFxalZFVjFrcEJ3UTVMYkRUSzUzZXgrZVRyUm5WL1JkakNMWWExdzJoMnp0akMwYUxsTmRndzFFNjRsZFZvaGNMSTF1dkoxelozVit0aG9EQ2lsQmhxeUhkSmNUTWZoUDJqZ2drclgvajZZc1NLTnlidndlSnZuakR0ZkY4QWN6U1daZTZSdDBzNUlaaitQdHF1c1hzbXVkZk5aZHlFNitxWERaaUJraWorVHV3Wml6MitjeXlSTStGZ2hWM2JTb0Iyb1RPUU1vaUNEOXJLdFJPU0MrV3ZraE9sa3pqSkNYbjl1K3F6VzNCRTh4akNRR3gxRnArKzgvWkoyNm5tYlZpbGVqNk1BSEVNbjBLS1V2QnkyelZVKzRWQmVuZ1hUMXZHdEVYY0F3V2pMS0ZqMFNoQ3RqYlZsTXAwcGpCeE45djI3RjFiZVpONHlHZjZLcDZib2x0ZWFDMS9nTHd3MngrbEpVSGZUMUFGanpENE9aSEZjTEZob0RJQm1sTjl1cVJjK1AzemswRUtjekNHeWVidnpRTHd5a2lKN3hTd29JdkQvYjdtQ2xMcWxXVVJaYkJnTWxmaENNMFpmQXN3SjJIS2ZIaENkS3pwelRYanh5TTZrdzkvYS9lTWJOSk8zajhacys2RFh4V29jSndBa08vamNHeEZQUUg3OTVoWXFrL1AxTks3VHdzc1hNeVFvQ3Jrb1FobzFVK3FLREJlMjJrUXhYN0VaSHRWTDZzeFhKTHlaY09FNitGU1VDSWxmWjJXZU4xZytHVjRQZWR4Q2lBb1JOQkVnNG5WZlNOTUtzRjhzU1NaSWl1a3hndUdkTkFzby9NZWpPUUlzV3AzbDZrNDNCSlk0aEtCcHh4eDFBYU1ZSythZVF5N3dwaWZKQnNnd2hoR1RpVXNEU3RTR1lEMmJCMGhzZm85eUFBSGxGTEQ5YmhERFU2SWttaENUSVhBZ0FCQlA3N0E5YWE2dW1kVWVIL2JzakR5T244cGZYTDA5TEh4Rm1qQm5rR2I0Z2w2My80Sm1QN2JGU2RSQWZvVU8vUWlGQmRLbDhvR2N6Rnd1Q2xraCtYR3BnWFBYc0g5L29vZWpNSy9wb3JQZXg0V2ttV2dKaU1SV1M4OWh0Uzc5NUhpV3JMVEF4MDdUNGlRaDFxTVNZWmFZUEgrOHlRMzVpMTl1YlpBeU1JdXFSajV3NUdLR3ZldmwvbVVqc0pzaGl1aFVzMWdOWjdHMjJ1OE1UV1VoU3YxL3RYTDdGaEwxWGY3OUdBWlFhSjhHd2s0aWhPQUNpbTArWStjaXJXN0xQME1TYlZlQ3I2akJzbUlWS3liSmlqTjJpMXBOam9CSFpLOEdqaGdUNHdWdzBUV0hReGY3cFZJTmZpcm9HaC8vWG83MHJKZ0o0SFZsTHdEaFRMVDlmUmoydTI5T3RvNC9xSUhCUHVzT1d5RmxnakhUOWVpNE9SbFZPdHJiZGphU2hIQUZKZFpGR1ZjQnVYRDhIcTd0Q3FjVDlxZklwUUxDQzVONzhrby9OUGRubmszSHRwUlhqcTQrd3NpSis2SXBpdUh1MytWOVU2NnlKOFU0aDJwYStmT0ord0w1aW1rTkpiMEJGdlVwUmxrZ0VvSHEvNVM5Tk10ZHlOMjFtSFNlY0hrNVVwSWNLOEVGSUw4MEpMZXE5UG5FVTFKNWQ3UWIybjQxZUg2R21BMU1NVGEwK1REaU5JNWVxZjZSRllFQU1BakR4V0E3WVU1Q3NKVkpkbmhUVVVwZVU2a2VCQkVoRGdoU3haejRuQTAxOEJXSXkzL0lvcVBQU1hERzYyYnJXZzdnaUR4ZXo5SlBZSTFNRk1ZbDFJMWhVZTE4aWtsZnI4cmV5L1JTUzdnUWVTcDFDMksxWEpPQVEwUWdtbnlEMHVZd2dtZDNPWXpNNGYraWVmUzFSa1FUTWVhNk8veENsa3p6aGR6WjJ4b1oyNEMzM2VDNzNjZEVneHJwMGtVTmUwd0xveThsQURDRlo3YVVucmY3ZzM4cVhSTi9QdHVhbVF4YU1JMWxMbEFiRW82OFhyVkcwUmllaEp6eVdmZDZSZnZDUFVBTU13NHFLZzMvT2lzZStDVVRDZGcwcjZ4QlRQYTFjYndoR2NqaXF1Y0ZIM2tRYnRiWVFTSlB2RUN1SCtxV1oxaUYvTFpWbjdPRFk5bERwQ09aMmhJWVlaRWRURnVLQnlsWkNScjZEZmtlTm1zVlEzK2pjbjZCbzdDalBvTGZJbzhEVmFZZmhOdzJZTWxXSkxLZ3ovRlpWdE9oeGlNQnlqQVd0MDZaNzcrUld3RE1lbXpIc1hWQVNJUStmdzdsODhiZXVaamhvRWpwVEZIaHFxOEFCV084eVZuYmIvYjRlQS96c3UxMDFCeEpWN1JPUFZwTzRiUEs2dUorcjNNK0xMVURpZnRLdkVuNXQzbmk0WVU5SVEzYTZYeFJFMytuK3pld2dzNkpEV1VVQkN4THpsTWE3ckcrYy9DdFl6enVoaEpRVi90d2NHWVQvYStBWGFTcFdiclFHV1JRWWo1TmlFVFZKbFRyZHU1b2FJZmwwOTFsQS9vZ0lCRmVVc2ZyTzNNeGVucEVoME9XZmVFSFVBWlNaVmEzbXVLdEpzL3ozTkFCZUUzTjA3dmJWR1VIT0gwbWVUc2Via3F2RkM2UEdWdlFodG9meWlWektIdG5aSXR6YXFEU1pQWUpOQ3M1eDBaRnR2VFRKNWJVWDRmTW0yL3VZenRZRG96RDVuT1N2cEtsOFZNRTZ2TlRYMi9UTnlzbmljSjRvQ0FBRUUvdnNDR3ZmeVJFTkV2U3VZM2FMVm4xU29pSHFPM2ZXRUpXOVRzaWJpeHlieTJ0TGFVTUZjbFlmbDVEbVU3MFNzczNPWS9wOTZoOUpEMTBsQ3pQRDgvS2tDK3JPaTQvMUR2Y3VQT3JFaEI5a3M3NG4wR1g2S2gybTdRZW8xM1p3TDRoVUxyalYzZXp5NzNoYU5UNENNRDk4aVlEY2ErdmNEMWFERS90QmlkSFdCdytaZnl2QjRLcTJZNS9GZi9zOHR2Z0FZdmFCV2hSQ0l3M0lEZ09YRmdzUXBCTkxUd3BVTUU1Qm8rRVFJRFVXVHJUSUdJUmRJSXlkVy8rY3NCTzdsNERLdm05Um4zOGM0bkpPeFNqVnVRREsvOGY2empWYXI5VU02V2wwQkhUYi9UV1FEUm9hWHUyTWFWNHRSTW05dHdTcjBPMWFsQitKQVdIM0pYdWNzcit5ZU03czRoVFJWQ1N4VXZhbzRXaTJiZ2hLZGpGaVkrVlV1WWRhYlVPbGFja1pralNLam9FaFovektSc2tYdnF2T1pSdXp6MjFVaE5BZXV6MkZCd284eVlVY0Q1UVhsSkk5bisyWU5HTG1mekZyUFdSWUFTdEtWQ1ZDTEl4WlhVaXY2TlNpU0Izbm9CS2lZZGRESjI4Rnh4VDFDNTFBcktEbVZVL3JNbVdNNG50RGtBU2tTV0thSEZyclVxWXR0U1VxaDlQOTJ3N1BKYTRuMUJOMSs5aTNwKytyeStGVUdWVnYzanpZQXlva2ZmS2FDZU8wc2VMQk1HNjdNRVhqOEJvaHl2dytEQktzazJibVFmMzZHZHMxSU4ySG1nb1ZRNFJFTVMvU3UrZ2RuYlJwOEdwWDduWmhNTmdBdGczS1RQbXN3c3JtMTlvRDdrNkpuUG1ndlVxTTNlUnBNZEc2VmlPQ0gvVHZ2Z0FvbGlhamxodnhNRE9pWVNoV2tXdVJQd29zem1rMEQxMVM3WWJEVGFJb3F1NmUwcWdIR3FQYUpXNWJFeTdhUVVBM2JyZDlvU3JQTFhRY2V1VUxPNHM0SmZhdzYreUtMWUNxWDdtc2xXU1kyUlJWeXVQaFNaMGw2c1hYZmZUVHVMSE5rR1kyaENsZmY4RUpORDQxZHRxaklqZ2JYR0RxNDBlWVVWNzM4T1dmK1VGbzMzbkFrQjVPSTVSREFWRlJsaGF2MThNN3hmd0N2N0d3NThZc094TVJPSHRUQ2dZQUc5djlYdUozb1lWK3ozV3VvOWYvNFNRQVNSOTVlVkVRZjROSmFsb1RaTVpyVXhWUHVjckpaQnlITUZzUnZoOGFMOTl4ekw4Z1h6ZFJselF6dW5ReStya3ZXV2NsVzR1bjVPejRuL29sQVZpQzFWMFpMT1FGRFNJRzh5UWJkVkVDcllJM25aWlpINHZueHRzZDBwNWpCLy9oYTEvRWZaaWxQWVNNMUVZTWV1SW9aRnFrRUZvWGRET2pyMVY5Y25JdDBFYUY5ZC9uWElTUkdoUWhJNVZYNmJrREdlQ1M2UDlCMVozWjYxSW00R1czTHZFMnM1MzJ6TWVRRmVTUlNKWVBUYk5acWEwY283czB4cU91cUNWNHlVVVdPYnRiVkZCRk8rU3ZmVVRDOFNxTE4yYzNiT2tVTk5jTmNTZHpRRGxuRFdDZGJ1RHNPdEp3akVzTkE5MXdFTGtsT1VvOTJYNlh5ZEN0MG9yQ2lWMVJGZ0w4YkFTZU5EMWFpZDg3dUk5d0NUZ0pYUzBwWkpWYlpkU2FOSm03S21JcWI3SnVFY01lQ1AwbXlCQjJVRUR2eUEycWpLWGpTY3hVSG52M1pQUUlBQVFUKyt3UCtIMEsxZktreTBMZTE5SlMzVFpYTDU4bHF4YXpDL0poN1RNSVJoQzM5R2FpUnJpSkdHK2R2ZXpmdG1VSlQ1TGpraS8zUHQydC9YVkFxM254WlExcFcxeFF1S0JqeHo2Q0JwQzRZSDlPNjc5U2FvcDFkMXJMa1NBRUx5LzhLSW4wd2pVT29za3ZhcjBpblFvNHVoVGdBYzNiWFpiS2pKY3FNWXl5dk5zcWJVZHpSZUF5SEYzczZ2VjRBRXJncDBWMEdLYkg4UmxVNEcyTTA0YkQ2T2hFYUFGZzM4dnhkdDk0SEFhQ0VDZUtobGlvOFZpUUU3elhDNzN3TkVtQWd2L0ZCNGYyWEFiOGFxSWZFL2pVQmh2ZGhMVEZGK1ppeDArQ1dEWXlFRkVXeU9jQXBNTXJWMGF0RmFnbUh1WDlqV3BJVVU4b2cwdDYyaFVBajAwMG41M2Fnd3dZVllSWnkxOVFXOXROQzJNQ2w0S0gzQytxbU1seUR6UkhXSkZ5b1NGN0J3R1BtSkhaKzAyU3JYaGVWcUJ3ZlpVUWxrcmRoZnBVRHRtUTZhOGtKUENoYyttSC9lNW9IajlLM2xHWUtHZFlBQ3hXUVB3QmJEVjF6WDRBbVRHdlFZdTdDeGtTNmVWUmg5R1pBODlBOVVRcFBCZ2VSUWhzTURwZ2ZNZEs0RmtYbHB0WE9NOStFRjF3OXFrN0kxV2kvdVlJOWdEcityeXF4RXR3TWFFUWk1OWx1M0dNMU1pM0JIUTFybVZqSzhtR1Nld0hJN1dKZzR3dmV4RCtIRlFtWHUyZURhOHV1SkhlcVZzSVNQd3o1cW5abDFPdzh4bG5sNWhxQVI4Q0NJRFh6Lzc3dWhvNFBnMG1mUi9mZ3lRZUprY3Y5cWxqWHlJYlUzRVRTQmp6eHZJelEzSmJVK0tLMW5hcnYyV3lXOUYwT0gzOE9WNTZnbitvLzBkV25ZRzJaOGx6d1VDQ3ZUTEJraTNrcG1SZjR3WnE5WGhGcng4U1VIcndvRk93M1NxeWk4NWd6ZDlkS1NFdnhMaFQ0cUFEdnlrSXd0QVN3SFp1Q0xma2lsZElIRlNNK21sSUlUb0tmSG42cTF2dlpSZTNYRFI2TkRDNHVrcnFoYmt5ZkNYSVNDY29rT3Q0dEVSd2hOYjYwcVo0RFdVbXpLM1NZOVF5WVFPN0hWZzFKRnFuZFlSOVZNN0hJN1NBSHY0VXNQSVp4emtLV0pOQXMyWmorR1dTUW1BMWk5RWhERGZaMXlDQ3NydCtxRFd3NUNmWHlJY2wza0NzSDhDN29rRnpIalk1MHFLdk5BclQ0OGlCbjRwWmlrc013enVxNHM1dWdPamxQK2lKQ29EeHRFUjdwaUJ3UnVnT0ZSR1cxc01TSzIzT1oxdVMvRmI4bTNiSDFrSmpYZHVtZU9ITHZlU01MZTNwVk9wZCtEY1EzOGQ4TEFFZWtsazAyemVqRjNMZk93cjQ5UG1FT1RFWW12UDJZc1lOYjdkQ29xT2E4MVp4OU1hWTJzY3dzNjBMeE9VcGJ2amh6VWFTaUEwemsvSCtGRW1IMVZ4NE9OcHF0Q1cxVU1TUXQweC9aNkRpY1p4VHBWcmZSSlZ2SmNWMTduVm9Rd1cwZDVyS28wTHZNTktBSHZUTXpmSVp4cHhPRmg3YWFCUWkxYy9oa0xoMElPemduRUxzZW5ZZEFUN0ZJb3JKcEMzZFhVNmUzV3lrSEdBejNFTGpieUlrU243b1JsMFRKZFNrMDVUSXFJajU0bGUvNGkvMzJmOXY2K0ZuZ3BqTWVuanJoenRYOHZFOTVWMTZOQ2swaUFnQUJCUDc3QXBUYnN0Ym94ejNYcVJQUFQ3VDhCOXhrdnlLckxiU1pNVUE2cDRZb3VPNFR5QmpTMVpNQTJoNUxLOG5ESGRUM2hvOUVGNWxQbm5SQ3F6K0huZ1UzanV0ejlFaDlvcVJEUzJhclhOMUVFVlV0SDhHZzUycC9FTzVYcEwxYndYYlh3K1lLb0NmTEFnb2d2M25sWHZybUJORTdKaTRTV2xyUnpDb2w5K3djVWkyZ2xQZ2RBOEsyQXBNZFFOYU1FUEUyeTI0anhEai80WXdOKzZBTG9NblBjUVBIUWZiL0k2dStXenIraS9OanlvL3ViN1U3MEZDM2lOSXYxY1Z3b2g0Qm9vbVo0cDJhcWwyLzdpTjE4S3dubUxGZ1dreFcrM2NMeStCNVBhZDR0VS84M3NzTHQ5cG4xRzZJc0xQejZLeXRTVmFxVnBjWTFPZWVCdndjTmptL2VDQWlNT2VRdE9zcTR5MjZPWi9nOE9Qcm52RElOOG9lbkt3Yy95NWduVDNqZjVBaTB3dkdhNGtKZ1VwbmpydGJoZG5qYmtBSUg4K1lDMGdWdU80OUZ4OERRTmxmdmxKNUphNFNGTGMxRVpWMzM4MTdXVytucUxxdm5pUVI4citVZTN6MEw5THRKblY0bVdTUm1MN2hsWmhEODYvd0xxTlFIc0lMaWtMMnBzTkNESzBreWtoODhRVVMweUhVRVliUkpIci9GNll5SWdibk5qMjI1RkhBMk0wS0JrdEhVZXd3bVVGalcwbEUyL1JwWFNLUzJpMEhvS2RWZzFFZmpTbldYcGg0QXZIT0Eva3BRejNqQytwL1lRN01QSGEwWjdnS2x2YUZJN0NVL2hsaTZTRlQ2ZXIrd2VoNWY4bDNJb2ltR2lVS0JHVE9ucW1lancvRFlZajhzN292ei9ZZ3RtUTQ4Z2dReGZ4Ym1pQVg4Y0s1cm4wK0dYanZCQjJmZkJVQXpTN09vN3YzZTRUN01jL1FEVXZHeldjMm10cFR5ZUc5dXAwNWM3elY5aTI2TUMyMDl1RHZLOWJaVnprN2VZT201RnNTTnRPWlVWTUZuR1doa1ZSQTBTV09rNUlObnhMaVMzRGpnKytTL3dvL3p2YW0rb0J1cGo3cTNVSTNLOWxrNStLcDFJWGNuRnY0UTNmQlg4VWFkSEp1Qmw3eGYrUUM4ZkdQeldOMVRxKzcxdkVUZEJRWDBoeHdQeFRtVThlZWU3T0pzaFJYTDB1M2paRVlpUUJRR3IrUCtGTVcyc0c1RlZhV3RDMjZ2bytOTWxBZUhsTEVUWjZQc28yeTJEcng5RDNaYTNZcnpRcG9CMUdESjJEWWkxckp3N2N6UThKTWFiYWF4dGlvaHhSbWNIZ0tIUm9Wc3lFSWVLV0YvYTdkRTREU2R4cVV0S090N2pKQkJDQi90Q25IMEwveE9rRlNsTnZoUG9IU3didHZBR1ptRjJuSitxNDJqbmprN3NaVk14SFQ3T245bmp5cEFiYnZtRXFRR0FjVE9KU0tsYjVtQUFTZ3RZQkNSaHJUbm9FSWhVK1RPUzdWbTFwN1laZXZBZDhwWHNsZ05aSnptL1g4Z2gwWDg3RUhiWXIzSnZXVERJWWJjZStXQlZkWjd1THI3REpLZzlHZFl0R1hSTG4xT0dPNEY5am5uUTlXZHg1V1ZHMGlZV1dNVmVsUWlaWTFtRFNEaVYyZ3lyVVdIOUNjR3VmQ1g5ejdkYVVIenNCaTJzeEpSNlRZYTBqQTFsM3JTMDBsMHpabGVnaHlrRGE4MlYrZ0E2MFNKN3hWblJYQVlPK2p4SE9tQzRIdmhxQjFtMlVDQUFFRS92c0U5bEFmKzIvaTdrbXdYQ0w3cUs5WmliL1BVRHNybUwxWWo4YmtENWhOdmtTTk41eVZ2WkdnajRHTjlrTUF1ajFsZmFiYlRrVjhDbkUyZ1ZaVWljWWtPdmorZE14SVgzUlZJNmh1TE5TKzlHNmsrMTBxNWYrN2tQYTJ1TGFmV0MrZG5DdFlwQXh5SjFBMlZsVENVT0R6anVKUUZHR2Fpek4zdzZuZSszVHphY3VkbmwxLzIydWdCZ2l2TzFEZ1pkOEhwWjZqK2pmVzhzQnY4L2NUNmVxd0JOSml1eDZScUVDYTZ5WVAwZ3BGRm9rbXRSeWdteTVSSUE3TTgrdGhwZnlRbzExcjg1SjN5QktvSkFkMDlOdVA1OG1WRWllOGMycEltTVBFR0Z4Qk5GRkZ1V1A3azRJNzJhZUJ2MkZZQmMvZGZBYWdZaGhwd0JkZitQUnZScVNBQjVJL214eWNjMURvMDNwSDUrdFNoZm8rWFdNanhFTFZOdjY3V2N1c3hLcFgxNnVHbmk3VTAzN0NKWVA4bU1jWWVKRjZvUktpcnppb0lTeXN4UUFJbE95MXFSeGxtcHZNUWRBdjc4QUtZeGZuaXFSaDlDamc4T1lPaDFVNHFzZXphdEdoTVo2b3JRR2NPTjF4YVlkZFdjUUcySzVyczRsajYzZy9oSEtNczJ2bGhqY1ZEb1FURXpWWUtZSDE2cWhURTNOUWFLbTQ4ZHVsQklTWmRISFc2TFN3dEdaUngyM3AxamFKTjVyMTRZbDh4TTBGY3NTOUtodHBZUlM4enRYcDgvNE5hY3VrMExUYUN3dlNkVEVFSzVKZ1Yrc0lZa0x5d3lwOWdmckhHWmZia0tRVjV2NHNSWkp0YzdEUWZ1L1hOQlEvd2xKRUU5V3l0TzM0ZHFDeEY1b1JPdWpVNk5wOXNGRTZmU24yeDhBS0xxYWl3UUZCL3ROUlNEWVV4cG55WXRuNUtpdXBrU0MrNklwM0syOW8yUk41aVc2cjRQanRoZVB0Vlh1UWpsZStLNERmeG9ydERIZzBYekFzaDBzUVlJSmptVjhpbC9WS2pWMTFZUEg2SHY4dXJCcFUyempDMUkrcUNuRkVWVE1xa0hqdi84Ynp5c0hDVUszbDhZRnVWZGltbTUyYUVVc3gxR3NiNWJXeGM3R21TazZvRHZwNVpIVXFnd3FtdzN6SXBGdC8wa29ZOVBZemJjQjBSWkFoODhHMkxJUm4vV1FOTkZ3a1hWWlJJQzBucFFvWEs4UkUxVXhSbTdrbHlVTGdJaHdLenZYMndkaEhrZ0dQZnNxaU1qL3k0UWNQZy84OEhZTTJjdGNrT05kSnJHSS8vdUJYbSsrS3BtOGtIelpBeVc1dG40OFlTT2N6ZHV6SE84L09aUkRsNmpzNkV4S3VTSVR3VEg0R0VvdldCNmxTZCtPeDdKMkdIelhKQloxYWE5YUVOai9kTUtVbEtoMHBYdWsvQStTZ2Fya1EvUkpvOWI3ZzQxL2c4RFlWelJ4cElPS0dWbjcvOElSMS8rQS9id1A2Q0tGeFNnWHhBZWRGUzBPVDVaNWc4Y1ErMVF4S1g1aTF5T3FyWWhQcEZvZHVUVDRHVFltUDM0UjgrNmVEQ3dVaDRTKzg5Mmp2WXc3VERVWGZvUjBuNmR5bWd1STE5dHpXQnpMZXRXT1NOc2c3OWNwSHZDa3YxYUdnYzFYZ04rS0VuTHYvQ2xYSUlDaGVteWVzTjlEekJLbG1OeEt3S284T2lyYWZpV3c5eWZuS0l6RjBEUytrQjBqdkVjdENGU2JDS2l5bWY4eHRIRGh4bmZ0YjJRSUFBUVQrK3dQbC9BYVJnczRNN0N5TzdBVHlXU3B3elV4WjcrdDlwemhkaERZcTZXQXR4Z2VVN1JHTnVIZTFFb1BocHR3N3RsQUlEeTArNERjbWIxTFFLNU5UVW16MGFRcGpYNjc5MDZWRzl3M3JBeEtqeC9qUTFxYUdqYVdFSHpkcWhQcDVET25KN21qRExPR1AxSUJIcnRDSEtaOHhjSUpPOXBMVDBocVNaQTdRdnhrM29odVlBbHJPcFp5alEwTnRFOHVVZHFDOGQrNElpME1BNWExOERtNHRoSlF0WVFnTXVKRHcvUjhXVlFxUGR5T2s5R0YrcmhwZjRCTitWUlVzQ2xjWDVhbTBCeC9sZ2RGakZ1Sk9iRmJSaFlCYnVmanNEd2VVTWtmdzAwUGpOUjBzN1ZvcWJsTHdYN1YrUS9ZdzJlRksvc2NDSWhZS3RJSUZPemFmUlJRQU95MGVHQzF6WG9OZ3QyVHZYQTM4M0RzdnJRS2dvL216ZE5Qb0VNZkdmNE1WVUVOTXZmSXVKaWcza0VmUld2SllQV0R0QjIrMUtCVmI1WkRrVW5wbUhHdTlIb2dsbXNBSTRxZHg1NWVoVDlLQzQ0c296T3p0OFdTcjlqME85aTlzaHE4T21OOFVGMUIrd21GTW1PU0grb1ZVK2xDS0hiQVdiaUo4TWxSYXFuUXJla1NwNlhSdUFwbmZMay90MytrZHVUWnJrNTg2SC8rWlZBWXB6ZksyWGQzOExpWHNhZUZrU1AvNGFIajM0Q2I4VHVBcVV3d2hFY1gxNlRIVm4rMlM2bGlWcHpRWFVRa2MwcDY5RE1vQ0VVRlNZQVNJOTZoYmZUQVIxLzF6NXVxbjZGL21nQ1FsN3hvKzlES2Nhc3FIQUp3UDFsajJyRk1sakc1dEtPcmFITGlRWUtLYzUrTFc4cmVvZk5oeDZvOEMzZE9Yd3REeE83Y3NBNEZGNWllSjl2SDhNWksvWEZINnVOR3hPNDhnc3R6UzAyRWhJaDBVbDU1Tk1PSnVnWDhlaS9WcEZHSlVWUnlwSXc5VE1nYmptKzNJcFdQUjFOUTM2cU92ZzhmQWkrNHNRZHFEYmZDVGhuOGlIRTJsSlFyMkJ2WUowUEZFR3doMW9xNjBuOGRRTFZEV3FuYjVKRHVWQXZwR3lYK0NjTUlUV2cwWUl6YjNZclA4bkpvb25Gek1keVJBMlBuWjlkK2FJa3JOWThjSzZoQ1J6RjRjT1FNY20vbEliY1BEM3M1VXg0ei9YNjdqMWR5ZzBjc2IwT3ZUQlZuVkJWdTNFY3pXTDRlb0lqZVhPTjZibmIxSDN4Q2svQUJYMG81aXpMQS9OZ0wyNFlFN0FYMzA0ZzdiRTVDSHVzSmtJRXhFYWtWMVdxcWdsUlcwdnNCVklvYUovVml5OFc1WDJqakpvWnB1RjhsQllsUlFWMTU1bXNzdysxYkxvekpNUWxzOHpKL2NSbGlCb1ZmUEFCY0sySXRmVDhUOU1XZVBjQUVIWk9lOHBETVQrU0lJRHA5M2pRSEtDcnErNXUrNmUweFROV1VUMFNGSDVFS3hXd3piNGY1cEJ1dzdpOXVtbmNPVndmWklCNmRBOERKQTR3V1YrRVp2UUc5aHViVjBlaWp5WWY1TlNla04wYlZCSUJGVURhRTcxWmlxd1pOZDV6RFNCWXF3YmZCditJampROWZnWFlmd1prNnpFdHp6U1Y5VkhkMFQ1eUljQTl2RmJEM2J0dlcyRC9DSmU4NlZMT2hvTjdiT1FGa2xOK0I4YkdBbjFLOWhsTEt6dERZZkhLcFo5OW5ZT3VLWmVvL3N1cllHQWdBQkJQNzdBN1d5NXZoOTlRTXVsUFVrREhabGdGLzVJV2FNcGRzMVI2em9FeC9KN0hDWGM0cTV0THExRGt0R0V0STZRWTJ2NDhEazdLNXlQemNGc2l2Ujg5eGduUWY1aERUbzYzY211Ync3UG9KODUvcXgxU3FGc2ZnSmtEcUtCK2tCdGxyaVNnS2RQSkZaOFQ2MVVVdmhOb1grZGFGclpiaVc4R2QrOHN6eVVBSEZFY0RoUThVVlluNEFlU0tsN1JKc0loUTBaOFB0ODdBNHJDOGpHTUtUczhqakYwZlJ3dkpmOS9nSFphM1c5bjlEcHRDM0YvckQxNmhGblJTNE8wdFVReGpYUi9HS1hWdnRUQVAwQjNPYkRsaTFodFAyNzJrRDVNVnZUeC9QS0hrQldud0c3MWgvZkptWVFjbjZxcnVtSytINVAxbDZZU0loa1NwNVNqOUxRSXlMdW8rYUM4di9oMmlUaU5tbDBKRGJhWTRieERuKzBGSnkyK0lIUzlURTJhVFRxODZuNWcyUVpGT21Fbk1uUE9xM0xlazZxN2dBNGVKUG5sK2tnRXY2Q0lQQVlqM3didU5nNGhzMjV3Ly9LV29Wd1E1M0c5QzVrSFQ2VVQzZVZsbThUeC92L0ZRNEpPajdncVR3T1huMCtvZVNoSUlKVGhuTHpJS0wvTFlJTXcxcG9za2h2NlViQWpyU2I1eDVBekkyck5YWVlHR1Avc1d6YThTek9uNlFEQ0tvODJYQnFCbDZPKzRwejJ5VXdHODVER1dwT1hpRG52RFlkeXROVXhDNnNucTRrMXVWWTVBMlBCdkFMb09RWm8vUklreEY2WWZadGM5am1ENU9BUVUxaEdTd1h4WFA4VDBmSUI3N1BLM1NUWHIvb3pJTnJQM010MldiaE00MWxQYUtraXFrV2tQZlMyd3FxMExHeWcvbFZldFBVZ3NvU2JjTmdYWmg3YjRBeFVsQUE4bmxXeGdVejhKRlRSdFRlK3VjNnl0TGtnTHhRdXR3U3ZCTXdZZlhGYjlYRFBVcVdseXhuQ1VkQldiZjllY0ljZU8rVmlyeUFqUlpVd1VudFBiYUJvMDVHOTlhNXhHbW5OTFI4MDR4U2t3VnZEcm1yUlVMTURmbFUzWXFiWjBKMk5ITjlPcC93VjBWK1V1Y0IycE82b0UzcUI3V3FYZUxMMVQvVVA4MWkrcnFQbnBFMmtwVDFHcW50Y3k3NGxveDluL2hRZitkU3czdk02VC9EbE9DRFlneDhzYU9DemFPdVhUZU9LcTN0Y3pEMEJDZ2d5VlJYL0QxODFpWjlORVJYNnlVMkRISHRWWHE4Vi9tZDFKSTljOElzdkg4RjRyNS9icFpNZkdINlpyTk5XTkxsbWl4Snh3Q1J2bFo3bmszL1MvcGh3ZXh4TUJud0l3SkRFUmgyN0tlZ3VKVjVVWFFDZm12RzU5VE9Wc2VsYmRaY1NuNVVoSkViYnRUNWZCQnpCaWhnSUVwS1BRdVdLdDBkaUV6czhsVlVCV2owUXlZUVBSK01xbkdiOFJqQVBBUDlReTgxTjhKQUJmTlpuYnZGQWUwRmpRb3VVTkxkcjYydUtjUlU0M21MdnZaakxkRnVjWUFrSGp5TEdudWIrL2VSTEtWWVZVS0hiOEdkeEt5aTRZV2lDejlnNVdhOU1DTEkzWFN6R2dMZ1VwRm5XVE50a0QvK1ZyQktBajZTK0p1eHhTWVllK0ZoUG01UUo4aWN3M3FMN0oyek5STnNyTTVtSXpNQTBZd1FjWU5CZzBTckl4aitIYmNGMnlRMklSZVArcmhDSmt2cDhlRDFtQUNBQUVFL3ZzQW8yaFRMRkpJek4vT1NwbnI1TnFYdkN1YjN1eVRiRzFuYm1tc2JsMUpHZXJIaWZlTHpneUJ4TWorRlFaNGhOeUo5WkFTcDNuWnJFVXVhb2dwdHZYQXpVdlh2WGZRY3pjYzFyQU1pOUszcG9mblBBNW9veUxjMGFUUG1QZEhkMzhRclZVSHIydjNaMGRmNXhsSTQyZ05GN0JLaU5HUnRIemZ0R2JBTmVzdE1HZDBtejQ4VEw2aGkrd0h6Y3Vzc2JsdjJtanpBWW1LTTBta1NMNzIzYnQ0Wld4VHlmVEhEMUIvRFZRMnFORkl3NTd2VXg0bFFPazJuT2g2NkJuS1VNREJRZGFZallwQmdIaEJVcFlJUGo1YmM2RXNtd2VYN3l3MktUWmM5eGY3c1RXWElvUkVTNWV0U29oZ3ZISlUxWmU1dk5ma0M1RXMvS3B6TEtJYWt6UHNzbm9MY0p2ZWFLZEdlZnYrQWQ1SGkyeTEvdnljOThwdXB3U3BpRCtocTFod0xFNHNVcVkyMHhnSlhTTk8zVmdYektlWmNzQVpDbDVYcGUvNXVyK0FYaEx5THpiNUJQYWxoK2tZZmJqV25OZmJZVWd4U3ZFOU9rMWI0bWVvbmRJQnBFRDlrNFhKTkhjSENNUXZmZloycDdlUm5HSzM5dlVaeEpBckhadmR2NEpLVVhaNGg2Ry8vUkd2cDQ1WFJtZnVzQlNlM3VqNUMwMDlXcEc2TVYrOFJiWVdMeE1najl1aGgyS3lOODNlSFdZdE1NYTh2cWRRYkErSFNOQzV6Q1A4RGdwMWxmWVk0UDY4ZDZ2aXBCSUtXeHpyY3RWNkdzaHBTWTZaeG1ZNjVxdEZtanBCcTBMQkdRc0xEaXJvRlpoV0lJTlhrdnpHR213UXpPQnBIMDM0YVpGbU5UT013VWRIa3NrT25ENFN3WVNZTjk0ZFdnenRNenR4SHE5dytySlZzWEsxSzF5RGxpeS9TZnVNYnFYNEk1djFzV2Jrd2lOVit3d1RvWjluR2NRN2VrMVJLTjN3L3BFYjFwOGNDa0t6KzViL3YvMEI3T1NTZlAwK3d3TkYxc0FjU3BQT3lNczRHOTRQMGhXbEtkZGRPV3dtd2owaXlGdGNSNTRFczl5RnpNUi9XN3BSOEx0ZkJESGQwQXpOdml1RXg5NTNRRGVQQXFxRjUzck0zeVFUSENESGFHdUkwZEtmWGJBaVhTK1BkaTI2N1NhZ2JNNCtZbE9lbEJwZ2N6cnhtRGVrVEtLSk1GV1hpMGlpYkxCMEJtOTBMWExZaS95eUJ2ZzVCdTF6dkhVWWtQMHEvR0tLRkFQR2hzK1dVRWpybFo1SnlkMjVrSUVCUEZkdU1adllDN2xOaTZBcWdPTGt0ZXFoNGNTZGc0M3A5NzhpWHU5Lzk0dlZQS0JDL2gxZEFya0MvL1BlUVpyYWQ1dlU4R3M3YlE2MTIvRGxFY2pQV0VHb0E1SnZLcldOeVdDc1BReHFxUk0xUUc4ZW5KNnBBZ0Fodm92cmVKUVNDSEZpbGR4S2orcHNCNjc4SWNoY0ZaYnZ6TkpXQ1NlNjNGMTFVb2h1S1ljdnhOYVdaMFF1aWJMZERxN3VKMCtTSlZZaGNPMjErRDJCQzU3c3lDbjJtUEk4K2JSdnpWRndSOWxsZE1tbDBScG04OUhlaG9PeGJuRDUzNEMzaUdCd3phSnU2MzY1cG1EclFKV0RHWngzL0FDcmlyejBIN2sya1dQZFVOeWNxN3E2SThjZ1k4OVE3L3FYZ1dvQXNvWm1tVU9yQ1RKSXNMVDhTSnJMRWN4N1JnWGl1eG1pTFFJQUFRVCsrd0NYeGRkQU84L21BcWhyUVFVU2lMa0RJbVJsVnd1WXdpendGTitlU1BteTl4MnhQbEtTOTlDZzZkTWJ5R2Y1b2Y2ZEFNa0V5TjhpZUhDT001bmh1SGNlYVN4SXdBd2c3RzJieUpTbzdGbDM3T0hEVGRVckdEMlJYbnBlMmR4MGhBd3ptZHZhckFIaTJOWEdoRXZYQ0lLa3h6RWl2TjltWStQUUhUamRIc29xbFcza1h2TUJsYUt2QkpqSWw5TitLa0p3MEJyakRicFNVT2xxWlh4WWd6eHhiUlQxc2J4eWhhZUt2ZTBSK3NJOEU1bTZZWHBLdm92NnFCa1NoQlEwdXZrUTg0WUE0Sm5leFpIbmNMdndwVUNJYUQ3Q2JaY1hObkt3dWVVaTZIcHFKNVBKOUxUb2JjQkcvTkF1VDJ0alZSSWpOM0pabU0yK2R1WG9ER2k0OHJJWjg0WTVEQ28yV205SXhpSWFGRm4wV0lvVDhhRUpjN0hEVklCcGZDSjFpMDd0SWQzc0VWRzlDMzUrc2QxQktHeFRLRVVNWHBzcUpGNU53akxSMlVnanRUY1FEbjkvSG1ZQThWN3dsZ2VUU0xZVlpxaldHVE9wcjJ4Yzh1MXEwbzVrZndTU0ZZZ0FZemZqWlRFekZSUFZyY2Q2NDlyQXFIL2xZQ0ZVUFBQdWUzWUJxa21aTjZsWmFjdExGM3orNG41bVNQaEpaMTFUK1BsaUVhb2NzL0JpczZydUN4M0RNWkFTY1VCMjUwQ2U2QklnSjZVQjZkZGhoRnhYSk1ZcFR1YitaUG0yMTFHMWNKc3pOYXlDZWM2WWIrR0RxTkdLQnUxM2UyVjNqS1QxaEozNTl6ak5XYVFUeGJ2NldCYzZSOS8vV0xjM1p3SUU1aDZNS1QrNWtGc0JUYnlWVmd2STRhWDNObWYway9KQ0xnQm5EWDNzN2RxRC9iQlRXUHh6R1VLNU9FVTcvUWorNGwvaEJIMjVlL3B4cHl5M0VsZHVaWk8yU2JUUSsxWVRCZW0yVTlXOWxWbjA1T2IwMVBxSGNIQmRJVTB6eTIwV2xTMW9LUkN4MHMwYThIU2s5N1liL3RPN3dQOFhkcEMzb1EwM3BKd0JCRjZRdUFZblZMelVIMytxRXpVZzdJaUVObEhGNXRaYStXc3ptRDZJd2RjQmNyMm85ZDRic01PT1lHbm55V3AzNFVTcjN5RURrR2VHUE44azBpcHQ3S3Vib0FFbjJKMjBXK24yalZpN3JIRWxOZmUyTi92S2VHM2Q3dHpMTWc4dUo2eG9wTHBLM0lNeUtjN0RXMDlBbURNU0x5NngvSHZ3ZlN4emtVYTNidG82RmlGTUVTeGhMdFlObCt2UG9CVW1vWGxwVTNWbWJxM0RJRTJDVWVNZVRPeWhpNEl4WVFDaWx2eVJjd24zd0tuM2gyaEd4MmtIQ2N3a24zRkkvRUJVMXJTeFBSamhadkI4dDBkZlpkVnlRZmdIQkJyc3FWVDJsYTNveC80R3FhUDhkTVVlR21BVW5mTHJxV2ZwWTFRRGhaYjdPdVRTSWhkc2pDRW5NTkRkeWcxSG9WdTZ0UCtTQWNkUW5zZlVYYzE5dEgyVngyYWNQNFFTNVlMVFlUWlVZR0NwMnFNbDBiK1o3eFBEYnpNUlI1RlZnbjJWUXcvOTZKR085aStZdEZNTG1HNE9GYjIzS3dEbFVidjZBdjg5bmdSWnplbC9vK2gweVZpS0VZM0VKZUcydW51VUlMdWozRm95NTYvbXZRd1I5QVlteDFHQVBzM2FlejhiZUYvYkJFNjByQU9OSmhFYVRiQmJBZ0FCQlA3N0JFWjhqOUZmL093ekRlcG5Nay9HSDJ3R3o2MUlIVGMyTXVRbEp3cXRYUEQ0enFKVFJERStZTkZ5ZEJ3dXQxSGJsb0lCMUZzSzFtVHhJVUNORGNLVUpyTWg5di9WS2MwOW1Cb0hVWU9pbVk5QU12YlJuRVNVNnNGSXNxYjc1cDVWV2IxN3gxc0o4ZFpVTFFVcE53b1BkdGJETks0R0FsdzVRbEFSekE4WDRIbzlmd0NleGpIdjhIWWV6QkVkLzVrZGlsdUhDaEJkVEJnNThTMkNabzh5VWlyY003dkRmM1hXbjRVTDN1QVNEK0IvZEtPUm1oeXZ0cUVuaGFQN0dRcFcrWEtvU0VnVlZWQkY5NDRDUE9jd3RQcVA3a1J5dEFmNk96bjUrYWxoTHpMd09kbi9TdHRKazVjb3IxejhWSnZ5Sm5NbEdwZGpSU1JUKzRUQUpVTkZWUUM2MEFTdXo5bndPNUkycEtncGJ4K2tEMjFGbVo1aXBHa0dEK0lZQ3FGQW9lcEFpTzVGSFcwUFl5TFUrUGsvSnROLzhwY3FHbTh4M1dwMnJEOXMzWTJzT0dka2x3T2MwWk9QUnFBVVNNdjkzVWFMUHlIOGxnakNNMFErTUtFNnkwVW5IUVpDWEtNR2x1dVpQU0RJdmNUN0xtQ0J4ZUYzd0ZzanVwRkdQYVk5Zi9HZ1RmSEdJV3ZCeUpqQVB0MWNrckxBKzVHWXRjSkZpN1ExTEVaRjR0TTJJQzRRUVpwd0dFZ2FwOVFERTA1N0o1UE53OXdUbG9ZYzlhQlArY3VSY1BRSTErclhLK1gwM3MxQ3IxcHdmMFFvcFoySEZQYUU4Yy9uRHo3QW84d2ErSHhER0k2Y0VzTWFqZnJEa2orMG1ELzNEc2N5QXRNQkZMeml0VGJBMnErc0NhQ0lab2oxRUVnbHZBdEJwZWk0UUoyMG1JZVlrVHpEZWtNMTBpQldtNnBTWklRSGg4SkQxd3FYOEJJVmxuUW9rQTVhTy9EWkdKc2pOdXFtRmFOdTBHdDRGTEYrWTZjN0dQUGl2cG1CTEtpSW0xRTFsQTVHZmFSOXdiWkU2UUEvTnh1cUtsMW5KTHdyQksraFQraWR6d2xGSUkzNDEvK1NHWjRjeisxYWhpdGROK3NOTVVJc1lRbi9BSHlSUkFtMU5kcDZSdjBzbXRuUm5vNjhIeWlERzZhMmw1S0Y5dVNScDQ3VGJwTFh4T1ZqMldEVVNQNDVvWjRWZ2t4LzJxZmtMU2htYkVwR3VxT3BBK3pLb0dDUUxNb0o0UEdIeXp4MllQZy9UcUg2M0UwWFdXeTFPUklrOGlhOGJTbmx6RGEyTDZDcm9UOXVXd1lxNHdQaGVRd3BDUFJXa1pBdThlNXQ3OVN2MitVSjh5M0dJd1daVzUxMWpUa0tSVUc3WXRVaE14QWJyaXhlcGdlek1HYUJ1cUtGS0tEa0lsZUM4ZGtrcDR4eHZyTzdISTJ4US8rWGVJTDYvc2Jxa1ZIbDJFeTBWd3BFMmJsbjJKaFdidks4c0ttYS91UFh4SmVYZ3FwMEgvd0o5b0FBN1MvL29RTTdDbXp2cTB1ZGxEVlU1cUh2dm40Y0NsTURkeVNxbzBOVCs2emdZcDJvRmlicFduMkQwTExoZXozaXVBN3dRT2JuSDI1bHFHSEJpb0xhRmFuMlRreXJ6RTFDNURwSS85MVROcDFITStEblVIYmh3M2g0ZlRLWHZhMURnVDJIRkpXTy90OGI3cFhlWk9ybnd3TEJFRmIra3VBZHk5cFN5MitIY2l5c2FqbDgyUFJJRDA5YjFSdGJVa2RKVWtvQ0FBRUUvdnNCUlJ4RFV2d05NU3BicS9Nei8weHB3YjhST0NrVlZkMkt4bE4wdFVaVDFHaVhWZHBzK1ZwRlgxS3JLZGNrVEgzNWhjQllVbklvK3BWY3VScHM1a1g5K1hJa0ZQVmNoNzBGY3pTY3JLeEVBNVVTMTBHL0IwSEk1Q2s4bitVZlI5VGVJZ3ZXc0lHeEFDbjM0VGJOUzNqRTVBdG5WYzZzOHJIZUJDd1BSVW5VMk1SaldPdkxzZFpaMTJyWUFyN2RySWpqb3JlYVlLdGo3dWVYSStaaEZEMjJtNlNrTUJ1czRteE42R0F2WUpuQzdLdk8rSi9DLzduem9FWWxqQVBGM3Y0ZitxeW1NMUNXd3NqaWkyY2VOMU9VT0w3aGtZZTVEbmdXdkFYM3NHdDM0b2lVeVlxaGdNc2puc1ljUzQrc1pTVWFBekRFc0hCdzNYbzMwZUlLOEMzakdTemQ4TUJqUEVoVzFJZ0d5bE1yYW91L0lQYUV1anl5VDJGK1J5TXRDYThaV0toYVAxOFVsclJhajBRMHY2UnFkUzFrOHhrdlQwMU5LdW5zUkFiYUx2dFl0Vkpqb3E2MXQ5dndObGdLM1Uwc0VscHNCS2JIWmJTTGtJNjNJOFA1cEF1SHJPa2g4c2luOUJ4b2V3WWM3WElYOVh3RmRWbnV0SmVTYUl2emtKZmlaM1AraktIVTYyZ29QcXhaQ25FKzFlRVE5QVJCWWthb3hZWWFCRTdVYVg2QTB2ams0SU1EVFUraEI0RTNEaUd4ampidWtqU3BjUzNtd0RoYXBRVENEV3dSNHJ6VkpsNytESUthK05mbGZmSGxCazlsVXRTWU1YNHhOb3FRa2RSUkh3ZEtUTHJNeWljUEhkcjUzeDcvNGZkbXhjTlZuSjB2TFpRakFYMW1xL0orQUovMnI5Vlp4K1FVR2NCcmtQd0lvdHBmNzBXb24rc1JsRkluNjFuQUs2cjE0WGk2UXZuSEpaN0NINzJVVkFHRE9Bcmc0cjlMbWluR2Zoc0hPdy9xdzhHSGV1S3czRFhqcThDVlgwTTN2WmZqdlBpbktYcUxTTGNuWmRGZ00vcnlkbGJWRmI2VFZUaFNxRDNIaW1CS1RiRC96YUh3Sk9lRUtDbU44ZmdDTmlhV3diaXh4MDNyQkl1VGt1KytsVzByY2lpRTJmeEtwT1E2dThWekZjQ1Z3azVQbkdwSTh0QS9MNFFoVDRNZkRoZXJxSzAwc1dITnMrdzZTWlV6V3JweklWZ3JYWW9Pa3puTUhXb2FrMVEvVHRwUVNPeWlScmJZZk90QWM1eWxoMkNneWdHR3lEcEFGQi9EZVU0MmJBL3lkMmJGYzdEVVNvSFlpSDNhdEJCeUdzRGREWHk2ZmJ4RGJiZUhjcVNTSXByNUwrZ3U0YWhhTGtxcHBuS1JEQUNsblhGMlQwUStTTFZTUVltN0RTVU1DNEQ3U2prM2JMcmgwSjdSV0FWNksyNmIzNzRPWDJoMTh2SUdCZElYdXRrQUJpMzd3cHZvUW0ydXE5QnNaUmtWWlFpTmUwUTkvckozbVdGYldmdzM1WXlOWVFIWWVUemtkd01tNmR4V0dSK3EvZ0lPRVg2a28xdXNlV28xUENzT3JxVkJVc0NnM21aRGhCdGlOK0xZREd6N1ppZXA5SHZKYWJ3RldqaU9hdEl1RFNUUXJTTytSZjAreXprQUg0bmovWE9WVTk0QnBDeEpLeUZ1WGI1UUFmTTlsbzRrcnlaMGhmN1BqT21pL0hmMUZHb2o3dEo2MkNxRHdnWG10TE1mTWp6aHQxdU9TWk1BR2NUSGF2Ni9TZ0lBQVFUKyt3UEhudG0vUURURTc1YnFoclVPaUNvdTRRM0JWKzNIT1BhQkIzcXdsekJ2SVE1SmdwMmdVMGZURjg5dzl3NFE5Z1FzUW5keXNUMDdPQTlLTmhha0o0M1l5SnJxNmlRYWJPeHpwTlVFMGg1aU9TdXpXaWpjcHYxMVRoTkllWWxRQUMvSUR4UWxyOFFxZXhwMGM4bFcwR252UHEyTW9PVDhvWkNpZ2xhTUs5OWxzQ0JIaUxjNzh2a0Jkd1IvZS9DblozUFRnb2ovYmhxUzFXbyt5MHNURnFwMUpkWmltU1YrMXNLS0lCeWk4dzNySzR1VjJmL1NWeEppdjVlOXYxNXhyQ3lnMEljUDdmWjNGdGdpNGNhZC9JRFNQZXVlVEcvQVRYSk5lNUdvWW11eDhwRGI3dDZUZ2E5aG4zSlF0VHVudEVhR2V4M3dXbFNRd0NvUjBxSmdvcXMyTXU3OHI5amtuUkFweXNBeTVqcXJaVjlLZXNGR1JsaS9qN2ZXRjlPaUs1a3VCekxyVVJibzFkVmNMb25PSjhXSi9odGg0QXYrRlMvczhBK3FEalljRHFZVjV0dXlZYkVjejFQalF3SDFkdEtDM2RvNlJDQ2RXdlEzRjNXWWJwM2k2QkgrMTZ0WWRoa0FzcWc3Um9CM3ZZL0VzQmRQQldwSzJZQStHeE5ucUhraExoOGI1Wkh1T1h4M3U3WDJIOXRCMjg1RFdzdkNkL0EvWGFqemhlVmxmMXBmUFJuUGZhQmV4L3BDV3k3YVBKaWJPbVE4S0JYeTJ1OElTbWorRkR4S1hUdTZRamRPN0phNnRjeGg3WUt3Z0s3MXRxNXpGZ0ZMUWkrejVoeWdDaHhXNVZFUGZySGE4bGNVTHdTQ200TkNnY2RtU2NrUWYrMDEramlxcVNDdytZQzRSVmhWSjFYYlh2cjIvOXhiUEJsVFRiWHBZRTFZM3BBdUMxYlgxSDJjRDN1NE9ic1lJd1ZuMjZaVnVnSS9uU01pWHVJYUNkd2hKR20xNWVJeXlZZDJ4Qml0NVRwNGZBM3JvVklXVEhyQ2xOS3EzNlltMU11UlUwMGxRbjkyZjJuYm9lcWNkZXJrbm9SMW1ickZBMEhXQ1RvRWk3ck1OZlRzN05nODRmOXpTVWVTOEt3Vkk2YmJUbnlWUG1kMEprRnhMM1RqVUhrTGlLSXZnUWc2VW9BZzVFSURCZThNSWs3bnpaLzN2NFpXdXArTmpPNGJkN2ZKUVQyK3cvN0lDNGtZbUFzaWZXVlJ4TkNyOENCajdPdzA3N2JNaU54bEpDU3puODRWN3N3ek5tTjAyKzRZVWNxZkMxeTc4ckszN1JmT3dabDJIMGpmMFdjbXJpQURtWmtLN0pOU0c4M25Gcy9PSURkR284dUJXM1NnQkdEUnk4NWQ4cUVYbkl2VU9CbWNkQU84Tk1Pc2FWeVBGdUsyVS9na3lSb21mNWJuSUFjQTJINmtJMUlqZ1lKQytoOGhRU2NsNFp2d0szTVFFKzdETUZQWUNoRWlSczF0aWpGL0JUTWcySGpkVWlnZHhpTkRrOVRBOEl4OGtyOWhzbU9sSzFlM25ncm5FV0dXaStvRVRDZCtnTWxScHhnSDNna2gvRVREVkZhSkN3TkIxK0Z4OHhORFpOZXlzR3pyYnpETUY2eisxQkc1TEhOTXg0ZGt2UGxPTEJDY0g0d3A1Q1Y4bVRDbVh5bDVObHp0TUVCdVR4Z05JbjNxN2JTRTJ0TExuMnVCNUdLdFAySDZnRFhsSjFyazhlaUVBWEtXdDRFUVFGNjMrNHZ4aWV1dnR0TGk3UEo4bWQ5R0FnQUJCUDc3QWlIaXozNUcwUzRUMEo0NHZDeUV4OEczL1JLYUFaZXZhdzR3OVNMUHZocENiTkZ6V055aXRidVFrSytRQldWSkV6M2R6S045N2cvenBCb1pEWXI0Qkx6aVJaekNRWXl2WjFlVk5PK0FWc2R2NWkvTkdnY3NGeVFFQ01wT09QancrK1krN0NiZFFFdE1STUl5T3E0cHdweWtVdEdZTEkycjUwMnVERVRFUEpIdlh4VG40a1FmL1psUkJsRFgxdGhtTVNONVRNR3F3MDNvNnRybkFMSm4wZGcybUhKWDNWYmFFWkgxdEJOWEJRWkxuenU1NzJtblVnMUpmNHlTa2g4QmxSYTUxSFNwaDFXblpkVWVqckVod3A4YjdLOERvWWFlU0ZIdkcvZlZQZnV2RnlMaUNaeS83UGthLzZEKzNyTVdOUFZpdnZmQWFmamllRW9ENGFhakRwK200K1R3RGZyRllMS2NvcDFEcmFWOWRGVFB5d1pkOURqTm4yMlJSQXF6UUlqek0xd2tnQnhwSUZQSW1aQitieWhGRTRGY2ZDeTdFb0RpTXpNQkFLbkpwR1prRGNJd0lWQWoyZVJyTGhDNlNhaTNNbGxVL0lzenFkREV0YW0zWVRvSHk2dUNsN2d3VnFqTXdHazFJYnNtenNQYk1ESnFkK05Yb09Bc3RidFpwdk1OT0Z0VGJpRU9WM1VyN0FvSGcwNzFHWmR3WTRXNnAwaGhBWHF4MUVsSTJKa1U2NCtoeGZkR3JsRVk1N3h4YUFkQzVpdlE3ajlqZDB0c09lb0Zvbm93Nld4bzN5SDNCVVVpRTcvWVR0dDRsTEs0OEdZQTlGVnBkK0hsWkVKSXdFbWc3LzBlc212UnN1ZDJxc3lsVThkNmw2b0Z4Ni9iSFlKOGNaaHhNMEVDaHlyRGw0ZG5hVm5kZDdrd1hCQ0Q5Uks1VkNaRk9Rc3B1TS9hQ1Yza1IrMm9TQURxUFJtVTIzVUpoc0NNNFFuUHUrRHJGVkRHRFM1Uk9UZnhvYlJWOWhGeFBtajFPUDJDaGJCMFRnMVVFRWxmNnJyU1l4czM5U2dkcHUydVNSSVpHSkFxeE96TFF3QkpEdlhEczZOaXJQOWJpbWtuQ3kveE9FWDQxeTRsRzQ0bUM1QldQR0V1Z05TcStXcWNQbzg2K2gxM0FUTGgwalhKcytNRStVdjB6bTRiTWdNOW1EOFNoUzFoTXFnT2w4UUtqSXZRNXZEVEozdXZVaGkxTnlIcXVFaWUwVm03R2tZVWVrZ05qaXZiSkFHZ0lENDAwUXpTRkJrVEhETlRJYkRkZWRveVVsRlROazUzZHpNSEl2Z0s2VHlTY2EyUkNvaUZ0ZHVSVHljTHMxZVFOdTJsRlJWZk84OWxRWDVnYnNPRzU1NUJTZVVJWVRZalVBUllnTEdDeTBmMkh5bTdPbmNIM05rM3BrUWFxQjlQWXpWenFNU0ZuVmJCQ1ZtbmxydkwzajdDdVM1MzlwMGtrWnpkUm92NTl6ajdzUzVkT2VZUkFkckVSS2RlY2doalZhdGo1VlREQ3Zodllwd2d1dWFXeUdLTnVabnJNRUw5amp0MHEvMkZ1dS9nQWQra1dDUU1HR0k0RzhTTllDMkwvMGo3Q0h3bURoaDdyNzZzVWdPYkc5N3ZhVHNDeEVCVE5MWjkzR3E4cU0rYnJmeWF2RjJ2RUpkOFJ6ZkFlUitxWWx5SC84bmFkZ29YNkJqMTlEV2R1Wmo3MTJ1cnFGUWUrVit0UFFFTGZNeXQweEdDczNVamdOOGZyUXRHUVkxVDUrYlBENm1vajdMZTBIVUIzSjBDQUFFRS92c0Q2M3ZRSnNnaFlCcmhqSlBnejRrbnFHdTJ3SU5UQXFGRlZIL1d1eGFpSngwZUxqMDBFRzVkM1ZTZTZ5eDAwUnVpZUdFWFV2OG1YK0lYMlFJNUMraVdJb21NNFp2NWVxblhUcG5WV0ZPRWY5N0Fac0U2b2ZVSWVzRXMzRTcyaXV1bVkxY08xV0J1ZHlXYXEzbFlXYUJ0VitzUTMzRVcxM3oxYTZTaEhqTmlLMmtHQTJ1ZVNSQ2hkZlg1eXUwZlMyTjZrWnhIQ3BKTUdXT1N0cUlYYnhLWE5mM0lDRnRrU3lMOG9Yc2FvcE1FQVdWTzBzVE9YVndjdjJEOGZGbHpuTXMwRXhSQnZ3Z3ZDZTBtUEgwV3g0U1pnbm1FT0h4WGZuTkI3NWRBN0tXa21SbURETFQ4WXdQN3o2R2NkVk9xZHBpUEFqd2lJS1RjUGQ1SEdFS0VPMjNDZ0JVc3ZpZitrQ0JQUXFwZkhNQm5oUnl6ODNOTWY2NWU5elBGYzBtVmFtT0VZeG1KZXZZNFVYUDRhRHdSbTI4TXdhNFVPL3Y1KzRGWkdmZlRoNkNQRkdhRTB3eE5RVDhkNUZJWFJLOEU0em1oU0tVdHVnVjVYWjROZEFhWFZLUER6YTZjU0RVdzVqRzhhU0JZOU1DRnZpRTJLRWNWSmY2eHZMM2NjalNsaE9EQUovaVp2OStxdTBOMjJQL1FiRWdNdlU3d3JiUlpxNTlxSEhMNlZndnNadmFHZUllOEtUSmZRWDJ0OVYxbE1ZMlJEWHVxWkdLRVFleEZwZFVrb1UrSFFqSGM3d2hMN2MvaDExLytCait4UG56ZmNoUzNsNmFzWVpxbkhrNzkrNHMwOFliK0pUanNEQXlxUmV6ZEtWQVJWR0U2VnFwZWdPTFlqMFcvQWwrTUNNMXNQaTYzQkFNN1orWEl4dWd2cEFCTU00VHhQQ2lsejlQcDBUU2NXTUhVV1JiVWVGU29VRDkyMm9CSzJNVE5sTER4UlZtdzVwMlo0R2tQU29ackF3cS8raHR4d0FsL3FIRkkyWG50YXZxTUUxOFRNN2xReEo2ZVZPNFRqUEVPZFJOSVRKcld4OU9SSkkyT0xWSWgxWG9XaHd2T0phWnI0YUdodGpNUkxJVC9UOWhaOHRTTzMvdWJtbysvbXVWNjFmOGpKdndNczJNcHdIU0lUeG9HWGZ3a2RTenl5SkJOa3JZWXdPdlN6Y3BGbzZraElsSzkxcmdzS0NUNVJadHdTZW1ydkxZbEdRNlFFWjQzZHZveWVLUEFTVzV0ZDJtelA4c0t2Y09ZdG8xQjhKZXFmdzdNM1h6N0hFSjN3OTVwS2xOZ0NuK0hmMmdrb01EYXVLMGkrMElwR3VXMjhmTExNdElMeGRQNUVBUVl2TCsvbnNLeGJlbGVwSEdwKzhndWh3RGFpejRrbEdVTWV3RUg5WEkxQUlRWUltTmhtRnhHRHk3OW91THZlSHVFblJuTEdQeFpUbWEvbFBOSjNIZTFiM1JzMUt4anNYNnhtaDhWMkdHZUZSR1pCY1dXUmFQOEdlZDZ2amVqQis4cUkxRFlYYzBRQ0xzWHM3Y0RCcGpYU1c0eTh1NDBMK3pIQUpiN2hQUXpCSnhhRWFVU01TWkFBVVJxcVVUMTRpV05BcDhGU3FOQVc4NU40dk92NFpQVGpUaGJFa2dNUkxXL3NQcVljVDhMa2svSUNSeDV1eXpGNktwaW5pREVGQ0N3a0dCd0R5WDd0QmgybVYxWndXQjFrckFBVUxoVUExdzBWZ1dDd0QxdFdMenFKUk11Z3BhZHMrMHdrOURBOStIVjh3SUFBUVQrK3dCb2d3WGJHcDVHRjNyaE5CcGhWcUx0aEwwS2syMkVaM1pmc1d0dytraHFqUnFrTlpVTS9xVG4yeVJwMW4yaTB0bmNveHcxNzk0aUkrMGZPMzdaYU91Y1E1ajVmTEtsUTBTbDUxQVcxT3NvWmlhd1EvV0Z2aklWU3JQSC9CTWs3K29hOElCTkNuQjZBWm9yUlVWVTQzN1oyek1MQ0ZmMkxTT0YveHM5aDc0SFVlbVNLa3dUbWlNUHQ3SEhYbXRvNVJ2aEZxcFc2eXZBL1pjNzNEY2dRbjNzV05VUGl1bzdHaTVWNDNjVTN0SjVXOTEwWGF6clBYWkxHL2RwRUcvR1JuOFE4dERxWWNBOHJONGhkU0NxYjdIMzU4YW9ibzVsQ01tdjJsWVVEU2diQ3gyRDRKcmtQYm5XZHlvTnFMNHdEY2JrSG9UTmZzYmt0M09Yem9MbnErZWNVaWp5VE9nY29nNTk0Y01XY2w5eWhIbE1BZUVmbTdQMEZhSmRTRmFYYkhnOG11azZPS2pObllsY2hnaEtmc0FHQ3NSRUg5dHgvei92TFlxWnNQajJhM0ZQVFZEc0JsVm5jcjFBTGdUYkxmZnFCbXlSRFZuWHlFY0lUanRmbTIwZ3VScERjNmRrblFGSDY1dE1wazVEaFZJUFpQSWl0ZGx0T2dTRy9hNUdwUnlxWlJvOThHL25KejN5b25NTTFaWmpCVk03bzY5TWJiT3R0bDd2ZFgxZXNibmVFTTBEYkpoblZyZ0lnZDVHOFRpSkpLcUkrTCtKRlFxMlFGbEwweVp2OFkvdmZoZVFzcXF3Q0RFcTk3UnZVeW4rL01ya1g4bEdNNnZBVjI4OFh3WUZLeXFCdDRMbjE3enF2QkpHdWtqTHdsMGlWWmlxMnAxdG00THRmVStUK3VaODJUcE4xOHJqSlU1VmpVS3lxTS9GUzhkMDNkajF3bGNOeDVnMjhqbWFnblQ0U2ZTajNUYWM0c29QQnBSZ0RqNXRCV0NCa20xQlhBMzltZlQ3RzhJcnpLckFOdnpmWHRWYXVzUGs4bEowekVYSWJsZjJDSWROdkpkWC84aTI1SGhJQjNXOFhjak5zQ2h4S1RwMTFESHhiQS8yVnQ1ZVZrdWdUcUNZeE9IOWtod0tjK0xJd3V6MDUxYjFnV0JjN0Q4MWhNUSt0OC9hL2wzWVc0a1pMcDJMTThrU1N5bHVVaC9SaTFNbnpDNVN6cTRKdDZFZVQzZGJzNU5pVzZWSTh5ZWpWb0lkbEMvNVd5VmowK2JDUE8yQldTSEJ4L3JkL3dKbE1nTThlNmRxRGNUT0M4bStVbndQU3dSRXduaHhkb0tzbFpndkduNVFRRUdnQ2RCRTdNZUV2OUpOeDRFNDJYSHVMaXF2ZXFPTHp4TnBSOEhuWXhJTFlHV0FwN2JWamdVbzlWQXZsVnUrMElqQ1F6RnkwdlRENGg1cHVsdGdjeTYraGNMZ1ljVGpObDhMeitkdWRMNCtIUEpIT2tpNFpmSUxnaDN6RkQyZkRMcnJlUTZNdi9DamZ5Q3JTZEY3am1jRHlEbjdqbno2K3d6MEd4dExQaWZMWE0zTDM0VUZEd05MOGxmcXZ2eUoxSncxQ2Y2N3dVcWRvZDR2Y1N2K1dZem9HbjVacWJHeTJyUGh2WWE4RCtLN3AwOGdOeEVCamNBNm5XV3p2cjVmSXRtKzlPR0tkUjZuWndlZFpRNFREZUNVdDc0R2pWMDQ5dlc4eUZFTTVna0Q0M2ZRSkRkNUhMVWVBcnZ5UHpSUUk2eFh0NUhOd1IvZHpXcGZRUXRmczQ2VHF4L3VCUWE5QWdBQkJQNzdBUWE0ZE83MUR4cFVSbEVLTVFBMFQyV3EyMFN5OExNZlhaanlZZmYzODUyRHl4SGhZcEk0YXUwZTgzRk5Ybng0ajdRMGhJRXZ1UFVwNjJrczdqRzh4TWF2a2NPaW5lMzRic2ZPMDkvZWFkaEtUMHdIbzBUT0dCdEFmTHhQUjd2a1ZsaWRHTnc0QnBnSjlJbUFCVWpFTzJUR1VacUtoU2p3R2FjNVM5U1pjSXdoOVlLdmw5Mkhub2xiYTNSWFdkdUNacFFNRFB1b2dBcS9VemRxTXFEcytmMXduTGx5ejF3NXlSUllCR05SVTVJNE9DRUlRWnM3enRKMEpxQk5RcTNKT3pUMk5nTmU3MnR0cyt3VXlqcmYwcSswL21UZFZ6TVhtQmdwKzVNczNtUStIWjhJaXQyc3R4S2E1N1BOaituNGFkOHpEWTY4NlJmcDVrL2N5Mnp1UUF4VVhLNkVVTjZoQjMrSjRKS3lrdXZUWHRhdURUM3JrMklQVHlEOU1ZTVM0R09xUCtvTHFobG9jSkJIVFcwQUxNWDlEa1RKMkxVM29xWGZIaGcwWmNrT3IrNjIyMU16a1ZTZVh5Z2lCczRQYmN6UXhaYXNETmlrWU5seTl4UTJ4TlZRbVJkdlJFYktTQStRVlkzVjV0bzV5U25xU0c4Wi85Yng2Q2luOTRzc0JBWFpzb0ZHRGJHMTNYdFVRTG1tRDR0bmh5MVQxYzdIUS9NcmJWUFFmNVFMeFh2KzlHRGxPTVkwdHBQVW00M09mWmRwTEZPZkNHUFR6RDI1U0hyRWtTdkVxb0h4MUZIdDlGRFNXdjBkOGx6bHY0Ulc2S2xJS1ZiK3M3eVdia0loY2hpVzB5elZQR0ZZcjc4d2NzelhQVFNyU3BqdXQzcXZxQ2ZqREhPd3Z3UjQ3MDJqSnUvekl3ck5jR0lzdE9MOHdQaGtsZEZTVEhYb3FqMzdFRXhnZlp2em1pOEN4UmFrNTlrOHNjaGhSSmNHZzRwOVErTERBYWVwRUtxaHV3dEJYaklQeXMxelNnaE00ekM5TWY1UWdVT3o1K2NJWW9EWkNQNEVwK0FVcnV3bDZrdHFkSlJoSVFOVHBZemxINHlYVngyN015bkQ3YWdFbTNjYWFBQ3dWYjRaYm15Ry8wWVcvQWhad0ZvSlpTbjVPVWVvZ0YxYVQvSkFGTVlTWHcyazNNTkV3Vm16MW43Zmh0emF0NDRCaVY4RThuaDRwUUEvUnhHMTFYNWlvMjRBTUVDVE93d2N0Vm5uMXowaE8vYmlUVzZvSk0yTFlRZjNWZ0xnN0VmVmZuNXI3YStuNzNWeVdhdm9sYklMMFpocVp5L1BIV0VkZVAwWEtzYmhLMXl2N0ZVVDNIM0RqVzRmblA2VnUyY3NUZjgrLzE4SGpxRHBKL1JaNUVQY0c4alBqU3oxSzhMOTAwcEl5cTJ2ZVpiK21laDFwaVFjYXpxcHQ2ejB4aHlGRGk4NE5WYmM0MTJ4L1lIbGltUFlJY2xNWEtzL1NxUnVWU29ZQTJBR2NjbmFLSHhYdVpCbWdiWFUyb0YxYlZmQ0ZGeTM2eEUyRTZVYmI4MDVRSnM0akVjb2VUczJNVi8wRk5jVDFrZ3N5RFZiNEt0SW1BWU1wTW9MalRDVVhqM1UxeWszVk43VkJTVzJWeFZJQWVIdDl0blpTYWM4OEFIbys2OG9sNnNEa09vNWoxWHJGb2llMkZlQ2NEYzdkNDRMZ2d4VmNWaERhWUVxaVJPeGlBN1d4SVJtanlDRmdjUjVzVk9IV1VhVGtCOEZBNXUrQmdWZEFsSjBxUERqU0RGZzVHY0NBQUVFL3ZzQXNPcC9ialJaL0dPd2JRTWJEQTJSUmVacUJvV1phd2c3N25pUFVCcUlSMit2Zjk0TUdaQzBwaTFVMjNLdFdFcHNtMGdBTlhVRWZuY0gyb2w1U2hWRWxSVUx0QjRvam1HTkZBSjdySGJ2cSs4d3ZQRG80QUJRUDA2MmgzbGxGbHFNdzV5MXNvMWlhU245bmhaZmhPQUhaRDFTSEwrZ0x6OG40dDJIc2JWNXRlQjE2Y2Y2V0tuVjNhMGpZOFRvSk1Wck5wd0ZkczBsa2NFMDZjVWpBU3FZV3RTeHNTajJrZW5NWFQyaWNjTlA5ODBrS2szN1BCTTkvYUJkVzdVVzZoREF5WXBMU3JoQ1BYSHVrcEduNm1Lekk2UTdvaGJsS3FBYTlyNGlGbVB1U2pOMk9FaHBaWDJtVys2SmpiaHhSZjkwczVmNXE4K1JRSXBKZ3RrMDdVZ1pIMXdndUtmSkhKM0NRRnRpVVNicjN2OU1xTkZjbSsrTlVOZm12T2xxYUVmKzVlQ2dXSkhnNUh4TTlKN2ZpdGdSQkl1Q0JOdERMZ1JwWjhxelRaVVpKWFFTNXIzSDNCZkM2ZCt6ODZQMVZPbTlZNWdFTUNWVDJJUGg4ak1MWlRpWkhHZU1TS2l0ZnZlU3MxZDhrQ0d4SzZqQW92THFEbG9mZmRjMXJBSkpVNEJlUVRyVi9DbXBGSjNRbS9OQ3hXSWs0MzAwa01mU3JkS0hveEtZeHNaRjZHbU1pVjRRNFhaK3pXOFg2V3pudEdBUlZCSzRiNkVQQXZlQlVlYitucWtsbm1rd3FKeW1saEhEckVvY0JrQnBRRms4Ym9MdENtdnhBTGJ2SEd2VWpnVDBmL1UwMUFvVjhXRHZkSmNTeDlVZURaL0VqSUc5cS9XY2FvUlg0Ly80Q0VWVlNwRUQ2ZlAvakNaS0NxTjFoRXBjei96YkhIRWMrOVFIak1TY3RwR2lqNTVmTzdnRTVvOWQ3bkV2K0tOc3IreXlmcmtobEpodW1qOTNTMUY2WFdHS0NZb3JscnorYWVYVDZaWXN1RHUxcmQyL3ZvWnpqNUtVaDk2R2dhMmFyMExCdDY4dkhya1grSnBtWTNoVHpralJHWEF1bjdkbTNFb0pXdkxNMkxtRFRjd0hxSHdkUDdHbXdGUmt6eWVuMHpJZElSdTFPNERsYUJqcTYrVmZLTWpibFNrbXR1WUQzc3BkcmRNWk5lY25wZ2dxR01Gb0IwdnBKbE5uSzllaENobi9vMVZsTzdCMGc1VWE5WmRCdlJpUnZCNGNpcHVEaHBpVll0bHlDTHUrR3NZdVVkaEcrcDhpNGcvSUhVZHJpUUg3aER2UnM0MHRaZVlmQlhtWXhMcnJ4NjNUT0tqaXFQKzJReWhlajErRGw4Ly9DbXFaZkd4VEZkVWZsc2VMZ3ZScXl2dWtUejc1VjZIK2tmUVpCVFlLOW5XSTE5SzRDQTcvVXNzWnpVT2lnQk9CSjNXMm4vUDg3cWZnajRtNkx4T09ueE0zWFAvbTFzQjdjNVROeVFwVC9tbTUyZ0pZaGJ1RjgyKysxY0JNaUR0a1RJWEwyTWEzODBQNDQxb2Z0bm5hL3JsRmZwc2hLL24zOXljb2ZsTG0yVEdOTFI2aWFSd28rSlNIN0tZUzRsdHZ0N1dya2N2d2NrTTE3ZjFpWXlId3hzdUtnc2pNNkpQS3VkZHdvSVl2RUM0VXZkY1BrbmZDUTlVeVhQZk5CSVZ0c0x6VEFlNW1ISGVPYUtMVlV4WGVFazNZcGFHckVyN3VIa2NBS2p1NEdFK00rN0MrdlNrSmpEY1NBT2xONEFJQUFRVCsrd1JEZU5uSDVKb3lIVGVoUTU4NGxkQVRrMUlMWWt3NUdFUDBkZldSbXZRN0c2aUFiOEJuVzQyUmYzdjVjUVhVcE0rdCtFWm9UYlhCb3pMdFFjeGFnU1hRRXZXdXlwRk9zVmxEU0QzbW5kYyswTHJ0M3N0Z1hKU2xNblc2L0d2QStSN0tHVXpuRGxzcDhmcUd5VkgyS1ZjbmFKMmxPY0JBNnNIYzRhaWxXUSs1T0dzSXB1RFdnMjh4L0xORWtSYWttb29SWjZyblUrWGpicldjSWZSb202T2hwZDlBTzZiVUhZYzEyQjZ5OXBZSVo2RGtZVzNpNkl4RjZFZVpTS1hTeHRRWW9RR2NSbW9IM29URFpkRUdsOURRQ0Q1K3p1Z0lIcVlRTkZIaDNaaWxNcnVoeUVBYlVrRmNKWlAwQXN0Syt1bTJhNmJQWWpWZ0VFb3AvaXlMVzRmNHZVR1UwMm9zM285aTBDcm1DOE5aU0VGbU1CaENtQW5sMG45SitNc3FGUWwvUE94ZHV6aTdEMDMrdDVyV2xRZnBSeTJRSmhGTjE0QUw3SWFIa0ZjOXNzN3B4aFVtWERTZlZNWUVmNUxvUEE1M0EwamlHVTVzVXZQOTkzRmV4N3h6U3k0K2dNNFEzSWVVL1RpdTRRSkRWUkFiWUdxSHNCZGdOT3g3bGZaUG04L3Q5SE5oTjJBMWR2UTVSQUV5WHh5dUtYUGlEenRVNGdZY0ovblJ2OStkTFRyd0RDbDZqQWx6clYyOHd5STQ3aStYYmEwKzB4bmdTM1p6SGg4MDk2dkkwVXNNdGJSQzBoS2JNckNaL01PRVUwUFZjbmdjU3VJZmg4a1pZbWJQUW9RUzBuc3NKaTVTRFJ4akY3V29wQ05DWGNNUzh3ZmMzYjQwQlhweHRKc1Byc2c5dGNrOC8yTU43ekNPMXRlQ3IvWFlrQVZEajhaMzFlRGsvMGlnWTBra08yVGNmd2xLQnRKQ0E2RWlONFVnUGV2MksycEhBd3hBU3VhVDVHMW8xLzNvYnB4TzU4VCs0OEZXTXVVSXVkL0dOOHB0bW1CWWtGT01nRDVwNUtMNTErOVlXNDJ1S0NFVkJBWHlRWGVFSkhPdS9SR3djUGNPSkxZUys3eElNYXBscDRhTXZNNTl2dDRXMHJUQ3d3bDNuT2YwMVVPLzlXTDBIY25XVC9Mc1AwKzliUmwrTHpRNjcrQWJ5bFJYUHcxSHR6WG5WWkRHU1h6TmdHeW05WVJpUlcvMzVGWGtWYjNBMTNPa253d01lZ1RhRlFWYU9paDJCckorTTEvSmU2azZnZnhZSWVhRmNoU2IvU1g3VHlJVi9Ta2pJMmtaUWlnbSsrTU93cTkxVjc3bTl2RFVCUndqYUp5a3l2ZTJiVGxoVXRwTVBBY29meU9WVW12N2FFTmFYSU85Zlh0NGxzRGErMi9TNmRuNGNrcFZaYmt6bkRTMlp4bml1UXBqYUJVL3Y1dEcvRFg1WkxNSm9NaUM4ckZhc0FZYXVKNU5zbkg3UUV4R0JwWWxrVllXYnc4UGxQV3llRWM2ZHFzNzNybEFRVGp3Mk1raXJBeURpNWlpZ0JNRTcxL3NpU2ExTThHc2ZtWkc3NU9ZVk9SYUEwZUtKZG95UUtiR1Jsek5Lcks5VXZsWmN3T09aNW1WZWxpeUtoaGU1T2s5SUZJZXB2elBvZjZpVEFheEN3QTdSQVp1T2diSzJ0R3BmN0ZPTXlpL0IvUGx1V09sOVJpNjRteW9VZUVxOExzb2N0YkprSUF6Vlp6VkdxdEljNnJTdkI5WFI3MHl4T3NPS2Q3TXlBRENBZ0FCQlA3N0FrcDVSbEpSZzRwc2RHcDhSOHJ1R1RITzYyZ0pXVEtvUmNwdXZOVndFVS81ODkvd01MQktSODE0elhZNlBRMEl3NmRKeU5CQ1dkbFlZRnU4TzUrMFNDTVF3NkgzN2dSVlNjaFN4M1l3cFI1MFRIVHJzRDVYaUVXdXYvY0IybzFZVmpSMzUrN1ozUGRPOWxlT1N0a2x0OWtZSnBRbXhjcVJpaGZzazRTb3h5SS9oTEpvSFpVUUpQSmRhZ1FweDlMSEZXdWV3dG5IR25EeW9rTVR2UU9ZMjZKWm4xT29ZM28xM1FPRWpXOHlzakRpS0NZTzJqbmEwY0Z4bFRMbHBEbGQ3NjZzeEhQRC9pMTZGTklJMTJ0Q1R2RHovQW9DdUxOejQxeERyTXNvT3E0aFJOa0Q3eWIwZ1g2amgzYTdzT3FGM2Z3TEt4VW1ydlozSVR5NzNvV053b0F3RCtvaXNUY1grajREKzZDcy9sWmk1WFZLdzBWZkhQQm9LamVZNnZFLy9ya3R1UUNVdlRWV1doQ3h3N2NESGVYRmdpd3BEdEk3d3B3TTE1QXArUFlJRkVXdHJROEdseGNVSXc5V3VPZCtCQmJsK3pKQm04Rm5iY2V4bk5XeFdEVTlRSG0vZFA3NmpScXJDRVBKV3BrQmFqWVJUWDREU29adnUrMGFTNHNGTW4xdGFpb3JPMnVsUWVMNVdGZkozZWQ3cjcyZS9ydlBoY3BWcUN6S3ZiYzR6eTFMZ3VDZERGaXErVWt1cGRZZlVNcGFDRVlkall1amxVaTAvLytSYzBYNHFpZVpBZXd1MjVnaE5RZWh6ekpCZkkvYlliNEQ5QVhDSk10bmYyYmRHTk9meGxwL1dZOEErZEtpQ2ZxTFRCYnZVcGY2MkNqdUI3em85S2pUZFozSnNzRmR4WVJDNjFCbEtIYVZjUHJZbVNjNGR0QVpBV0FTR3FhaUZpVFVtSXN4U1YyaDgvOUl3eGpKY29tTEJDbCtWUzF2KzZ2eS9WV0dWZkwzRWphOXlzOGY3S2I2ZU00c2dMQ2VHLzNNWUhqOUJnaHlCdzlYQk5VazZibi9mMUdHejgwZ04xZm04NFdjNGJjTTFmUkcra3hua0JyTUdyYjdaSmpWTmg4dGIzSWhQanN3M2JsYjlwejd6S0xYUG1FdkZxUHNlWXhNUlc2N2lGK0hvRHUwZ0I4bDFLamRobkpNNStnd1NvNmtWK1Nad3FNelNrMTcxMCs3M3JBc2FHZ3FKYWN2cWgvR25QYkpXMGZFSUxaOVVFM2JLTjhHU3B2TEFBY0d1YTNPV2M2R2ZjRTYxQ0kyWUFDWGpHdHJXU00yMmhVK3VLaFMrVW4wc1RuZnN6U2dMRjFrL28yMkN1emZWa0wwRHdaZDFLaVBqdlhYakRxczBUd1U0TDAyT1hiK1RWcTkzdUFrZ1pOYTVhM0FFRlF2aGNQMUNzNkpmNlN2L0d4TjhhWU9JOFNlSGkvQ2dJQ2U5dkZYNEoxaVlhR3plbXVtOVZQNHZnRElSM05ld2tUODRLaGFIb1JBTVVmVXkxTWdjbUpaQ2lIVkZ0cHZqY2JFOXhkenVNZ1V6UVJscUF4bW5WMitja3VYV1JGV2tPa0ZPM3duS0lsZVZsaTE3VWIrT1o5RG9JR0F5ZWZkdmtEbVlJSG5ScFpKNGpmeGFNZWhwL0xCZFBpNDEzc2ZwaW5PWVJ3MVBZUHJ1RkFaYUtrN0ZxbmRoT2luMVhWYy9vc2pFZk45UVBtY0lSNUdIZ2l6NVFMNmlrQndlSWE2dk5CWFowQjZ6WWtMR1VyTC8wMTc1L0N6WnVRQ0FBRUUvdnNEeWZOUGpWcFh6ZzVzbWlnSjVWUlNKRTNUS3RsWE9DMW5UK21vdHlJbFBjbEdYWCtkWEJETmJVcm0wcWgydTlNMDV3Y3BNd3g4RzNIZkU4R0hFcHErQ0FSellHVEpIZU03M2ljNHUyK2RjRURic1FDaUYybitkd2xUd3JlaUtlUVlJZmM4dUdYSTVCSzZ1Z3lYQ3NuNUtXM2xLeXFWUGlPVnAvaFcvZWwveXZxVVdSaW1neDR0T25mT0R2ekFUNjlYQ28zUVRkandyajVpZkwweTdyZVQ5QXUzNjVWbjUrMXFJcXl2L0dCN0E4SUxoRVg5V3FoRXJzVkdyZWZVZTM3dFhFSy81UHZrbC8wSHQrNS81MURtM3ZwWlhGcHgxK2N1TmhoWXo3NkI0QzRHSDFTNnpkVGdvbmRkNTdLWVNHOExzZjk2SXE4d0RrTi9zdnphWFVqc1Fva3VGRGd2YzhQWG5yS1NKY2lNL0N4Yk5pV2JVZHczZUh1SEgzdit2UjhBZmJnLzBWUUdTckc3UnZ3NEttUFc0YWY2UUJGNkFJbzNmdnoxdDFZSE02Q0VDYWVoeVNxZ1ZxRUVERFdxN3p3TmJHQW12NUJCRWYwa0FYb2FuSWNmL2kwQjgvZE1MVU5GKzVpcDAvbVc4NHhoRkpteVNNRHdNSnJWMHF2N2FuQ0gzWDhwV2lBVVBjcW0wdFcyWWtERzB4WW5mWFo4d3h3VlRCYXQxNm9XUE5NUzJMK2wwNkVOQzV1bWpWd016U0xXWDF6OVNMM0J3V010SkJCK0FHUVhYbEtWMVJ3bFpXb2xmN2Y1ZnU0RGhtVE9hMG9KQXlpUCt2TC83cHIvajgyM3dXWjVHVHdBSmhXcVA1MWIrRjNhWHdVbUxHc2VZc25DQkVSdGVaVmgwbWJIOCtnOW5Rb1pCcktSRHh2OURsd2ZyTkk5Rm1ibFV0VmlNM2FFS2x5cXFrdklLMmdMdVFjOUtEcW9yeXV4U2R6TGFORWlvTm1MM09jMVNpMDJIZE5yalZpYThpS1NGUUZHN1gxZzFndWN4Rk9IV2dub3UrS0RLY3VSSk5XcUJjSmpQM1A1Wm5heDFBazhkMW1lNW15QUg4QXlJR2p6QXI1b2hnSVB5VW55UjFMZ0J3ZmxrYVA5a2xpcHlFRFV0a1JJQmlieDlJek4zS1hVVUtJSW5mSHZtR3hoOUJRT1pIOHZWNG1ncCtveDBRQ25xbTJJOHZ2d0RTREhUT0JrTDNuVm1iZjRXcHIvWGxCclpjUmhIbW9vUk96d1NsK2l3WmpKZDNOSyswdm9Mb0w0WUFDcnlvSXcyQVJySFFLQ2xmbXhsZGNIUWlPbW1qVUl1SUtmSGd1cTdmdHhSY1hYZng0RkRPc3VXcm9SYnVtZjZYTDVDV0FrcnQ2dUVYa2g2cjZxcWRrRExVblNLNWVZL1F3cVFGSEhiZzNIRnZEZGFSL1BNN0hJVnlCK3Y0MHNwNFppenZ5V3ZkRDQyWXYrbG1SdG1BbGl5RWhmRGNoMVdDREtycGlxNzJ5QUNXbnkwY21ya0hBSE15NzRrRGZIaDQ0TXFDbk5ZN1FrOG1WbmZwWldrall3M3VwcXM2K2dUVGxoK3VWQ0d6eUNFU3pwQWh5UHV2eUZGMlhGc0V5S0lITTcxbVMvYzcrZjNmdjE0SmhXZGpHZVgzS29lYThMa25wU09wRiswTVF4OGJZTDEwZkZscmMyR2VoNzNBUE8vYjVvUG1nT1BVWmt2RFNZd0lNcDdSNm9wZWJRMWZsOUZxWUNzWlFza2tMTk9XcGJsemcxVVQraXVFeHcvQUlBQVFUKyt3UmlseWNCcXZSa3lZSHRNWFBGOWVsNENCZEh0ZjFtaG9qbUdlc000eHNMNzVJRjJtSlc0c2JzcW1FdjBRYnpWSzVqcTcrMnZSQlkvdktmakZhQUhtdkVQaUsvaWFCVm1GQUVETEZXSFlNU1VrZkttR1c5MEZBYUU2UnMzTU9lamlXWUVPZmFIM01FM1NrS2dmTTVEWWVrekF1SDI5TjZSM0pZcm1iWlRLRGxyUndubmFKK0ZjdGdPNlA5QTBEU0JuSjZvS21iYUpSSWIxZm9FNm5vcWNWdUg3VHBCd2FWNnlLaVhRdDRXVUNoNXZwYml6S0V5Qm5TWU1DUlZaZEx5ZVU3SFRJRGpZKytGNWxQTEhRWHF6RDRlemZpanNkenBRR0tFeG5zYjJiYlhKSkVjeVIzdm5SbENXb3pFTVZLUHIxSkZlTW9jQmplb05UTHZ3cHY3TVRsVjFqWEYwazcyQzZnV3NqUnBVcnRHOUljbUMxOWxMa2Rxc0xqQXRRZGtkWFJFRmhoVnU1YnJVTEM2d3oxKzRHVjA4bXJZUTA0TmEvQlR4Uyt0UWppb0FnMC9JOUFTSzA3WStvRmlGdml6aDJFb25vQlUrTlI0czRNRmwydDdnMDllY1VMQmFmVDFCNVRhNTIwWCtBRlBaYW1OaS9MM3N6M29Rdk4xQ0NJc3JQOTZLOStJMmdRVmovUG41RVVCc1ljRVRrTmVGWURYalBLcStVLzdtTk1EN2x5NHVONm5pUEkrY28yNDlFY0RUeE9uWGJqNTVCNXhEQVQvNGsvZ2NObUI3dHVKZmpqNVBIY041YTY2VHFmZlhINHBJZm1RT0ZmOGoxQkplTlpGeHdCRVJIVjRMMjl4YlRra3NyNjRpcTNnU1VyZXkxTXpOa05KaWQ0L0dSRW1GbDUrZWtmTXlKVnBLT0VIbEFMdGtLenB2KzhpanVtYSsycFRnWEMzOERVOE0vRndxai9wcVlVSWdEbnloSkJCYmZBdXUvbUJxaEhFdXcrbGdaanZwY1MyMTNxQ0NLaW1xdmZ2dDFLZzV4RFdrM3NOT0Z2WlZpcGRqT2JuajE1NEgxL0dnN3pQTG1zQUhGZVR1R0YwZitBWER4aS95SFRWWUxXc2VoemYwNldFeHU0bzFrNGIwaUVudllqMlE4UFlWYjh0Q21wenlBdGgyMzQ4bkVRYlB5M21wZ1hKVUtCcm5RUVBiNG9ySlJmTGhXNnVBckJjTVpBMW00NWdNOXREVmZHM21mSm1nZFQrZUdTVXFOdUV5TTlwdVhoclRnKzl1VHZNZFpDVitkNUdnSWluWTlKMzlNYVVaUkJRQkMva1YrenZXT1JqZE1OWVcvVVM1bmppeVQ2SnVNL2FQWmRwZzE0Zno0dVlaZzM0TmxwNTB2U3VKV21uTEZ2YUxCcFh4cEhFRnZhQmhCL2FlUVY4ZnVQZTJNaXRiQ2Rsc1pnaUFvbGhsK3dJYm5FcjhjZGU5S0pSUmEvcTArcFozQ2ordjl5b0YyQStQTlVDY0hrSkxDSVdTMnVRQkVqeW9vSUhwSFBLWnFTNzBpUld6bzg5S21ORW5acnQ4ZnAxRkVTbnlWOGIxcUVDUFV6bDlrSUVWOHpZazN5MjNCcW50MVI1bVFWaXlGWmVEbGtGYTVoRXk3U1pCcFh0SWFMZ0o1d0lBa2tJaW4xMFAveE5tTTVsSEhHWFlGNXdTVWdINHFiejhDVXBhNnBteS9rTkg0c09YOEcvZG9IMXVDcHlkbW1rQnJGK3dqOGkwZDkxNzdoQUcrZ3JZQ1RHOXpUZTRINU9MR1RDbE5FS0VoekFnQUJCUDc3QkhWTFRIdXNuay94WEQ0TUROeGZtclhENm9CaWJ1bmVoNzFOaUFiMWlkVGZYM3dBcHo0TEZ5RjRMeWozdmUrdERsRU5yOTlVSGVUcEZxWXg0b24ycHRhbU1yaTFXWklPeUZMMVJFY0ZLZi9WZ2FCMFZaVTN0WVRtdXhNSzNNaWhLRmFiS0t3azBIRUUzMmJLRXBzcVJRNXZ0anFKSEQyNStUUWpiblRQTDZJSDgrOVh5N1VWbk1KN0xOWi9LMjNuT0RpZHBWdHo5cFVmSUcvRjduMndxaUx0cUF0WjY3OFNVS0VyazczVmo2emt6SmoxdnB5TjRaeXl2WnVnT1lFSjl1SUF3VDNuZlhYYi8wVUxDbzgybmxaZmlmZ2t0dmlJZEhoSTYzUlpJNTF1cE5RbTlKR2t2RjJhNWZDN3QvWVZ1UDZmRVM4S25OUllEd3lTSjIwMk0xVEdVTkx6N2VMU0ZJNmE0RE42d3dmZTduU0RhUnlkaEYyZjI4cWdRQWpkT3k3Z285K1JwUWlqeXpkMzhqTnZLZmVrNmNDd2xOS1R1NXlSbmtCQTY2c1BhUXJtRnJvbUtCeTltMFZSWXc0Kzh6bGg5L3lobzBCcis1TEp5RzZvS3dmKzlHYVAyTWtIRWlTOHNtcUdtSW5FNUZ4aE5IZEZYbU1razM0N1Y2ZS92emhZMU0rVmZDR2dKQmpBd0l4ZndQVEpSdEtBY0pJRm03cWN6RkFrMDFWSCsrdHZoVHcrdW1NNHhIRFZzZjUvV1krczdhcHMxeWFHRWk1WDB6akNySU9zbVBzWUhwRjBvWmFpOXpnMElYS3NoZ0NhbEpHMXNCekNtdi9NRE5DMjc4a0tZUmVxaXI5aEJ5aDI4QjRPMGxXeXFydXpUZEVoTVNTb2RRRmhPTXR4K1ljN1djZ0dBSzRQc3o5ak5YaStoUGlNbVd1WGh1RVZ6WVNDRTBSWUlvSEU2akZUQkhOdWFIQzRrTnYvQkdHWi8zRmc2UGF3UTJabHg5ZnBXRGJITjZiMVE0bU94UDRGMzhTUUtyNXA0QlRDemt2cDNmNTJhZmVrUnJSNEM1L1MwekVlSy94Z0N1dUdZaHp5d1NwMWdUakhYNWU3a0lRVmtQNVZSU0J0NmJCbGZyTFhNaFJJd21GRTJ0VXF0Q3Y0WXFEY0YxVVIwT2hwNk54OUtsRWhmUWIyMHNCY0xwaWkzUUdyL3RoUlBqYk14cFh5NzlscUttS3BQU0JZNlBkM1NXL0syU2Q1VzI1dTRLM3QwK04yVlRtUStsZldLMVBmc29wQ0RONDBmREJ2aDlNUWtZS2xtV2NpQnZWempYSjFpL0dpSG1NdVlocmIyMXJDajQ5akN2aEUzRFA0a0hqdjJzYUJ5c3pDWXEyTThVeHVXOWptbTJPYS9Fc0kxQjBiSkxVNWM3K21UMDRXRGpGNTJYVmZnKzZtTlh3QnBMRi9ya3JQOURVekY4QzhSZGdoeXNFZUxIUm5ubVFzTkpZa3NsWjVJSnduTUFwWkt5bEViVXp2bTE0bFhVTE1JdlVLRnZVaXdjRkhWZ0hVZnBlaXJ6OEg0UlVQOS8rUEhWbzIxZGNpT0dOSkJHSTgvamRYUCsrRXBuTWtGamI1eVQxdGFvL3FTR0V6L2V6c082TE80UkFMNnN3Nk9oSWFTSnJ3a0g3UEVublczNm43ZDZheFhaMFRINnZKaVozZWF3S0VMRCtxTUJ3bEh4MVBYaVEvVmVTVGFzOFE0eEwyOVRQZ1FGK2Y4QU1WWlJ4NklPT0dVSDR0OE5WMWYrQS9iK1A2dktFNFNtZnhnK2NDQUFFRS92c0R1UXFDVkYzaERXbWU3T3VMKzZZRXc5TEJwa2d6cDZEd0lVRDZCZm40VW04Q2J4cTUzM1I1S1BGaEVVM2s2VkxSNGtIL0ViTU5kRHZobUs3QklWM3dNUHNGUXJCNDhFajRpZU5kMTJkZGhmQmVUb2dTcmZOQVgxY2RkaE1wSW1JRHBjWE1QY2EybzdZSDhEbDczNVZLNkFBM29NNlRXY0kzOFh6QVlHTFV6bUUvc3BLMDZCOFhxc0QzdWRodTRoTjZCT3hqdHFlbmxaZnBnaE1NNXl6UjdHRHl2eXEzemZ4WlhPdWFwNkJkZERhbzZmMHQ4QWYwN1l1TitIY1FFaXpocDl4ZXRyMEl3UzBYNFBNbVJsTHlLL2RUaFd3T2FZRmpQSzd0MDJWRzNBM2JBOStqV3ZpSzFyaUd2cVVSSDdscXgvcjZEQTdKYTJndkxQcVB3b0JwcmlHSGw1OG1jQUpPRlpJcjBrR1NPdzdYdjlrM3hSczJBdm5PNFp4UVExeHRsTXMvZHFtOERPN2FpeTRBY0sxNERzVXQxSlN4WWZZTWpaRFEvWXNXOVFxbmQ2ZWs3MkVlcmlKZjdSUDJWYm9za1ZmZDVhKzBHUjhPZ1MxalJPS2ViRzNSdElCcnViSHNZZ2NNTW1qd3RFTThOVG9zZmxwbGJxdndZTFVFUTVBdzhlRVIvdEFDc1JaQ3RMVUY3RGFOUmRJQU1DMENHRTF6ZElQK3Q3THZzQTJ1M0lNdmt3SlhvM3l6S2ROaEVFYkdEWU10VUtoTVkvS2FKb0kzeVVjYldubFk5MkJXQi9pMTloVS81WDdrQm5xSUhNcTl1b2pBbXM4SWZLZTQ1eVNoZnRLcjR6SW94T3hBOGZlcjh6M285aVJzc2EveG1LOFVnbERLd3J0TVArU1MraE5VSTFBc0hSNFduaUpxTWlKYW0zUXZlcmFwQkhTdkFpbmZCRTlWMzZnZDJUYTZrMjg2MC85aVZJNHBRZkppWGJMOHdpV2NhYWRrUFArUWFPejNLQ1poVG5rcXh3dzZFUUwxcnpIOW4wYVNHbGc0cCtnWExnbjAwZ2E5ZThwa0VTeFNDQVRqOXpKYjZEQWcxL0J6L09wcjZCRG0waVRCNzRnK2N6TGxhdFdIMzV5cjFqejI0bFBtaktOdFBlcnNIUDJRSUtLVTUvblduTGVDZkxGeEZvK3EzU2lYRWRDNE82QXMrWUVyNXF5Sk5QSGJNYnUvVjFHUXVLaXhISSsrc25yUzgyR3FJcDRVaVo0eU1KVnVwWDhvaTcxcG9HTFhWYUNwMncrdE10L2p1ZTBWcGV6Ujh0UUg2dHF2anNkVWl3TXM5TnFFYmFlVEJIL2NITzZseWdxeUJtNEp2UEdZR3lkMXhhNFhuN0pRY0ZCa3FtYjVnVHNaQWtGR05YOUVjTjBUdGcybUk4ajM5TFBlbkpNb0dWd3ZkN0JBcHZsdDlYQ2FHVXEwWXk0S2NCQnZ6RlFjdkFQZG16bEk0OE5pM3RSVTRZd0JYMFRqcE56eTBiVWIrZXN3QllUVjVWdCtFV0xXTklmNElrNlhoZDVabmNGSFloRFUvSGhYdW83RHpDVS9ld0tpNGJrN0xYM1I0bG5iVjVENHVzRmt1RXhNYWdaMWY2bzVsWDIwb2NEVUl0S0pNRmhsOGNOWFN6aEZvZHB1cGNuOVlnTlFTVjdUbW9jd0tsYk9vNGxNTUZ1WHpIN2N5bGlJb1N2UC94ZGcyTTFmQXNSV01VU1BnUUVzWkJDOFp6TWYrZVVJTVovempTTEsxcm80NW5tNkhFeHBOZEFUcVNGZjVBSUFBUVQrK3dOcVQxdXRBdStFQjFVV3FDaENReHAyYmJZanA1OVRBZVlkKzhXTUtrVzV4cXFRa1BKcGFWTnZ3ZDR3c2psaFd3b0x2OVozYWJKdWhpS0lkZjFabFgzMGNZdDJkUWJNSHd1ZlNyZWRoTTFwUUMzNUNNSE5DRWRMc201MUZIUmhBNFdIK1FkQXBpSUdEYkF2bVhiRjFLT3k4emt6akJjRDd6Q0p4dW9HQVJJTWpNTDQrTnhxYkVqWWJGNDg2b2NJK3k5K3gyaldLSWxKc1NaOXJnTmFsRElrOVhaZWdGYjVrbVpEcFh3MXZhemRFOTNKTUhBR2N6bTVwYm9HRHFCR3M5SU1RYVd2K2NDTzdFZHllemNsc2pEUkdkd1duVW41aGpUMjYyZ21mcnlzUHN0ODhmcE0xZEtGd2Zpc2tDK0tadW5OdGlMaThnTGFQSXhabWo1NlVTM2hCNFdBZGVCcjRMaTA4TlorcWN5T1VQL0ZXTUMyUTNrVlNuNGZlUVdsSVJLOElpNDBhY044OHhVNGNpKzRHSVdUVk1obUYrYlJPL0xiOTJNSGphMW05c2hEL3RDdUY5TER5S2pqblYyNGlVdERRNnpYVC9FNVhibnRRZ09LQjJ5YnRsaHlobXIyUm1sZTVCRnZiaDlJS0hnQkNIemM3MjUvQTVuaVFWUDY5THZDSzlENU5WbUlZZjhoelNvelNpRkxSNHl4dXBXYWU4dm5oN1NUczluMzBLUGI2bzRIeFBiK0pGSTAyME1IUjlSVzJSUFQ3TTZCNWpHUURWT29Fa2tuZmVxNkxZUTY5TGd1NFNGUGVsK2NnSjc2VW9OT1lrcndrT05wNHVrMkRBOGhLZGdWL0E1M0cvSzVpWFJwVWZEZXcxbmdUNVR2ZWxTUUpMcjcxYVRHT2NQMEw0ZHNoS2tKYnhucXpPaUw5TFk3TTRScDFNbEl2M0FidnpvNWJ3UjVlRExmckJMWXptR3YvdCt6OXNUaE9zK1FyaUxKOHpyQjh4a0pPL29wMTJ4RndBNDVZR1V1T2UyRGJQRHBkMU5OWnhDZXNwKzRrVnZJWTRjMld4dVRMdXFRRkk4Y0l0NUZTb2ZEdGJ0ajh6NWZBYlkxY21TYlgrelBvajBDSU5EN2dLMjZUVW4vdVRLSHJCbk10V1ZVaExzMW0vYjZrbzJrZUVON1M0d3FDVUtqeXBIbHBPdW1VdjhvUWJka2dmSmgxYjRJeFlaQTA4bHRXMkVVUDhMNFRXVlQyZXRtNnpaTDVBTDdRbUZ3aWZDeXdYZlhqcjlOREFzcS9GeDBuQU1kOW1hdTlTUUk0K04yVnJMeUFUUXFVNjhuQ2ZhOUJrbzVmOTlJNTFLbVJkSWE4MW94SVV4UHZFUG02eFZQTURQbG1YYWhiUUVKYzlIeTlNTi9iVjBHK2VXY3NtbzA2ZzgzQVI2SXFjaUx6MVFnVUpzMU1lbzJQcFJFVkVwSDFKNm5KTXdtNGo4eCtuK0NRWUNkcWcxVk01Ly8zRk1qRGJReGFjYXdDMVNPQkhUYk9MRzN2OHo0MEYrZ0ZDWElYd3IxbTFnVjlFa1JMNnorMkMzSHVGVzY4YnJtd1ZKcDlVWUloUEdGRjBiNW1ycU9NVGlIdUpvQk5mbExBMmhlSjV3Q1dQbk83c3Mzd2kramg5YXg1OEM3d05FSnhVUUsyM2llbXVKYTVkblFnZm1jRzhKVFNWdE1sWmRaclNrV1VrUkVwcnVTNVhKQnpSZzNnS1lwMWZTeVdKcDBrQ0htc3c1VmhCWE8wY2FZWFBSMk1sakdoc1FZQUxjUHpReHExTUVKQWdBQkJQNzdBeUNhaU9HZGw3QkNmaDBZdnNPbEpNZkxpSEFzakhSRFVJU3VJNVBtNlg0K3Y4WmlvNzJKS0pNangvODFKNVUrUFFZVk8zdi9xUnpXTzgvWlkwQmdLTEVsWU9EZVpEdUMycXM5MlhUUjVkaEVqaHFUK2NSRklEM294eVl4OFJLbHlPVTlETHJrSmZEbU54dkFHZzhVdnlvaUpDU2tqNUdYWFR3UGRVZ08vOVVjQVF0TnBvaERYY09GMHpwL3pkenYyQlZTMFdzNDRXQ0lWdFJRV21tT1hPcWxIRW80SDNGZUpSVC9SSThyNGlvQXhRc1BtOGNsUmRYbVMzSHBsaC9KeHhxK0ZycU9qTmFlRDRudlhGQ2lpUDlDVUtVTUVaVVQ1NlZ6WkcwMlE1Q0JZMlpaTHBKaFZKaWhEeUp4aHVQSHhYZTNLZWxhVDU2QVZxTXhIbGUrTlo4c2pjZWNITUFtVlZEcmNORTBJT2tFbTNWOWZCbWwvZFh6RXBFVFUweGZHbERFQmZxbFZhcGMydUdGYWhzeko1TFNhVmI5NnRpcGQxbUFFODZGUFVqa2U4Y21vT2hIWVZQblUxd1VkNHBXaWdVUnZCMjRnbjdWODBRRy9hVFZiRGI1ekVTMThWUW0vc29YUU1FTGxYRG4vNmo2RSs1ZzdoSi9sNFVwelJoWVB6L0JWZy9xTHNCQXJyU2JKb2krTkJOd1ZOb3kycjhCczBhVmJXQnlqNG1oMlhDdGtMeEVHVnBqWjN5M1FrYlBSb0dPZXZVdXp0RGpuaHNuYWtRLzIwZ3VkOFd4dmI2MEtDcDB4OGZPSm9OYWZCcVpxc2w1M2QyNldEeDA4WkVLRDRjQ2ZtZGVwVk9RbHEzd3dTS1RhUXkrYnJ5RTFQQnlNZUI4d2ZiQWtzbW5tODlZaGdxYVErYURRUC9COCtOdG9QNWRFRjYxNFdJUUNtUkZiTno4UzVIZGh0NWl4c2N2NjI3V0NNRHZZTzlYSS9JNnBFaVhWdXN1VG1sbjVMdzNmZTVxN3RLdHZzT0VsaEFjNjNRQ09rdEhZZGxXZFRCaG5NWUhJbERmUElNSUxtSUF4T044ZTBKekxjbklzbHAwSWllcnZjLzdCZm5OdjhISHhCU2hnT0VibEFqdmNqTlFFZjlaak5sbEd4Z3hYWllBK1JnYzR1alRRbWJ3T1AxditoU1RET0cyL05wM3E1c2krQlpLN0VUUnU2enh5S0o2NE8wNjc5V25qTUFtZWhHT3VXdFl5d1EwOER3ZDJJZzZic3RaTnZ2VDRZT0JqVFRGWDZDRWNic3JpeGtuVGtaMU82K3A5bEZPUHdoejAxcUZlUzNOWk1QcWx5aTcxM2s4cW9rVEgwYXZsMGRHYytWV1JqRHlSL1VSYlI0dktFZUlCT2kyQ1JrNzJaNDU0UDFzNHRkTk5nYkp1UUVOUkJzMVlmUnZjMFJBUFZ3NC9QdHpBYnd2U2dqYzQwenFuN1hJbUMwV0d2cjJ6MXpuOG90bUlDMmtqYkNyMFJVazR1Y1gwUnNpS0Rzem1jTHJDZ0lQQkNSYVBHbUJVVm00QVAxaUxLV2RvL1ZFODIrQ0RxSlVqRUJaOUNLNERFc3FvZWV3MW9POW9YempsRGJrclVqdzZJb2lDR0VZSmovL3E3MEdRUFc3L0VOR3VqYzdXZVR3Si8zZmJqSXVta1p1d1B1VTM3RTRSOXpaL0habXlYQWpncjFVdjcyZ0lUVWZoMGlPVms4ZTcwM3FIdVc5YWhtY2VzeHRUMG9TTGlTOW44VVRmRE83aTlmTU81WGdEeVVscmtyT0F6NENBQUVFL3ZzRDR3WWs5dlBuNlYvWXUvenZHSitsbHdJNUc1MFlzTERjWGhQTTJEZGgvVXZWRUdraE9oWEpnMGFvMmlvRCtCRUVpTXNqY3hyNk9PU1JKNVFWRGVTY200STE1MFRhWThjMXJJU3N1ZFhncGhxdHZ6cTNmNmZ6WWNmWDVNM2RYNGwzMDd0UGpVRjdwVkRxYXJIcVk4NEhBUXN2c2FPZkdRZ25oSGs1cUxGOHF6RjBGS0FpaVYzU3BKV3FoWHdMeExqSys3dmxUR1k1N0ZZV3gzQVY2aVRRZ2taTStVMGFCTVdhVHJFOVdXYTBwaWdHb29nMjY1WVdhbjhkRlhFMlBCcXBLYmVOSnVMdlpYRGhQU2hvalBYeTNuQk9hLzZkMDc2dXJIQzdyZFVxdUJobU5qSGF0L2dNQzhwcDdxa2E5eEwwc1lwSkZyZHZTcGF3WGZwQktWQ2RCOGI3dmpxcEJHR2RjVE10Rk1JSENhZmlRUkQydENSMktyU2xHaU1JanBvUmJYdHFhbSthYTR5RmtYa3NBNUhsM1RoMXFzNGZDeDl6bWlKZTQ4b201cERsVGJWa2k2VmROQUhlOFVBUUQrSlpKRnRwVVdmbUh0Mm9rL0JibGdFSHRycUplZHRSb0Q5VmNSaWV2MUpRMkp5SmhTYWZ6OVFMZmNONUJ2QS9SUGh3RDhPbDgvcVFwOWJWUGpvSGpXREdYQ244R2phbFdzT29rVUlFNmxQM3BYWXhnV2lldkNZMytTVkpNUUlNVHBUTnRLZ3RLNWZHL1lKUVNJamwyM0ZyUVd1VVFBaHV0SEdkTjNzUzc3S3R5S1I4VXl2YkkxSmg0dHhpdUExb1BWSi8rQ1F0WmRQaDZHeXVsbVE0UGpLeGF1bm14aFV2S24wQzBPU2QzeDZiamVnTUtSSnBoblRkU0QvaUJ3RUJ1T0VHbVZXM0VGQmZhOUFINXRtMjZGaTJwTU4yVVB3WnYrcWJWNzF2cmFvSEN0R1hVK0xyUGtaQzBYNG5vanBsMytrVEhKbDNlbEhvVE5NSGhxWFpHYVJuakRXVmVWYjhTMTM1RUJOT2x0VFBxZ003VjNFVk95OXY4b0FOMm1WeTcrMmVNMG9jOHdWYW5OYXF2RGpycm9sME9talNtWWpoK2twL0MzTTFsWTBsZXBoWUpMbXQyVUdhUEdVS0ZWY2pibEZVbmM2TmNxdlRzbGdLdEpBcmxRRTF2ME9lLyt3MXhtRUYxS3ZFcitlNTVNYi91R0loWG5TOHA2bjNUR0Q0REdnMnF2NHJPMEJPN3FyRXpKVUxnSTdhQ3dNUFg2M2NreVNjV1Z5L0NscjA2cWY3blR5bi9mMzFvUVY5SFR4WFJBTkZGTjRBS3FUVGlUbCt5aGplcjlicXZWRjRieE1mUnhPellGWXh5VU4vUUUzYmtXZHAxb0E0T1VYQ094VXpvS2RKS2VONVFRdDRwZGNtT0tzT3AySFI0MVZIMFZDNGVWQ0hrL0tpQTdTaEl2NEtPMTV1ZXJJUkZtSFRPRjJKK2pVSnJBRzdNVFNTb0Y1UGlja2JIMDZETFBYU0V5Y2dDUG1SUi9HZjN1Q09rd0ZLdlFJT2o1Si81azZ6bzQ3WHRLd3pQWmNVR1ZwZjc2TmU2aTBmbExOSHhhY1lrTWpjcVdOOGQ3TWVCZFpBN1ZES0xtSVNHSkIvR3hSejc1a0cvMmlZRFAvZlpsdXNOSllyT21tSlEwWVY3Yzl2V3Qwa3pSRHFCSENpeGI4YzJEaU82R3R3cGwvTU5kc2VNUHNQVW91dUNiUWNNWllwSE1yQnVvL0I2blQrV2dJQUFRVCsrd1IxZ0tUM2hmL1hBMUlLOU8rL1MvV1V1VlRtb1MrK3ZCeGJVK1IzOGFvRVE3NzdpZUJnbmZRV3VlbU5mU2pRc09ISlBRNjQvdkI5NW9ZZnVHWGhZWldLNmRvd3FUaE9aS3ZKVGF2ay9raVkzV3MyQ0VmdTRLWlExT0dlZUtoOW01ZWZyVlNCMzRmV2xjYit3QnVVbFV0a0VlZStBdEFRaS82KzRFN0wvRkl3YnlSeTc2d1RPY3pZeWtoR1R3alZRbHV2UjJGU3NDWG9aTTFmTit5bURTdG5ZRThHSDFVR2VxMFpIU1kybU9UNUo5MnQvZkNkemgxVFVERVhZRmh5UVJ3d3R3M2JENElMMURNSzZtU2tJUW1Oc01JcEpvRWhrZi9TS1owOWpocVBVYTZpaTQ4ZE1sclJEa1Q3NnE5SWI2YnM1aEZWMkwwV3g5VUo5OWJGTFRvcFJBcFpkazNEUEs3OUFwNDVaMUNQelBZWDVIcW1mMXVlb1RFYzhJVWU3eEh4LzNZZE1WdXRDa0JkdVJpTzhYcUNUNCtLVWtQY0pydTFmNWpXRFlVUjNpSVNzZUJUZElLUmRod1d0am9uKzZNZkdZeFdubkpIU09vVnFWQnE5Nm9DNHVlN3RQYVBTRVF0dENmNkNqa3MrVWhoUWpMR09XWC9xOXZWazNjb0xWd3VWTER5VlhNUkdpcGpqeVFmK3lIQWJFT3JWU1c2eGdSVno4M3dOWkpkcEZFcE54OEhENHhGc1o0cnBMVUdwK0k0Q3V4QUorcHVpUE5Gc20yYVk2dlVsL25CSm05L0xaZXpHa0F4ajJvTnJPeHNiSTNUT0RGa2RRTyswV21Qb3FEWVNEYjliRVlnUC9EOHBnaHpNK0ErMzZHQ3l4QW4rZ2JNWEI4RzZldCtQWWZJbk1TcExtcUI2ZUV3d01NakFKR2JQWEU5VXZGalRSWEc4bXVaeU8zQVZkM3VraUxBS0pFeHRSdEZhTFNETEl0RlB0TVBJRlVRODVvakdOa2FZdFJ1RXpoN0paTXV3L0FUaW9iZTlaVlB2c3NyY0xNSWdlb2RLL0gwNHMyd3J3cHdmVVRpcFFxSHV2WU84WWpuaXo2OW8xSWE4bngwR0xXY1g4UDdqZjNEWWorNm1DTDM2c2M0QWdjQmM3d1V0VURBL0s5aENkMklzWWhTRUU0bHZRdHhwVGE0NlozTG1JMllURHl5ZWpFMUtpQWVtK2hTNVlSZ2gxMURXUXIwOEpnVnNuVFdrQU5hMi9BQkdKMGpqZW83RmJWdWtXdkhGTUYrdGFmeUdIamlhcGxMTEw2SUhWR0FsR2xHb3FSb3dSVkVmZ0NZTisycXpGM2xKT01yeXEvUlQ0bWRjd2xYSUh2NFp2L3VHVFFjVGUzQ2hqSmRGZXV4TVpRc0p3bmZBQitSQkFtWk5TZDZkdjFSbXZqUm5vNERIL2FEbzZhWGx6aUYwZVMvcDZYVHhKTEV4QlZqT1dCQVNKczVRSjRuZ2c5L3o2Y1JMUU5tOVVwNHVvaXBKZXcxb0p1UWhNclI0SkdIaVR6d1lKZy94NkhiM0hJWEJHeVJPU3NrcHlZOWJXN2xLemI2TDMycmdUK0VXeWdxMWdNdmVkd3BFZlJwa1FFdU1lNGw3NmV2VHVVNDg0YkdIQVdkV3hwMUZ6bHJSYmk3K3RYZE0yTWJKU3kzcG9hekRtYUF1Z2VGZTZEMkl2Q0MyOW1kcDl0eE03TjFISm14UXY4YmVGYjZac2F5a2QvbFpFemRWMU5FMUxrUTJJSldmZkxrc0tPYUhlTUh4TTZYUTZxR0g2NEpBZ0FCQlA3N0JOTnZnY0E4ak1sWkxjcFpQRy8yUUNhMXZjWERjV2ZUcVZEOVg2UklydEwwdHpXeU9adXVqZk0xd0ozM2UwTzRNV1BTZEZFa2JFWm1NcWtENS95eVB3V3NPR0hNQmk1bm5EMVpWNzdTd1Z6TDlnRDVpWHoydjl5bUw2UUlWSGpZa25ydVBsQStyNDJXNjlOQ0pyM0hnczhkNlZPVG12VU1hcTdMMVhwS282OHRWZVlrTklXcWwrRm9XMUJKZ2dDSW9Qd0xNTXNOYUgxMjl2eFhNWEdaNmIvVS84Z29ZYi93OXJQNkdVb2FZZHR3VEVhODFET1gvZHJxK1hGRkhsSWlLY2xrNzNiRkhkTllPSEpnK21sYzZVdU81bVcrRW9rbkZHbGNXUU9QUm50T2V2S21VZnY1U0RWWlVXL0lEU2ttRE5vZnJtNGFJbW5XK0lFU0FIbDhYamJFUzY0QTV3V1NwNVNzdDFnSWVTZ1B2VWsyMklGait2TVpzYnRjVFdvOUF2WGR1b3ZBb24rYTFxdTg3amVYNmxTT0ZPYTQ1NlR4TU1GU1dHd290YWYyTFFsS2tSbGpkSC9LL3cvelIwYitTRlhGL0xteCtncW0wa0pPVzEvaXhHZjV5TTg0Q3I3Z2tkSzVnSGdsbXJkTzI2U2s0bUdVSmZ5QlAyMW9uc2JxUzhXc1FpVVQ0ZHZFcCt6aTNhQTN6dUtkOENGd3lDeFo4TFRvVkVpajVpQUcyRk1VSnFLL3l0Y21wUHZsSFdGdmxXVnRZa1NSVEFITTgxKys5YmI3dEhwNUpOcHFUTkpGMXRibmtCTGxLcG9ob1FiSXdnbzY3Vkxqbi9LMXA5dW1ObllLemsxRHliSGVHYWJlWmZhRmFJNzFJOXkyazlFalhNeVd1OGpuOUpkSnQ3Vmg0WFNlVmR5Zk1ndnVYcGNWNGVrbEl5dTRIWUQrWHFGd21acEZzS0hNQ2k5TmRMc04wSHhCQTdOWnhXVWEzQjhFYWFXQXMvZ0Z4UmZHRTA4MUVTUTNXU0VFQndJaFJNUG5TUjFVSlRpcFZsN0NtV3hFNG8xazRsNDNvOVdxeVFxemZmek5wNnZzVXNlWWk2Y1VObUNWOXRTUkgydEtJYnFrN0p0U3pRTmUzL3F0ZVFFRWNvWEMxSjJkTGRNajVYM1NzZDUrTk1oaHIySlpRQ1lSdGY1VkdiRms5eUJmNGRRa256dTZ5RkpXNnpBZSthb2VlekYwT0NaaUplZkNlTDFjMkpLRGlRckg0cm9MaVNsRmVpc0VFdzhFVEVuaC9iRFJDMitUTmVrcmNjRWd3SURqbUd5bm84d3ROMEluRHRGRk00M3lVMWFzRlRWMUR6aXpxSmJmS0xzdlRSMy9BK0JZSkE1TFd5azJrSkpuQXliUFBXVnZJVjRLQklnM3l1OFpsUklyVHlnQzVIUS9TejF0dTMxencyTWF3akViNXBBMkRWTW9PcTBXNVJFZjRGNHBaMU5oVkdHT2R0OUhGWlU0b1YxejFTUldYVmdPeHJTckhhMFAySTNJazZSSU9PeGhVcmJlTGNIemMybWxyV0FreWdOR3lqck5qdnJESms2a2JKUVBHSTFuWkxQVUQ0SHVpSEljSUp1RkdtM2RPbnpJZmZKRFF1QVBGdnVTNkVIREx3WXVBYWkrTGt5cERISUsyOWVsRGt3Q1Q1L2kydmxuUWZYNjhUSktyVFA3bDJUUE0yUGhRb1J3bFZsNnUyNGQzenltaDdBVDhzdTI0TklCdWxZQW55MGorMlBvYkJJRkd6bEFXeG4yWlZQL3ZHOVZtMWRlZlhZQ0FBRUUvdnNBbFR3dkUrNGo1NGVSMUxlcG1EektyTkE0QmtacVpMYktZaFlKVy9iR01wNDdtdmpLL3hYdTJuTjdkcng4SldSdG1YZ2FGZVJFYXpBRmZ4V25NWitOMy9qNTFlc3lHS1p6WU1YeWFtM3JpR1JOQkJvV0lSQzZTVjJWZDNrc0Jxc0RqRHJnbnA0dFdqN2tIcDg4d0FoNzVTS3Z5TkN3ODhHbmhMc3ZrWTNSN0JYNVQxQmFaVjNPdVB6a0t6QnBjS2dMSFJYOVMyVHBsdnF2MVUxNzJrNFA5N3FDQ2cyR1Q2akxlVXp6RUIvQndxNGlOVDNjd3pGUjgrdSs0K2FWcEswZENLRE5mWGQvL2RvV0xCREs3bytxeXFoSVhoOGJBcGt4cFdsUW1zc2x2NGJyT05vS3JhTjFaZktOSlprVkNaZk93WkdGaWs0bHBtZjRGL1JzdzNiZjBsOEhMdDJCdmVFd0hKUSt4N0JBOHM4RHcyUE9YYXY0WnBLVE9GQkYrTVBNQ0pKYk5oK1Q2dGxUQk9VcnQ0U3lBRXAzZ2lYaDFHZUgvOWttWW9jMHJhM2tGNnlZd1FnQVM1WkhlRmVLOW9OT3YwOUlOOHc3L3RxN0puVDhzZmNQcS9WQTBlc1JaTzF5WXdTMm9PV1F5UGNoSWNzem1lRWNVNVlFOXpZOEJjRnVNSGNBQUxqOW81VGVUSHBBTkY5QVNjU1dRaGdCbW9WSXAzT3NKY1NiUlRya2xhM2t4ZXQvQTdiYTlNckVTM1pQRzE1QXZnVnV3Nm05eWZ5Z3RhY1lnMEZ2UTBGd21UaTFWTk1heXJ0bS9NVDJWSUxsSlEvVmFaYktCRkNYc21RUlRGMmxxelc4cnBLVEFTVDc1UmxXOExiYWkyMnVrS3hqRWorb3VvMWxiRXR4d2VyWjJFVDhsOHVBcXlkQmN3aDM1YUNOVlhaNFBycHRlWEt4VGlRWVQxMTVobDI5ZWI3R29RbVhVa1dvSjlhSDVENEpFQmZjZDZVV1JSSmJOZkNGaGNmeHljNUUrUXFZcVFOeDZaWjJtZUZ1T3dCLzc0UWluL1NxRkVGL3Rqb1VZNDN3SHdtemVDcktOMU9KdUhrTys5RytMR3Nuc0tkcjExWlRVUkNNYTJQSGZNb3FIZTQvOURyMzRlN0xhUDFRUmtoWVFocmg2a2l3ZmZCMDlzdWduTTFmdk80QTdIUGt5ZWZCMDJhRHhNUnhHeGQyaE4vc2RoWmZ2djJld3d2R0V5RjFqWGdwenE2VHVaN3V2ekllMEpaSStSWDNYdmt0aVBCSHBXclg5M1NUSjBUWDhiejQ1b1ptdVpmZjZDWVlKUytmOGVqWU1yMkhMdzVUOWJQYkVxdHdmeVpKUG9pNkhRMHdEekkyT1ZKOS9WRnF3OVRSTkNIa3lLTUIxK1pwVEU0NFZZb3hzTXMzMGRzVnBTNEVGcFZxbTF5R2ZmNjNtZlB6b0F2c2NFRVU4ZmMvNTFzVzQ1OEt3RzB2M2ZpdFBJcE1pOElJOG0vTURobFdrT0VCOXR1cllCUzc1UUZJOWFla1dCcHhKWlZYdnVWQ3g5eFMxWHJxZ3FFT3hRZnBVdHJhUnBJeWdSN0xpOFUzZzc2Smpac2g1ck9lMm4ydWJ1TmJKU3k4WDZ1N1AxVi81TTQ4ZGhXTEw2ekJqOVBMRHdkZWhvWWgvR2dNR3JuNjF2Z0VRSktaZ0VhM3RJSWhRVVdHOEg4UVNPZm5udURzTHpvTTUzaVZWUVNiOWRhZG5KM3BRMTlycVlZTWV0NWNod1FxNmVXT2REKzJadE5TOHFtbWZwMm5OZ0lBQVFUKyt3QUQyTmJOSExtZzZWZU5WcFRWZmhNNkVheG5ROG9lTmFwdzlTK3p3TkptQUt1MVRWZm5RaDNadzNaL09GMHoxZWdYTm9abnU5K1JEblhvaGFscjMxSVRFM1pWVmVmQTVnNHJ3ZGNtSzVvMSs5dEx5dFpNTHlTclVCeEdRcFI4UVJveFVxcVNKTXJtMXMzMXdlZU9YSm5ldkZ6LzBZOXYyVlQrekQ5RUIvUW45THI4VHFEejZ1V2ZOTE0zMld2L3Z1azVpbnNubUFyYXljOGJRcW5USHA4djNhNVUxR01Hd2QyWFRaVy8zcytab3pZRU9mWnVuYVptQVpyRW05dzBlTXdOcFVYRytMeHBwdUNwYmRsSU04bmpYOUprSTNua29jM1Nxdk5KZUh4RHVnYTQzTkZRaVhReTRKUXVzSW9ORVpnWnlSZDY4d3NSVTE3MDdyZTd1Z3NFbmJVcW53cGhOUUdYd0k1eUNvMDIyL0NIVmw4dEN1eE5RdGZLVFI1Sjl4d21hT21jV0xaaUpRMnV0WGlQYnFubnB5bTE5ajRLWGZudHR2MDhEY1ZpWVFodWk1NkZweU1FQjdBM3FlZy91TnFnNFVZNERGRWtybFBQUWxIUVhOREpaUEh4cmFGL0lDRVlwZlEreU9FdkVwRDJKaTd0K0RFMUNLQ3FJdlVmQ3c0VVZkQVdOUEpxVXZFTVdEZ1IxMzlNMnp6cEpoTkFSaXo5Z1BEcUswMDMzSkhZU1ltaVgyelMvK0QzdmtJWWs3eWVvdk54cFBiWjNEN3R6N3p0eHdwTFQvKzdzQ2JlOWpaZlQ3YUZnK1lHOXp0VjNJNGxzMDdOU293d2NTSFZ1dlZEaTdsbHJHVEx4SFJWcTRaMXdocTBMNFBZenZDWHhnNGcxZ2JxUEEyS0N6YjJUSlNZRXVaeXI3S2duc2pLaGxkK1ZhbXVuR3VSOHJyTXo5S1ZlMXg2VzRPMzRLdHVKbDJwYkJ3TWtmQjUxMnlWN0ZLQzcraUxBNlhtMXhsN1hkYUFyaUU2Ymt1QzhEMTU0ckR2RFRzRmxGZ0pvc2tmL1k2MTB4MExlY1RvVFdJN2tNdkluWk13UlRDa1J5a2hZTzlaTmRCMDNIQ2tsamYxa2I3Rnd1SGhXNU91SGRpWFl1bWFBYVM4SWsxU2JsQzNKSm5Vb1h1dDREZTNXVWJUclZtMEtRYy84QktneC84T1ZNd1hIcitlYU02Z1hpVXN1T3loVTA5U2VSUFBrUWVmWUg0TU0wYTVWT01WcXpBUWoxVVdONzVPV2dpWU55SjlMRVRMNzdWckg2QmtWRDFRSnJLaTZhRHd0QWZrek8vVHJyR2pBTmhjb0hObVVUNCtodERjWHNQaHlValNFcjlFbUY5T2Fnb3hvYXZjYkxicG9HSHpYUWoyS2RWQzM2TG84OGQyaEpvblNXbDNyWHB1cU9kOWpwS1BBZlJDTUhMV2VUSzhrTURSZnJ4N2pzM3hwcUcwaGVPVGNhcVJTcy94N1cxSGVwK1EraVhBTTFHa2xVbXlhWjg3U3J6TElRb3BrYkJrTGhJNHZZcWlCcHlrUml6THpLWFZLMXpZZmlWWnBkTEJlNlVUNlhpdHo4UUk3R1JsNms3eFRQV1VzOFVUcG5ES1o5L0VCRGtodzVScTh0cm9YbG8zVy9mZ0l4aG5BQTlnVWVyeStqV0I4OHJkaXQwRk9EU2E0TlplNVRDMEYwb2JISTBKUEVDdWRvLzYwRXE0TVgzTWh6aFRaMUI1OW5TNFZvV2tFVHJZRjA2WStRUUdLZkRTYnI1NEtJeFZ5L3BlcDMrbEFnQUJCUDc3QU5QcEE5cU5JUWMrTEdmN0pJc2xnakxnQU5DRFVVRTloRHJLL1dLNFpNYTFacitjSXVLUnVZLzFxWFJrNE5qRjZteHBYVFd0UTBScnB0VWhXQXU4MCtTNExKTXBvdEdHWTA4TnlnT0tUZVB3cWxmTE1qNU1nZWZzWUdkOGY5QUxhLzJsOXk0TkYyeVI4WUdVMUowSHJESmFrZElUWVlCSTYvQ3Avc3ZOMDBLZjUxUllXd1hFcGF0eVVZNTFPOWgrZjJXb2ZDZ2M4TFEwN1UySXpsVVdoaEhOTVlXWnA0WnBlMk84UXo2RUdmaEcveVRPeGF0KzROSXhuSDhUMTd4SldpSWtJS3NYNkV1L29NY3FLekNVNzRtMnZnRHNNMXFwdlpWN1h5eC95WnRJNlJOU0MyNE95dDlNOHNuUENVQzRqOTE2aW0rMXBlUnZJeXhrQ3M0TkQ0Qkx1cWY4R1hnalhUS3lsdU0vQ2lhQXVIdnRtcGRJQWQ2NzJIczJub1h4ODFlVjJDcmJOdFJ1RVFRdGpDN0w3RnM1NmVrL0VIWkxwSTM2c3BMSmdER1RlUW8rbVpPbXdSTE9DQlY1RklQeUpTUWw3L2t2VHJjVXBwWTRPNnFmWi8rTmo1aHZUUURHZ09xcFdkSkZ0Q3V5M1hvRENkODhOOU1OMFFGMTBoa2p0dlhoQnY0SjY0VEtseDhqdnVMQ0k4Y1F1Z1k0VzVLczhIV0gyZzJnclBqVFpvS3dNMndqcGZVNEFBZzNUeittN0w4RnVSRVU0SDcvQk55Z0x2UEpNbmd2ZjcrZ05GeStwZ3BPcGhaWXN6dFpJQ1NKaHczdi9MYmsvc0t3c3p0RUZuTm5kM2EzclluS3E0WUxCWEt4MW1KZjd2QmJnSERwZktEVEFlU24yU3ZQSUtldWJ5ZVNScmVYeDBkYkdJWDF5M2NTekp5eFpXZGc3SGNTVktMdlcyYmFKZFN2T0pjY00xemFLTDc3QWZMRURGWjk4VUlvYzBWeGoxM3RYUUtnMXQ2OXR4VkJrY1VzbGVlM3J5bS9laTlTTENUdnFsYUVyV0xmSkN0SnFNbzZnN0Rld1BXRjRJelE4ZE1Wb2lNMm9BQXBVaFVnUFNGVE9kR3FsTFJ6VTZiQnJGOXlkQUlZQTdOZkowRVc1V0VXTFMxbFgrSFRCN1MyaVdEQlpKUFZVOTJOOTBuNmdqUjV6M0I3Y1FJd05idFExM1JnT0pmT0hyRWRDM2NqOG5MT3VJd1dPa1ZRQk5McGY5dFhDYkFZb0RQZUFvSDZiV3JOa1g0dk1QSCsyTVpST1owWllhUDNtT2tXOG1LVFlscXF2NHNCSXNHTlN0a2VSMXdtUE0vcnFPTzNPejZLQnRQMk1jc29pLzg3bjVHcW40cDlHSndZWVRrS2Q2YmdDY0tCdVYyNWVjcVRwa3hDTVFxbDVzTmNGZlN1VEU3dlJ1OHh4eDZjdzNodk5yVUZZaGJtVDFLVTVWWW83SFJBa1NOWVcxdzNxNGNXdWxQck5sSFRHZ3R4QkRSc0RjSkozZTNlbmV5bUJvT1hTK0lXUm5lMTlBd243K1U0S0Y0N1p2Ymw5ejN1QlYyOHpJc3dHUmpSYTlEaFVxci9RZVArRkErQnFnVkVxdDlCUFlxUFRVVytseHBKYWhmdHJqa1lsc1hYazBabitxVWwxVFRRd1YyZkZ0QThzKzI1bVNydjZmM296Q3FscU1zZ05EcTVxQWpja2VxaHExRG1peUdxSStxTnQ4WDc3NVQ1RG5XR1N0cjM1WkJUVlRINkw2U2s0VGY4blQ1ZkZNL3MrNU1DQUFFRS92c0FYL3NpZkhQNzB2VFBHOEkrME11VHpVcmY4UVhSQTM3eU8rb2UvS0RVWURVVS9sdkI2WjBWM2lSeDVmN0NqS0FhNGxtYXNlL2FwdUcraGdVUHhic25UK0EzbmdHSndMQ2R0TE1EdmhBaUZMNjk0YTExbzZjeUJ5WmxtaE14NE1pM1JRWW9YYlQybTd5UlVVYm1ud05pZDE4a1hIa0x0VXdDN3ZKVE5Fa2oybGNaa2NUQitkM0NhbVJCbVYvV2p0bXJLTzZlQmhSb1F3V0pHbEJHRTNwR05HUmhJcUltaE5rSzdHMlZaNFZmY211QytoeHF5QnFKTlp3TXhhVEgyMlpwTkgxdzBzVGMvaHlHN3hnaVUrMjVPMGJac092RVE2djViTElIUXhLbFRWQksxUEVvVlNZOFEyYUYyVElVU3NYSGpoUE83MTBhSW9BWkNxaDZCSnI5UlpCVW5YNysyOUlMczFleUxYZUYyQnZOaDRvSCtlbDBLdklUNnlONHR4VEhGV3R0NWJmaGw2cVA2K2JBWnBlZTNFVWd2SDNWV1BNUHQrcHpHbDVWZjNjeTNyWjV1OTM4WFNEckFIWnNHK1pweVcreVJtMFFtZER2WVhzOGlONjhkZDJxekxHVDV5ZW84WTcrQ1BTdnhGYmpEYmdiZXgxczRNSGtwcmt1ZC9BTjhMNnVEZUxrUzRRb2ZpYmtnSE5SenNibk9PZDlVa1B5VytpV29nZDlwc09zY3NGeXFIbFRBVXNmRmJPWUZVaGR5MWJEYkdnODArbGJPR2pOcUltb2hpRktZc0MyQ3JSRXV0dnUveEh2eElvcHNOUDI0M0dmVFFQc2tWVTVjcHRBQ0FUUUxkSHFGR3pNRFp6WDlrY2NUa1pmTTIyRHVYSkQ0YWRDblhsSHk1dGhwdWREcmxMOFpBd2lFZGtLT2hDRzNhNkpwYWFxeWhyczhNL25HejJlb3NrTTNwWmFCUVU3Q0sveGJSNnRsMTRFZGVkZVlMbkVFS1VEbXBpb1ZnTUlVdDdoOFEySmxhcmErQWVKd1FvOFFNTkxSQ1oxOFZudjZoZVBzaHl3MkRITzkrOXZSaW5QL0s3azNja0xNOUxBMTI5dlg1QUZXU3FydDJ2blQ3ekR2QXRHd2tqYndqRWlsWmdGMnJadDNJTDBmY2lUcWVaOTJYMU56OHI0SlpSVlJrSUhxS3JGNmNlMzNUSDFxVmZieDhzMnd6azFnb0g0cGZUNDNYV2Nuc3FIQm5WZ3BUNTZCZFdCdDIxVFhLSDlWdlJhR3dZcjJhck1ObFBmWmRVZHVwYmtZVkkwekdQSWZGY2ZDSjVOZHBmNS8yTzI4M2dJQjB5OGVzampzSTF4RFRwNTFFUHg0UStLVnFsZXJVc1hUdEtZU2VGa2tyNEt5dUpFd2dEMFQxWjhnWVpjM0Q5ZmhFbytTOCt5L2g3WWhvbTVMa09MUE1tWFMxZHU0aC9waTdZbm55Nkx6dkFKVEtGTlQ0dGJWWk9rVytOSTlTZllWdEVkbUM5NFd5cGp1T2EwUEQrQnZpR3h4K2pkVmdLTU1udzhMNmNwRGRUT1FjbWdVaThQYkFST3dtQnhTb0w5bFF3dlluNTRRSHlnV05DUTdFS0VoZExQeDgwNDFuRUVMbHV2SktQaXovZHA4Y0V0WTQwTDBXVXpwOS9Wb1FVMzlmVXZiRnNyMERYQ09ER00wbVhEd1I1anVuNWd5eTUzaFIzZ1JNVC9OcW9MS3VjbWRJWSs1UEpBT3BLNE9QS1VnZ3p6L1QydkRKenJDZzRDdi9XamdDRG5TUlY3RjJlOHlBSUFBUVQrK3dUOE9NMWUyN2RtOTZiaUI4Z1B6Wmw1SVNPZmlBTjVzOUU2OEQ4VXl4bjg2aUszNDdubHc4dVlqZ3dQeW1SdDkxWlFQY21XRUpNZDN0a0ZMTXd5ekRZQkJUMUJadUw5aER4dEN3WDdvc1JHcXpHUWZsdXZWVmx4NU1LVVY3VDVnTUU1WVo2ZDY4WXhXRTdVNVNxa05mQ05ZZGJKaE5Eb0VRdDFiM3FLdE1XM1JpZVFxcktWTnU4R2RsMEZVZ21LcnBrRXU4a2liYjBzVE9EMXh4cjFScFlLSkFEOFJkQ0tDeUhZOFAvalVaaHlZZTF3cXAxN0cvYjBWSzN4N3djS0dadXZ4andURDNvUzVGOHZLZlhzNjBvczB6SGUrbHl2dnE4MG5TcGRRc2NxMDYrT2gvdi9YT29IT0VHUEovS0JzMStMUjBEa0ZGaTJHSXc0THBqZzlMWEEwWCtDOS9JRWhRUXJEV1BTQm9Zd1N5eVpTSXlac0lDdk5HTkpudnNhVzlDTnYvbFMwbE1lRFBPbzlBcTRVOVJxR1RrMkZRdHdsVHdUcm9FNU0xZlJCQzRmQlpMWk9BZ0ljSnNFemo4cHhxQlNGeUh3VWFwU3YrcGViNzZRYWhjVUVsdFBhNnkwVEdUK2dxeFR5eGovKzRKSDRKK1VIVDNpcDJyandMK2FRaDlKand2NFNwaU1yZEs4QXNSdzVpM2NNR3cwUU54bUVxNFRJT0doRDMrbjBJKzg4Z3piWG8wcjhMWHhES0FQWG9MNU1YVVMwR04vUDNVTERCbmNhVFJIM2RiSi9GbFNQN3k1V1FvNEhLVmVIcGRkZFNqSnI5YTJTeU1Ma2ZXZW16aCtRVUlQR0pXY3hjRWVOV0tvUkdkeUtoU0l4T2MyOTBPK1JOK3pSUStIVlc1eG5qeVR5Wi9xS204cGp3bngraWlDaVVrWGZnWE1WSTNZV0RodkloRlVnOXVkRDNKektYUjZwWlRIanZNZmRwdlFOSlFHWi90bDlEbjVGWUFhR2ppMExZMGQvNWRGTE1KSjQyUDdBNzhXbnp3enAwbGFNbmxlQ0JMdGQ3L09mdHpjajF4R0lwenlCaENyS1h5L2lielJidHNoZEhOV0VQS1c3clIzcjRjd0V3eTh3RFdyQ0pqMHQ5cDF5U2V3RFBLVTVnUjdjeVp2aEpKV0k5SE5DR0xodEZUYnc1TlljTFZTUTNWNS9XSDdFMnB3eklMeldqeHJaR09rT2RrNnYweU1jOENKZzZtWUNybmhBUVdwZmt2MFordHVnR0kwcWNGemJyRzlEaDI5WnYwNGdSYkkwN2hUbnlwUkQvN3hhUm9KaWV3WDZyaFBYWlRhcjJ4VEZaTER2bUFwS0IwTHZ2VERoNmpnbStzeFBOdC9BM2NaZEVaRnFkS2s1UWpGMEo0Ynl5a1Fsa3h6VFYxRFQrUjB2OFp3WHcya3BzTkRxQ1Q4SG9HR3JqYmFnNDQ0eDMrUjZKeTdwZEkvZVJFMWp3bGlOTGtiVEtPSkVRd2l0UlRuUlQwRjd4bmllOEpCSkw1TjZnRU5Ja3VNRXkrRmZpdWF3NitGNzA4TFUyRW03ajI1YXBqSVoyM0V3Y0UvZUJjWEZNWU90Vkphd1ZibzNIWERmRzdSeU9DVnpDKzd6MjhQbEdnN25UM3BlRlViNUpTVmhwR0J4RDMxOU1KcTA4TUQ0aG5TRyt6K3duRWdZWmdjUmpwbzJhNzB2ME9yOXhNNGJBWU5WLzFPOW9HS1drellsc21YQVljLzBLUzRiTm1qR1I2UWNkVGFsL2tjZkt1NWRiWGYyamhMQWdBQkJQNzdBRS9WL0V4RU8veE1kc3N0eGx2enAvaFFXb0MyTU5xZnVmZCtVQ0dXK2JQMzRDZ0xVcGJaQkkyQkhoOXBmeWlIbEZmc0d4SmpXOGUzSWF1K3k5eHlQRFZpL1F0aitmQi95eHVDVjh4Vms5TzVzbkMraGxFUU9SUnIxemVTRGNLdjFSVmM0czN5aFZ1d2J0TUE3a0FjTUk1MG9pTlRadDZMVFkrbGhxdG12Z1FlTEFDeE8yb1lHNHhFc082OTl3bjNOd3NBT1UzSHNIOS9aVFRBL0lXdzBRTUVEUFNSbCtickJnT1pJQWc4N2lHUHR4bzlSNld2NU42eUdTYTBPUzFKMjg2dFNFcTBtMFlBdjNXYWZpSUhBSWtJU3E1RUdCWEd0SmNvKzJHN0ZPbDdObmFRcTJRdzJ2QzE0TXRRN0U1Wmg4UmxsbHFHdytlMS9vMTRhUy85aXhaRmhNY0h5RDNwSERxZ216L0s0ZytISGJVYXRVQjF0c2ZxV0VyVjM2MGhZNTdvczhXVk5yOEZMODFIa2FBME5jVVFBU2FZUDlTOHNaLzJGZW54WGN1aTRzTWo5K01rUmszdFBGQTllS0FTVzRNV2ZoRDV5Y1JMMmJqZ1BVSHVOWkVaNnJXekk2U3VvbmJsUnFDSDlwa2laR05VU2dkMklraW1aYlNtSSs0RGpiWnhVdi91c3pENXVjODlRRmhKNzluYzdWd1p3bHdDdUJMSnVaMUNRRzVpZ2liaDN2OU1BZEUxbTBhTkt0ZWN2QVZxS0VlYjVWbWdPWkUwNVBOTU9KNkFpaDBSSllzUEJLTkRZUVFyWnpPekJKV0RKVE1TdXIxeTNBckMwTi9ROC9mMXV1a2VZMXNFRENYNzJGZmh6elBEWldlWmFHZURTSUd0a1BjVnN3dDhTU0c0Sy92QVlQSm9EczRmZ3RmM3JCcEpBWUNaUVYzVi95bERGTS9RbVBQYnhiWWtrMzIza0h6U0dkS0VvOHlZanNiMzZHaU1LbDVENGZKK0dHOE42WEhuM21CMVZPQzRLcUdNQXIyQk9PWkZubFFsZG1udnFLdW1meEgrcklFY01FRDZRTWM4R0lJVkNzVHhmclpBSEtyVUdnUlNmOTAwTUFvbjhRM3ZCcGRCeHpvZWFaL0JqQ1M5ZFBYaGFwTlhUZi9xQ09oVjlKRmw2ZEQvN1NiUUN2TjFyRXFTendYYndISFkrOWdITHNUS3R1cWl0cDcvTzJzRVlvOHU3bU12VWFQWnIveXlscm1TbEVodXBEOTNTNjk2bDJGY0NWUXIxTHhVYWEzVGNKWlF1QUMxYU4yTXZ0TnpqSklvaCtxR2lhMlFyelBCZ0svY0hzTVgyNXJQWXpCVGZFZ09HZkl1TDdlQTNGNEpNL0ttMlBxRGVzeFBxSWtkNWJHNHdGSmt6Q2Q1MDZNZDVoc1BPL2ZsTEJpNTY2VmZNc2c0bFFBbWhPWlUzbTlkWWRPc05Sd256UWhlR0U5b3Vrc0tKc3RuM3RkVENpLy9WbFVZT3hoME81Vlc5V2xCVFJpZnZCd2NvSnNDaHFhVlo5azVDTDIranNaQ1VhZEdaWiswNGxiSVJrZmJpUmY3Y0R2T3MyQXRpK2FiQlRXWXU3bzZ4d1hUcTZncHFFRzJYaWg5ajlpREs4OWpDa21aTld4YUZiY2Zlc2ViZ3VOcWtmc2FUK0g1aTZIQWtWb1p5VFlpOWtxSVJOSWZDSXIvSE12MnpUU2lrQk9qSjhXMkFQUEY3cWpnbVltSkw4S09taE5wWEI3bXhNQ0pjL0hOV1FwQy9tcTVIQUxqaFp1RlVXOENBQUVFL3ZzQnhSanRLQXhCWmZESE93TmEycnB5N0hHQW1nUlpheEdKQmJVeDl4dUo3bHVMUkZCVUduaFhSN3dRempJQXBuWkdJTkN4ZEVQMHRsa0lBMzVuaGxkdkNiT1ZiRjVxNlpzZytCc1UvUCtobzZJVkJyUG9xZ1I2aVNiR2RFS2UwZDIxNXNqZEtBa0htK1VJaFF6MVRhQkdiUGRSMnY3cXU3aHlGWXl3Z0NsVjZJUTY2UHh6bWRKUlJRWjZra1NpL1l4eGJjeG1BTFF6UFBpSm9SN1dEMU50R0E5ZDBCdWROYmV3QlV4VUdOSWR0VnVCMHNmK2NxaTR5MGNrQVkyOGYyLzY1UVhTR2srdEZrYUhONWtMZDcrdVFZeGFzK21HRWdUNUk2YmdzSFJEVHoxYm5WNXE5bEVKRmUxZ3RoWVRNdGE2Wld2TzRtekthb0hONmw4cEpWeTd0ZnVEb0ZmVUs5dWxvTUNONnZzWHRhaXlXYVRUUXd2V3ByRFdTbThrL0NoRUhreGV4aXBKcVZDMjJWZmowclY0Vkp0b3dvTDFQTnh3WWFhdExyVTF5aDVFWmVtR2pRczZCSlhpOFl5MTZEcTZReTB4eHFFbXRBRUJMc2dIcG9TRVpZc0dqTkFnQ0lwK0RpeXlIcVVvSnVDTlN4V2xSdDZqeUYwYm9FR0cycGIwdGNzNmN0eTJEYVp4Z1Y1Z3QwcmJTdk1aNU1uWm9RK3NNSzJtM24vYytpcnVDekhqaGtIZU1BaENRd21HUGY1bWpzaW1ob012M1RDa3V6UVR5MDEydG1MMGRNT0tSNG1KYXEzRzErNGVWTUVSczR3cDdMc1FJU0lteVRST1ZOZEFqSklqTHVqdUVDZHFvdWo0TEZoUTVzanY0Q3UwU3pJeHZ5ZHdUUXFVUStHS09VY0xqYzdza3c3Rlh1UlhkcWp4TmZicm04WHRhWVlTTjlvQnNaOGU3cE15ZVFreCtCc3lPanNnUWw4Y1V0MEV2NVgwZGpwWDVUdkk3eDJacmFjZTBGYk1xZG1YL0JlZDFHWjlhM1lxSXRRMHFxdG4wZmdNKzdUQ0tEcWtxYkJKOVJxRUhFTkttMnZaNGlIYzVjMWl4V2FRS2VqdTNYdWFuNmhxQ2RzaUYzbW8vZWNUU1VoZE13ZVNORmswQnY5dGZONlZkbW91NEtjSWFhN2E3eEtra1RpanI4ZGJqSm5NV2JDU3pPQkgvN09nbWtsZ095QmRlbEt0Zms4anV6dVZONUVnSHV2eEswTkhMQXgzOEZ5VHJXMGcxM1ZzWFd5UlFXYis1OXJFTWp3SVd0K2thaUp0RHVUQmtCeU1HRDV2RElRNFVPOWJXL1p5R2w2QkJGQWRWa0VDRitLdWsrMm5jQ09SaVpDTUEyWmhMVUJxcDdXTVNTUUZ2a01XMktFRXd5WER4T2VDRmVtL2FXSXM3bHpXL3ZrYlA0MEJNdGdnY3VEWm0zbTV5aUpQcGxKellQcmFiWkFvaG50M1BHeXU5ZVppdm9aMzVCYXhPdXRRVFQzbkVPR1hldDVKaWdXek9oVjJRYklsckd4UDhxbEdnVHRIRTlwM2N2WlJSU1VER2NBVkk0NitDVThabkNoZCt4TU9HcSt2ZmF2bWgvQUY0QjBqT2FVWnlzdTJhem1zVXFzdlp3ZmJsYnhKd093b2hSSmExSU05enVaNDVNQzdjdTJrRmxidlJkOVpCYms1bkhKZERURWp4alpqd0JXTFZ5UFVoVFdPNm1vSnNNaG44dk5hZUFZaXVQZE4veVlXcXhOR3RwYmovdWROTUMxcnMvcHZsRWZPZGdJQUFRVCsrd1RRWW9nS3g3VER5aGJJeUVTMlJHWGdTQlMvVUFXb00yYk9YYUlEZU1QdEVYL1VxUVVqZk5jb25mTGhZaFh0S095aW41ZWdsOVhyNTFwQk5PYjhnWmxwdkVtck55NElaS0ZUcFhmUEJMalZlNW4wRHp2MGVwZzlVK3VQVUVGTysvQVVDYkZ4UUFVaTFwditSS1BOODFwQXZaenIzQUFlQTdON2NMZUtjWEJ0Z0FBME4xZS9WdmE3VVF1V2pnWHhzYUk1OEd6cnlFb1oyQXVvN0dEWmRJb0tEOHJRdUpnRHFXakhwVHhZaDQ1YmJ4aDRiSkhJSzNpN0NMRDhSMVgzd1NtRVBRMnNPNmNneU5WNWpSekkzWmo5RVovYWRTR0RJbEt4N2dWazlzZ1dyeG93RklqM1RQcmlrVklvbmpHaUFTbmFSWXRZT0RRRWFJaVBsRG54OWtlT1VkblN0M0ZEM0lLTXhYVG5XV2xocXRpb1VtSVY1MHBvNitkV0swVEVrd1NmdGkzSGJXdStFaU0xMzVFVWtOSm5Xd01ZMjZkWkExTVFDVUExbHRWSmRtVXlqaW1mQVlEaXBCdEgwVFVnenpMZVlBZngyRENJYUdyRFRuQi8xWWtJSVYxeFR0K1Fxem9UdUh0ejE0U1lHV1lvRzY0VElyVURNdjIrZ2NGOXp1bGdzQUdCQUFJbVRKVW1hL1laSVdxN0xIMEYwTlhScCtvcnNZb1hYV2xtKy90NVBWWnFKdlFrVFVXdjI2bGdxVGVic2lDT0ViazlxalNXMlkva0UvNW5OMUU2TDFJTWVDd1BEc29TbUp5U21JRkFiUi9ORkpxdGxROFF5eXNVYkU5NXVFbWRTa3pXcEhSQkVNRUJiWGpXcjFmVjBvczlnMUk2WG52T3pCcXNDUERKU3BuMmF0VVJWTm1PTG1wdm9wUUwwbTBGWjMzMmFwY3J6d0xPUWM1ODNVZ281blVjMXUrdC9rUVJLTXBndHN6S3pnTTRQMEI1cWVCRDNqTjNIMGx0cGFESVE3ek5BS3duYklzRWxhaTBLLyt6YWtmNHFjQ1ZBZDB1Q0poN3QvciswREpmSGlqYlpSdE1GUlRwZXNzRkkzUUcya0sreHBkL0RvK0dWY2dxay9ydWtRSHZnWmZQMkJpTGdCaDlCU3VUSloxa3NuMmdTTnF6NjRqUWUzWURRNDhSN0JLSWRtQVpBWHdNR3BwQmZ5VG40UjR4UFYxcjg4bEl0QmlLWlRXTHB0ZUJ0ZVZ4OVozVW1pRExtUExhZjhPOUVTbDJXS0k3dk9DK2dObWVHb1dub2VYOVdRaHNCOUpYRGRYZjBGTTJNMUVHejFVZzZGYzY4eWhKVkxmNzFYZW13eVhKTi9qdy83YXpLT29pdHgrTGI5Z2hXanRMM2ZjWndwekNiVHZYRjFqQkp2Nmc0SXlaUlhRZElEWEYzdFNVRElEMitEYmQxbmVqNXhjd0FZNU5lUlA1bFNZOFNyQmVmMCtOM3VMU2l1eWhmNG1yeng5bldFdkpXWkpLT0dSOXgwMW9zTFB6YVp1WkFPSUd5NjFRV2Y2R002OVdLUEkyVWxIOGV5MXJJNnd3L1dzazJ1ZGg0MnhIdHptbnMvV2dQNURrVGtJNW9oSGxWaTcwS3J3dTFFYVB5VkR6QlBLc0NmbDNJS28yUDNiZFRVKzlCRmlnaEF0YUw5RDBERFYwT0F6MXc4T0pRYVFBL1BSdkI2WXI2dzMxNFFPRGdGSlphWG9TQ2dWajhSdHhIdm05QXlhZVBxUnprTGxha0dpSGcvWHNIcXRMKzBlRXk4MGdBZ0FCQlA3N0FBbXQySU9JcElOQi8yN05aRURNVm1IM1BBamhJT1RWejBaMXAvdkY4S0x4Q2Y0RHFDbnhwZGJUOVhLZTMzUkljc045RGpCRm9VYzZJc0lvdGxNWWRHUHllZGNpWVFrem1QK3NhREZuZ2F5OEV3a0JIaFVJNm10WE9QNWlmd1pIRHNORnB1QTdVWmEybjZyRDNwVDJqakt2RUw0bStUSDhnb0gxZG8wT2piNlo4M3pTUDU4dUx5ZytnblRIV085ZkVDdUhqOXZONTNPZTcwQ2xlUXE1Wk1XRVNBanhYNVJDMzFLd0xBVzIvWGpLQWJMdENuUEdVNklnMTZjdVQvRTFEcHNQdlZYTEdoRFIvaTRNajRMNVBDYiszaG9weW9TR2RrWmUrbEhIYjM1cmpRcy9FU3I3R0dVdDJLTm1ENHFhUDlCSDlXOXN0NmpuUnZvSWFDR3RTSFlEaXZhcTdSQ2N0ekd5RnFuRlNmR3Foa3lHVUxuczNtZkRIZzJkZzQyanF3MXAwaGZPbDZNVWNaZmN1Y2JwczVZWWdzci8xclZwZ0ZzQzVFb0ZUdU1zdlB5K2htdi9ZZWFMU1JXOEVHbmlIZ2c0VlpqWHY4SktQY05XTXhPOEFoK2tSL1VZRG1kOXA0dm5nejFiMGtlR2RGdXpodkprM1FpdExnTTFsK2tKUjBaVGhKZ1JJdmp5L04xNnlLZ3RrNm5DOGhOeEdDYnpaekI5Q2hkWVRPekZpUnA1cFp6UjU5RE05TmJsZjE5U21JYzlPTGppcXVHOVl3SU5FZ3NmcGdqaFJjejBEUDlwSUhFcTZ2TVVtZ0oyY2NwRW1sbGpWUXo4QlduTnM5cGVkWjVwRWNqQ0dHT3RZdnBDYXJmQlhod09TRmlETG5iQnRLN2IwQU9TMm5rSTk4dGhJNHpqbzl3T3cyV2VMemhZSzJVOUZla0dNYXYyMDJENUVpVFlwL1l6OUwxUDM4U3h2TW54UTd0K3pJd256SGNuYlVOVTBWQkFjS3ArUVFHaVE0bGp4WHFjeFhSd2ptaGdMNCtnQTRNUlh2UnBlL1NTZW0veDNxOW9aN08wMXBCSUJOaVRFWklzVjF3NzZKME5DMHhlaHZCOElxcEFXcVFpcjAvK0puS1J6VmxaNk9FZmM3VDh6R0w0K3hVQWJGWHUwN2haMjZPdUhzYmFzZjJ6ZzFEWlhhM1hmOHkrZjdLL0dxazRNb3hkbUljWlFBMkhjV0FSUmE2aFZPa2dwTTVSWlVtRjdraGlCQXJCVVBDU0FPcXkxUHFML2s2TFJPODZ2NlU4MGtLYk5mUHpzdU15Rk83R1RCelJwalMzTmwzd3lJQ21YbFNDeXFQdzQ2UVQ5WFpqNWo4OFZxM0dHaENVdGFlQnRMMW1LYmllUmRydjBBVzJPblR6T3lSVjdhc1ovbVgrQVJPaDd1NGlyQ1dpcEZ1VEIxQVVHcTJTM25GbDhySjVsUXNiOEpOOHNib01RRGRJUlNMWlVsSkhrUk1LdHo0b0NFMXVqU3FNVUxITjJnandVOTdPTGM2KzRPQ1VkRjk2SXd3YmQ5Vkx3U2xpdWw2L2pnY1VkbXJVUUQzM096Uk9na0xkMi9JR1hMakdJZkJJRjNSV0prY3F0d212bkY5ZExLcHFqNm5qZWFXWmdESENOZXZHZ3JCL1UrenVmZXVmRzNVdWdVc3NmbEtlRzBoVVRjcmVuMnBoVm5lNHlvb1VCMzZHY1lVYnZmM21Bcmtrc0hjRXoyU3pMaVFjL00vQVJQSTlmSXZpK1dxTzBWZ3J2RXlTU2k4WnBmbkRIRnQ3UnVRQ0FBRUUvdnNDelBGejB1SlZnRHk0MzY0cmxtc3k5UUxQc1JJdEpkS0JCaGlWU3F1WHFsekc2R3dIbytjdGNCdUJBZm44WkkrTEY3UmxCdHlsem1FNHNpTmtiRmNCUFg2QWo3R0tlVnBkZFBVSFpuWTJ0VGxQY2RCZGYrdi9OVC9hY2RreXdBU2xpaW9rTHd0U2c0VStmdzVhQTd2KzRDVEpKNUp6d2lzeGl2eVNiYnpYVFVLb1Y3d0gvdUVaM09sN2dmbU12eVlLMTBTK1NMbGlieWZUcWdLSk5iS1k1WkxGNkwwUnZLRVdrNTFLaHFHWjN1djR4L2NMODBYczJrV0tIY2JhR28wVjlnTDVWS0JqNGI5WURDMVk2L0tQOWJTQVYxMUdHS2ZQMXNZZGpDYTVJU1BmSGQwU0swZThtTEFuaU9kSUUwbHNxOE9MeWpBbzIrY01INW9FMXBWSGdRL3hoZFR1ektoT1B2MWhvL05ZSEFnMW9WSGxTQjNCaG4xcFpodmlPeFVLTkdTYkJveXc1ckozR0d0VjZWZjRpL21tODF4RTdOREV4Z1k3NVp5aXB3dWxXYitoZWxEVEt5S0VHVzRteE15UllJemc0SmhBbFRKSXlTRUhpR244TE12MWMyT1hlN3JpaE1mK3BUVm1NSFczVE9aUUJOWGM4VHAzRGpnRUNmNVpQTVhHUnI0L0ZlTWJjR0hlSHRRQXZKOXY5N2dpVjUyWlpVbG53VGJSZXRzMHBWM29DOUxlYlVSYWx4RVJtWmZqZm8veWNVbnoyTVJKVnVKYmVudkFVSU5LdFlHcDArdXJ4dzFuTllqQnFzYUxoUUcreVBReS9DMUFLNjFaWTRRRmhpOXd6aFBWekdNNlV6VDNPbHJYRnRPQXN3MEd5MUlMN2tJaDFCNldHbXhnQk1WV1JKYStOdVNCZEVDSm9UcEE2cngvc2tiRmxWUjR1WjhRT3NjUW44dS9RY2JVQUtxZ1kxWnIvMmhGUmVVZ2lORk1SV1J1U3ovQ20wRDkrVkJ4RldqeVI1ZFV6OGRNbU1aNTYvZ0RKSU0vTGQyNkI0YzYzUUtMNlpyY0UzcXR3REdmNWk3SHRXOGlHZUVtOHFCQndlTktGd2tCQXRnZDROaTk5clFFakx2Zk9NOXdiZVFSaUgrdzNlZU4xQ2Y2L0hWRU9sVVBiUnRhdEZpUHBORXpUaGhNdjIrek9LMWxWd0dtbGI3dmdvZ2cyN1VIOEJRaWxaUmJwaXBsdXdDRXlnQkJGcmZ5R09IbVVLaTdFc2MrRVZaM3ZwZ2M4bDFUTTJyTGpaR052cnZpSDV6dVdpZnNGVmlzU1o4aDJUUDhudXViMDlJREdyelBGcmw1OWI0U0t1SGJtVVZ1bDA1Z1JiUXlLWUpLMjVKTm5FZ3VFLy9PV1gxZmI5VjhPNFFNNVlZUGgxYi9ycllQeEw5M2g0bzF5NG9xd0FlM25sYnZoYzJCV3ZHQ1BmQW9rNVJ4akI2S0xBZ1NHSHBBQlc2b3YwNXRvd0hRdGZYSlM4aUcxWjVFT1dST1U4bzljbGp4clJ6Z2plVFRNZkFwUitjdGFNc2lQNC91MzAzeTRhYTRRRFMvaG81bWRUK1NFQThGRnNyVXI1bkRESHkxMStQSU9zVmRVdzN0empBdUVWL3crSDhyYTB1Y3VHSXhDN0hSYUxrY0U4OUhOTWZIeGxsTFg4cC80RmlwZXg4djZaU3p2aXlMQ0FwbVhSZXdteHk5STJjMmdzNU9SU2ppV2xqMlorT3k1LzhwWEh5QXhsK3BtMWhVNFlwTE12SVpuVVJleWdkSlU1RXVLUUlBQVFUKyt3RFpYMVRkSkhJeWRFYjhXNWFuRVNCTjBKb0lUYkJ2VEc5YjhMRnp4Q3pHcWtmR0p6TS9PWUJKN1RLSzFCM2c1T2ZZa2pvemMzNWxQWTFmcWlYOEswL2ExQk11ZEdhamswTThIRU1pL2hkcVBmaDBTRkJLbmdZRXEvQ05CbDBjUWwzWk9Db3VjTDRxWHcxK3RQSkxnTkhWNUtlcUNJWVpRYWNLSE1OZlhKWlBRaU1qL0c5UTVCL0ZGVHdJcVBQNGUxTGpYMjdWbTc2T0VYR1dsbEczeHhXMndrZFNVRFFUSVM0N2dYME04MVAxbEx0SVcrbVJhaFRwNHFpYkM1UFo1VFBYbGh0V2ErZW1CZEhSLzNUZUFYWk1vWW9zTE10Q2crU01mVHp5TjgvdzBudlVjNDE2VlE5eE01VGlBalo2akdENjVqVGFZRHpMQXEwOVdYTTBJZnZCWk4wNnczSk1HYmhxYUFseE5KenFJUGk4M3NKci9KVkVvYkZRNEFoREtiWWdibElFWm4vZmEwd2kxcU1pUXY1bzE2VVBFdHVTMngxRTg3Z3ZqWlJIeXYwcXkzYUc5ckJyQXBKRlRFN2Zha3FLR0lWVDZQb1NGSjV6UG9uQkpMV1VzOHRtTXM1QlBpb0Y5MWNSR0NiMy9Dd0FUbk5ycE1xWkh6WVFLVEEvQlYzSHo2VzFtTTA4eHNmWDlIb0FYQkwzRGM0ZEtyMlViTko3czl5cWdLc21nTlU1Nm9lR0owbkE0VVBZZXF5WFJrUzgxMW9HZDh1S0pHY3U3aXkzSTlLampWWWV6QVF6ZVl5cHh5RzdsbU9UV1ZlYmhnUzBCRmJxanI3cUVuNTdObGRGKzJ5NERqVEFCMVRWMktFTjBOSXFBajRjdTlnOERTVms5VG9zRkJrbzNoSDJJR2VxWFNselJidVJQT3I5ZGJwL1ZFQjVvNHlxSGtXdUVEOUQwc0JWMEY2UTFZd25EYWYxbDArL0dBR1cySGtqb0MwM0htbWN5VnJ1ZU9reU9Pakc0NnBuYmFndkpQTVU4YzVPcWpVbHVPSlcwVTZuVWN4d3hUa280ZG15SCtnTmN4V0kxajZ2MkFvQlgxUE1ybDUwbS9DOURtVG5IaDB1VkN2NGl3MTBwYWtEK2pNQVJMVTVtMzJsd0wrREd0SHBkK0k5NGhjZGEzYU1NbWV3K3ZXb0pqeDAyQjZ4RFJpZ0dFeGd3MjZRZWZ6djhFYkJNUDlicVRzQjBpbEZrYzRvSkFmL0o2NW5zK0F3cko5bmZFQlF2K0IvOTJVYSswbnpCWWdaMHRHUWJOWERjSmVYb1V2dGRLUGIwTDVHTUV4emRzOGlSbUx0M1hRMDkwdjZveU5RV2t0Tm12eVljeEovdUdzTjVjUEFlQVV1ejU3YjAxQktaU2JtaHhnTnN6NUNhVGd5cEtXZHJWSy9rZGE3R0cwVFIza3haZGNXdWpKUzJ3dEFML2kybFBCemhteTg0Vjg4cTNta2FRME44blZsOXh1VmNyM01hWmxGSnhFSFg4c00ydUpCbXhQWkszM3BxS2NWUC9ucGUzN0NaVWp0b0svNkloaFVWTFdvV29nb1Ntd0RDTW9PUUd1Z2NBU3Axay9vWFN1eW9sWG82YXM3Wm5IVlJNVHk5b21PVkVBVldQZTdhTlhkSGhhOG4xY2VsN3lXUXQzMVpRSDNSSU5lem5XOU40T2swU1h3S2pFbWh0dnd6QStxeEFGWlRzdTlkaWJFdkVIYVJ5V1BxWTVSQlVRalBWeTlUdGxVN2NOZURCWVRJdmh0b1lDYnVveVBrcTkxSWcrSEFnQUJCUDc3QTFOOG9IS09UZytGRmxrL3dYWmlxZFEyZU4rNkJNUHJKV1I3dTZKbHViQXRUZEZGV1ZOWGovZ2Z3ZDY0SzB4VkJzZC96amx6ZmFTaEdOVFgwczh3dW1WYncwbEx6VVhlMmtTbGUvMVJBd3hKc3RQVWgxMHEyczdoaVJrd1pwY1Fmb1RLM0lnYkt5bi9NV0JpelJjQ09WYW9STzZCVml5R0VQaG5qQi8xNVZreEN2UDFJdlBXbXpnaGVkOGNmbWtkMEZpcFlsK21Pa2VDcFYyMURRZWVaK3Q1KytVRXFOTGpwbkV6dEtEWElUdjZkUG1FVXJNQ05ScXMzNXg1MnZHSUVadmsxMUxINHBUL1dMTkZkS1hoYnE2b0lWVHdUL3Z3UWdKNGtVZ3hpVEJkM1dleWhmeGVaWWhLcldKQVZsZkFkdE1wWTJJTXBmL002OFlzb3pFSDhqbXIzN0JLSlFBT29LZVRmc0p0OGFMQTVXSWR6c28vazVKVTZBTVh5Y0RhdVdkdXVoTXRCRVZqYnFlUGxSdnAwaFBXNTB2UlVtQy92MWkzY3Z6WlhIeWFjS0R5ZER1b2IvMGM4SkgwUll2UitQTVFvaXpPcCt0ZVdMM1F3VDhYWXZPbVJ1SHlMZmVhaGNVTzBvRkVQTHZ0cm1XZzNNbmI4dCtsV25tS2ViaHZ2aXNSd0xrOHgvMzZrUTdxYS80djdQbzN3cDFwL3lHS2wyVW1ZQUt6RmF3cjBFSFdPN1RYWXRsK3hVVTJ2UG5wNGFSUVhWd1JsTFkvektrM0ROM2E1eTRvY05SNDRNVloxTmV4RWZhV2pielFGWXMyOWRXbjE2ZEI3M0llM3lJRDdTTDIxcnBCa2FMZFlxL3RHVkVPcEMyRlJET2VuRzExdEhKclpiSGdZczRNczJoTXRDWThQVHFHZnVsbHZhdG5ZUEFFdjVCbThXMFIvOUNyc2JKQ0tyWHo3SFNOSXRLT01POEM3VTFBZEw3K1RiSmhzUHF1SDROV2s4bFhlWHdCS1pKaHFrYlhEZXd0UnFoRlk0ZWFlWUxpeVVzYkdubjY5MnRXZWZpdjlnUS9USDdwQmdDSWE4cG51Z0xBcjgraGZNQzRaQ1FnZnZtci9US1F4TnhBR1Bkdjg1VG9vQ1NIc2VmeGtLOERndlRLWHJ2NlA4U1NUUk1HSTY4c0R4NTFudHhxQmlJQW05TXYrcllkQkphdlFpbEFCSjlWeTZnSTJiNjZIRyt5MHlWaXQ0N3BRVlZpVXJJdndoU2M1NmV1UEIyUSsreEdLSmhoYlhuaHh4TTZ0Z0xHcjBuOVlVYTBHdVU0Yitpd0x2ZjA3UWJ3ZTdoa1pDeDVDRGJqK2pMVTZKTWdzUEJYL0dWclBoQlkwbUxCNTRpUWM0amxBOVdWM3pLckFqemg0dkxtVzZQU1BZbnN0LzF5SU1TVVcva3VuSnFDdWJGMUZseXE5Q2pORWNxNCtxQWwrY2dyUTZ6Wk5NbmJIYnN4VjRhUSs2akJIRWErWUhwTDh4T3FyNTQ3aWJjeUFaVXRwVVlvS0wwRG9FSFg4S0FFMjhTdG9OL0h1UTBWNCt5RDh1a0hWZHJZanY1VUdBTk45SU9FSEtlZEJOTGNTZTcyeXJTeWQyNVN2Q3lZaXljb3hRc1hLcktaY0pSa1RtYnhnV1laaUVFTU5TSkVVZDBodGlTbXY4alA5RXplM0pQVkdTUXZnTERzcGc1dG5YRHVHUnUwUlM3OGNLSnZYbFJIdkhUZFd6bEU0L3BpbU5SYzRXb0IyMFF0cEpieTNiWEErZk13SjRUMDVVOStLMklDQUFFRS92c0JCaTJIMmsveVA3K1lYSlgwMUFjdzdDZDhCL0MvTytMMDI4Yk5PU2dva1l2MVhnWHJRcHV3Y2R5OEt2TmU4MVlnelE3Y3A2bFRTN3ltNlVLL0JOU3VvZFIxUGViOTdZYlFMT0pZanZxSWtFK1RoZ3lHcmI2cnNGZnJSV2s1aGxEV2t3TVhISGJFK0hBVzBwR0p5NUtCNWxvRHBBVVVwWjNUMkN3dlZoMlpKK1NhNjZxQjRUV3BYWHJhRlduNDNlcXNOM3BFa3hzZmdMS3VJV1p4RERlcTRhSUJKZGVvQnR3NGlHNFZFQTA5TCtiSUdjQzFLWkMvUFZDSGxCOThzVVJoeDBRL2Y1RUIvNDhoU0RLZ3U3VFJpblkvdkQrN0tvQnBISER6REM2Uk5QaGFmczllSWl6WUlLdVBNVGtSNkkzeHV0Y3ByNldqVVM0L1ZEZkl1ai9zcnNqVkVZVUpGVVRORTMyM0gxYVV3YlNWOU44QVhSSTNNSm1mdUhUOUdaeDd1bTJNNCthZnpKTXJyV0Zzc05jU3JObzRYQ3duL0EybDJFVnJXNmM5Y25nK3QrYmxYNEV2S3ovNHd3WHVnMUxFeUVHaHBrNFQwTmxmNDNTdlprLzBUUU5PYWtaUzlxWkdZRkVpcXFCTHNMUG50R1J3Z0E2bThrS2ZKdzdGZ3BPaTZGN2JmK2UvMWhvakkwYjY4NjFpdnVPckFIZVg5d2RTWmVuekZ2TElmQkdRMGozVDlnS2FtZ0dZRVg3Vi93QTFMQVgvTXNGK21DcTBzbFJPY2ozYXdjUDI5RFVqVXNKNlQ3UStMa01oRGlFa2VQa0NmYm96b3dhM0U3RGgrSEhuUDUyWGw0UFdWZE13Lzg5dGdwc2VKKzJ1TFk0ckgydWJCMy9EU041VjNSMzVCcmNTRDdkbzloK010WDh0KzJQZlVsYmlZTmVqUGVTWlFZNXZyaXZoNXEwaUNRaFE5aGU3L1daUlQwa25sNVB0bUtCVWNwVTZ4dnJjbWlUbFRUWnd1Z1VBU1R3OHUxUEQ4RDlPMnZwTDg2SjNWRTMxWEprUSs1QjhGajkxbTBPQm1kYURUckhQZEpOUEtSZmF4NTU2b2hSM2RFU0RlcXhZQ2huWG9nL0QyN05xTU4yazg3cTI5TXBxWEg4eVpNeEM3ZmFOMDFaWE5nSjduNnJDWDhRTFlqemlLL2dSaWFDSG45d01sWEJGbkswODd0RTlQcnJvdGl6dkFaT1pkejduNUhvRXROMm1rV2pRdkR4RTJpTVZ5ZUowMWJ4cGIvbDJNb2dldXUvUmJvWFVpQ1FwbEtobHBBaGR0RTg5ZURPTmszaUNvKzEzRVJJUlNOYzU0YkNoUjRXZzkvR1B4UUhLV3BpNGpoaTBQSzg4RSt0SGtBTE5SRmphc0JGVzJpWFh1dnhSdXRCKzYvRWpxUzJXbGVUampZaGxxdDNlZVZINDJjay9NL3hhTFJTTlpQdDJtbkVvRTRLTnZ1TkFERnJ4UFRuTFJqamVwWkE3d0k0STNNelRNUXBGdnlHdCtMVjVuOGtBaENaR3ArNTYwVHhJM0JlU3V4UFo1YjlxOXNRUm1LU2t4WnQyK0x2Vi8zbzhraStSOEJhRFA1TEZkeURkTG5saW1QTkpFdkVLV1VPV3ErQmVSbGtIM1FhbHpyZWlkR2V2ZWMrRnIyUnVwNEkvd0ZlVThvYnUyZndremt3SGM1TXovRXlXaVE5VkxzSkhQaFFYQy9aeGxpMmRKR1NCNzBQNmxQbFRsWEZ0RXMzdmhSUVRaSG9JRlhYRlNlTzJrVThuNUMra1d3SUFBUVQrK3dNOWFOR0Rmb0VLV1RFQUhHSlhwWUNqckVRcmI0VU80RlNmUVBqMDA3amdTOTJoRXJDUGcyMmhDT01zTmlldHFmQjJpcXdJdnhnN1ArU3JKZ2JPOWJMODJVYitONjlaQS9BUC9hRnVieTUyUmdEQW9wUnRzUUJIdWRrVmRzN0pDeU0zdlFPL3VLQmtOU0dIQTQ0TlR5SHY0ZXBnNVU1cVRwdzZ6RUZQTVJKd0pLMmZEQk5GTTRTTG5jeFpsWllQV1NXUlN2Z0RvYWRIRi8yZHNMQTRmb2tZWHNOdUpLTEwySERKakY5RGhJVHdJeS9tUjM0NnY3WmllTDBLS0pzamFmL0pKM1krK1FZUE85ei83aHhxTytmWnAwQW9LRDhsVWVEcFpCbUNoS3Z4MlZ6UjlkZ3NqakdUZXNTUUlLL29TeVk5OFNPbHRlVmxEQmZrUmZCNk4vN0FoQTl1dnlFaXRTVEVqMitYTnp6aWRlc09PTldwQWNwTmM0ajJYUkdGM2pvbHpSZnZ1eFd5MGRvNHNtQjRWaE5RQzJuWFhKaWxva3EvSDBkZStCVGVSQ0lyY1NvWHhTMFB5TWZsUlh6bStuRUdsamJKWkJyWkZpZU8yOWEvRHdidllsRHppTnBDc3FVNkVVMFRrYVdFWk44MnZaQWhZM0paaDVMRVZPbWh3eUpraG5ySHdIZXhLZGhhTjU1TVZnMHg4MWZoTllzc1lzZnRITjBtVVZCRWNEdzBCT2xmbXd4OW54bU4vU3J6Y1pFOVU2VmZWRkNyQlF5bEhhb0oybXlGY0J0Vkp3VFNWbFl3NnJHcFNWbTBFM3VGQVVnZWU3MG02K2h3WWQzbkwxd2hkLzlXb1FVUHZPbTQwbjZ4OCtFR3VLU29iRXo1dDBSaDhkSW1HTXFvUUhvTEVuRGQvNzc2bWU3RjdreC8rNFVremVaWTREK0xWcWpxdnNBOXJpaWJrWWdKTlBkd1c5cWUybDhCcGthSmJhbHk3SWxoMlNDdFhieWhHZlpqMlh4SlF2WFBjWUZ2ZWxZdUU5QTludVluSWtSTTI2WXVQOFhFdllLMExDbzJ4L1hPMllPTWZMK1pWTW5oM2FtNkJqd2Q4VEFLRzRkQmZnWmVBbE90bGxQd0ZDTDZhUUsrNWJ4TDFGNXlPT0JZd2RIQU9NbTdtNlpZandyOFEvbURBUDhUOHlsdFRmN2lFUG0xQ0dLQkNuNUYxZHpTUzBQZEo5Nld4bmd2bjI3aUNGUHZvTzl4SThJNk5VaUZWbFF1SG1uYTVMUTNkZTdJN2krdHpjUFpsbXdjV0hUME9nRkhadGtxZGN4aGI4YXlJZzNmNzRPVExxWUFHT09VZStKemw4bVJzaWgwT2lmNHZaYjcwZm16djhYSHFCU0VnRWNiR3dqZWNyUlFrLzlsakN0bFd4ai9YU29BV3hnODR2blROMloxT1A5dnJ4VDNERlMyaXRyQnF3QWlwQlp4N0hQUm9LeGF5TU42aHUyYzcveW4xTUNTZXM2T3Jtc1h5OFkwL0R5RjJKMDY1c3VDTnZIVGFvT2ZqU0hGaHFEYmNZVXJOQm1NVHNaMWxhOGQ5a0JPVEFndTArZUZlUzNTWkR6cXZpZ1MxOEE4am9sS0gybXZzVWVPY3gxV3lqQ1NSejBSRWg0Y0tJK0ludWhPQ1ZFN3BKNno0R2xzZmRmek52REo1UUgvUklFMUJmVHFjMXBBY0Z4cS9GdHpSYncrU2puY3JreFJuMzNJbVMwN0drejJxVnhjOHRGbUh5MElqY2lyUkJYNzRuZ1h4QnN1S0FBenVjTDNDbUlQQWdBQkJQNzdBNFpzaHNncjlXc1QvU0FsK1FaSE1wOEI0Q2VUWUVvL0FqMlArWDhKVHYyam9OZUNyUFU5SFJUOVdtM3ZEMTd3TGZpVVhFZnNwd2FRek56Wlk2eDNlaDZMMWpudFFzcGlZc3NZSTMvcUZGWHZSQWE1YUNjTXJOODVXdzQwQkN0ZGFmZER0eFdSenhsYVB5VDVFTVVFVXFLbnY0TFlkNDRHYTVtbXlNd2cyNVF3RWcrcWkrRUphQndDbGkwY3ZNSGRqd3Zxby81bW1wSFUydk55NlJMWXovei9HSldsN2dJTkcvOFlpYkRZWGxYTTJEZlkvWW5WM1duZ09xSEpoVWI1MnRzRDVCRk9pUFFqQnhyOU9GQ1JzSlFIRGJ1YzU0SW81eVBhMDhkY3JFR3NlOVdScGdTdExUb2ZmMkR6NmNlZzVEdmRCWW1hMHpWUHBrR0ZwZXZxZ2JGeVkwRUhEUXRic1h1ZkRRaHRoTUU1VHJHSnE4NTBlNkFGaWYzU1ZKVzloWTBMckxpVSsvZmw2MllIN0VRV3NIQUk2cWZRTkVaNCtiZ2E1Y1VwVGpvOXAyWTFwbFFHWVlqMzZ4b1dmWDgyRmJ3MkJob3JLWjZOcWVKM1pWcmgraWkxakREeUwzQTdhNDJkRzc3ZHJLdTdkdFYwdU1sbXlqSE50d0VNWGNySDd1c2FJaEpYc1NoSlQ3Y3dTaFd3ZHZxWEtiU2RUTVl1dm0ycGVtSHpjVFV0RDhLT0NWdmlteERjdERKMkJMUnBHc1FJV0pyVWJYSnF4RzhMYXhHRmEzbm9BNDdsNVRpenFnd2ZuQitJbXVWZXE4cXk1aDNsVWJXWmk0cGQvQUVEOGZBUVIrSXlKRmxwdkdkRkhyK29HdkFvbG9BSEpib0dlYnRSemovdWNhU2UxMUowMktlSmt5WTh6L0VMazhNbEJ0Yy9XL2o3RHhhbFJmck1wODdWQmpvVmpTN0czaWs2R2pPbEY4UGdrV2NFNVZNTnBZOHhybWdLdkJFM2tDVklNUmdNZ1pUa3RJMHR1NWNlL1UxUUNvajAyNGxyaTJzb1FLUnVTM0VRTjZBU3dMSTF5STk4bVN2aEk0NWhydHl1dURwb3FGS3YrSWt0LzlPKzZBMnU2V1R4UG9heHVla254akV2RVgycTBMeWROeDdNalVrTWdSSWVobWZkR0Q4OUI0UUJuZUVCbWR1MytWRHphNG9IWnRsQTZIZTI2Y05PVVBzWmxPcUNWOVZ2NmFxQUNnK1hHT0w0UGoxQzBINkJvbWxsZ2VsU0hBNTNDbEU0VERjSHVLVXBHUjFuVVRYYmVUNzhZRjA5RUFGT050UTVxdWs3OVhGSk81NXZUSUQ1MmoxeWllMXRNN0VjU0FVTm5PT3FtVGhocm8xMDcyaDltUUxoV0VyWUN5YzFSbzNsZWxoWUdMbTEyWjJhVEdWS0ZRTWoxbEZxbldxTm9hdVpzcDRLU1pCU2xjWTEzRU1YL3pJMVptRXoxTXpFbGVkQjVCei8ybUtDWHMrODU2bGRURzM0em1obHF0QXJtMEFkN29iRXlwWElnSWZhbkFQWlgvM2N4eVJYV2VxL1FWb2M2anI3Nmp5ei9ZVDFnUVZqSGRGWExnTXFGSVVBUjZTd2lkRitpaGh2cnpucWUxRzlidzBmQ3hQS1lBUXhNRVBkUU5iYlMyZVcxcUk0clVYRk96a3pCS2NUS1Z0NWl3c29wVm9tS3F1RXA3UFJGMVZyMGZLNEhsQVJrdzJpQUxUREl0b0t3RjdoZXFVUnBtRmNPRktKMERYRXJLcTdlalNKb0Q5UHlNa0NBQUVFL3ZzRWVIRmxiQXpIQ2R1MWNuTUVGWkVGSy9PblhqMTBibmNyK2ZvQWZZcUIrWVExS0RuV3lpK0ozUHdSOTJsd0FkVXhsQ1dUcDFOTy9UZ3VocEljV3AyVUdua1haV3RpdU5uNkFkMUNZN29sV3JkR2hrZ09lNERJQndoN2svWjQ4RFRiR0oyYzIxc3pTWFd1bVJkQ3JCdUVWZ0JtS3JLaTMxSmtQdDM3VXhyVStoQW9ndVI5YmVTaG8zMGQ5UWRwenE1RHQ0YnpydXZ6L09MV2hmclhwRklnOVArLzR2V051U0RtdlM5bHZHMWJUK1RxOFNnRWRiNlZpU0pnMC9UNHVmaU5OeWhZc08vSjBnN1MvcHA5NFliOHVOYmhJNVhmNlIwd2tEajNaR1hKSjZzMi9oeVl3V3VlQ01IdXhhWXoxR0Nlc2FqWW02Q2YwMVNSMzJiV0tNWnJ3SkNVbUV2dkViNitQTkMzaTRDK0xrN0YvR2t3WGlUYjd4MFRTTXdHeWhsRy93aXdRcSt2OUdIV3NBVG9FczNCTjRlbTNpdWlZTUFHaTFYNGVwSVpCeVpWbUN2NUpkMzUvZmFkWGgzTFVKUVhzMWpEUWRVdzJ3MllEeFlMckRPUzZ0MmsvZ25Ec0dvcFlvR3NrYVRTTzUxSGp0ZVBBSzViaTM0ZEdsclpEb3I3b0srVGI4cnNCQkdhMkVZV2I5VVU5L2JGTWpwR1JPNVpYRTNsUEYvOXJaNHdaeCtQWXZhVTVOcW1tbHMvb2RNYzBJV2Y3OVh4MDNaOU1ZMnRMVUNtdWNLT0NYcnlUelNLV1VQMEprTzFGSmo3RFJBUkNDSmFzWXhUbzRJaWRtY1cvem9LKzJBZk80eFBuczlIdnVwRHFRUnFONm95NGdLNzkvWXlTQk10WWljWUNoa3NLRWhRUXByRzdHVWVxeFhWS1hlYUxjOHVsTEI2Vlk4UnZ5b1RqeGtmdWlGOGJLV3JkU1VCeHA1VnE4MHpOZVpkY0ZHWk42Z0gvb3hyc2YwcmRMWHFwOTA0MSt3ZEo1ZHV1dk9hc3VLYTg2dW9seEhCa204RExaNnozMENhai9ZTklleDBiRmZUc2pGdmRkMis2R2s4b3NYWVN6WXhiTjhncnZEZHBtZHpsdUExMzJPQ01SQTMrcmZNT1IrSTZYcCtvb2R1bkllcDBHbzk2YTB3MjhOYUFQMmJMbkgwVWh4anRCVkw4dGlaN3UwWVZaTHV1aUw0S05BeFl4dlVhQWVEVW91alBwQVBGbFdjODZjaldObWJZb051Y3pnTEpRSXVvUENxaWpMZXFKWGt2aFlybTdOK2dYWWRkL0dENHVDdzBncndmVXJpeXdycHV0ME9INGgraXo2OVBGSmw4blYwQWJWTlgyZjd0djBJWXZTNjhTSlk2bVU0QVFjRWN4MFVwa0FLL1A1aGo5MWNzY0pTdFU2R3ZSZHhQRFlrNlFITExZM1lUSjZ5SWpIUUtrMGU3dWk2NWQ5Z0IxMVBXWUwwQ0pnd3N1SFdoZ1BwMnlnQkZwMUZqZkU3Y2JWM2tlckhITUdJdFFIeWgzallhcUZMOGI2UEhUdUFvR25Zb3FOb09oWFNmb0tZcysxdHpFWGxlK01VeXUzUjlZazZjOGhYdEh2c1ppanU0VFF6VFViQ3p6SW1GZWl4UEpSaUo5UGY2QitlQk1DWnJDZWdkdUJSbmZpem5xRURIdllRbzlTWHREak4wU1MvKzZVVnhCekVrQlV5T2VOQXlKdndRR2NuU0EvdnozUVI0UU91OVFkNEM0Z3NKZXMxNVp1ZmhHelJBWkdpaVFJQUFRVCsrd1MzL2p3dDVmTy9hWXF0THlUVkErM0tzTTJzK3VzbXRhU3dsS2tZbkdlZ3M3QVB0KzREY3JFZzJvV2xiYTg2YzhpVjhqcENudzlrKzlYbzBjTVRCajhCc2I2S1RGb002d3IxMTdZT0RRSTZuNmphVzJkbzlRdnh6RXE0TTJDWGdNLytZMzlDZUhCK1dieTcyQjNYUEZlSGloTU15K0hnK3dIZ1Z1Q2ZpQ05oWTBac0tBV1dPVGxiMlBiZ1V3UzhGRlZPVjRSOWNSMy9HMTQ4M01tVExhdFpWRy9SUUFlMVZjVkJjYWJUa0ZBT1g1Tkl2OUpKdCs2eXI1c3NqV1kxVFowSWU2eTRRbU9zZEtBa0dFWkhNamNETy95R1AwdXM2MkZzQnVKbllUMFhWeG5TZ0Z6VTloUDVKbnhjdjhTbUlhU25WRzdZcUhxR1BrbysybzJjNjcxQ3JMMGdnZ1FkNUZPVm1pSU1DcTc1MWVsS1NxOVVWVW9rcTRVa2x6Tm9LbENZZ3VLSVNmd0FNTm9ObjMyNDlpOVhmbkhvNmFmVVFjZ1VZVGp3M0xQckdRWWFkdHR0VEFLODlUT2YvZUhxWTNIUUhvOGlVTWxoN3luRkN0T0pPQjVndm1rUTZWYU9KR1hKRXBzbkttbWpXYjJQS25zWGVxaW1zL3M2U0pKWi9tOGdEYk1tUTlyeXJoWWFiV25zK0Q0U2FubGJYdlBFYXE3QTUvYVNENVFhdCswSTlpaFd2UnMyVDRIOStwc1p5N3ZFVGRVOVp2VzF1aWZBYVgrZDF0KzhBemRiNnFxT2NPWS81OEx4WDhHdVdOQW9wS2VZTFhKS05SbnJkQmpLWGcvRVIxVCt1bFZrL0JpeG13cnEwZ1pPaFYrTXhPTDVPYy96Q3RQZ3ZkTExnUEVscDdlYzI5YWtUR0VISmZxQmFXM0Zub3pxcnNYa1FzRVRhOXN1cDVUaTJxQnl6bE9kQ2lIdHlFcFpZYlEyVkxHamV5QjUyR3NVQ2FLZHlrTW0rdnZxSFN0dkZtVjNZcE9SbHdIUjgzKytQN1lMdEQxNUY5clBUSEpGNmRhOGtBTGx2cHBGb1hmSVpBbzQ3UmZqR2ZJTHA0YW1PSGF2emk1RFBMSGJHVlRlUGZhU2FJdjFTZHoyazRrampzd1h1MWZudUpjNXQvQmhQSFF0VmNTZlF3di9Yb3NWck9takkzaTQ2b0RmWHBSdzU1ck5zRkxNeGkrZWRGSU5xbnlVQS9KWi9XVVkzQU1FNEtXMnM4c0ZuUmNHRS9VMXppUmFXYkFFSFFKN1JDTG5yUjFZSlMycDZGNGttVFJFRm8xUjRuZzNEZFZzeWJHemV2eUNwMVBzQk1lWGl6c1VYbURTOXMyUmQydHlJYWlrNUp2M3pZNWVHZnJpZVJZRTQ0VUMxQXFkOTlNWTVZclNnTjZQTkhWaEMySWtRUEFSZnY2MEdWMWtKQ0R3NGJ3a3JEdml5S1JXa2pDSytid2VwakZQT090aVJ1ZnplRzVjS3BKU2lmdkg0THJIaWV4RktDdWhFNVFFRDBrRC9ZalJ5bStjTmQwcktNRTV3SlhqSVd6TG8wY3RnMEk2RHJaRkdZMlhVd1dzOGpVTEQ3YXptWmE2S0R3dlp4M3RBK0ZZa1E2Slc3azJRNUtxQTluUHhHV1dJZFlLU0lnRXl2QVpaUklPVHl3Q3ZIUUhTMmR0ZW4zY3d4NGFUVEY5NW00Mk1WT2hPbDBXb1JFcTRMQXByMU5FVktHT1U5LzdGUUE0WDEwYTFYTldBbGp0eG5TcjdxMDYyRi9JamFTK09HTmhBZ0FCQlA3N0FJSll5M0ZKbFlXK1JrSWozQ0RWbE9vU29mbkZSZWxrMmw5R1BqS3VIa3FMNGpkdnZ2K05JaUU2czJEYW1xN040NmdsSkx5dXF4MC8rWCtKemtwMmNJc2lyTnlQeHN0bUI0U0d5Q0VFYUNNYWpmcjcrS2RBdVpsSFJxeTBaaUZJUmM3d2RoQjE1OGVldU95dU9zcm5SSlVyQkZUMVZwMGduVHBEZ1d0UGh2eDY5bHgvQkUzcHVZNm9QNFJtNkZMM3FSOSt5S2NubFFVdjRlNXI1d2VSTExmM21CVEtkTkJQQnJkcU1iYmJZbWtKTVBhWU1vYzdBZmdaLzVIdTFYUDlkcHQ4QkdSbW1UQWFlZVF1YTBJRjJ4VUNNYWVOV2ZqQTFkVXlQcVlDWUR6eUkyMkVpTUZOTnhvVElZbTZxMTJBZHdvc0pLdXFqUFRnMzU2U1dremtRWisvd0FwN2p5Szl5UDJ3TWNHOGhQQXZRNDBXN0d6NXZGQ2paUlhPaWZ6cUsvcHBXcWdHSFEvOWlXUnZsdUd2TUUyLzJyQVBJN3FqQ3VhR1VxZytlU2p6YUI5WHdvY2lXRDNndzV0UmQrdHI0eUdWM2EwdUNBVE5BWGNiL2JZV0t4RE83bXVxWnFnQ1h2RWJOcG5ocFp0UU9jdll2NlByVk5wR3JTVjFyUExRSlhRVkI1ZmF3VCtGRkU3V3BvcjR6L1RidzhIZmRsOGlMZ0tCYStHaUhKYyt0YkJ3OGt3RGtXT1hYVjc0czVJT09DeEY1c1ArQ0RaYmZ4K2w2ajFUMHVXR3R4eXlia3FDZ3F6aE5HZkUvMGNtRUlkYnJRZmtBS3dnd1NNQVNwYnZlUGVLeElOdHZ6NUlzc3o2L3JlNzJuUVRzWkFQYmZXaTBla1JvdTFoWXdlMkgrVnB5QkFoODh0Y21aSWM2SmE0OTVVODJjR1pNRjRBMWJpNG8yTGV1M3A2TkVaQUVzU21Rb3NCZDRYQXAveXNiY1NQUlJQa2ZLMTV4UUovcDdZQzlIYkUrM2JERzZWQXZRWGN3OUM5MnZ6aHRTMFlsa0ZPUS9Od2xUaUZWRDhhMjd2Ky9QejJSWUlqSmFEVmFaYlNCT2FYSzJSeVRJU2wxalhUcnJlVE1pVFo1VXBXM3JicGl5eXVkS3dZRXJXb0ZJMlRiS0Z4aXVxYzJFWDgxc3RLcXlGQnJnaDA1VDZOREhheFBoVnRZWExIVHFJWWNGM1Joc2U5Rzc2SG9lS1gwVVViSjB1SHZUNDdFT2JjR2FWcFJhVmJFUEJlaGZ2eGY4NE0rUTZZNFFOTDZieDI5T0Z6TzlKL01JUUlueDZxaGtGdHRxa1VubzFjSDdHelZpb1ZOMjJKejNrSSs1bStDMnUwc0x4ckFsYk5VWktNcm1NZ2ZCTXFEKzVqOUNMM3BPNElhT0ZRRGtnMFFqdmhPMGlpZlFWMHRjdUVuUEJmL083NjdDemttZWMxMDVhRGVNVG5HNXgyVjk4R2R1OWZtZjJid3luR2V5RnJqZGNwdzY2anViM3VpRElDMEU1SXRCVWVYa0F0UnZBOXBSL1hSWFJISis3WFBieC81Z05tSzVkMzZPZ1lrQytNOGVqWXFiMzRMMjVUdnJPZkVrcHdYU2JuUGlDNlhRM3FENVEyaUZLYy9STnFJOVJBTkpIay82TmQxeEpwbTA2YlZhVXhBOHVZMGJvVmtpNVdGbFJxaEZ4U2ZkYTNWdk1vb0xMc01VRlk4WmcvZzFzSzQ4VUtkbTJuM2JtdC9vcEJpOXdJYzIrUER1ZFdkZUZXOXBpcnV4VHE1VzlJVHFjQ0FBRUUvdnNEUGpoUDJ1OUJaVHF1SGJXSDBoTlpEWXAxRlNQM20zdk01SXdtT3FkNnR4WG5OR3czOTcxRnlEZkFXUUI2U0lmclNWV09McWRLL0pJOVUybDdGR042bkV1Ukxtd0RoVkdOZmhIVzJrMldqUCtmMERmT3c0REFveTY3RE9yMHNHSEdxb3ZpZWlPN3VCbEcrN3BjTmYzSHkzTXA0NXIydnJOK2xtOTExZkZ5TkZtckdGS0xkbXRLTFZwTUZNMFpMQ0U3R05udXhqK0sybi9zcEpiQ0tnRy9xNDllL0lOdlB4OWIySTNOcHpEYTJCRDhEV00yMnk0N250OFN5SUNXRmlnMktiNDVaRTZjNEE4bVBub1pjeFhnTWkwWTVNbC9ZbDNDOHNYb2FWaUk1T3Y1My9TR081L0tvL1RPSjJKRy9BSDVwMWFGeVlLaE9ob1V2WnRrYzBreC8rREkzZnMxWkhaUHp0bisrYlIxMWJ1S1FnT1Nlam83RXpSa3YxZHNQZnl2Y3gyQ1R6RDFUWjRjU3ZCU2FDdzhyL2ovSW5lakY3TUFTN0pDUXdvcDNydjBnMEx1cDdhNHp0bnlHbUhUVmVJQTVaRXh3TUNicjZNb3RyaklmMWxmTVJOaDN6NDk1MHpSZER6dEl6ZERkbnVTcWdocVcxVVFUZ1QzOHN3SVAvcmlveEFlcjV4MHljemR3UGl6VFdtVWJJa3JyaVhkRU1nT2xYdjdzTFdFVjFWdlp5WjJFdXFjQ2k2SFVVVXk0K1k0Mzl1ck1aRVRGMEJhTnNoNVNyakFFcXd0OFBadU8rb2dEbm9yejhkUCtyeGZVeitOZFpDK0JOWWh1dDdXZWlYcTk2Qm1XeFhOUU1ZcFZyS0NDUEJxOXA1T0Y2ajBndEVoZFdlc01aNldBNG1pU3ZaUnZ4eVNxUWRaNEJBcVJ5MFdGTk1oVnBpQ2tzczh6aHl4VkdndTVoUi9tak51Y1FHSmZhVmNqMDZnQjNjOVM4K2QrQXI2MTAvM1NRamFVL3BIQ0dISTNVSndOb3BoVTZMKzVZN001ZDUweFpkYnVOdVZYOGQzZlpBaXRTN3A5blF0b24vZm1EMzF2SFlCN1prSEVyR2NjRzBONmdyV2NQc1lBTlZuTkszSlhKcjNtaUdHdG9KZkJQU2ZMMDgzNXVWUlJ1RE5rc01Sb2tMRS9oTFlqMURmTXJxbzdDQXZJcEVlL1RielRnUVIyK25kNGdWRzFCLytiRGNEdXI2MkdnaFlrT0E0a1hkRWlRVE5jQUpRbGVybmNzd3hKM3E1eHlQMUpycXJvQkpjcFk4RHJNTE9iVUMvdDlRQlowcDMvbXAvOEJ6QjFzeUlqdkt5ekZJL3M4S1kwcXJIZ2tGQ2VzM2tLcFMrRkVtQjVsT3N4MzhBdzVhZ2xCbTA0UGpBWGpqTW54ZTAxd09MNnZuS1VnTTdxNXdLN0ZSRHhZRmFIMG9ucHhWeWtaVXUvMVFkKzlBems3WW0rVjVVZThTeHFwQkdpV2hXNksvQ2dnSkM5NUtXWjQrUmJPaVdZRlBpUldRS1lOL3dhRk5vekRSNWdMNzJ3Y0p5bGpZUnlWclJHUHdnR1ltb0pVdXp2Uld3OEwvamxNWGMrbmkwUWtqQ1NEeFNmLzcvS2NYblJxTmNVVnhaTnpGZHlIZCtmVWJzWGlyVGhsa1pxd243dGdqdnFlL0NVRXZ1VnZVMWRnbmtsY1c3QmhhVTN3UXpZdzRWQUMram9XODlPMlRjOFl2NzRmU3hHa0NFWUxlYUZDV0RuMlZxK0trZ3had1BXUDk3NTJFSmk4SGIyQUlBQVFUKyt3Rm5nOHhMd1pNeUxPL2UzN0FOOFg4QlExWmN6aW04Y3ZqNFpsSGVJdE5OVE9vN0dzbVhQN05neWxTbXp2K3NtVFYrTlJmNWFMQ3hDSDBJb3dURGdKSmxFUUVZRjNoN3hhS3JFck51K3l0M2lLQkdpOThHMXpCZEh3SlZaTVRkSGFoby8wcVB0KzdNMUpEWTZwbkt2NVhxdkZvZFgzY05seEdZM1dBVE9QS0R6TlZmeG5sSlRKbmM0SE01Q0pyNW15ZzFNbktjT3dUWENBQzZjd1FlbjJIMEVsL29oeXhWTkU3eWNTOXR2dW02d0pKK204bS9yblhXUDN4REhXUVRvTHRkNjN0UitZekNtRHRCMCtlWCtSZmRUMld3c2tpdDVjQlI2aTd6cXEzMlJDdzc5eG5PSUE3b0JKUmF0dE91ck9iYms1aWtnbjZxN0tjUXdIV0M1QklvcWF6YUdDYTkzaVpSQjNoMlBJL1R0cFRkTGtRYUdrOFduaDRkVFpsdDBPa1F5ZC93WWlvdS9uaTNsRGplMGJ6VWRtaTMvZzU0ZFAvazJ2UGtvcnhNMmc4aGdiVmZld0xXVHF6U0VvYUdrNS9acGh6Szlrc2gxN3oxbnl2bWlSRGZ0SkJTeGV1R2ZSRTVmYW1wdDJKVHRoenFPenpRYWdLMzlZVzJlQzNlOWY4V3ZVVHZPTlFIMGxUWXBGcElianVBZDZ0N3EyRjljcGpUenFCODF4a01jMThOcTVDb2VaUEhSZCtSRkZra3ZIcSs0MFYyQ0xsdTUwT0Vxdnh4TmxGWlFSMmR2OUVMTnYyajEvaGk4bjBxWjFzOEJIOXRzSndOSkJwaWcvRTdmMVNhUm0vZE1SQWwvYUFMaU1oTmR4YUJ5Z1NUTDRYanVqR1V3SVF1bXAzd2s2UmJyZEl4bUF6WXJ3SmdORGt1eGNyVXhYa2lGU016NC9BVURINy9qcnFma0V2VUFPVXUyT00yUzFHbXBocUpMZ0lyZ0I1dnhqNjRRd2EyOVY3TWxHT1RGMUNlNkhEcEV4RlZaOFVGOEswaXRlK1BrcGM4TW8wRUJSUC8zZGFKNkQ5T2FwVjF5R2xPcysyY2N3L1hQY1pNeitlQ0JjQm1NM3hFRVJMczlNYUM3c2ZjeTZydEJCcnBJY3I1UlNBVUdKRUhKaXBnZVJPRGFRY0htTEp3a1FIdmdZMnVtRjhQMTg4NmpwdGtPNWVyaDdaMFNZWTRmbm5HWGl0SXBDVFBEUEtmcDhwcUVXbUxlemFtOW9VdnJPb1I3TlJEOFlIc0Y4ZGo2ZzV5VkR2eUFwUlp3OGNwNmFySVdJZGdTcmlib05ibm5xWnhPbTBVdjNKWUFnemJmdk1EMGpKak5sNjBIQW9nU2Mvd0dZNkpNM3NKcWRVTjBneGRzd0M1OVQ4ZkR3eGp1VHBqRjB3RTdiUmRvazdWVjFudXJsNTF1SGxGSWpJZE9EMnUxUkZIS2pQMHVyOU9XajlSNks1YTNYa1FQVzF5Y0dlaWxmdWt4WTBRN2w2a1E5ZnNJSEE5QWlyejZvM0hGV2hXbDZERmsyRDNxYWhnOHNYWEVKQmFMNGh1KzFPcTVtaW5MSnluMGdJVlNZSmR5QkxNSHY2UGxxZlJVS1NuT1pqYnB5cFZGczdzZDRPcjZPdDBibnVPMnlGQlg4K25Ca3NhMlVUM3B4RjE3UXA0ZVdSSnBHbFN1QTVnOEUvN1FhTU0yTmV0OUxGbm1nNk5UK0NGU3NWK0JBZXNXQ2ZxSFRkaEd5OFV5eXlqZzlwazRaZTRMNGNnQlJycW5HSVY5dURSVktTNUFnQUJCUDc3QUVSVys0eVlmRHN2ZGlsNDFGQkJuNkJ3THpOczcwNHBZQ1ZLOS8wa0REQmlpWGdnZkNGWUJaQjJRb1dGMmM5RHphcldpd1JQV3dra0YrSzE5eVh4aEMwbmpXclJPak5rMzdpaFR6ZVE5WTFzMml0WE5lNDRTWXh2WlJIQmVXTU5mcS9MNW5jVUhRMUVYUC94cW13cUpTWlpobkRremtDamtoQTRHNVJhREhUOVBLOUpuTWdLaXdKRzlkdUExdWRYRldzWHpMd2lYNVFpdTNQQzBxZlBmTUtlME55VHNFbzI4WUxSSEg1Rk8rQWVaNkFBWUQ4VVcxdFM2UjBWK1NTNzVjYkNBYUN3NG5xYXFPL0pwdnkrSUFYMnhXUW5hK0FBbmltSlFyQTd0TThEYWhCSUZCeTlYYTJ0bzZBeTd5WTZta2t4ZDhoQVJROG9KYlEwbTFpUmgwYkNuNVZpdlYrM1hBa0xma3c1N3VkVG1ra04ycGtadGNTVSthSENIV1JFbVdqV3M5a2VLQzJlOWhSM1E3R0o5bEFsRTVKR21XUVNJdmNtUE5uejdBMlZ0SVdwY3ErQ094eFJ5TnVKS1p4dHhjUEhhR2FkTkp0d1ZNU1Mva2FHOVJoOFV4MjV4a2JEc0JqRUg2dFFiQnNIN2hMUVRRNUtTUEZkVlVzOFVXWkwyVHNVNzhXcmpvdk9qVjFGSXBBWnNLalpCQmI5dlpBVG5mUCtjTkpjczBLeVgzY28yUHJOL1lyNCtjNTBoL0lCNjBKNGJoVHdGYk50bzdjMGx5S1BvdWJPWnZ5ZStrWGR2RUxWNC9PZHQwaHoxVjZYZng4eUlMWUN1M2I4K0NBNEFGdHM3K2JueWZXeWNtMGFtYWJ2RzN0R2lCNjhaTjFjekhXVFFDZDQ4ZDcrRXZUTXhQN2poN2lFZTJSc3JzRkRwakV1RWZBMjhBR3VmK0lpU3hnbzZDWXNnSGRSV3NZK09KSjk4VU9LVzBtVzdRY2ZwcitzUk1IeXFDeFRoMHN0RlJxWWNraHl5MkRER1dnSjAxOWI2V2hCcUZtb2xpSHJZanUyaXJSbnVwWHVCeEVSeE1zcDZ0TnE0MEdmeWdNbGtVQTViNXZZQ0FqUXA5RmtGQWpNRUp5VDlyY2MvMFpHTTVPRHZYTHg0Y1ZDVW5sb3l4NWhDK2NNcm9UOE5neTdFVVlLSVJBcjNZdUp2S2E2eWl2c2FzOGhHK2VlcjhuejN1OWE5QVZnQ01ueHdoNG5sNTRFTXVkcFlGN0U3YVhCbXVtb1J3UHRVb1BoNlEyY2xhcmFFQWRId1dJOHZzTmRSQTExNTFrTDZvQ1BxeHdvMkwzT1hlOHFSZ1hQR3E0UDNZNExlOUl0MTh0dkNaRGlXY3Vyb0d0aFQxbkRtQXRFd3NiYmFERWxsVWNGK0xiWjNIdjBEY2dncWVWOTlIMEF6N240MjVTc1JzUUg4cXJRNlErM1BESFVxZGpicGN1NXcwODFyNEZYcGJ2NHRuWEpuaFNIOVhVTHBlOTZpdFVPdDZ4VGU2RjhWa1JhSWdZWTJXM01obE9PWmRRZEhwWTFZYWMwa0dPMWZFNGZFcDVUZHRUNXIyTW44d2tJWEV3MGVuempWNDFwRFJwNUtFTmg0WHVLQktsenJTY1hPdEs4U1M5a1ZiNUt5dXhFOGdDd1QwSjhBWVpBM0NWZm0wbzNTMDZ5WEI3U2hqSzVuME54UEdpWFVsZnI0dlhwbkxiZG42aUxGdkJ5VEFkTkY0dENWUXFrVitPRTlTdllyOUU3bUZKNGVDcVZ1RWUwT0Q4N3ZybXg4K2dDQUFFRS92c0Q3RGhja1VnZ3o0N20rT0FsQVk5TlN5K29EaDNmVGlpZFgrbEsxTkdlNVR1elF0b25iRlJmWmJjWnJxbm9nOWFOcDRnVnJZeXBQUnRDY0JmQUV1dG1EbHA0UUU4aWZRcU42b1lvSUVrS0xHNFVqamMzTHkxSEJwTHdRaXR6cUl3VmRWa1UxZnRveHBRekpkV1Bad0gxNDR3cUJlc1BMcVdFY2NGNFAyVEZ6dkZCOEVNTmJUdXplN0xGU1VkNmZ0NXl5czljVllpeFpNalg1OTUxcStkejBkUGkzSDREQklLaDNUYjNxTGJ1dlRaRjRReis0dmRBNDJVL1FMZlZPZGNTRW14QXpRTHloY2dsMU5qNmliMzM4TmovMmp0bEVyOWRrc0l3bkZsblNOVXFMMnhNQWpmWnFBT2t1Vlpwd1oyZkhhSEtNLzkyMDF0QkRWSkhlMGxuNHZ0V3QvOHJQb2JUL01vWENMSFZCbi9GcHppK0FwbXdrUVlBRjZ5allkM09Ld3UvdzVlbmhaNEJZY29UOStRdHhGdktHM2l2VW9rN0k5MnNLdWcwQXRoS01vRmhLaGVGbkpsKzlDMWJLRmNVb1I5YThWUmlkVVF1SDJrMFFHY29KYzdVTG9wTnVOQ0lyMnZiMlFVZHZkNXFFbkk0VmJTMnhDYldXc3pPQm4zcGdOOEloZDNQOCtlTzhvaWFWSUtiUnFneDg5eEkxeUppR1VGdGpMOE5lankrRCtJNW1qYnRCMytaNTI1dUJFRlh5dFJpUzVaZUdQcU0zVGMyOC9CNURkR3RkYlpDQnRvOUhGb2FwZm4vL0hkcS9ld01BeXViRFdYeDZpRkdOZ2tDZGxFRE4zWlZPaDV3SzU5UnRDbXROTXBvMmp4R0lFSlR6Nm5FU2pQNXJ2VFltanp5aXovVDJXcGp6aThWdWh6bGpibStkSUJSdnMwcDlxR0YrcVhuVkNTdDhHcjJYZ3lVTitrVEU2d1M0QWZkSHpTdnFiREdzQXlsVTNzWTFoYmNNSnh5WVBVSis0VHdrcWN5S0dRRTVRWGY0RTdYcVgzU3BIMVRZYUtJUEEwc0hQZENpSmwrSFV6Wkh0TEk5NFg1MWdEUWlnOWg3dVFaUG1oODQ5Qk5QK1NrSUlNQUV3Q0p0ZkdDRURUNmRlTUlNbWJFelowMVZQdUhES1U1dGxYa2doOXZEM1BSWG5TMVd3VFErSlY0UUpwQWN4WUlvNmVlWW12KzdWeHhaUFllNmFvVzE4cU5Wc3BWZTZmOEFKRzN1VmFORlB2SjZPOE8yS1F5SENuV2pYL3BNeFlJaVNkbWFpbzdkQlNVeGgzZVlWVUZlUHE1YTRnVUNFL3JGM0t4TWloZFpJNzVtYXlmYUwyZ01wOE04ZGFBTmNYU0NDZUFhcFFQOHhDeWhkWktjTU95NlFad3lrVmR6eUpJV0N0dzMvbmQwWktnMDBIbEJVYWZ2SkRlTzBZMm9wWE9LKzR0WlM2S1JZbDBkWElVRUw4WkVGQW5ZNE9YZmVDc0lKVDA1ZGNnZXFqMUFNa0tYVGtobnVSSlVXV3B0bStNYjNWM1FpMFdyWlpybGdrSlFNNzlhVFcyZkRUNjNxSFNITHdLaUluNCtaU2lZRmdkYnpBWGZDdE9abG9BZzkrTVAyYWpLa3dRZVpab0lzN2UzbGVsNmRObThodzl5bFRxL09hSDNQTEV1N05vc2h0U2tFcnhlVnBITWttYVFGeDBYTHo0WFhvNDVIV3dXclVvckZnYW93NWxmRFZNZ2tOTnNjRVJsK21zL1JNSDZUemZYQUJKbjhOTWZRSUFBUVQrK3dEd3BpMW5TRGtZdlNHT0swSXZweTVsaXJRU1Z0eEc2ZHNsRjgxd2c4NCtZTmVMeXB2M05aUzdKVHB2QmV5ci9pbFlRYjVlNEgxVTJFd3IyR1BWU1kwMU5GcWx0ekY2ZUp2LzR5NlJyaHFaNFZtTDNzQWJXbHZKUnlJdlNuWkVCaDlDaXBFY2h2YXJOTjJRZ0tPY3hac0FBc1VicURLWlk0bVh3ck9hMjJsbUhpUEVYb2w4OFpKWmJrS3RhcFljcWVQdm05eFI0RTh4L0hKRXEvejRkcWt0V2x0L3A0UlFEb0JFTU1PZmZ2ZktVTWlXOExNbDRDMExWcFpnQkZpQnRSOWJmNzZIV2xlNEcwTmpIc2ZhSWNHK090eGhQR1ppa0F2YitYOS91aHZCVjVKVkx0UFpzc0MrUUZGdE9idHJPamM5RGFldk1SVkE0aWp5SFZ0K2JoQUE0MENCTUZOMFBpUHBabHFMaUkvNGhsOW04UVJlTENleHYycmhHeEJFb2U1bDl4UDNGUXNrT2I3SEpYK2paYWJBUFlYLzBia0VqL1NrbHpicnJnUGhJQWc4RHlFY3R3bzl4cVdWNU55eSt5WjdPWVpKN2M0SVNISzBSMGJSdjN1YVBDSzZBQVFJN2E3NkdIREd0cGNVKzArN0plbC9OZ0NRT0dTeTJpaTFpOHNuN0YxWnJjVGhsaitHVStmaS9pUjRLaSs4aStSRmZNY3d5Rm5wbnpxc214SEtFQS9ySGNRYTBrQ0R0c25xTDBvZDM5UWhBSjdYczdhVmpyOE5MMnhIOGFDc05Wb1FOU2JHUHhLOElwOVJGYVB4RGN0QTRnd2pwT01HUmczdGNGQXVlTDRTazROeGZnSDVGTVI5MlYzZ29VRkxOWUFaT3JWVEk2U3VjbllmUnNlSDhwbHhaT2RVTmdmM0lqNm1zclF2SXk0RElyYThVc3p1VGpBc3VlbzloRmpKNzdyY0UxeEV3dFlDRHhKK3VTOUNiVzY2Z21IaEwvOGhBVlExQ1VaTUtoZWN4d1ZNS0l1YjlsbXdPUUUwcXZQVE9EcUFneDF5SllrUEFLTmZZVkVyTHpPL0JCNkRlak5ZdXVseUZRcWswQ3ZRbnZmanVwb2U5MXRjREkzN09WZk16NzNETG1ldmFJR0Q5NEY3a0RrVmh3dlpTYlc0dmZ0WllDbG9yYzR3Z3V6MzF4cG9BVkdaN2wweC8vRkRjTTlobVBiYjBMWnFreVczcEh3d0dZMkUxTXdEamluM01XajlLbVpEeS9LWEdEVU5kbkczM3NGMXYrQTRLbHlNeXIwek9EMUZDbFIyZHZmdktxdk5mNC8rdklIT01GWDZCY2ZhR0ZrVmdNU0lmdmxBMnFvK0dneFN2OTBtTUZFbjlRMjVCdWhCY0RvQ2FVREJhaVJlZEFEaDY1T1FUWFhxTmVoSzlPQmwzTkFVN2FyUXNQTVhyUCtTTXdXMHdEYllaZGg2THVQS3JlcDl0bGYvald2SFl1WXVQV042VWZMWlFQd1dsa3VTUTBoc3BIUjNncTl0bC81YzZGVGwxUGhVbUswUGNOOVFZQUNTYUNtTW45TVFqRFVvSGVveWlieVFpRE90Z0IzYzNNTVoyNFBQL3pCT2ZJWU9oUEpNTCtLQTNWN3FNeHltZlByQWVyNVB5b256NVlDNDcxS3N6UFo1QXFQdTVxUVBVdmZsTFBlNTFhVXlNbUE0SHdBMmhBRlVWRzg1WWEyc1BSeER6WlJlMTAvUHV0Y0tDY3NlM2doVGJpL01WczBZV0JpM08xWldyR21sVFJDZkR4ellvSHNDQWdBQkJQNzdBQUFGd0xMemNYT2t2YmR1MzEvS25GYUt3TCtiaU1NOFcydm02Qm5mTmJHMWFwSXp5RGFzd1hlN1YwVCtNMXdJRzl1Vi9UUkxZQjJmWGd4b1NrOXpRU1ZiTHhibDkxY2I5eDhydFRTY0VmQVk4Y3c2QlpYaTEvUzh3VTc1Ly9wamEzY0hXbzZZUGJkT3BjZ0tjZTVOWXY4ZXQxdXY5QjRlb3UrV2JzUUxqWFREMHFOaDFpTlphTG1CUUJicGtxc1c0NDAvdUxFRHhkZnRvdEVKVXIrWUxsVk5jZ1RITXVQK1llazg4bksxUVVTak1Gd3NrVGpubHVGMkFkZzQ1cjNoQmorOURYeEozVFl0UVNDczR3UW8xbUhTcm5MUUcyR3ZQRmpMeTlkZnczVHJFc0pGanBYWDJFR3pnY083UnFjbUwvNUZrUXkvSzNqcGhUUlpoQk04UHBEMGlZRFdZSUJwc05acXZXaXFmenNZa3FqM0FGSGlQdndqZXhWTjBJR1AzM1lqTm12OGtOSFJTMFNKRGFyTlFpdVUzTm1ZTHV2cWFMS0lkUit3alhKenFGL2dLRC9nUnU5b1VrZW5IcG1EcUtOVjNoZkZPbWZwTUltNi93VVF0WmlOaDlkRzBoT20rYVNabC8xdnZJbmQ5RERTTEFlTE1JcWhnUm1UZ1c1dFNjYUJseDlQNXNidFVsSUhWN3dmWkxhZFJJNXg5ejl1RWFrVDRPem1zMU41L2E1NUx2VmdhZEw5b3d1b2NsT1M4bHQzR1JwYmxXeDRYTCt5SVR0MUZuandSeXJ3Nk9LNXNqclhwbzdKT0pnN3UrMDFCVmd4VHU0TnZqRW8rRk9HR1JrSTQxUEVTNWFFOHV6K09NZnRud0FFazRtRW1oNEJFQ2srSzVvdFRIVk1TZkdOY21KK2JvZHp4SmNxekNGWHlpMm5LR0E5WEY2YVdEaExwNW1wdlFYWVlFdmdUMU5UeExvc1dkTzRYQjk1SHR1TmN5YkpTNlFWVHlXQ3psZER4UnJkSWNQUmEyOXBtZTdkUnZDUzdYb2JYYi93WTcrQVpQRkpYdTJGc3cyekFhRXRCMDJ5KzVPbm5oMmpsY0JVYlBvTzZVUFZtdnBtNElLVWRucnNGMTZVR0tldTllQkpqaXFVak1BZ1U5TXdibDF6YytQbnk3cW9kR0ttRzRJTkJLL1oyS3hyRHRxWFI5TVVBT1hsOXRvcGxobjR3Q2xaY1cxYW00dzVsTVNzMnZNYi9rejNncE9oYlYvcTNhZzEyVkJCVzRBNEVXOU1IT3JiU0V5SGNhNEQ4czdZU2NiL2d1Z3RnM3FrS0NjOHpHSVU1UzJyVS8vd3h5dEpmakxESzdzT01mZ20wMnFJQ3J2bVpRRlZJdzFtWHFvdkRkZUpMRnZxOFhUc0hSc0djM1pCREp2alArcElXUVVZY2dEMWdmcmFXSk00YTZvMm9ESnB3aGIrbDNKYnlzTzU5MzFKVXlEZFJuTlhWL1VnOXFiZDIrNDdGV3djV1NSZDVad2ppZVlUcStWRXdLc0Y0alVRWWgzRzE4Z0RyVm1NY09uWDV0Nk5sQWhkbThYSmU3ZlE0YWNtSG1WN2RvckFxMng5MnZ6dFpDcTlRN2tzQkNXWnY1dk0yZUpOVlhodU5idXhtNUFsNTFCd2JrQlZTckh4TGFLMUNWTENlYlBVVUdKMlBTbU82Wm5SakN1ME14a3M1a281Y3NibzFQRi85L1owSlRScGRoKzQxdjFINjFGcmd6WC9vV2xMdldqZ3hkTUVHaDhqT1ZjbU0wcnVBaEhaZU1IRVM0MENBQUVFL3ZzQ2ZKbFZVNEg0NUxGcC9sbjRnRlkwOHJHeVAvdzMzR0VqTWcwcHJXRGFobkpUYk5RVzAvbVA5VEkvNitUbWZGT2ljaWludC9OZnhIcjFtaW1ZVGlZZnI3MU5QWGZDei9pa0FkaXBUdzMyRlF1YkM1NUMvdlJ5TlFRNDN5VmJ3KzMwc0FDdTlMa0hhQ3VCRFpqcFc0UElVbXlDTnJRaEJVZXk0bkU5aWFKOWV5Z09DMFdsemxxbEttcjJ4K3pWcTA3dHA0UTl6ZW5RdUloMWkvdkRqZG9KaVBPMmNYc1Qxek9nOHdVMHdtM096WEdsWGI5d2ZIOUpXVlFqRXRkZW5iYmhnTEx5a3pBMHpYbkVpS2ZyeE5wd05PRDhDWmxudkthcnk4UXZkRFFmZHRlK0pQalZaS2grRDN2eUtKZ1hVM3VQdmFNSHJjRFIxTEZBQ0VjaTVKdUhXcUViTm00SjRSdC9odmRVeWh0N0NMZHF3ODA4ZU1iVE53cS94Tnc0Q3BlV3VnVVdzYTQ1MUFiQ0ZQSVpYZ3VUN043WlA0cUQyZWVLZVpqVzhzcGFDanlOdFQrbWJKZFFiSERJOFN6Z3dZSW4xVlhxd1NIMGRnMG5PL0VnaWRYbEZKQW0zWmdERVhEYTVTSEQrUFd4Y0FVSjlsUVc3eHI2RlBNYkRBVkhwS3NvaDhKTEt6SjFsb3NyT09rRTlydExsSHVIWENDeDNaclNXSEZMM0t5TWczUnY2azZzazlpMFdxL1NoTTVBNnhrTTNpQXJrNFdoWDJLdzVKSVZaaU9lMzBaQ2l0SmdXODRZVHczcEoxa1FiRURqbHZWL0YyWGtqZ2VmN29CZHBGUFdjQ1RHYXl6ZXRFRVQySi9VeWtHUlRpd2FBNGtWSWVWdXd1Q05xL2psLzNSVjE4M21vR1pyQnM0ekk3V3NNdDdUdjhFVHp1TmdWY2RUaE5qZ2lxanNhMHNLLzJyNk9hU0xyUHplSTlrclpJb1ZYYkgyWW1yTFBROU9VeFo0azZxdjNiWlRXbkdiSXRTYWpoTTBCeDQxMlo0WjV2NVlONlE2Z1ZJdWVNY1A2SHdEcWh5UzlCcVdjMS9odFAxMWM5d1F6aXRxYks1NW5wTGIyNFZZcFhRM2dGVUJXYWhYcjlTZENvWU9VZVVCNzF5OHpKYkY3dkI2QStEMkZOVXZScEtPK21wWG9yc0xEQ1RhWisvMnB1d2Q2L2JPM3JBRzNmVW9kMFNLNDBHM3RTUnF5ZnRnT1pIK21ZdzRGZWx3cVdJOTFETUx0VHFkY1lsbFEwdGFtMUxoYkhJRU5lb21LNGF6NDBlc1pERGhpUnNCempsN0I3RUJNVHYwQmcvVlpmSk1rSjNIZW84RlVGNGYyb3MvL1pkNVpoZ1VHZ3lNazRiOXE0RlJnYXpQY0lhZDlySDlkaXYzSld3WjduVElTTGkrQ29ndEo2RDZjSS93N01XTGdXRG4zRmFnWGxOMWJHZWdTU29Bdlc4YnNjbGd0RHVZTlRVR3B1Nll6NXA4U2hkQ2phbERtRkxhQ2NQV0VRSGNiNkpCdkd4NVY5R1JWeDVONlpoMVdZbjJlZElKRGFuSGJGTUlNMVFKbFZVUThyTjFyaWluVkJITko4bitydkwvVC8ray81T3p5ZXBxVVpHTDZML0ZNS0RCNGlKNmY5M3E4N2E5OHZ1elBQNE5xbnlabVVoTlhYSVBhaGJZRE1QMm56WW0xaStqOXhlRWdtbE5UaE95NkdBOGdvZ2dRTnpaRU9LK2ZVT2hrWS9QV3Z0bjNrdlFnLzJGUzJTZGJoRkNDYlAxbGdJQUFRVCsrd1R1d1FzZURid3pnQ1ZZN0l0MlBuRkduYUpTMDZZc0g0MEhsVUtMOXM3RHk2MWVYZFRWbER5clkyYlUyNmNocFdoeXFBNUJDd3Uwa0hJUExMZHh1Q09jdTVWZ2U5alhKajVIeGVNdFpFTnpNSDJuM2xPb3loK3ZLNVlTSGQ2WlkwNGRneDVQb3Z5TGZwVG83SXlWL0tqSy9NdWN0TUVxT3NqUHlPa283bTdjb0M5TE14TmtYMGZaWUZ4b2MxSVRHNVEybUR6SWhhNHdrbGwvUWc1UWR6RHcrODdyRkg0OThBY0RaZzZoQ2pleTByWU05L3Yvb3dOaDlDQzVvb0o1T0l2eURIazVaVlNlYUpLQ0FUbEVJSmJoSTZsYlRPYlYydkNSYjZib1ZYQm5wamxvNzBrYXJPcFZ4UUlENlR2a0h4UlVLQlZKU2tTNVg4Zi9FL0FSeVBUWlZ2VkxTbkZPdGpDRlNrbys2NGVqZWpPai9JTG1pTFVVWHZlR1hXeWZZUCtUTUo5RDNHSkF1R1dpaDAyNkY0UXlzaklJdjBKNmpoYU1QOTQ2aG11QmZYV2lVa3l2U3hxU1BISnJaazZ0blZUOTlaYU9PRzJpaUg0SFpQRXVHV1pncTlVZU1IVGE0OTVxekc5c1Q5bmJkSHFoRkR4THhtK2h5SjI5MmRJYkhJdTN6RndwN3NINVcvYWNoTE9kYkpaZ2ZkdjkvZ1BuOG1VY2FjcTVHNjE2VHRNdGJkc1NUc1ZhV3pPNldISk9DZzhvd0dhV2M5Zk8rRW9ydG0wS284dzVKMVhPMTh1UENRaDc4dTIwUmhQRmUycUNndjg1dDRYYmxkVWZvelNVSzIwMzVML05YdmdSYzRnVGpyWlNENFdVdW1iYzlmNlJNM2ZQYXA2SThHMlV3OHVUTE8rTEdWc21USDZjL3Y5YUoyWjI2ajBHd0lxV1ZubkxrSEdrNitTQ3FLd1NTVkFhUm9BUWpHWDlPS21TQjY0b09JTjdNUldOcnYrNGJqL2l3KzlEN0xYZWxvRys1b0JiTVdld2dRVXNxYWoydUI1cjVpNWljYS9MZUdYZ3UvakpOaGdhcGNGQzJPaWd0UlhKeHhUTHQwZXZ6K3Y3WWxFa1NWSjJvTVhmelo2NUhPQlhlQzBJSUFlV3dGb05EL2JrME8xeUlDbWtkU0pFUWlsRytzS01JVXNLWWt3VFdpR2hjWmJJQWh4TzU4QU00bGN0OUNSQVFab1k1aXRSYzVHMWNrbU5Ubi9KTW5mMS92Lzl1NVFaelFENHBSVWQ4SFJ2NTlKOHRhTkdnZ0VjUWYrQ2FQRm1haXVlVkdiSmgrbjVjTlZVYm9qb2FRTFB1ZjV4TWtzTHZIR3hrV1EvRkRzdzdTVCtiait2RFBXWUJIWkNEelBrVnh3cXVNaDByVjJNOEF4bEFHblpVMGFMN1NnOE1UcldBL1R0cXAvRG8zQzVjbi9wcUFUenR5cjU1TUYwYTVRR09WSlgyZTR0WEdCSHphUnRBK25lQjFqQzk0d1pBRCt2N2hPSS9wcEVEQ1R4T3hDeHVVcTJmbi8wbVBIMnRpRy9GM00vdXp3KzYwN2pRZWdLdlNDOHAwcDN4czBrNDBXL3pyTndZcE0xYUhGcC91K1kzdGV6QzU5QVhJVy81R0EzWVpvMzg5WVhTOWJ1S2cyZCtyclZHbmd0TDFGMW5lMEMxcHVzY01BS1pjM3ZxS1pPYitySmFOUnBNRUZwSVNFYWxwSUZUeVg0ZHJOSUZRMTVzRUlrd2VBdi9sSkJueUpZNHFoTWFGQWhBVm5HR1JRcEV0WnhBZ0FCQlA3N0F2V05aTk5tOEJSSHVTMSt5MzAvMXU2WlRmSGhwN2kxTkxHR1hHYnhQemtRQ3dVN3lxYXYzTU9VZk1uWEVjaXV4V2hURCsySU1NSVJKUEJqZjJSclE1eTRZajRMeE5HOHVWQVQ5RWNMeDRmR1Brc2p5a0hndjZsVkg2ZnBmck5oTEhJSUhXWkRGNVNiZ0wwQlozbUNLVTRDS0doYXpmYUY0MUxuZHlueGZBdkd6YWt2V05EaHIwdU84a2VkQ0Y1aEI2SlRGUzVhekZSejhlSjZnTFc0R2E1QmxuMHlJQUlqc1U4dCs5SlZCdTZWczZ2WHFqWEc1V3k2b3lBdExCdHBBZVQ4a1k5YUYyaGxRdHdpenJZNGVpTWViTEFCT240TGp6V0tlbHBXZEU4SE0zWVV0WXBQOTlBRGYrei85ajlNY2J3eTFRVFlpdWtraUF1SWcwSStQdzYrQTlMKzVTVDRKN3B6d3l2ZWlncVNjcnhIVFZ1b2pyd3cva1FaZitsTGdRV01rU1lOMTB5KzVMa1NiK3JUYkFMVk5WMllpcElBNkJ3UmtxR2FrKzVLbEtFZTNrYjRPUGZpODMzc2trVk9IWERhNDQzaDluTDVMS0NhNGZsWWV5MUc2NnVQbExUSVY2eEdzNmRYMXYwZHNTWTRJYVRmL3QxckswMjhIYkJjaUh4SVgwbURxNWlMRmpBMjI5b01hNXJhMWxaSHhBL1RoWTd1bDZoc1BrWmhaL05YSENFMUlWSDlTSVhCMW4za1poYmlnQldPTlBxYnQ0elQ1dXgzYUdzcTZZUDQ0L25XOCs1RXVOQ214anc3QnB4WHA4V2x2ci9WZW03VE1pTHNHV2dtWTh4QllMZmczNWorbGJCSUN5RlppQ1A4aU11L2M5Q1h4THE0aElqK0NUV1JNQyszdGVaa0JQemM1enA3RHFRRWZmNGFQS2pHZGI2aEZVUWI1V0h4SHRzQUw1OVc5NjRpTlowQVpmRm5KamI0ZXRjMERGMVpDMzdlbTBUNGx4QVJjWmY4ZmdmeWJFbFkySXhKcmVJdWVsZkEySU9idFhtcGIrdWR4ekpuMllnZHF2S0xrd0VreURZeXZTMGpLM3BaYVlTOGhydHdPaFAvek9vNnZ6UTBPc1hYOXRNd3M0UUdxbEtWN3VJaGhCNXVHb0ZnT3NVOVJOTytBT1FzZE5TSmdUcWw2amwvaTBhcWxlSjQ1cDhST2xjUStzdVBRVkxVbTZyRlk4UnJPbWlIUlZrZ3U5SElSWlJ1Qnovb200WDlzRkE3RlpqeVZwZVN6NjlNWjhabDY2Z0Rhb01pTGN5NktvZU0zUTZMREpvd0UwU3RWVEY2NW83SHVHOEtHWEFtUXFEMXdUWktRUWxIQXBnZHlOaGk5czRFNHJ0OE9CaHc4K1IzaVB5d1ErZm0xR3I2eDNVY09tOFAwUnM2dEhHUEtkRTFUcUJNc1c5TE9IdGxJZ0ZYbFUzdkVZamcyekFIV1JUZ2xleGJveW9IdTlxRTlRQmVGa2J5Y2VHclVIUzdCTWNnRWRwMzhaang4dkpUL21yQWpmeU5SYnY5SHgvdTV5ZWpGWTJzbko4SzJhbjhLK3NnMDkwRERyeUpGc2Q1Q3I1SUttbmIyRVhvbHhSZ0diVCtLZFpLM0pMUG5ERXVOditvV1gxZms5WEpPK3dNdzRZVGg3UC9jcmJheEtSMzk0b1h5MThxU3dmcW5zWHZJczBCV3J1Q2dQQVlrK0p4eXg3YkxDRVNFbm9rQmFtb1hFN3JvOWpRZXZYRFM2dUdmWjV3T1NkT2hNclBjdUh4ZWh3Q0FBRUUvdnNBNlJXKytUeDdmOExNU05lZ1lQcWxHT3BVSUtoTWlOTksxd04xeWh0QTlxRE1CRWJXTXVobEsxV2krdWdZcTRCbXF0VWt4UEQydkk0YlFDcFkvYnNjMWNnZVpieW1WNmlYWnBiaDNXcGwwZmZNZzY3T3FMM1FnL3pSRnZDK01WeUdVL0RPRDZQRXZGbWR5M2wyMHNTelFaRkhxSTk5anY0RlVpTi9YS0pPYVZSdXc4Y01tQk1LK0g2aGFKdE9qSm1TOTNVQ0Q2SFo2bFJiSktReUowWUhXd21uTHlDWTBCUUlVTEFhVERGYi9MSEl4Qy9HaTBkbEoyay9Nb0FNN2FDS09CMVU1UFRZT0RweGM4NWxiNDJZcW12OEZVOXkxRFF1NW1iWGs3Yzhza1BxL3E1cTVmZ2VTRjlLK1FZenExNk5nVjBoUW1IWnJpcUhjTElxSlEwVnRPRkxtOUhONUUycVk0WmFRYmdLVnNQZ1hQNVBOeU1KL0VKUWRSOEVGWVFJeVBNWmUwZmpWVzR1bTE2T1RuSGtsZ1MzNlJXa3dtTlM2VFJESWZnN1ozMEU4MW4xQmJ1Rld5U1JoeFNTNHErYk5KUEc1V1RYSlJ1bWF5S21HdEZaLzBuZTlIWmNvZWdzaE1zQmc2cU1sVHlLTiszdzdYc2xjNGQ2Wnc5YU02Ymk4RGE1akdqNkJUUWtZTEhMR3EzZFdhNDBPdnYvWkxRNnlYSmtHYXRxNEFsR05LL3FqZmo4M21GcjlwVUZvUmRRbVFnQUtYZ2dpVkllWmlMZkJrd2gxcVlpMHY3RjE0b1BlZHNTMjVORWs3anJqU0JINmYxaHkxK0dETEM4QWtoRlNrNGdhck9LYjRYTDZBZ1NXSjdIUGtmQldMV2FzeDVtVHM1SFB0Z0ZMMWR5R0JUM1ZDemtUc0ZydmNyZkh5NFFnekF3QlgvSFdhVkRtQlk4M2NjYTlDZ0FOaExCRFpZZDM3MWZiREo3aE53OWdCUW1ROVVGNnI2R1lra000ZkRZSXF5NVJqQzhsRnFNZDdDS2FtZjU3bEczTmRJVGpYQWVVZ1E3ZWRDcENTRXFsb0dUelZlR2hwcTB0Rlpkam4vcS9INWJOaDlGV0d3YUR1L0FkVlJ6Mkk0TlVkS1hBdTBjOU5pakRWZGtZVG9IRkJBbzRCRXFJQVdxS1NuOVJmaVJZZXA3ZFlOLzlrQTZvOStxZVVWdkVESkRlTUJ4MEl5UVZJd2VEZS8xdDAvNUdQT1dFM202b1BrMzRXbkd5VzN1NWVrYU9HVEdKYXJvYlJ3dm9QTmc4UmxPN0RXZXVGSldLVTRRVWNkd2FUbUU0UVd5VnVnNmM3MklOVDdtMkRvQlFGTkNya0owby9DV0RqM25mUjFJVk1uNEJ3MG9wUUFEWnpPWVJDazV2WDFxd01PRGI5RVVkM2M5dUJlTWF3YU1GMmNuK2w2b3l6d0MySWl4NFJqaUdISmd4VzVyZWFIdlZVWlBNTlJib1R0TzB1ZEZUODZOSlAzL2lhN1FzNlF3d0orWmZCdFEvZUJ4OXo4YUpVa0JCWndaV05FamJBbkRocGZpb1VudGFxUDQwSzlHM2t3U2R1RWlMMks2M1RnMDhrc2tvK2xRWUV0aG1qYVlyQkxXdUlVTmhzT1NlRGN1eUo2VTAvZEtIQ1p1aC9jTkxEN1FhYk15TktXRHJRRy9QdFlZR09vVDlIbUtaWFVXMnpKWjI5OUFhL2lpbEpkelptek00WEk4eFhuS2FaOE5kSFdYOXdDVi9yM3dhY0ZGMnhIOVg4d01qZUx0bTREWk1YM2VxQUlBQVFUKyt3R3h0NEdiaWViWjF4NTFNTjVVZ2RiSFNHTVNNYkVldTlsTjllcHNzR2lRalBYbGtmdnZHM3BVUnc1aDlDMk5mVmRMa01HVGgxWDFMMzdSQzRvWWtKbzVYTmVacUI2ZmcrZldDUzljZmVzQWpyYWk1OTE4ZXdqV0d0RXphdFJEVmNqZEQrQlprdEt4MEM5RC9kZXorM016RldSSlYxWnEwalo0bnA2YmZFY0lHeS9kZ1MyN1VTYzhZNXF6QnJvcG9QL1RNYTcxN2Q1YlcweEE3OFB0dWRnbWgyMGxYMHVMbjlyOEJFR2JKVGZQMEdoUjV1ZlRVdDg1eVNzb2s2azVaaDZKd04yekNOcGJmWmhtczZvYzVRY3JGK0hJeTU1cEZPUzY3K2U1V0ZyNVVoZWIvODNmSzM2ZThtcnB0QUhwYkZ3RFV5b0FZWVh0d0MwbE9pMWQ5K2VVV3dFL01FVGVTRG0yYmd1QTBwdC9oNkx6alZjVDhuOGV0L2xCUnYwTlF0eHgwdnpsMDdzQU1TS0lybzd4cnR1NWlWd1JUdUdsd01QR3U0ZkhLaXExNHpqWGlMUkpiREJXb3VBWk9VZ1NwTWRJRC9QMEJPc3U1TlRyc25WQ3V1Q1lMTEFGTURtOUhGa1dtdFQwME9Fd2VBMzFzalgxeUNIZW1RTWY4QTBzYWw0NUk2cmlrdkczYUtia0ZoemwrSFVDaHdWT0dJU1ZMV25ZUzgwQ2NxVG5hWkY5MThuOUdORmFZNnV0ZnJoNjRRMmZadFhLYWwyeTJha1h1ajY0UUx6bEJMZ0tTZVB4dHlhM2R3UHRVSGJMbU5mZ0M1NEp2MUlINkc5emM0M1h1cVlhT3ZLbHd1bkRzZHIvMStqZVpQbHY5U3ZsaGI3MTZKb3BqMVJ5QkhzNWZzbEcrdmlqbCtHTTNZYkFWaVo1amxVU0dUc2Jrb28wcjRNL3QrRGhqRWM1NXMrSHJmWW5CSTJNTkp0Yi9sOXF2QlNBbEUvUUIrQXo0c0RLVlJUWWExVnZENzBHei9oU2dWVkd5ckg5MXJhTTlTU0I2SFpJK0llQ21PZDJ0aFgyeHhmQTRzZjFRSk5YUVE2MHRZVmdWNyt6eHRvWFFRcm0rUk1JMnZQT1NHRlFDL0FoM0JJbUJ5SkxsVFJNekdjNkxJZDVaWFltanVJMWpnZHhFTXN4cE9odElsSmtQUTVQY0ErUEtKdnBzdEUrRDR0Y2RuSk5TRzFUTTVHUFV4c2V5SWZ3TzlpV05tU1VHS2YvN1NWNGQrT0FieFBPc2I4OXlZYjRvdW5Fcmh1djgwYjlMZmd6QmZtREhKS3BlSEMxU0RpMWErdE1lMmk3a1VHWlJRQ3dZSnRZWFlqRHM5Q2t4czRWeGZNWDczZEgya1FEQ0V5TXZudDhQb2hSdHVrNnppUlV0ODZHamR2bmcyUExGM3dLRjZoQ0RMblJ6ZlRqR3I4MnF4VU10V3dJU0pxSFZDd0VKc2NOYzNydGtyZGlFQk1MTVJibENVYS9UN3QwamRFUmNzclF0Mm1sOCtvVFVYNXhoMk9EaWVOd2FOTGo4MXZHcllYS2s1U2QxZmtCaXZhNXNaK3MxOHpnUWFKM1dpZHZyK2lIOEU3S1BaT2JsZVF6cktZalBQTld2MEJuUCtlRHEzWlRTTFNiUlNsajVNRGlTOVZ5UnNINXcwdkIveTVNMkJwZXBMNGpUUysxemYrY2NWaEVzOWNBbTdlc08rMWdiS2xDT3Y4ZGlvdUlIZ0JFSjBLTDhrWFJKMVJIYXdRWlhTeERSZDVMMWFpUkxkNFJDVmVlOVRSUUFnQUJCUDc3QS9uUyt4bER0aGZMemswT0MveWpoUFdhVThIbUlIYllva0U0OHBEVTNOc09MMGpXUU9JTjVvS01vREM5d08wVFR3SlBuWkxMeVMwdkNINENua1V4MmhobEtjQ1AyWGhMRzlNY09yOXlUbE5jam9wRmNjZWZSc24zdWRwcnFLR1lzeXFTTVZOWnVoeE9ObGlFM3oxQ0RTMUtOL1p0ZkcwTmc3cHhFZWRjZFVGQ0dyM0NOa0VCS3hZdmQ0eFkwOTVDZ3lQT0pJVitXaDY0c2ROa1BNUm5IcC9jT0Y5VnJ6RDgxK0habU9pdXVmdmN0MHYwa3pBRE96UHdOWjRYUzlSWVdpNWtyMEZ4bGV5MEdLUmN2SjZEc2tNU3hPUnFEdUVEM2pEOWRtbnQvWFZWTWhRclUzbVU3a2lkdyt3VG9FL1pWQll6UllJbFowTVJRb0dHNTd2Z1FETFlvRDNTVGFWam1XTFYycVJzMWtOQk1RMXlKZmlnaWExdU4vYmV4N29Tc044TW9KM1k2czFVS2lWL2E0ZnZ4YlJJOXRDRURyL2pjK1c1MmRrVVdJaU80clVWMmRyQk5kWjJsalFaVWtqWTZnV1Y0R29HS05zVjV1Q29PZ1BjdXlCM3JtUkFxMmpiNXdhYkJvK2g2VUdHZmc5Y3ByeHVCR3o1WVdkbFltV1ZlNjRQT1g3b3lLTXRacDU3V3pNUDRlblhweGV0NHNmc0ZEQkh1MDUzZzZldlNoR1VzRlZ2a0lIY3JNK0s3bHByb0pWWGJ2c081TUZNN09Lck0rajZ3Ynp4dUZqNW5jTFdPZEZBM2lGMnlybTZ1WlVoSjVXZ3g5RzhLSjVUVDB3c3JPSCtBRXEzMnU3cHZrVzJkVXhMcVVtRWJHZkJUMEdhWkd4S1c1eml4UGdzVHBHUHozL2NHWlVNcGwzZWJPdURCNkVEb1htT3c2cXprcGRGckZZQXUybzIrbkpUY3RCbzI0NWM3alhWUm5yR2E4VUxvZjdaOVlkWUoxTllSRUVYY1o0T1NHWW5Vd0FrK05zWTVHdkVqQ1oxeXVqaUVyQmFKbFlsaTdPMFdISXNvWlI2T0NkMjFQNThXaVphcmZLaGRIdnQzdEJITmlHeSs1YnZ3dUxnTXIvclVpRUgyT3M1RkFkVkFrT1dFNDI2R2JHMys3NzBiYW0vQS9vdFpJSzZ1bVlQbXhFdVEza0p5S3B1Q0t0K0o5aTRHdUczeGNwR0dVRXFEdVRQOFRCR3ZrU3V5RnZ4WFZNVm1hTkcvWjRIVWk3UFdGVFp0NGhVQkpyK0crbG9HeVdkUGFFNm50bDE3SnJ2T1laL3QrSVNyUjdhZVlyQ1c2U2ZML2ZtM1VQVldrNGxsd0lZOGoxSDBsdUhER09aV0VRdGJRLzNRWWtFQ0d1MSt3RjVZZ1luZ2IzcmI2LzVUOEFGK3FJUWpRMjFzSGpJaTd5dVQzTXZjZnZYdk5pc3V0QnFNQjc5OHBGVjVkUStCN0dXK3BZN3pLenBzRFJGcEkrRXFJMng5eTdxdGQ1aUR5amNsUHBpd2pQWFpkK0hySDZPblcwUkkrS01icFgva29TbGtnSklGeklsUXVLcys0N05PTW9jdmtHRU5LdDVYZHQ4MmlIWkl3NEtlMlRCcUFXUlNnak91dkVKek9vOGR2ZkVTQmZlSkVZbzRHUHlGL05jbS96ekVnbXUwRTVVVTg0bS83dGJrTWZNZFliM2RRSUZVOWxhTngxK1BQVnN3MjFJL3k2eVJyWVQxNlc5L1NHRzRLMHRCRUhaNkpkZXJhLy9OOFQzZkxkaklWVWxXY1lDQUFFRS92c0RTdHVjWnpxR2hOdThoVUEwS294NXhpeVY2aDJvUUc5TVVTNmE1NTk1WDlLTVBOYStHQktod01PT3Ewb1NhUXF4Vm82UkhVREtYcExUUGRjUzJSeWlqOUtlalU3TFVTdWtUN05mYVNwOXdmTUY4RnJsRVA5VmdVVUY4K3FkV2hadzEycXlXdzFGSXo3d09iU3VJRkZqZldDWk5EdFhUTEtwbTF3czBmUWZRQWlCeUhGRWV2dUxlSnZFclM2V0FPdTU5dmZsWXVqeFAyRFlmc2NLSXpGVUhDeFgvWUFTckowck1ZVUk0Q3VmQi9pTjA2TGd6ZDA0RW1TUDJHMzdDR2dzVUNjcHFiaDJZNnpOdjhNN2FlU3ZKaW5PYjdJcDJmeit1Sys4QTJRUFBxRzRiN1YyZmdBU29sdHRJZ0JGdVdvVkJjNEtDd2czYndNNnVFUmt6U0U4QTc0TllDR0o0WU5nYTA3UFRnZzZCa0hTTVY5d0RxMFhETXRGM29RQW5mUlo5SmJnV2FxUmQvaHBvY2RITHYyaHNFdzQyWWw1WGxCdWRhS28ySXJKZEY4WmhIenc2QytTUjVrNk9MWUllQWNLekpzL2FVWEpKbmJQK2RFUHBkeWE3aWhxMHVkRHAwSW83RDhLVWVYcGdSa0ZoSFB4UjF4NjlSUXNZVEZpZW5hUWM2L2pTODA5S2lOVnRXQmxXeGZoUmQ1NjNmNE9oSlZ1WVNFWHRVN0VHbTl5Tjd2aW1PczFPRHVwanNxU2N3djJlaEZ6M3A0bGZ4ZC91eXl5bGRxbnNnZDRRUk51Qzd6WE5wZ2pvdXUvMkVkSytMcmVvQ0tIY1o4WEFTMmJ5QnZsMEh5WitoWUdvRFpLWkF2WkJpZjUyM2UvSmdZcVlncnpwZG9Vc3J3NnhrMU9rU1NFMHQrQ3ZaMGhkWElSaHhmRWFPbmN3MHRraW5wb3dOK3h4dGo4Ti9KTUZRM1o4NkxoTTR0R1loanRiTjJ6VVdoRWJqd3lCRGRmUkF5Rm4zdU5tQ3ArY1VFOXNLVzlWQ2VyYXd6RkhiNEpBMndQY0ZCVmpRUktWbjR3QjdHc1NZRzA2WHN1QVk0ZUpiM0Y2eVZ3WjkyWkw5QWhXZi9Hb1ZzUEZlbXIwaUt4L2VIbnVQR29aMHc0dDZWaHU5S1JHSXVvNTNxZ0VoamRBcjZtbVlMRnhrejMrMmNrQythcTREU0x1S2h0dnFFOVV5aUhrUW9KVnZmVlc2V2VURisvcG1TSlI2a1I3TUZoeXlDWFhmV2hRZlo4MmNGSjB2WGVjUU52SzFhZkUyTTloT2JtSXYxTU42WmZQMmpFcklMOUxFbzJlL1Y1Mlh5TUNyOFZWSjdoQUtrcEJyRWQ4VEFpRzVoQjhnYmNBaXl0Y2xQaUZCLzZVQUxSNVVsTDJWNGNPRFZZcnRHN09DZTdTYWJZajFQOG5ma2NBUDhUWkNuR1RaYmliL250Q0p5QnozN1YxWVhTMUVNSEo3ZVcrM2pybnl2aXVGTVFvTkJ4ek1ML05SQ0ZZRlM1SGpuYUo3VFhkVGZJaUM5UnpablpQR3pjV0tuMHlRRmZaaFlxTzh3WGIwMnlpUTBENzBlVFVhYXNHQm1VeWVKMGwwT1JjaWlLT3RINFg1YU8wUyt6ZXNWN3FQS0V4VWVaRzVqZTFyVExrd1ZseFNzSlczTC9UaXFjVy8wOGtQbnNOMTExVC85dHIvejNMRlRQaXVYQnpBRFVwUGR4SUhPMm9KZGFmY01haGd5YzJQekUxQjJTVnM1SnJ1d1hiOFpaL0Q2RkNKMXM1citDVHZITWFnSUFBUVQrK3dUQklmUzVQY3NCanp5T2VLNWk4TDc3elcxdzEvMDhrYjg3VWtyNmhZV3dwS0hhL3dFcU1vTGxpVVIwZVZNMTlORW92UUZBaTJZTjAvNWY5Y2V1MDQwK1VMakkrRVFaTHY3aS94a1pHYWFHbk9OYmpjWUJOQTBaV2YxNWdzMXd3Um02UUdWTXdzcFBvdGNFRlhTazhxTHdDVkExYVV2dWNxTGhLcERDMDl5dTBBWTNka2RYbDFEWXVOZUtVWWlUNTV4Q2hjR25yMlpKZkhrYWMxNzlhTHJ3b2VGQ0lOd1JBaEFVbkROTUppSFh1RUpSblBRTHIwcGhzQTBNSXZmSDJ6NUlKSlBiNmgyeWR6M1kyMDRiMHhFQnphUEJuQktvT3Z2SldxOVNYZGNHSllEeUZQbUVaS0RtckpucXVrajR0dm1SNGt0Z3hQQXZkeW5lUnUxNk9ZajJ3S2pQVTIycSttMlRUV0xRdXNnWXdBNXRkY0EwRlZDYzJyU0RYQ00yUkhxOGlaL3J6QjNucWhGY2ZLNDFvZVZmbmZTUjYzRXEvbys3ajBya3FSZjZkUUdySWw2c0NpaTJpV3hUN1lqU01xTkdtMzhGdnY4UCtORm94Y29INFZieGlqWWF2ei8ybWZaRjVNSmljaW1HcS9FZ0tVNDhsZG1STXRwRjI3TUtXbW1jd1MrcE13bHc3cVRjK3k5TVdwQjFXck5Na3F0OE1qTXFCOXg5TXRIaitmOHM5dnk4aS9aRFJSYjBrakdscXV2Q2hlYlpML1prWTJURWRTRE50TTZuOXh6YnRIYzVrN1k0a3FTSG5aaXN6Q0JYK1VPeHdvMFpJSGJQWGM3NlFqaU94ZDRzcFhWUCtnemI3OXpRdFFTTUZWNVAzWWFtNVNDK1M1aDBxWU5DRXdqbENBellsbjV3bEtUUXVWLzl4UWFaVnZYNkI5dlE1ZXQveWl5VUZ5Z2xCbndpWXJHbzlkNHhUSElpclI3MHRPZ01aWmJ5eldSUlptZHRaNFlCQUR0NTgxRWw1c2RTanl3YXNiUkhDMlhtblRWVnltSElNbmRmNjdtZEQrbjdyaFBUSVlwd2VLV3JVQmc0YkRDcnEzN0REempHMWI2aFJBRmRRbWsybDZWTDdGako4UElaalRpcDZyUkJ6cjNpMGxzZ0xMSUsvdXdwWTVYbksxczBPSUwxbzZOT2FSVGNkcUlCZFNSOFRIK2syTVRPRklWS0RFWlMxaU0zTVVRR2psYkYwR0FQNkJkZHowY2N1RGYvcWhzQnlJczBGN3RsZ0xNS3daWFg5Y3dSRWd0UitpL3pIblZiejhab1M2Q3VnZlE1U1gvUDhlMHN6a2ZtcG5UbWpzOXp0Y2VNUWdRK3RVS1ZESGpKQ01LYmVpZWY3cnZ2QTQ1YWh2SkJxRDE4MU9xWFQ4bEFZWG5lbm1vc25ISDJOd3pIUHlVSmFuUXVpRFR0cCtPRkJLM3pUcjRTR2VqZEU3c0ozSDVvQXoxRHlNUnBFdVhsM3pDVitWZSsyZHJVVEIybzdsOXQ2WW9nbkx4bnBSbkRBcjRWL1RDOG1jZ1kzQjNqVUpVZ0pvQkRBZEdKWGpsTC9LYzJ1SytXcEV0eHZublliaG51aGc1K21mV0Nqdkc2Yjh3dDladVB1MWlKT1gxZzN2YWl4d3RDUUJRRHNmQXZHQnJrSDFSbUNxVWRBNWNicTE5NkpGVmZ4UEF1Rm5WTkRTMkRLTW5VVFk5a3Y2RDB0TnNoT0NKcGl5NHNUTEhqd214RE54THgyd2JLNU1oN3dQdGZHRXlmcDdpTDNnamZoVzd0QWdBQkJQNzdBRis2QXRzNDJJNWllajN0QXlGV1ZKSnM1MHd5N2d2OUtzOXRZL3dIMXhhdmQwU005RWUvb3RrQXJKSVk4dWFrdkFaZFRDQjN2NHV6cUNrK3k4bjQrNnNoSTJYbkFPT2dQMWRwYWtMWWMvTHN1NjVoekV0TGhuL1o2algzM2Y3VDVFRGk0TEhOSEI1WERESHRuZHJCZi82bW9oR1VMWklsNDFSLzZ0STk4K1hUVjZGT1FMN1VsaTNOWklrUzRLczBESVdzKzY2VUhuZjF2eXFwL2t2ZlVtSFQ5Q1JtcitkUHhLaGJvRHQyQldzN25PZHdOR1dTSGt3aVhKZlZJVmdUekpUZ0VhR3NkS2lnejVWVG5XVU43Uy9qWjVUd1gzckxWVjRWdHRtWEZuMGI4OUNyTU5FM20zaGNza2JqUjYzRWRwZzZid1N4VXZDZ1BHOFA2V0VkQkFDL3lRa1lFdnZvUXZ6cWlwUVRLRGFQNkpmcC8zNi9ET01JTEpqZU9hbkkwNXdTTkdYL3lWVXdhN1Q0ckZvREJpN0EwVTAvUE5BcDNsQmRJdjV6R24rNkg0Y0xDVVA1ZXpHL2J2WEdWWkJHVFpVSWNITWxQOTZpazJhb2RKd3F0aW1pby8wbGtsZ3ZTTzgzZGNNMTlzSzZudWp4K3RzZUN6SjMzeTh6ZnFDUzZOS1ltMGlzU1k4ZzNqTUo4OEhFWTcySjdPZFVBM3pGdE1Gci8zSm5wOTFRZktmVmJaVjNuS2o4bFFHRFRMa295L3duUUtNT0lMaFRuWW9YUnhsZ2M2aWNERnNabHBPcTdOVTFDYXcrd05wWlBHYjhtQXUxYncwayswb0drOHd5bmJhZGYwdG4rb2dPWk05QjZhVDI5UDlsb2dxUjNGU0t0NGVGUHlGSnAzck56MHNJWUNjSEYzTThCN2ZPd0g0WTZGbFg2ZnhvOTNxUG1NRXVrOU9zRmZNVEcrc2pJQWxhSDRxbGRQMm91NmppVnhwaGNIYW52UWJLYzlLYU4wMWtOUGFPbXZYQlh0eVVpenVzaERhNHdCR1Y1VU8zUXFlclVsbDk3MzIxRTByakNGYVpqWTlSeXpSaGQ5VHE0YndFamJyZUVQUWUzZmYrblQyU1NLQk1sU2RYQ2c1cTJBNGxmOHFncG9FUmdrcUNNcjUrR3R0elVETkdPd05jOEV5aFdCbHFiYzhtazUrVWJtTCtLQ2dpbXJkZDRWdksyZnJUaERWMk5XbFY2MDFxU0ltcHM3Njh0WmwwU3p6K1p2TmEvRkNkOXZsbEd3QjluZmozYnlyT0d3YnJpQXlnQjJyRkNkTlJkSTlrNC9xV1ZZRlI4VmI1T09lNkd0anhXSEdpbzd3L1NFSE9KNHRWZ096OFFiZ2R3U0NReTByOTdESy9OR1prNGRCN2xhc0gvZ3EzUU92NUw3clFtOVEyMUdVckJ1MmlSYlBmSHN5L0tabnRrNGgrMXE5UGxHVW5YR3ptL011RUlvN0JERFVUSWlMclk0UDJZWnpkLzZBUjlvL1poQ2thOWQvdFlOaDZOL0x6N1dMOXNlLzluZnBIQmhrY0c2VDlDVEVwbUJCaER3WDUyR3lJa0xoWmdIMDlQbWwwa1FoMnkyNEJGeDNBQzFYNS9KalYxbkc5MWhVak1UMEIyUTFGbHVseU5sQTFFWnZiTm1ITmtsT1FxMDJFdDZuT3JQUXAzVzVmM292aEU1UWFKVlc0YWlZZEp0RkRrOFRmWlU1dXJzUklqS3grVGZlWWhjWkdaMlIwQ08rVXdxc3Z6SnR6YlBUOUxXQTVPcE5ZblptZU1vY0NBQUVFL3ZzRUFBTmhOUFhLYUp3VTNXUW9QemsxbGJnaDlNdndSMTZEcURwMXRnRVpJNWV0QlM3eUd3dWJ0dldaSGJxb1BMSm54TzIxNGV5UnpJbFp1UmhEczZxNjJaVEVjSmFDMW5aSXZBUms4RGxsNGc2MExQRzg1d2NJWjhwNmhOeXJIbmROMEgyOGJsMHhqcUdmWFFXaGxDcGNzQVd2UlVTSW9XbFQ5L3RaQUFkZit4cWxjMjBDd3UyWmRMUHV1VHBCWHdPTmJiNVhZNnZKd2lBLzVZeS95b3BBTDlyVnYrMUlzQXlzSCtzK3RmYXdBS2s0bkR1Z0dyQ2F0OGtEY2JIUDJ2eWx6Nis3Yzh5VmtUcWluMFJrUXRWRjBhNFRyaitNc2RXS0pWcmM2MjMxNmJaVERaQTZLS2kyVzNsbzF3c1R6UFc0cVdCcmdJRCtBSDhEZU85K25iemUyS3ZYRjFjY2ltb01qK0U1KzdIZ09lRDZpS2xoK0VaZUtHbVdpamtNMkp2Z0x3UUxGSGxPdm9UY2NXSC8zbDdxM0k2VHNxdnpWS1RSa0FjN1ZWQkJrS2Fna0NFT1RKT3F2enhKdk82TnIyRXN0bVlqVFc4SUZhd05RdFdzZTZBN0dCNUhTRGVFTzgrR2NVc0I2MXBzUCtJYVlZY1hyaG5HZ0REVXhoTnFKb0ZjcE1RSklibW5QVzZtcUgrR1dVbzAyczJjcHIwRHJMUWdHQVR6NU1pVllTSXBDbkg1QU9uelNoSlVCMHBvcTZFazZ6T0tLamlZaU9MRFNhUUE1dHBtbnpXNGRTL0lmdXJvYUtlblFTVVUzemliM01EckhRYVpkalJ0cUFKSDlWT2ZpdUVsWTczUS80L2dVRUZoL0NrV0N2S0pYQjc2dmtvUTNsYXpKQzdKZVp2bUtyQ2pJTDN3S3NjWGZhaE1zd3c2bXBJTy9ud2dTYk4zUTZqeVloYVFiYS9zeUQ0S2FoZGJIL09HYWxuQUpmWjREelVhdk8xSTlpcFdWeHRkVDZiOWxKc1Z5NUxFczlVWlpndTFUU2VwYWJlZHVkK0JBeXhiZUtwcWNFcy94Y0o1WDBtdUY5QkZwRW1ZV1hJSE5RUHIvaGdzWHFERTRGUkZ1Z0JrUUJpQ205bnFoUWFEaFJPTTV1SnlPYlB6TGRQQnZRbkxpUEYxcDFlY3g5YkNUTzRINlBvcWFjbkZDb3k1cm9Ea1hNRnVhNmN1eTVURjJuWnkvVk9sQ212dEQwcFZZWncycjdGTGUwaDVabXViQ2ZPZGlFTmYrazNxVVN2bEZwSjNUSk53bDMvUm5uK3NQNkFMcGozd0Z5ZlA4M0lsNlhTOGVBTFV2aWRGMW5mK1pEQTRtaGVDR1VnTEFvYVBPQWl2UXk2dFBQcmJlRlJ5UFFlU0hZdmhTVjcyOEltSmpyY1h0RmZldVBnNUIvQ1lQQ2N0b01TVVE2Yi95b3U3cklDanpYaW82aHpmNDVRNDUrTE5GVko1eHV5ZVFWTGdxa2VVc3ZMNy9SNFltd081NEdxMmtzdnFuVWtHYi9YeHpneGFRYkJ3SGVkN1pDSjByUmhZS1MzTzZGNGtjelJXRnJOUkNIaTBEU3RzR2JGeGV2U0M4VlBnQkZTWEx6djlYaHZTRE0wT2QyQnkwYWoyNU5uM3pvNVJHZVRpYmhiTTQwZ0NJd3JlOXdFWTVJb3pnUFNQZDNYREMzOGtoZkMwZmo2MG9GMytKRlh3Q2J6MnJQYmlKNlI2a2h1Sy9MekJwcXRQeHV0VlJ2YnpMVzYrS214U3ZQdDY0S1hIVit5OEtEMmg3WlFiRHdJQUFRVCsrd0MwUU5wR2REMitIeXBGSjBleDdpYzlqWC9NQTNJcjhIY2E2SGlRczR5TTZOK3A0ZmcyYmcyK29wL3FTZ3RkUStkQ0lLQmRaK3BSbEFXSVZwemVFeUlqdGtCRmtVLy9ObDNaRW5lYjRwdFpwZEVEbDVpUnVvdVN4bGE2VkhhRXRsSmExakpXQWlpMXNsQXhaVmlxbUFlREZRb2Z4VkoyRjZjN3VSYit1MEh6M0RCejk0OFA1N3QxekZiM21OcTdJdXBkYjl4T0RZSXR5Nk5KMm9YNFJ2QWpFQ0FMbERNUzQvbWRSV3BrdFY4K1B2eXVrRXA1NHI1dkwvOWJJbTg2eDJEaW1zek5NcWhySktHdVFoMmMrVk9KQkVvNGNBNGlTZHlReG1WbTE0VEZ5QW9FRUNPdGpVdjdZYWNTdVRwSHg2eDZack5JVGM2b2R0NTFoc2ZFdUlPdTRNb0hSRzhyY0ZSTVZrOGdHenJVZ1JSUGRQd3A5dFYvSzAzWHVkK29YWVJZNk5qM2NCOGt5TjhuVWdYVDRZcHJYd2VuTEQvM3d4UURkTGRQMExlaE1hVGJjV21RTUtXWTZJZG5BUThadTVFNzFZYjloNXNMQk5WbWh6QUxlV1V1ODBMejIyd0NwNmNEV1ZuQTROVXhQb01DS3p5N0k2Q0UyOEVRTjhRVEhJblRxeFdBdVFvaEpQS3E4ZlFTMyt5U3RreGNRYksvWXdwU2oxNjlBUDB1TVJPOHlQQ1ZReWdXMFd3TnZJR2ozeFZMaVhqcVlmcjRXakFHeVEreGliNXZGT0VlTU02L0xyRHRJNDZqa2VZbVVvNCs2U2lmYVBwWDVvYzFXTTdnNjV2SmQ5VnIwQ0hVM1l3dXRBUTVBVm9iZXJic0svbk8rMnVWWmhzQ2t2RnNOckxobkpzT09jRFlYNlAwVk45R0JDVi9yTVRRckhRNUI2UGFtRDhPRkhMV3hvb296NFRiZ3NFNWRsNGlNQUpoYTlLaWVwZkR0VHh3NlV3c2tjK1grRjZJc3g0T3dpeXk1cEwrS0RiYWZ6aWxFejJoMG1PR2F4eDNia0NDemF6ZE5GVEUrVWVBRUNaYnhBZTVBSk1nMmlNMlN0cnZ0ZmNmeEtKdDN6NUhzZ242dkxjSDJtOFQrNURSYlRPaWhlbTJvc05oekFmK0g3TnAyeEFQOHlOY3ZwSng2STY0RXBYMzJkZVpaVjUyMVlpNGFXS1Z1OHA2VDBhRkVnV20xSXQvZDRUQTR2d3ZiVldQN2hORGZPOTVld0lTcHhrQ0hIWWgrejNESXFXaHZTYmMwOUNEMnNyaGhDMEJsc1pPdWZNSWxWNkZzeitaMnhyK3BmeTZSV2dqSUtCTGFaUFMvdWJzSzg1eXpvUncxcS9UTExjY011alp3RXErM3FmcHJ5enpkTUFZZ2JVYUZDU1R5NkhZaWx1YzhrWFcxbE5LbUNHbnJubDBJejZtREMreGdSVkdZUTNIZXFMc2NEYlJrOGRxRysySE4rTGcwY3NiSUV0ZHZUODdHT1l0R1dOcGY2VmdFRXRlUWZ2cmY2RU1QZzZJNFVaTGE3ekM5Qk56RHRJa01KMElzQjVRaGk1dFk2a1hudXBjUXJIVVZqOFZVVzBFejM0SURaa3RDeWkwNHJ4U0FpUE5IWkp6cnVZZ2Z4TUtEOXRqbnlJVHBNSUlCZUZ3RHE0MENEdEZPM0NpVUFYVXRTeUVzL0NkL0M3NmVpeFltVGsxZkpiZGVEM25CSnhKVjJZR0QrOFRtUU9iRFNrc2U3NXJ3dGZZdzYyanM3MUxpQW9DVWs3U3ROZ2VBZ0FCQlA3N0EySzlGMHVJVS9ETW5IbFB2cXZCSDNLVE5qSEpnTkc3L0RZWklxamNTeDY5emJBL3Y1R1VTOXhhZUdKQ09NTG9QS3QvYlAvTnhVeEdhMXgvWE1ZM0xsMWdkNmQ5L2V6cUtvU0dKeGxrQ1VHMjVlK2o3NnhRMXU0azlhNTJFdVFweGNJR1A1UU1CUEpqMlJXeEx4U2hORDN6WkhmeHgvdXY5Sm9hMm9UbHQ3c1Vpb05rWmJYNGFTQ21uR1JZVDN1K1lmeUxLTnNzSVVBK0YrOU9aUld1azdVZTBzMVppNG95RmZiM29IdHo1SUFtZnFjS3QxM240V3hCOXhSRmt6ZFJXZng2ZDRmeVNlV09DS2N2L00wOXFXay9GUEI2a2t0UUxrSURMRkVnZnNMV1IwM3RqUHlmUHpkbnc0REE5eTdsRE9YMGNtRlNxaXJpbVNPUXVMSkcvN3I4TlNYSEozUHU0ODMyT3JPZWxrOTFrdkd1Tkx1cldsS3FkaDlLaUZwdkZEVVozeUZxR0Q3dTNEL0wyc2JzcHBaaktuMi9oby9wL0hCdjhoL1YyTUROSERBSjJGdjhCR01ZMndjN09kK015RzJXSUNqT0tWUTVhMDRJNE9ZbXdYcGljeHZnS2kwVTVCdC93MTBVOG5Mb1VGakQ1SlQ1ZGZTT094WEtWdlRMSjB4R0NRSDZwM2FGL1lKTE9pZ1VhNXVDYzNZeFBlQWszWk0xTG5hQ3p1TCs5clRLMVN5SzRnTkdlbmM3U0RUaHZ5UnNhZno3YzZ1Q3VERGJUVHdjSC9BYWFEazhQUGpZSWh5am5MTWJTMHBDSGdwMDNxdjB1VUpKcHptNEZ0a3NHdjdUYitMQjVZRXhmc0NlcjJJb0g3aktmODlmSWhQTzM2Yzk3RXlpZE1ydEFUZVdkcUtTRXdocFd4RVFwd1RyOHNRSS9QbzhvM2tlOXB4eHlSSGRNUGhWVFFhVUc0a1FyckRkc3NnZmxUbjdVYlhuVi8xdmZTYjZFcDZjVWk2M1VWTXlZZWIxM3hpcjk1RUtGNTlhWDhoMlNsYkFpS3pvOEtWdWNlcUREam9ycmNkRStxTmZ6VDhsZGYyKzNkWUx1bXZXUmlYWDk3OW1OQlhKUUVvcHpySnFDRmRxYVo3Z0Y2LzB2ZEh6ZFFpc3A1NldBd1NpNC9aY3Y0eVMvQWRoNEU4cStDM3RGS29oTzVqcGtodzhFaHhJVkU0dUVSU0ZtbXR1eUFIUmZZOWMwazZ1QnhrOVpzL2krTUQ2cDArU1NhTGF5UHF4Q0xUSUFVTDFOcTlocmFKbjVjck1uTjZDeGJaYmNOdmdYOWwzZHBCTnRRRHBtSFQrb20zZkVqMmN2Q0lCcnBsUEVqV2NybTMxNnVYV21QdElBRGRuV2EwcVhEVDNoaUZKdHFWZlBmVFBMeVUzOHVWeFJzN05Hc05Db2w3RStCTFdqNGpmMWJyRjdIWXYrWkVkL1M3emRRUWQyL0xkMmdXRzFBSCtlemNWdXN5MnB3am9rRVk0RDNkQ2lXZk5Gd0w3bFJQblZjeHFKNUM1clNOQkpuMnJxUkp0cFNNRGg4SUJiYTYvd05RNVp3eDNkbXJBOEs3QjRNeXRqa2F5Y1ZKZXM5NlkycXJMZ24xQ0dNMFNLb1crWUVuSTVydXM4SC8ydy9xZ01CbVU0UFBBN0RoVW43bTBVQU9nNmszS1BBT3BxMDBLUFZTTHhkMWFoVXBBcDVaeTFwV0EvNWNkNDlBaGs1c21JbDdrZXc2eFdKQThpWTlXLzY5U2dwcEM3WksrWjJlUksraTdZTnppcTJRQ0FBRUUvdnNDTjNRcWlQTUV1dHViZ1dQMTRDYjFhcXYrY0JCYnRjSWxaZWVOSUhwN0pDVGdhbFRaTjZadnp1RjQ4VzR1a1R0R2Nnakt3dUZCSEhRa2J5WWxweGpoUUx5M3hmcjZsQU9xL1pFc3RiamkrbXZCSjBEU1lORy9OdXpIdXl2ZEw3dm9RdndLTE9FcU0wMHNQemxhMFFqejJudXlOSStyM3hpOFFnTVJPTHBPZW9Ma2crRU03RHFsT3Y3aklxNkxoVTQzN2d5NitPam9pQmlWMVkzOVFCMi9GbXJGdEZZc3BjMGtBeGJGTTdRNGJMdC9oUHFNanlsbUlRcC94Tjh1UzF4WDZkaVhkU3pIckJ5TWg5VXFtM1FnV1pad1c2eEllbWM3d3VXQTA4NHZ5YnFXNjlQbmNOVkJOb3ZQNVdEd3JSdHRVbnU1UTBUK1dkRXVkdS9CNHFKL3gvaENuSkttZW51bXZCY0VnN1l3M0pOYnd6bHkyN2hmQnFLYUJYRWpOUk5rNTA0WWxZMm9BUjFreWtSMGRiUmRPQXYyQ0RqOVBRQS9HdVhoUW0wSzNibUFlRU53bG11cloxSlFjLzVZMWVsOStFZG1wV2MxQVU5WDdBdHNyaVhIMDZxSjVQaUxKWHJGT0JZRE02Q0tabHNDU1JkVHBzNlpGMzQ0TjF6VnFPeE0zaE5BN1FtcHFpcTBYbHVKaVBKdGRCVlZBNjZCeUlRTE9aYnNPRExyd3hZNVk4N2w4bnptVUJGVWhEUGRlK2ZweGE2M1hqNUxIOUtLc1lRbFJ2MFQrQUJOZWFlTmZhd3lHUXM2QmMrbVk4RWJPSnByRmtEbG42M1o1UVFRNXJDRTRvYTJQakNGOGViQ3JIRzdwYThmb0MwSHhLVFhWR3RRdXhhbHdUNitvS215OFJwZzRjUmVuYXZ5ZXRvckcrZmo5U3YwcE5PMFRBN2orWlpoR0hiYnNUdW5HaW5xTHFldzRmYWxYUmwrd2tQN3dGUUFtSkhXeUZnRDd1TS83RXdkNVFVZlFCbzVqWWhxWWNYakNTdGxteXFRck9VM1JZaXA5SnFoeHNKQUpKZTBidXZWUWFtNmxJMzFaTHdObTNGWGpMaElvVGp3OVVyQ0Y5aDFzSHdsTURiS2tyaWRVTno4OXJDRHk5OXpyWDlvUCt4OWxaa3pEY2NRSFNwMTlDOTFwZDVuei8vS0FnNDVaVXp4UWRZVW5xaTNwaFdhYkRHV1pqNytMUVlmSFJweUwyeUV3U0FFWXl2NXU2L1A1OFphYm5qNE4vOFBDMkhTbVc3MDAxOVNxV2t4Y1ZRUXk0by9BZjNTZVNHY1ZOQ2l6RlhvQVRIQmV4enZudXA5bUE1L1dyczl3cnpDenYwSGcvNlM1OExkZ29aMVBoeGNpUkxoUVBtYnhXNWYzL3pZcndMV3FRUnBPbS94bVlncHBzcjZGV0JTenJmaUluNkM3OC9KNExnOGwvdEdNQlFyZ2xseXF6VlNwS1R2dnd1K1NucllvblEybFA1alFZYkd3ZWVMVjNOcExGZ01na0t5TGptYWJoQlh0VFZiVlJZVlA4S2J5TEVib1RQMjlWdU9mTjN4MlE1dllwSlQ5TWxKUmxwSEZvbW40bU1iWElDLzFPYWJqUVp3ditiS3FLS2t2d1BtRGFKY2RaUThManVaVWtWMDJhYzNiNXd4V2wwY0pBaStpcXB2eTBQdVJmUFlhUTVGN0RxMythdFRIRkUrUUQxZGRMYzl5UkZjQkhLejQwSGZYWWhQa3NXbXUzbEs0bmVsV2IyY2dLeEZXa3E1Y3BtNEtrR1Vud0lBQVFUKyt3RGhiZEdHQTQ1UzFQUWUwRFdYcC9pUVg3WFBUcEVTYUZQdzFOQ3ZsU2Z5Q1k1Y0ZEUzhmS2hYb0dtM0dqZ29ibUdHZTdZRWozT2tKL0k2ZnJ3L0w2RlZUMHBoN0RMeWxiQ2tRdkFCcEVEbEpRYWJ0RGNZVGc1Y0xkTFdNcktmYzNGSGFCRlNYK3Y2OWQrY0N0M0VxQThXOTNMdUI5MFgva0twQ3ZSWGtJU1BLMU92WVR0WVVqaDQ5cFdTUjY4NDJ6dEF1Wi96OGtSZit6dVlCRHRWZHU5NGExQTJuKzF3bXpNRTc3UXBCaVcvOTNva0pEQVFpYmNna1NHUEJVRjJZSVZzMlI1RG9LcVRpeEJQS2drTEY2aTFMQ1hMaEMwblhtb2FPclprU2JqM1Q3K1F6bzI1MnBsWEUrNjZTVWR2emhFeGVTa04yNjlwNWpJVWlBMWlYR1B4NW16WkpkUlpYSENlemxXanVSREtHM2hhTW5SOFBMQkpjc2dpaTA1R0k5c1IxaTFYTEdzdXpEZ2lZcFEvdXluQ0ZhYzJmQUdlUk54ZXNIQTJ1SUlBSE9GRlIrQk5aNW9BcEQ5b1d4UlNReDBmK2FTN0pjWXRBV213Z1hwQXFFdko3ZnpzSUNuMkdtVHlhK01BL2lrUFFrVTdwcy8wYXJ0STRoeUlYY210VEtEODc0bzY2VWtqZHcxQURBK0hKVGswKzFnQ2gxREN1cFVodmJXM2RBbjlma2M1YWVlbm1tY056WmtZdGZxVVVhRjRIUjFFSTJqU3N3VWUxeTNxOXJ0M1o3RjI5aVlsclpJc21TUVNudmNkUFB6enhBMGV0SDZwaEs4Yk85SlJsZHN5S2ZadHRzUDNhS0tkMDV1NVZEaVNlMGJOOVhCODB4M1h4a0REK0JnNUg4VlFFQnNiN25uUXJBNDhTUDVkU2t2bFVmaExaanRtNzFLcmNvdEpqY1pGM0pDbHNFclpseFk4dllRVDYvTTRjQlpjQlVMZFh5Z29SUHF3L2F2NHU4N0VoNHNCd1VMUmJpendpTE1RbzAwMFNpSktvcy9PZy96eitnYmQxMExSNC9xZGZVaFYxZUdYWHg4QklCSUNnWGJWK013NDNWdSs3L2JuYWZYWGNxWWFYS1pvR3lwR2R4NXFaRzVjQTNYNVFEaDRBdDUwRXY3TVRmN1RoL3VFQTJTR3JyRkQ0REZORVMwMkpnRzdmNHNpb1JpRDZISXNESGRaV3ZvK2o1TCs4VXVLdWtrNTdSd2ZPcitYUktyeW5TeENoMG90THhvOWNzOXl6bUFTR1pFSm9sOEg2ZXBCTEZuMWx1cnJmVHVBaW1WbmRwV0xCOVlSRjh0ODZ0eHFTa0g3eXF3bFFFQXliOHZZdmdpYnB6cGs4Z2pJRUFTVHhiZU4vdzVHNXBOdHZjVHhpTVZwVXZab3FCNnVDeEFNcklScE5obTdGa1l2SVc0cjA0dlJ2SzY2VUN2d2Fxa2hDK2ZNcjMzenl1OHI5SjlnU01rR3drSW5UNTVJTWtkcHZGNTk3WHpCQU9scFIyUHROWU0rNlpxY0Q2cHVFSXBINUdKMHZsRmQzZzJlNTFBTGY0QnVxNG9vYkwyS1had3FOQVZBR3NnUHBvN0Vld1F0V3N0akNlamlPTXNmb0I5aExWbHltTTlFUThacmFLSWxjRWNoK0l2WkVYdjZEYThnUGVVRTlOZ0FZN25BMjNHc2dzUzE4aVhROXcrNFBKM1UwZGlWcFFxNVNFOENyM0ZYcWJ0R3RtbkplQlNuOVl3THQrL3dpcTRPVjZ3NWV3MThFMFNZSWxZWUFnQUJCUDc3QVFUbjY4Ky9PTTI0RUl0VVRNMUE4dlJaZTh4WkhOOTc1OWF4K2dxUnpWemE0cDkzWU02VndQN3ZUUjlJK1EraEdEcVF0UHNoSWlaRXg2ZnpVQTdzaHg3eWJ3MXQ0VlNVVGFIZHhsNEZJUEtsUHd6VStLblJvZXhGQXZwUG1vWnJYNk5QWEIyTHVmbFplbUFLSFJ1ZkV5ZjFUS011SUN4NE1rMks5REhlRkpBZmxEZ2sxOCszbTNWbitSN2ZyNXFhQUVUT25hamo1WWozTEkyZGdNYlRIdThvOGw5NFhUZGd4OFlMNnZsRklHYUZ6NExNK216Vnhtb3RjTmd0ZjYzcHBadzVGTnJweEhKUXk1cFFENXZuYnpmYnlvMVN0UzZIOWw3cFVzS1orN3YxeWtrSkhSd1V0ZjlNTDJNSUVic2g0OUZFNWpyaXYxc1JZSmlkVHJBb2VTajZVSVBPSUVOK0hTbGZzY2p0TTU1emdqR0V2Qy9uVnowOFplbXdIcmNkbHR4cnZaNzcwUHVIN29JNU1OdmNDQ20wdUR5R21RQzMzSlk1MDBHVzM3T0pKYXJxN0MxMXdOV3N4QjFNODI1N0I1ejdSK3J5SWFFQm9QVlBnakFhV2p2OW0vdm85aGtoK2ZOVUxMQ0NOcUxxbld2WFUrZ2VtWXFvd0VhOVJDb2Y0UENjczZISkx3V2NQL1dFbzU4dnBHTlBhNzV3aXVwSWp4b2p6cWZQaUp0SWM1R2JTSm9OaittTVE3WEF6Q09YUFR0ejZiYUY1dy8xOFR2Z2ZlaHpocW1KRFdkM3pDVk05NmlnbFNvdWM3Tk5QUDA4NVdsQkk3OFVmck10QVgvbFZmTnRMMWZEeXFBc0I0VnFTcy80WFpYdEJ6QTdkNnlITjBCNnFSSFhTQTdCYWhiVndVSy9YbkRjV3htNEZ5WTdBY0cxQWlScGdjOXZOZGF5OEMrTkNtb1hqbTkrNDcrMnloZHl1QkoySllHREZPMnNOeDkzalhkQzVZTXhoOWI5KzFXaXdQR2FpaGRRdE9nbEFDL0UzZUFzaUoxcFIvaW0zVCtEZ0VRNXdQMWxMK3I4eDhHQzR2dEkvN1Z4RUZNWnMvaUdPOWwxSk8xQzFOZ3RXN1lzTHFVNzlBTmhvK0FPMzJIN0RQZDFqMU52SGkwajhjMkl1bjBYN2VXem5wazd3MzhNcng4cVFOU1pmcFdqUk9FWUo1YjhxaG4wU3dta3lqL3RoT1hGVkpkVEI1czdvdTB3R1JDcHpUK3RvbU1yVjRZSXRPL2U1V2gyWWVUT3U5ZkE0RjRlTytMODhleDVrdTN5YnEvT21aOTlPV0NWTFYwS1ZKQzl3OE83SFhVVUtZM251RzRXdk51bnMyTTd2a2NqZTRkVGpNNyt0QTE0Sm5wWVVicERxNWFiQklRdnhOWEdoQ1dhanVjekkreXNMWjVKTEh1UmRqRUtWUjRQS1ZtYVJWTDR4MXgxVUlGR2RNWDFzUFR5ZGM5U20yMVZlVm9wdnJLS3ZPMUJPTFphcFJkUFlwcmQ0K2VNR1RXS3Z3Z3NGNmhvQkZ2QXhqUXc1bHRldmVSeU9WRkxxTVdrL2ZuOXpHS3FvWmF2SXBkUCsyYW5ObXppVkJSWHVsWmJrS0VxcmZmSWlWTXFmTFBmR3R6eFEvV2RxTEQwVGFsRllHUjRGN2VXSFc4aWNUMG4zQVNMb3RpUHYrNEwyb3dMOElJOEIzRkZoUFdIcTY0bjFjUElaQ2NVVU5xcldGQ2N4cHhpRzdRVzNOTlkzMTFXZjJLWFMyWjBGZlgySDdacHY1d1FQd01DQUFFRS92c0FHdVg3K0JLWXlRL28zOXBnM3BMRktkU2ZMaEJoTlM4ZFBUSVJ2SnFJKzYwd0hiamNpUm1hZytILytrNjJocHFFQzB3ZzRoRGRBK3J4SEk5OHo4Q052c25LZGZOSGdCM3ZyYXpzOXYwQ2d1NVRwQUZTaGVXVjkySFZoakpsWVBZZmV6WURBZnRVRERuT3JmQTlURU1LbEkzWEM4LzYxd0lKRXg3VUNIWnVmc3drelRKWXNMZXhWdXFzY0tWRkVKUVBwTmhqZXdEd0lTMUlTSTBZMlNIZUsxVXZYUzUzaWtJU0NkeE82ZUFsRjgzNmc1MCtMOWVEeW8vM1BwVDZKYlp2L095eS9nMVljcjVuNExoVW0weFkyS3JWTTQzL05LZWxjREZLZUdEL21TNEJybXVaMlZrZTNrNGJsMXZFUng4dkhuWWRCdE5DMTVGZ2hsK3JJOTF2Z0ZHY281dGxBbEFiTXpKbVl6cVgyTE44MnlabTZ5TWhYcHQ4L1pMOGJzQ3QySmJucWNEdnZ0eG00RHd4SkhJT3F6ejRNYWszV3VKL1E0UUxEbkZFSjhQcmZqN0ttc2ltOE40bFpTM0VWaTFnSVZnR3RmRmI0cjQ2V3RlNDJVUHNIdS9hWE1FcU9wcGhVR1owa0dMYjluKzB1blRCckpKWUxqM1p0OEFnUUMxdGtMc01Pcnc5Q2FmRU1hVkFqaWhqSFQ5K2xCQUI0N21CYVZPT1BoSHBJbHBhaUMzNC8xK2o4WHBlWWllbXY5M2hraENab1Z0bEpCTkNGZlFrbzc3SEpWNmprS2IvUGRUL3ZMbFlqNmlrWFRZTnJ2Zmh6Z2p0RDNZYzJncjB4c3FWSnR5SysyMTcvWWFRN1RvSWtYSmhSNDNSekh0L1BKTzZEd1NiN2ZyNkozQXF0ZzBVMEUvN0pZQi9qQUNCT0ZLeVlDaHNpMmNuMFYybnJXYmh6ejk0VTQ3aW5TUXBLc0c4WitTRWZHd3dObGtpbnlDc2NSRzVFTHZyWmNSSTBzdURlc2xHTDE0ZGhOUXVBQUxYSExZWWp0ME42MnhsOGM2c3FGb21OZnJHZEJKRklzTlJSS1BGRFNoQU9RelVwSVVHWVExQWNGSXVjYjV5azBWeDlnR21GRzE5clYyeG9UVkxrWUQ1T2hwVFNxVHZjdXNmNE1mMThqSnhTZWY4Tm56M2FENElzcGt2UHk0MUlqZThSTXhyVG80cytPcmtoQzdKVzdxaUV4NUVkTmJxRC9wK0Z5OXdiWm02ODJIa0w3WWhRbFFpQ1RCTWNCZDZ4MkJNUjR1czl1YXdpQUdjcWgvVHBUb3FnMHh5VG9uMUFFeGYyVkZFTDd1L1JCN1JlanhZNHVrZEZXbWtuaXVIbnNuajlKcDk5eGxjUlkwck9TYk1iYjN3TGl1djI0SE85NTk3Q0RsNmg2elp3clZ3dlRwWmFpazZyZjB3cHV5STF5OW9obEhEN3VNeHd2RzFjRDlobXZiSDBEVnFWaVVScEpFd2FZMzAxQm9EaFNsa01SVDlKV1pteTEyWHZ6VkVkcDIzTE1GOHZ5NDRRRnc3eW5zemR6M1VDc0IySy9mYktqZk40NC83dlBqT2hsVWpCZUhhZVZtMmdQV0k3dmxoMmxBK3ZneHl2OTRtOGxHSzlRdTVpK2pTY09zQ2EwQmZhcmRlcHdCVTYwdVFOSFdKTlRKS3krQ0EzRGtVUGFveHNDUVh3djlPTXlPMEpEYmlaVXg2WGVOQnJRcDlaMWNXalhqSDF1YWtQZUI2YnZKelFMOFdEMHZFUTNoc1lIU2tnbTV0YWY1VjZBSUFBUVQrK3dBQUhYM1hZd000V1Zkd09OZDkzdE9VMjExWHhUeDdMOUNlcDgwZUVYc1hpdkdyQjMxUS9MRmszYjEzdVZRRWJKbXZtOFRaMjAzWGVINDFFN0dwa0lmbnEzQU9RQ1ZLMmZHU290d0phc0pZczVCUWZuYTBLU1RwQzlGcks3RXpCQ3pOU254eW9lalk4YzczQ0hRL05IeDJ6YmdJL1VYckIyc1NOVjJoc1VzY2FNckZaZ1NSSHowNXJDWU1Tb2NDbWRtT3djUkw2d0F2d0V2em4zTUd2VWx1RzEvZW5GdUtlcjlKaUdBOGgydFI2SzdmMHJGU2FnQXptRFpVd2ZtN0lVUXhNeHdJa2R1RC9aZExvUjFxWHBkb1EwL2NRV2RieGhiVzkvQWJkeDhydGY2YzFQRG04YkE2WEpVQzE1NjhTRTVaL3hoalZIY0xXdEdZOWJkanBiNEswdTVyWW5BZW8xc2w5R0llaE8vK2JtSUxublIwMG1KaEVTT1BhSEdCY1JhbmttSVc5bzEzdVB3RFNOY3lvb2dKTnIrT0xoeE50d1F1TWdmK1FlbVg4Z3kxQVVRVE1CRXNRVGo4bHVwMnNOZ2s1aWpoNFQrUkRmOUpKamFXUWZPc2tRUzExdVBTbjNLTEc3R3ZDVmg1eTJ4ZjJIUVVFcEZGWnBYYTJEQ3p0c1BkUnQ0bUd2NzRrYnEvZEhnZGhRQlo2QlBrUG1mMFhvQ0NZSnBwVk5Za3ZmeXExVHRla3FUM2sxRUxQbUFqalJYMDBCbVBESFptTmlqOGM5RVRTOGlKanFwUFF0K1VHTmszTHB6cUtyS3RkWFd3dTNLOHFFSGcvRC8yUm9abzJrZXlIanFENktPMjNzM0Y3MmZKTU9TNjVRWEl0ZktOdHRjVzBzYW1vcVFQbC9wdnBJbUM5QzNTTXdmbk1KeWg0UmtpZ2JadHg4YmpsL1JQenNiQVV1d0hGN3pjWlBHZFk0Nlo5OUp1WmFreTRBYm1lMVA4L1NWNUl2VSthVlQ5MXdzWGNtYVNoRnRlR1F0YnkyeXBYTFd5YlR0QUZzandQU3A5NkNpNStUci9wbjdKZTVpK3UrRTFmMWpQVGowTkZ6RU8rSHVHbWhtdzR6WEVBcFpJOGk3K0hzZGhuK0FFUm9ram1tY0JXeW1RSy84dEhIWElTZFNOZG1KTGJnSnpWWmRFekpoWEV5MmRLTHM5UUY2RVdMUkxJNW0rdmJMWVBFdS9UOWRUVHJwTVdRKzRCUjlsSGlpTlpDWXhTN1lWQnlWcXprOUREUm9USVdEUlZHOFZtVVBkci9CWTdmUWJmTDlsWXdpQU9QSE1YbkdGMFEzN0FZTXRuRTJMK3pXbmxSMFpsV05VZ3ZxODZZWFZidm80NEl1VUFYcFNGM2VVazZmazlWdEpwU3FDakQ0Z2dOUDRicWR6L2VPRnk0YW9xbUxyRzZZTmNxL2gyRHByM2RwNFJ6c1VTZVd1OXFrcFJSbDR3RnRaY0cwbW13ODVWTVJDMnNvYlRFd2Znck9ocjErVzNZazFNRkRmVzhRNDVXL0VITXJiVGt4dGNVOER3ODd2U2ZML2ZPaThneW1rTlNld3pNOFVGQzF3VTVyd05TdWNmcTNEY3J0eE1ROG1lV3I2Q2dMbVNnRXhJOGRtazZxQURUR0ozVnZhOGNic2x4dDdjL3BCWlpzL1AvMUlmQVh3Y3FMMTFQb1BXT0k0TGFxV29BcHBtaGJ1bDQ5YlJzT085MTFKbXlCZVJtSlgzUFVjOWtIZGllNHJGVDBjMnlUYTVlMGo4K1ptcS90RWthdVM0a1VRQWdBQkJQNzdBSUtNUHhnSmIrYXdBd0VXOVZiSEd3a2M1bWMrLzRUb2ViZ1RvQ1l0eitBZjVydTdNSXVxQ1F1bXpoTGdId0tZaS9ucWZIMTk0SnhCTlo4MlFrVjRrYXdDRUFFaUs4U3h6bldWNjhicnZhTHZ0RjBpOHNUQzhEYTRRNldWdkFzSjd6UHBuSmg2Rnpub3FudXYzWEdDdGlnQUdEVi9md3NMUndSRlhsOHJqdkQ1ZFpSSC85RDkzUWtlSXgrVmlKLy82dGJLekVBRmZMUVYvWFFIVjFFbTBjZnozNnpRZER0eS9seS9sWjJ4bmFJUmNqL3JOMEs5UlFkMkNWcFEyTzBHTHk0WkIxdElUU0drRGo3SzRhdFRNWkdCbldOZ0xSZ2ZVOGU1eWhNWklQNWVRNmwyQlV5TW90alJrMWRKbjhBdkxYTmFybEM4Si9rSVBWRjZINmttbHFLa1NWMHF4WXIva2IwVnJtVyswYWlyTTYwZzc1YmdpNlozOFRrTnNPdW0zWGRuRG1TQk5GbjFsK3kxajVrWFRRU0JUTk0zSFVDSWRhSkYxREVBM0RNbWJ5S05FVkhWTGVzN3RON2ZETW9TNnZSRVpKZGt2eC8vclhtcEF5OEZCRlB4eUJOR3hySVhlNVNDOGxWdUk2djYxcE1HNmx2UUJ6MUYrUTlXVGk2QjYrVmRKcUdVdXdlWXdIK1NUTVhGMnFEVDkxakZNNVU1dGtkcFJZUWFYS29SOE1YL1EzYjhEc1ExeWMwUnF5MUcyVXNJOWlaNU1FbE1PNnAvcFJJTmJIc0NDQmJWcW5MN0dMZXh5dEh4SzVCTHJYcnBmR2MxUFIrK3F5dVdIdGh3T05YKzJBVk1lQy9JOCtZWTNXMVhFYXYranZPYWF4MmF0T2ZWK0JabWljcGFzR1J2K1EvOW1DWWg5bWdxYjVSckpmTElaQmhrVGRuaUQ0RnBYTmw5WGZBcXNoU3ZoaGd6Nmoyb0ZnZ0FBUjBya3BLbjFxWnMyY2NmaUc0ZFBxeEVqOUd5YUt2M09ZVkUrdUF3eTNjTTUwU3RvYm0wWkRZMnREeElESWViaVIrUDBDSWlCSmVlRWlyYWI5RXlPQlFOSHhoVmF0bW5pZjZwc1BCWVNqRUZESjJaa2RBd1d6RGVqQkd2YStaVTZ4UzR2U1crZENLZUVsb3ZBa2padTBGMHVpTjRLelhqN0EwN095QitzNmlyZkNNQUkxaXA0aVBtU21oSkpQZU9aclEzckpGamcrTXpHVDU3aU0wVzdTUVBlUEpHTHUyeDk3ZDBqVUlYa2FJei9mQVU5eHdpZUxsZ3BSSzdaQ1I0Y3JtTVhFd285WUlFT1VsUVFhbVJUd1l2MGJFS2dqRGd5SU5UUjRNZG1MaTdiaG5ySDA5T1plbGhBTHBNK3gzbU5OMmFMQVdad29JcUVBa2wwUmxGNTRpL2RxSktMWi9rcWQ0dnZDYW81dEFoR0FOa2k3NFRtQjhUOTZiR2FVN0U1RjBsTzNwNmVhWkVDeGFPaGY2QVNTMklkRUJOSlpmNEpNaG14SEswNEhhQlhDYUg1emhTM0hYQkF6bHZCNFZUeTRndis5UnBzSWpOZzAxTk5McFVWU3ZFTWJsVFc3WFVTKy80OUxWbnVna3BvM0hvL2wyY1JINUN4TUdaMVE4WEJqNUNMWmg3aTJVUXIvSnNFYkUyODdSUDgxYzZJYTJLQkVTRjd0Z25Hc2VRY3k0emwweCszTEYySWJKc1hiQS9hZlZHNE1ZdnBwUldsUmhPSTRzYmNncnA4d0JoampxVWM5VHVYcGI3dEZHNEx4RUNBQUVFL3ZzQjNlUHRsdUYrdlE3NWtlNEhJNzk3MGR6UkVENGpUdVpCdWI3Nm5pVG96SGVHelVIeVZML0ZzNXBpdEdDNEQ0aitQUS9yMThZTDY5T01oVWZrcURjL3BSZTZYZk9SbHdlL2JaaDR1c0lhMEdybVVYdWRLaWRVR01MdlRBcGp6ZXU4NTdjejZvUkltdERPUWFvaHZSb1VTSHIzd3ZpdHMyM2l0M24vUW8zQi9GS2xVaENmdzl3QzZnS2ZkQ0ZvYllreFJpbGcxcWxKU0VjWURhQnFTTlRiS2M0S25IRmJnd2xTQTZiY0gwZ0hjYjdCc0pyREVEWDZUclYwYVR6L2N1TFVqWENJcGZweVhGQWdDK1B2RW9nR0xJWnhJdi96bmNGZzE5alBKaGU4ZnpqTnBqMDN5bjJzUHZ1eERiTEZnNXZ6aFhwSVl4TU04TEFJcnhpTEZKUm43RE9WTEdXZEtmempiSkdsT2xmUGtpMkU3bEkzV2ttYkRocDVEWHVxWUNEeEZnVG1HOXprNTlGWDFNZ3dNUC9INVN4UUdUQlcreS9yclg3eHdES21Udzc4VFdxVWgxKzlId1QvdUFBRUhubkJHeDdHTE9ueXBxbnNKaUlwUmkyMkFXd0JZNVp2SThtZUlPYnoydU9SN3ZDUFZWZG5HVG1WNzFZYTF1b0NwWGdPdmp0bDBvSGhjeFZFU3ZWOHQrMDdZcVFSSUFiUFZxZElGMWtndHUyRlU2UzZKY1NqajMvRS9DZm1zTXdQWGl1Wk9pYUNKeUdUNFovUldnVEE3K3hMUnd1Nmg5TkcrSGdoTlpCR1AzY0RHOHFNaHV5ai8yM1JBaU93ZUJvSWpZSVpMMlZ3blRqOURjQU4xZldpQVg3SVpGY3V1R1phYjI4ZVBSQVhFZkJxcUc4WUpiOXN3NSt2WnRWTFZHL0ptbDI5Q3dxVkhGS2V4cnhOTjFiNW4vWjhQZC9wbDVhU2U3bjkwQmJ4OG5KeU84cjlrSHFOSnJnSGJaVTFxaVVjYmFlNitISnZHYjNvQnZYSzhvRHY2UU1GWVZoVnhNd1lzamZPK3N1Wi9QM2NNTzJEUnV4TUtiNUdnams1WjRXTGFQWWY1VFJZS3hBM09MOVAwL1RocmFZWmpseFc1RzBtYVAvYzJXSm1pQU1OUzU2VVc2SlI4RlNKTExva013RFRUTzJjRlA5UGpPK0taVDEvZnZxd2NubjlhalJ1Zk9Rd3FFM0YxbEJLNGE4UTlGK1JPRE9TOHE1V09DZDd5ZTI1b3J6ZHhqOEtDMXdwY2JYcmxrbStyNEFGYzVkWGRBV29xZVIxWmg2TGIzRml0VEdpZUJjeHZiVG1FeW9hcTlNU3lHRGZiQlVVeG9iTDdFZElsQVZWODRKSnozN0J4TVViSVpHU0xYYk1lUElJdjNDRWtRNHVVUGJFQ2xlSWlpbEJkWDZIVnZsaUVFK00vT0daUzZaL3ZpSDhldy9JVVJ4S2xZZHozeGMwOUdKQTJKb0U1aWRSR0pGY0NTYU5XSC9vL3JQMVFQOWUwSnZmVmdENDJqZk9GM1NmRUlqWUI3eElncmlsK2Y5R2YvOW1EY09rVkI3SkpPblRSSUVCMDRpRGFZVzcrdjR6NS9jTCtZSzhrU2svWnRuYXRnaVlYSDNMam9hWU1ZVmdxMHpiVTBCS3VFMmh4Y3VMOE9abHpiQ1BVK0hmWUNqUE1SK040TXJ2cXNGa1FIQ2ljbTNwL2pPUHR5ZVkzNWxUQVRNR0tWSkdENUZtNDJCWkVyY2hFZW5MQjNEbkJZd0loU3k2UHNkLy9zeEVTU1JYQndJQUFRVCsrd0xzOGhMK2tjRGovSkZGQmYwK0g5bm5GNlBTalYrY2RRck5xUVlybGlBUTNZTU9SWWtieHkwS0cwaDJhWFRZQXVqT0ZCOFpHZjRhMXVQY3FNL2tNWHcySUtoVWZSV1Rsc2tDN05yREJCTXVzNXR5bXRyWXBDRDM5eGQ1WDN0TGorb3h4WVVpSXdFTXUxeUFGQmo2NHY3TDBOdkRJVmNTbmlTaXFSaGNqdXVaMks1NlNzT2RxeGQ5akhCb0p5MkVJYzk4NFlwNjIvV2taR3RtN1JRcHVjbCtjSDFnMXMrWlRmRldwODIxbUxFTVhBWHhWRGxZQzgwN1BxYWozQXlVeThsZ0VWYXV2V2lIRHdhSWdjTFdKRkZqNG1UaVE4SzRvejVjeEY2OEoxQUc5STBMbFlkdVBoZ2pPVUdCdjZWVmxhY3dmcTVoRm5KdEhaVkQrWlRkZ0VrQnUzbWFLU29DVjJnY3pSV0ZrMUxyZDFYeFdBc2d6UW92SzlCTHIwbU9ZRWNsQ0FWaG9hSVFGUWxhUDFSVThYUjZiclc3R1R0QjluMzNJTmdqSjAvQSswRlZjdTRBcyt2WDdEV0o1ZU82M2lEUExCVnB3K1Nha1NCYUEyaERRcTBpdExaRmVqTWVETEFyT3BzTGx6VlNlcGxXMkU4dk15b1VlWXJ5OStJRDlPekI5Z2hNYTd3ajFZM1lzT2wraU1xSTNFSkZQM3EraE5KWDVjUDRGYm8wd3dYZWlBcGdjdjlIZzFzTGp0TXd3a1ROZjhCTHp3V1NrYkVOWTB3aDVOd1MvdXFxYkdUVjJGMXlpbjBBOUJ6eGt0cWE3Kzc3bElrZVZVYXJPUGppRTMzeGttbE80SEJNNDNEaDlYS2xMTjZhWC9temUzdEc1YXVzbFBISXBxd1lzNTFYR1AwNnNZODRyNlFRL2xCcjJFMlNIUUJjYW55UVg3R0RWcGhORm0wMkdkcGVhMzdhUTFaNnhMelRmNDQ5bC9OczJrWXhaL2RYeFNGSkllRDl6WVhGMWd6a1d4WXpnQytPMmZyanR5N1RZT3haYU5FcUc0T3Y0MnJXSXU2MnVONm1OanlKQnJoWEpNV252aWJWcm01aE1xWHNxR2dMWXlGQldiZmMzd0QrajdBbEM3eFpZeU44aUhtL010RFR4S1M0SDRnNENlQ1J4Uy91dFhwa21meDg1N3g3aHFRdWZaQWFCYWlzZFhhaDNrU2w1Y254dHR1dEx3SldPSzUzTlQ0QWhQR0tKaDc0QXRjK0RQZFpDbjZTbTd2NDFCQUpjWlg4bGdlK2JPVlkvb3haclEwdXlWY28yTlNickhrY2IrQ2RkekxDMldZZHBQSlprM1lrMnpiY3ZZOGo1WG9lYVg2OG5ydEtPcC8vTCtvc3Y1VTBnY1dJOXJBd0RvU05xaHFWZitLc2hONXVCNEZUT29rOTY5TTRBRFVzN05UQWdYZWwyVG0waS9XcTErS001aVVST1ZleCtqaVBFVkt1bStiRjNzVHhPbkdId0ZrSnUweklQcFFHQjJmb1FJVkxzRFk3VFpqdFZzK1NTNit1Wi9WbENxZy9hdmNpU2N3Y0tuNk1DUTUyREFNd1hFUUdWU2w2clk1bnVGRUtSbkR2UXVEMWdqYVhRUXRIVjVqbHlBWmltYzZGNGdwOFV4aVk4N3QzMC94eVEvN21UV3EveDA4Y1NtLzkwVzQ2WVhHRUtaRTFhcURTc1cxTCszc1hJdWRYRTAzSUVZWGdkVEJhV1kvZzl1eWhvL0VISE5wVTlRUmV2MFpPY2FpcldYUTNCSUlnRmRwejhTcnhBZ0FCQlA3N0JIaFFWRzNmZStCWDlJZXRzVXEyeXRucUpMaUlWWXphYUpybU1FNGxBd2NkamlRN0NWZ3A1cG50SURvOFM3V2pPNVVXVGRQMjJhaXc2YVJVeDk5TzQxMkhMd2htOThNbTI1cStSQS81VkJwa2JpVFh6YmE3M3hlRklDSGNaNkROZ1JZUUFiYVhYelpmN3lMR0RSK3F6alc4RExieWpWaDU1NWlxODJYRWpQMW5rUEN2d3ovclpIUHAwVENRcTNFLzgvSzEwWXRFaXZQZzJsTWR3UTNJUzZhUGpuV3I0SW83dVY3YmJyTTlpNCtpb1VTZ3AzdFg5RkFPWm9nZi85RXB2VXJEVFlibmtncXNRQ3Rob2tBclVVUDc0amZ5VXN0dVNZVGVtdU5ZcjR1c1IxSUwwaE1FbU4za0xNaXBzT25iUmpyQ1Z6MllsYk5EZTIybTd0WDZYWk5UTlFGQXAveDM5ZmZhZEJJU1cwZDBQMUQ0azluRk9yKzFjd1pERHVZaDNQaU50QTJodU4rODJhcERwT1g2ajdyT3NpMTRycFFHb0dLUHZlWGY5OWNHWGJESVN4V1gyVE1vd3hNMmNnY2Z6V29hVVc3ZUxFdTBITHo1NUl4OW1BcUpyYkxVVkI0Rmp3WUhXQi9KQzhxOUkyYWUyNzR6MlZpbSt5NUg1R2t2MjA0UGpWSTd0cUozcXpBMGpSZTV6Z1RObnBRZGE3eTBobURpRmJJSEhxNDhMaW9IL01rb0VxaDBsa29MRE5MckladnNVT0Y1c1B5VmEzOElQTkRuRFFsR09MbDVjUXY1QmI2ZyszcVRGdVNJckE4ZUpBUEdEcDkweDIxbDJSOEVBcTF1MU1NWm9nK0ZyNnVWWDJSQzBiRGRkSkEzSlMrellmYmRhZlJXS0JqbThVdDJ4S0hnd1h2TFl6UTR0NW9XUXVYWDkvTWdsajhjWDNqd05uYmRyYXlKSnVWb3NaVHlYUXBSbitneHl2d0t1Wkt4U2kxNm5objlSd3BOWEYwYStpYWsxaUUrU29qcFM1ZGM5cGtSaFZYd2I3VC9pcUJzdTQ2NnNMaDZoKzJzMXhwK2prbmR5MzdiL2xaQmFYYXpyd2V0RmtLUWptbllIb3NPTThZWXFjSUpqYUtCYWU5SG1OWmxyOFlDdEdjcDhVNnE2SmNBNVlURm1EVFFPb1FpOGV3ZVVHSldmVUlhWVlWR2FIdkVuY0pzMG56R3ZFdWxITUxUdGdOZllzNk9GTFU1WlIxaXpwQ3FQUEh4ZDN2RUF5bE81cjBpRm5ESkMyVCsyL0JjSXplME42OG1DZFBCUEhQTlNEczdQM0xMQitzVnpyMWF3bmdweFlDaGNNMXVUVld0aWhndXhLaTB4eU1XQ2xMN2tJN3o5aGFFQTZRRjNyZDFjcHhNUER5MkZKL3pzTlRJRzhtNEhCNGFLaERTN1gvNEVqTTRVSE9BOWlLcnhGSzN5T2tJSm9PUUg5OXhIakUvTHdZdHBkTHlMT2V1RVM4S0NJRUVHaEZJRythODdwUE5zMWJxSDBnN0RoS2dDOU1Ic3ZkYWpwMUVRWG1Sdkd5RjkyYkIyejAyK0oyOVdmTzluQmp4aXZRMUwyY2IrMjhwWEt3S21hc0lqOWkvWVJFV1lacFY2ZHNManQwc3hpeGZuTCswWmZHWWhjSTB3bWU2andia00xT3VKd2haVWxsTHFFNmZpOXNoanFYS3BPQ2s2TDNkMytkSWZJZXJJUzB0VGFZVDZ2eXVMTEtMVWh0NlJ5anhzclBLOU5WWnhzZlRJQnVRUEhPVUZaZnNaUGhXd1VJQ0FBRUUvdnNCN3hiUlhTSm90K05uVy9LdHRjcjFsTExWNWdGRDltcXgrcXdmekc5QmQzZDFKOWF2b0lmSlRtMDlkcHRsNUkrc2x5TVU4M2kvTUdmbjUycXIrMU50dEF0RmoyUHd3S3hMQ0hJY3dTN0RyY0hNTHZYWVdGNHV2dUJONTdXUS85bHhza1R1MTUrYkphd3A3WHRzTTBKNi84YUtvSWhoQUg4bm80djFSZDhuL2tlU0JCVmRvME9ZM2lqVk1KRU8zbDBKK0o3Yk5DUjNWL0FvaVlyWmh4NFlNQkpVRE5iNlNMTVNkN0hXdTZaTjZlcTRzTmlRaS9XM2tUcnZsbm9sUnlSaDBDMVZmV3BMR3NFY2g2ajFSWDZZQzNvWUo1by9YSHlabng1ZmcyRFdEUzlFZmE4QVBiWXM1ek44M2dpVUd0NHpITlJaVmIvZDcrQjJrdEd4cVM5Uy9VR3pQWE9KRlNOSkFWWXMwbmQ0Tlo1WWZORUlTeTlkZ2JpN21TZTFZKzZ6cXJyZG9MdlRZcTdMN1Q5YjEweDA3MEh0bnRqemg4MGxYMHRZbnl6ODlrRzNKZUhQR1dpUDV2YlRHOThreVlnb1dxbHdacU9KNU4yQUNKVmJDWmpJczc0Y2VnY3JGMWJJdlo0L0ZCMjY2K2NxV0ZUNTJSZU4vNFRmQ242WjhrVHBkUUdJYkVRRG5DcHlZVVR0MWkzTE9sOWR0dWVDV3hJL1ZFUXNTQ1MyS0F2MTB2cC9pYUpBalFJVGRYOVJ0MXhCQS8xZFFreHhHZnpVMDVVQXNDTDdybDN4ek51ZWlkc1JVT0grd0w3R3k0ZE5Lb20xTERpVGlLQkpYREM0b2xjWlFVaStwSnRJdHZOUkJKUXVVZFJCc3VaQ00rQlZMRWNGN3psWkhKOFd1TlE2MFBBd1RBMnBza0QxTHlGNm1SY2ZTdzEzYWw4NU42b2NraHkzeWFhWkZsRGxCWFd2aDZ4T2dvUklMWVBZTHMydWNvVG5ZWkVYMTVQOUVkSExZL210MWJqMjRSK2ZEdFhSYW5peWhxbjl1bnk0SWJ5ckJLZ0tpT1BrdHo2M1Z3TkJVQnZMc3Rjd0M1Y0o2RklLNkZ4ejRJMXl1aU1hRlBLRXdyWERKOW84MXdUZW9QbFg5ZExsZGI0aTZCQXBPRlJwQkxNNUdjbDcrditqZmVGVDNXbkFDQ1pyamtvU1JqdHlrcmMwUTRQRnQ0cmhwVWQ5NWtXSFFQYXlCSW1NdFpzeC9sQnFkQlF3bEk3UXIrQ1U0Z0hLZXhTMWF3NXY2TDBsejF0U1RGVlV5cVg5OUxaOTlaR0JFWGFYK09XQ3F1Y250cS8yRnhjMjRrUDEvSk5PUVIrMGJZVlVWd1d6c3RyNVFRL21UeE96MmdqT1VXRVNDeGdoWFJMQUI3ZExEVFFwek5nNmVZY01aVjRtM2VLU2pzcHhrOHM4cEJSdG5GSjlQVk5QNXc5RktBcnB1ZEdaRDZkY1gzSm1TSjlUZHBGVVU1MGVNWWZJT3dtV1dXUnVHQnYvMnlVUGQraUE0eE01c2FBOWlZWUNvb0hFbHh2UDgzMzk4dmkvQlIrRFpKS2plTSsxRWpnVWF6aE1SbWo3a1p1WmV3QmFZREpZb29ncHN5R2ttTTU5eGJFWEtYZGYycHNEZ0V3NHZnbDhpWWl0dGd3NjB5VGZ0OStHOU51b2cxakxmWHo3Rjl0Q1g3bmh6V2JqcEw4Z3E5Y01IMnlvU0tXSE9DeTRKdkFOMm5xQmt2OWlpaE0wTVRYbFMwWTJUM2wwaHRGVWNtblF2R245ODBFVE1uNHFod0lBQVFUKyt3R2xLUUlZWDdoT2dTOGZjN2IrNWdHcjdHNHV4b1Vrb2Q1dHMrd3JKK1Z4b0JuM2xHSTJyQVF4VFVXU3F1KzhVaFR2TUw2aCtTVWE1RGd2Y1VraDhhZHJRdlc2Q0Y0NnE3dUNsVk10d1NVODNFbGdob3hPRzhsS1NBeW41MGx2K0wwbDBPNXplN1FsOUJVRDhsVjA0Q1J2RklpTlptVkNCU3lzeGxDaU4xZmhwWlVzakMwZnlwWFpZRGlQekJlSWxvcEtiR1JWanRuWVRmUTNwaVl0dG5BaU9ETVpjc3piVDM5d1ROVzBpRzc3NlhBaVl5YkhacFhXVk41Zk9CTzg1UmN1S1lzdHIveXBnUjBLd2tzYkFhb0FGRXIxSlhCemFNVTNQSTR2MmdQWkhwdGZTeWlDcCtyNXRzcXRBandpTUs0S3JHdkFxTWM1YWZkYkd2aTVvbXRpeHpLbDlIVXd3d2VUZFV3RVQ3WGMxVG02MlI3eHMvTFJDMTZMNVdGTzhLMkJxS05jRkk2VzUzYVlhUnNMcFRKTGh0eEV6TlhLUURsczNkd0p6aCt1UVhQdlordk10R2xpQ1QxN1o5NURBcXV2VWJwQ1o5QlpaK0l2dmg3aUNsWllUNWxkaG0xTUNkbmc4VjhWTlBobWNZdmxMelNnUTJIUTBGaWY2bHpKWnVjbTZNVVhGdXZTRExrMVduc1pUcW1keWMraC9BRXluaHRsTUd0WHU0aXdLTjIzQkQyUThRU1VFOGtvb09NMkdONU9jeFlzQ1FyN29wZm5TZjVHVjd5SVU0RlhkelJHY00rOFdiN2JuK2VYcDljMzFGMnNCanovU3AvNHVMMjlDdWZrWHFqcTBRWVM5b1VHYWcwN3pTMnR4Q1hNMlpDY2laZzdIMFRSMVBWai9oditsbEpsNGp3ZEFDb3V4NzBlVGxaemY4c09QNml2Z0FiWEpJVSt2S0ttbEo2ODg3QzJnTmRTS0FEWERFNjhvZHduZkRDN0wzSHdLS0huM1NLSnQ0UUpNK0pPcHBEYkZZUjJ0Yll4N1JpaXdjK2Z4ZGJ5NVAvL2x4RlpOZHVtdGk0NlB4c2ZUUEo3aG9ad2pZamVKZGVDU2VwVzRjT3krQUNaRTh4YndOQVphTjIrL1AwaExhOEJPOTkrUGMvcEt0amZ0cytSUU94N3c2T0V1QkxOL1lEYVdiQ3R1bXNYa294clh1eGNlOVZ0VG5LMDBGY01uV0pYUFNRcElZR0dhTVVHOVhVQW8vOFdCRTB4NVZseEhEWFhMN2NVTzZsTW1uOUZaSzR5bmhwVVJFRHFlYnNsQXRrZjZyOWFEUHJ2MHRDMitzc0MxT2ZlT1dxM2szZ3IydlU0aVJhaDVXeWUrN2tpeFRQSVR4elYwZlhvWGxRSk1TNjQrNVF6N2xKYS9EcWUxYVlIRmZld0hzTUZmOG9wZlFWYW4xS1UrUWorMU0zcmpQRFhsNEVCZnFPWUlyM21qL21UdVNHRlhRSlgwOG00bHh1MGp5Q3A4Szk3dFNjZWRhQ2RDV3p3aFBaR1VvSithbmdJTGZ3RFZ0NUNMQlNjUXBxV1M0aWsrT01JWDBtVG96TU9rNEhIbDgzU21BWEVaclZmb0JQb2FXMUZlanJhWmpVcmp0dEhER040c0pIcDFoSEdMZzdjSTMrN3FZS3AyZjJNYnQyL29xanpzWHRzNDVHcGZOem5Ya3BicHNIQllxek1BeWVRSVc4dDRkdHQ1QmdCMWFkV1B0T1FHdlYwVkUxeGVrR1NlUmNVcHd5RC8zWTJIWnJSczk3OVFtbm10UllabVBpckFnQUJCUDc3QXA2OTU2NWttOVpTT0JyRDl5VmpMQVdkRUNGYTFRME5DOGUyN3ZPR3J6MTZMUWdjSmRCM0dXNUszRlJVVVpwejhVNFVMTGFOcHFwalViYmgvK2tuWFdQanNRNkRxd2FCNloxOVllZmtuamRUTmJ0bDROcGd3cmVFaDJnM2ozblRPUXdBWmJKTUMxS3JKdGdsb2s4Y0pjODFZZEF4ZFNsUURsV0pKbnBFTmcxQVRrNVU5Um14SDJjVGVoNVZPdVV6cENxSzZITlFJVWwra0MvSnNQdjRBd2QvRFA1REYwUzh6QXVrdm52aGJKcmpkc1FldmYyNzNra1RCcXVwTmVqaDlHVHhNKzJnVUlySDNHT0JuTllFalNYS3RpK2lVUE9tZTVHbW0xRzZvSEo0TUVvQWFVTldneEwyVm9oZFdGLzZ5dmgyWEJzaXJndUx4RFlDN0VPNlFua1c1QmdsQ3JyYVE4RjUwVkd1ZlNEcXFOV0FKbHlTTXB2dWxKVm1MTDVDQ1I2aGw4RW8vMzNTSFJzV0doR1RoSzdXL21KRnhrYm5BeVJHaFpwL1JGODBiMVdOSzUzZDVvWU5IUTdIWDFHZTVzWDdnenA2WlR3U3dWTjhYWmx4eE1YTlZXWE85eTNUNmJaSFZXWWFYeFMyb2lHUy93dW5wTXhYcGV3REtNbXZNQnMxaVhicXFtWS9xRUx3MFI0MFhWNzMvOXB0YnFSQ0NSUERIdHduaU5rcGdQRE4vR2ZSczVNYkV1Y1F4Yms5OS9vamhObVNBSlQ3Tjdib2RTYVk0cjIvdVZyRUw0WEEwOW1QTTB6ZVNaMTZucE1VQWhmZjFmMExDRWEwWEw3dkhyUTR5eUVWNVRWVW5EU0hTZVVDTFI4cWsrQzlDeVBONVB0RjYwdldGSEV3b2ZEWmNNd01SUnpUT0Rra0FpRkd5Q0V6bjlQNXVBTU00cjBVYmZsVmRrUGpOaUVKNkI2WjlyZ0ozS1RUUGhPWWtka2hUdGZIdHVwK3F6dTdia3drcWV1ZTc3Z09nWXhFdUtPRlJxQmFyMzdrMnNHRFFQc0NBNDBnaDVFcFdDK1FPZm9sRWthaENJWG9yVk9ERElZa1Y1bzUrUnRRaTlpcWhnKzdEK1R4VGdiY0VNLysyMjdMelNkRGxURzlYMVFYRlh4aDZySnM3dHM4dGwrVGFKRnpmanV0Ky8vZGlkb1MybG8vbmZkWFovZnd1SG9QeE1pMjZ5dWVrQU9sUVprVEREV1RPNWI4WFBwOVJUazgzaUZMUitmK3VwUXBRblo3eHorQWxtR041TWpPRVVmc3FiU3REQmYwRGltaWlwWjFIMmoyWEtyMi9rRDRyN3NFQkZDS0xLT28zbXJ1QmZMUUgwRnJwK0cvWHNTVCt0N2UvQnFTMVl6MlVNS2RPVUliSnZKSTlkUi9tSzBvUlVxM0RpWUoyN1ZwWTZWMGRrRmZSeXd5d29sMFJoVDFJR1ptSEQ1V2lXeEo4QXh1K2NmeHhNVStOOC9hYzZzbVhKNE1KR0JjQVhOQ05QMlM1M0pSZlBXcnZsRENEK0J0SGNKNWN5TkQ4K0RTbEtUckxqeUJuRFc2MHpGT29sQTB1MUJWWVhjbFduMEFMOWNVeVVEWEthZzd3bFV2bU5VajJKbHVhQ05MSUEzYzNNSERmbGZkd3pNMXlYWCtrVHBwMldoL1NWM3pRQ2pJWW4rUDNBT0lKWXlFVW5pS29uZFBmSlU0eXFQZTMrYThza25UeUNjZXRHRUs0MGZlZFZNM214Rm1pdHpqeEJsZWV3bHJvTTZjWkJZeTZyNFduRllDQUFFRS92c0V0SEhabmhEOTFyd1d5TDdjK09OR2xjY21Ua01ZMGM5ZVprc2JwOU80MEpZQVN4YSt4TmlLR1J1R3hINXA5VnVPTWJvc3pFWDExby9SV0JZNWEyQnE5dFhIMkVJZEZPcXhLaTlER3RVZjlHYnBwYlVEanh0Mlh4OGt1bCtqOENJV1JFMUZMUXdvKzlTSWo3eS9mL1FDMjlzNDdXbnpMalpNdCtOc2JGRTNxL0VhQnZua3lIc3QrMHNZTHArNnVDTGUwTjlqYnExU3RQUVJQVTRCb0R6UWVNaGljNzVYemZ4dzVQMmlrUTA3WGtvWGhSU3dKcUhVL3prcXZZSm5pYmQwZTFPMDlNNG9sd0VKaTFvTkJmNDE5Wml1bUkxTlVDM0kxMFN0THVYaXRoazdHVWlHdmVNT2pmOEIyQTA0V2NkNU04MzJ3U2k2K0dYVXdxTlBXOWRnRmE2a1RhTDlDUW8xb1V2c2N2emhXSkRXMDhxdXlBYXNkajFYNFZDdHVKcUt2WWprNXl0Q01zSEtyN3hKbW5tY2M4djkzYnFPb1ZGQ0NOeUxBclFVVGpNUUpyRFhUMExBbk93TDRrcThzQndNNnZjNTI1dEl4cE9hNnM2eTNUMVcyL2NieVJHR3pRckJSaEtRT2x2SnNLOHFYYzRHNUlCaEZJZUVTNkJickFMcWhVaFR0ditSZjB2M3hPUXY4aWxiUnVGNnBZam93TXZQbG0zcSt0bVRTR0t4dW9zWXlRNGtkYm8wM0ZBYTJuaURPU01nUk1TOFZKL096UExublJHK2ZCSTF3K1hkblZDUnQzRUEvcE83dEVwRnFkRDZFUUd3SW91c1dDalRpYzVUTW9oSU1xbEc0SCt3dnNnUDdORkZ4ZThIbmxhRGlzNGF6VDhhbWV0RkdNSkVjdnlHUFBGMEtVYzhhOW1hTW54RlhMTmpXcUtjRFM4ZE16dHdmcVFLKzJCTS9KRC9Xa2xNTTZzNk11Z3ExTnpTTWpiak92LzU5dk84OXZhR1JYYjAvekZBcXJuQ0Z1YVdMMlprK1dTS2RVTE5TTTV3OXpiYkxuY25rdzQ0UDZSR25jQ3MxaURaK1VpeGU0MVBJT1BQN2M1SVFxR096ZDZCcFlsUDlBeHM3K1RRN2dUMkZlcFBJNFpRNVF1Ky9aalpxUXBDandnM0NFN1lpWDVpbFA3UXNGOFF4VmlaM2ZWNUI5VFFJdXUzeXBTVW95alpCak1pckxIUDlac3hoWEpjclUvMEcrajdaWnZ5eldRdlpySnRqNFp0QUxsNUMxRlI1dXRTSFN3T3NiaEhiV1ZjbmVSVlcyRnFNa05mK3JuaER3LzdEQk1pSVVSd3hhVW5VSFU0OWpCSHErTERRRGlNMVhtaG9RSE5RcDQyMUtVbTdFZkpYUEtvalJtcHo3VDJ6cC9pelZ1YkxKVUtDdXg4WTlybngxdTdPS3YxbGFOeWFiemNBcUwvZFZ4ODgzOHMySTdPUllWc0RLNVNieVBMTVpNR1psYmUwTThQRUJkRnp3MGNZRGZUcWlvQjFvc3dGMXRsdExNYndXTFh4Y3hkRXBkUlFTL3ZIcUpiMThZclMrK3VzZlNWU1pqUDV1MmN6bi9tWUhSWGp2Snpsc2Y5UWlrK3hrTHJESHJKVk1Jd2V0NmY2YnZQQStkYTJ2TFNxQWg4L09wclR5eEF0SG1rbnJFc3VISGdOOS9IYkNWUmFxb3V3RFNYcDVDRnFhMUpUbDRTSmVqakUwUUpFMzRYQTJkRDE4UmNFbExsbmpCMCtRTytDZHFWVENxb2JsL242VE1nRDd3R3BRSUFBUVQrK3dDRFlqeXhRLzAxK3ZRR0F4eXNwRzRKS2ltakVNc1BOZm1VYkxhUW9sbWRmVzQrbjNRSUNJdkw1QUVESFU4TGZQa09tSzNXMzcyZUZZVXhpUUd2RFhPV0JITC9VRTRSdXR2YVlVR1NqNUJIVFRHM3BzN205SXJkWUY5Zmkya1RXQnBiVlNGcW5CMmkwYzJUTjkrblRvU3VMa2dMckd0TjJwanZ4b3huTkhRNTd6dkNwUzlDbXdwc0wvMXVZSWs2MUZqVm1lZ3kzRi9yQXFFNGJvNldlaW50R3lFYlZMRnNPa3pzN3J6OXRzOC9ZOVFIUXhaZGR4eU16VWZQb2xzQU5KSjk4Z0Nra2diS1RKcDNwSXV0cUlBK3pNbVErd1VoM21VN0FMU2dLRmNxYWdyWW5mSmV1dzFoK0V2Zmh1WFpiRFdrM1VMVGgwRG40RWJOQVI0NkRNRHRRTnFCZi9HbUNCRUhMYjRsOTFTcDZqODlJdVdhVjJwT3lyNUxsb0hOVVluTjROWTBPSVhPKzV1VVJYZFB2eFNwcUV1dVVrM1R0Q1RZcjM5UGNxaTNvSVIyVUdzZm5LeHdEV1VrSG40aTFKY0FJWjBUbFpUT0VSbXMvNmhYenl4VFVHVWU3U3ZqTFpROVgwckw2RjRvdHRPWFZYMUg4MlNySTlIK204MWMyRWFaUndYRUg1Zy9iMDJ4K1BCSVBJOFBHV0dqQk1LL1dBbklFdWZvV3Z3TGlwOFRFVGJNNkZ2cDdYNmNEQkVJbTVqVk9aL0k2NXdyTkdmL2RsVXFhOWo0QlZxeUJwYkFVMDJIUEZ3cDBsRGJJc0Z6VDM4T0gxVUxzME8xZThlLzBQV2FWZUZHTDVXeGNLc2wxTjVoaytTb05weW10aHFpdWYyT2tsZ3Z0TzlIZFdZMTlNS3BudC94a052UkMzUjNyaStyZmgyU3pOTG9teXVzLzQvbTN1c0puOEhOWXdhSi9PZTVBOURGUU1Fay8yRm5ndDFIZkNqVjZwVmtuTXI4bkFIeVRHd296L3hVUUNBT0tMaVJuVzhYNHhrVGM3K2NjVnVwbGlLcXZOV2FDWnMrZ3RwaVBOejhQQXMwYjlza3MwcEdreXN5UGJZQWYyMW5ib2hJWk45QjNxUkY5SGhsaVFyQTNBaUtNNGRZUDV4SllYclB6eUVJSlNjb0YvVThtTGVwd0c0WXRGbng2WE5vTG5yVW1PZ3V3OU0vRmRZVDQrdHhJQXhhRTRxNmRGQ29jNmpoVng5aFpIWWt2ZGZLd2RKTE55cGtmL2JCbXN6QkZ0eldpMEdzR1RhYndIU1ZjVU9MUWhTcmRGbXI3M08xdkVyTENPT1pCWS9aeTdKaDROUSs0U3dFTnJvZEVNd2VsL2NybloyU2pLRGNsWE5YaXc0ajJGd2xzc3FOcHBNUm0wb0ZNb1orWGR2MVVOWkdCUU9NOE5xaFJobFpiVDhtVjUrRmJqWCt0eWdZbWhGZGJWdnIyUW5UQVRXRk5lSlZJMDFsU0R1cFVyNWd0WUowc1R6Z1pzeGFtRkFpOWoxbEVnRFNuUWYza0NyT0d4THIrUXdpQitQRitOTVdkTEprZ2ZwL1ZXOVJnMVpBT05hNmM5Z3RXSjJpdXJ5dFNGdk95SXNmZ01uOG9iaWJ3U09RcGtxUzdHQy94V2JsNFR0NzRhdmIvaU8zTnV1ZEwvYlFpZFEwMUFzcmJlM0FSY0hmRHN5SUtVcnRQb2gzMXJwUHZHVVhYRjdtSnN1V0loSEJRRFZKSWxEckxvT1dZYnZkRUtDbzl0clp5aW1IOWN6dDlkZ1pOeFh6QWdBQkJQNzdBYk9qeHlIQlFXNzBaWmJMR0daVGJMMWR1azV6b0ZhbFR5Z0l6Smh6S3c0WmFIRTI5TW11K0ZwMVZBcWhGLzJNeU0wazBnNWJlVkxFYXZibDJRWElKMUdaNU5kdXhIOElwVEJHZTk1OERXRGtKMW5TOVBPQmdzZUpjOGx3Y1RWK1BpbmkrQnJtVmZkeXh6K1grem5zbzFOT0d3VDhQc0dHcXhrN0RoNDIzbXd2OUJiSmJNdTgybm9WQk85WDRiYjNQQ0h0WXQ3VmZLN3dSczRDazJSaHdXVGswaVl2MmNSUjlJTTRFOTRicUExMUpnRUJ0cndmQlRUNEczcWJlN1pCSFJ5b2g5SnpMYTYxYyt4bXpHMVpRdDV4czJRU0EvUFZJSXVDS1hhejNNTmtJMzJPSlgrMHBINm81L2s4L1hnc0s5eXJSNUVud21DOFdocmFqa0tCSDE3Q3cwYnBkUVdrNlpsQ2tHbDY5K29XU3dmYSsxV2xXVzFzS0hpWkdMTjl1YmRCTDQrU2JiREd0cXNQd3RkeTArK0VpemRBTHlRYm9QRkl1QXcrSHdvK3l2YmlBTTA0eGpzM0drQlEzSStzY2N2UEN1YnN6eCs3c2UvaGtRL1d5VHpXUXFLYk13RzdybTlhNU5WREpmYmNXYnVTMVdkN1VkWGdLSEMyRzJjSWdUWVRUVWRacVI4aGFhQWpGaFVEbGc1QnlpcmUvcXRHRjUrRmRXb29YZk01VHpsUTJlMGVzU09VbEs3WUQvczd1Q3NNSVp0eVRpU0M4YTJyMUZYUGFVWXYzdG1YSXNOc3NsZEhNcVJrbmJNN2pWRHFrS2lnSEJ0M1RENzVSdk12RWh0Uk5XRzcvd29qNFVudk9PRU5jWW9iZThJN294N3BqZXFFbXJuYm9vY0JUQytWUDNjcG9JZUMwZWtNd0I3aHh2RnFFWUdqRWZNSlhMbk1QUnlwZHlwN1dmczB5bmxrMGVXd1FMUWMweGZ6UVZiOVlRUXAyWEhzSkJuejNaSkNxZ05vUnFFRGNmK0tpbDk3aUk0YVFHVXlud0ZtUXpWV2RlVElkLzVyYUxzY08vOVZDZWliZWVHd0hYSnVyVDAwcUNlQ0sxT2tpc1JVemIwMC8xSGdVaXpYWDhPSXBmSzdYTU9FNG02TmovaHBXeEo0dHRNK1B6Y25raEx3S2NlcEd0cittUEFVbW1uVE8zeFF6Rmk5WDE5WVlrU0RxNEdwRHVRS3hyNnVIeUtKbWxrc0pjWjQvRFVmdkkyeDZuekdWOW1nM2FaVDltUjNTWkk1RmdvWnNBdG1UYSs3cHNweHAvaDNvQ3dRZU9UdDU4VXB4Ulo1VDBtMExXbEZjQVQ2V1pjK3FFYTQwQUUxendhQW14UkZyYnVaUVB1Rkp0a2FmTGcvRWhObTVzVnlxSVBWTFdQQlBrS0QzbGcrR1RyWVVzQVZ5bmptVDBzSUJ1RWJFcTI1UHRWakx4dHVUS2NPZVlZdFl1VG9sSlNSZW81S0QzaFZncHpuV0pWTDIwalQwcG1iaXZNU2lFekExMDBLL0ZnbDd6akdMSThDQ1BTbm5rcEpyangyeGxEdytoS2JtQmNsQjloUGVGVFVxTG1JRlE1MTBTUndBQVpTNzBnRUppVng1a25EUTU2dFdmcmdlSTYyVHc3M0hUejh0VjZJMlVrS2dzZFp0QldyTGZqY3pvQ1kxSGZNd3BLVXFxYkF5b094OFp5SXpjNm80UFBYVk9nNDhvRDhGWnpUUE94cFFic2xHMVkxTTFiN3ptd0l6OTY1OFdxdllTanFpM3N4YjBieEd5VUNBQUVFL3ZzQXVPdlRvYlkrSW9odFJzVnJ5Y0w3RTRFT215UUtuZW13TGxCYkxyNWp1QmVuNnI1Q2I5UjNQeHBSendUcWZyY05naTNCS0lIaXZGTE1JNWdkd0hNZjVqTi9OZ3FaMjJlZjlSUHd3dUVGZlhBWnJva0lpa1dCY0pOUXpOUjRMRmF6OEoyOUx2ZDZmbGpNT2NwOE9OMk5QVGtFekVrUVp2b1A1aE9JQXpjTmx5d1Z2b1BDa05nMXJZaXpVVXVrQ2pCU1JOTFQyS0cwSTlyOWRLTyswaXJzSnlTeDN5ZUNqV0hNbVhMNjhCQWFWbmdHczZpTVp0L2s0VHMyT0ExY29pbnFpZ3RlUTNwQ3VLQm1aN3BSeWdVWVZvYmVqQ0lDdGs5RlpFK2dOb1RaOTNjcTRnSlo1TkdJbDBlUjhvc1N4cXE2Ym5ianRyNWFGREpaQXAyMWRGQlhaV3FxQ1FkSEZWb2ZNbEtJRi9BN1RCWXp1NXZ6S2pCVjk3Z1BrcnVOelA3MzM5cGxJbGhkTHR3UkRkb3RwNk5oMm12NFpQQTlFRmdMb3pNbzQ5eWQxV3JadFJrKzVQelVrRXg1QmI2YUw4eGIzVzlqeDdyaXJjdzdNdkZyN0tHblFsYWNnRk8xQkNNNGRRNkhTUStRSm1WMTF6REZ1UW82RVB5dHQwczFZWklTSERxRHh3aDZxTE1NVGFtbytONUZoclBFRUlOUDRDNEh2RzhxY0pWTThVL1lHOW5VMEJUVmRLTXBxTldOSzIvWFFkOXlYY2RZL3RnRGNFOGtPTi94VWt6VGVJb3JYMlduRGo5Ynd6RUQ4N2QyMEpHaEVhUVZjY3lRQXFWbDZPcG5vUS9ldTgwN0dZYThoekFMRk5VdGgzd0wwbVZJOHlyekNHekNwMFVEdkZuZDRBTXhmWU05SzJtN3RxQUIyNllRRE1TY0hDWFRtUlg1dWNFaDNmS0Q4VlVTVCt4THRoOWNYcktpWTQ5Uy9sNG5BR1l1cUJPSXlHNlYwQ2dlMGZvTjhZRTIzM05MMzNpV1ljRDRaekJ0eVhLeDJyNm9GRmdlYjg2bExsenRKNDdNa1VVbVY0NXo2U2VmOGZyZTVsazFJczY4NjRUSlE5WEEwRi9VVFl6T3RNdzVNbHEwZXFyc01QbkUrd2FWR3h1RmtsMXNVTElqbk40TzQ4QU1YOHIwRzkvOEJNVi9oc1FDckMwNTBhT01tUFlPaFhMcXhuSW9NNFFhZ2dFNVFsN1JNQlJoWE5JTWVnTERKanlDNld3c2xjLzUrSytJd1I3eXdzeXlPNUx3S052YTdEalNFOCtoWVdOVWE5WjN6MEFLemR6ZGxsU2YrZXVBM0NibnhNdTVJWk9JMnZZMlVOb2d0V0VmM0tMMzM4cEh0QWxtdkE0SDNXODErKzdSVkROZWhYNjJYTU8yek03K2liTVYyNW9QeXlPdnZpWnhMSTYzRXU3M3lOZEJaV3gyZTRoN2FTZVZHc3BhVDJDRk9nVUcxTUovZ0lUZDRsc3ZHMVZJN2tCRFJlOG9ld2tTQUJueEhPa2hFRDJTSWlXaEl5WUcwMjJEY01xVmhOVUJIc1pNdWE4SVExNUVzd1dad2hwVHBlKzZDR2k1SUpwTC9KTUQvblRzOWM1NXptbHc5cTlkTEI4Y0JPaUN3TXkrK2FjV3I1THpyTURIZ2RnYU1DU3N5MC9ZRzFzVDhnRFdyVk9CbU5tbmszbUlJMUNteHk4cWdXRkduQTNEZWl2c1FqYmRrenhxMysxcU40ZmdHY3ZrSUJaZCtUOHlHQ0F0ZEdPc2YxMWcya3NiUVFJQUFRVCsrd0lhZVlqRjFsVDliUHJQcnJIeXpGU0w0MEZ1NncrWkRlZzMvMDZyYWJiSUQ4SjNLSjl3REliQzhxWHMzT2tXeFRTWXNKZ2tCUTl6Z2dQSE95TUI5bmFkMyt1OU5qRDNxV1JEVXN1TXVvUUtxQ005NjZqM29NMWNXdk1sU1Z0SUwwQzN5S1BuSHpYZGRMY1JDYWd1VFd6VzNEVHJnQXNMWVVIQ1BaNSs4VjFmdWNyVkcyT2VkNGlwYzR5VWJNMUZ0dTM4bWlkZTJnaVRxa1NzYk5NMGw4K0VEYk14WVFsK3h3L1NUSkd3dFlpK05xRFRQUzhhb0pzc3diVitTNlIrQXhsalF0ekk4N0EwSVo4U1RZVDBwWW0rbHF3Nkp4UktKcW4xMVV0R0lDbUlLUWIwTkdSaDU0aTJucjlTdDhicHRYTEVMaHprS2VmN2M0c3JBdXJveDhuTzY4cFRTaU1pMjVDZXVYRDdGWUpCMklybXdyaWp3b2crOENiTEppVmFMbGxROVdIVmREWHVOWWx1blRKU0E4UVF5dXlTa0tLSTl3ZWh2ZlRKS3gvbndjMTI0WGIwRlVnY21TbXoyQjE2UFRHZ3NNY3psSnJramxRWEl0emozS2N4cnIyRXVhVnB2ZG9Ud1RrMDEyRVNPSll0NXE0WFJKa2VzY3k4TUNOeklMUlNSSnprUGVjL2JnRmMzT2JqZmlxVU5uN3J5aUt0WlVoek5xcmRvZmw0T1V5em95bWo3Mjd5ZDZpcEltdjl5Uy82TEQxRHdBN0h3NHhsdjNrLzEvM3dKcmZlZ2lCNDBDL3Ywa0R5RlhkTzhVcXEyTVBBQjZ3Q0ZHZ2E2ekVnSFJ0R05XUnZMM0hHOHNuZ0lZcnlOSjBQSitVTjJhZGdVTUNXSGVZYTBWN2g5L1RVd1lHbmFFSUc3S3dLUFJGVTVIc09DeW9DZkVxWURaU3NhSFltdHQwZUJuTWovSzVwL3J5RzgwMytkYnk0TDQySkRSRlBNV3lGTlFQQzlGa3BFSDQ5aE1DM3N3RTllQXJ3eUtlbXlFdkdmMS95Qng0WUlZeUo2OU1XbGdJRGQyWktNem5nUkpJdndzUnJTR0VIZUQrTEpjYndkaE50Y2ovSHJUcjNnL0JMR1UxTGNkdlFpTDR6eXZlbGtiNllMc2lDZmJneHNuaGExODE0THV5bjJ3NzJPc0hxUnBHcUVXN3VBOGNZOGZRbFpWUmpWVzhqc0ZXZ1RRY05OUHhPeWdnaHZ4eVlFRnpvZGd4VWtMZnRzZTRCVmZWSVZpSEVjdTNvS3dlRUEwbFN6bnhLZ0VTWEtHSEpxKyt6c25EeVlDbVFNQnRjc1hORE5HVUcyRUkxOGgvc0VGRUtRYUVSUzhib3pzSnVNYS9LYTVETUhpWjNHR2Q1U3d5WlJxUFo3UjNxdDczSGZlWnBHYVVpcERoQTI3Qm8rTkJoaXlSWHdCOHViMVd1NzkvY1BVUng3b3B3ZVQ3bkdOREg4WmxqME4xMmU3cEp0U3RaTHg0M1dRR1I4L1dQYnhCd2djaU1NZjhRTU1nRStQcFlvbms0MTZ3S0Z3ZjdwWStGVCszUUVRejYva0FIb09NWFBUSlM4QllSa0JXQk9lanpoRTN5YnJrYzRiODJWSGZqL0w3am1mVkpQazNsSDUzK0k5amJrZm84VWtlYVVpMnJsU0VnOWxJcHEyOUxac2pzUGxNM1BkNmVqM3dVczEzRk9qbGRWYnBNUWswSjFlOHBxZTAzRUlLcFRlLzZJbWttSTJQZGNPSDVoalZmL0E1L0RHNXdNVGtKWWkyNmM0S1FBZ0FCQlA3N0FxbHU1bGZxTlJOVmxoV0F3cDdJOEJzNE0xMzF3NDRqM2QvWjhHL3NraHIwTVVtNFdpY1dTS2NWWS9WYzU3OFU1a09OVVhDWTVyNm9yNlFnQS80TndWd2psTXN1VjVrYVJZM1pNVGZhbkx4YWF4eTBDRCtLUEc4QlF4QkZFOWlqRHNEc0o3ZVdxMTRjT1Q1SVBjTjA5ejJ5RWNBRUlyT0JRY1ZkbFUvQnhibTcvRXBQZDdwWjBwdzVyUE5hTWJta21ic3FESlE1TnhjcWR2T2h1b0tiVDJOczRKbjFHNnY4Y0t0YkNjSk1aVnlOaUhwcEpOWGdzRlJHTjl0dmZlRTI4ZHd1Y1R1VWNpL0tkT0VxSFBja0VDYjFwN3ZoVTd4YXhRRDZnQVBOL2ZFc0RyaCsrblBCckVDcllGTy9OdXdudTVUZG5ydUpRcTRLeWVIMk03RXNsem1oMGRmeldIc2FORnVyU0JpUFF0Z1J2cnJOZWlia2l1SHU3TGVscWY3MUl0eUx0VTR2N2lXNmdPZ0hpSVdWeG8wd1FKNi8rMnEwdElzc284MmhBd2pGdmJSbGJQOS9HZm8vajJobXBRb2p4Tjh1UDF5UjZTS1g3eXlGck9xTWx0WGxtNGtnZlpZS1c3QklxV2Uzd2lXQXY4NFd5WStXV3RPZmNOSkJxNHRXNVp6d3dCc1VVb3k1YUVSMVdRVXUwdTl4NHVSL3YvajBuR2VtbW51UnZQSUVqN2JRM0h4Ymd6bDcyeXhmdUtMQkJlTWplUk55NTVjWTVvMGpBUkprYWtSL2RWUmR2Z3VKQ0lEOUtnRHlHc0RoelczdzNWR0FLa1BMbHJpcmYxSUtjOVZZdCtueitEaG1SV2VJQVdGWHRRdUNyaHpIOWFvSDVQR0xyWHJ6T0FFRGVxQkhadHNDNFJmcnBxV1pYWDYrTno3Visrd1IzbVpBNUFucnFweTBmVnZXaUhsdEZ4V3dBM3lCZklRNk9TUHNqaklzdzFrNW04NjI4Z3ptK2hFSWhJZmR6dWVQeFdlM1dEN05IeitLZjRTNFJyb1RGQUFhZVlLTjVhdzBHUWc2VnM4MVk0WWJ0WnJORm1QbEc2MmY1UXNRMDdERDRzNjJUakI3OFNyQ1dIRzZwUjBmQWkwbnhDRFhSMnRGdXh5bENqN1BvQWF5VmhxaTRjOWVCcXZEZWh3cnp1ZS85YlQwdTlOZ1RORGpGcGF6R09uYml6c25HbC9xZWFjdzRRZWxMaG44d2k3N21sUmttQURXZEZnbDd2by9Wa3pTNVdnZlNCcFNqVDVxTU1WTUNVaGxRQ29LckE4M1ZJZ1k5RkdoQzhJd0pGYTB3T3VhUVQrNklvMFhaTElOeDNHdmpIWklkamhhOVMzQ2U5ajVzSFFsd2phbmtpK2QzdHlYOXZxRHM5OE1yZWxveU94bGxRTXpUOGR5SFVWMXhpODZwVVJuYi84bkFubzVTMHhRUVQwVUlhaG9wdWlhalRIdFpvbitNQVlPSFh0eW5HeEF3Y2dFaWl2VXV5SFBLOFp1Ym5YNGhQOERDK1hTMEc1dTA3MVN5V2s4Y1RBUVdZcnVBWG5TNGlFTFZGMmlXVldCQVc3QmFoeWZuang5aVE3NldqWTliN3h6emtNSGF2N3U1NHZkczRaU1BtRmMxUktxUUxLYmdHNHkzeVRZWndJQXFVQnBjMjk5bVM0cEljcW5GZjFTaXJkK0lzK0MzYzlXNE5rOGFmdlVNT3dyZ2xsTHEydFNCcVJ2djZlK08zcFFvdlUyNmY3R1FSckd4dWM3VjAxcFRWaEtnc3F5SFRrQ0FBRUUvdnNDVVd5QzNiSklZeVZlWU5FR0VCNzRtRUJjaHBxdmpONEt6a1o5UXVmQlJuQUQ4dW41bWtwb0lLcE5HSWpQc1hVemVma29MSEJoSmFPQmtmL3FsL3hDOExsRkxmMlROL01vTStOV0JoSHNUWWpScUxtRnZaWGFuZGJkVkY0TEpjbUJUV1NqV2N1ZCs5QytGYnR3RS9lSHV1My91elZiVFpRWU5abjVtWUZKNlFjb3IyWWJEMGlwdkp0cytDamZCYXM3SVFLUWpPM3VoaU9KOE9nSHk1aDN3a3RUdFh0Q3FRR0UxM2dpQmpucHBKWEdsZVVUK1MvWXMzMmFnK0dTbjEzRE9iMnRLUElpOXl2dE5jK3pRaVNBUkI4T3VIZWZrL091SFJSbEZpR2xQU1JkRm5BdURZMVJKeFJvSkEya2t2bnZPREhlSGxMRWdtSWFVVjBvcVp5c25weC8vY3ZTUlQwTEVDY3QxR1NxcC9YME5aOXFlSDBiUzlJM3RiSzgwbVVnOVZVUGx2bkFBdFQyajE1NDZBQm9qWWd4NzdDcmFZZHdDZEdLSW14RjhzU1FKOUNmOXVwOWZnN2ZNN3VtM3ZZL2pmUmFDbmdIU2kzNUt3K2dPZ2RUNGlvWEdueGNLUXRlcmhhbmVuWm5KSm1YZDIrN3c5c0d6UjNROXQzVHRLRVA4OW5MQ1B4K2QwK1k3b0dDYUtpZGY5NCtaNWYrWVdYdWVZbHhsRTZkVjhrL05ZWHhvQnJmazFYUWxWcWpxSXdYbmlEcWNIakU1M3BqeXJ5UTZoN3YzUEJBdU1BN00rRlk0L012ajdiS0V1ZkowZisvQzdiNWtmRy93MTlLU3Q5emFYZ3FNUFo3WnNiTFYxeVgyQWxxNE1paWFVWVE4SVJWbGhXcTM0VlpMNUNYcWlmM0ZsaTJYdnJuQkVYRk5WL0dzeVh5UXNZQmp5akNlN2ZpY0xHMm91QjY2dVNYeDJmbk5pcVoxWjNhbVR5ZXVaWDdKOHB5VGk4ZEEyVWJ3Z2dKaWhqVDFFMW54bmFSbExjVWU0UDd4TGFVd09PbE82bFRVK0NpdlhJa1ArWFA5TDFiV1Eva0VnQ2xLVmZiNm0zQ2xzOGNDb0IwdFBsMzd3NzRyTkdiWXl1T2FVN3NCQUZmaDlZVXlGckpyVktScHVaMWFxODlBT1pmZHkwOSs1M0FNcnJxZFlqZzl5K1ErYjRhSXR0OUgwYlBoQ1M5dUNFT21JOUNZUzRtb0xlSmdYUDVWVG1XVHdKMjNJWTdGdTZvNmtpSUwwSTJ0TnlaL1RHTERpMWxTV0d4Q2pCM2RubWNqNG9PM1cwWVJzWEJ1QnUxc1VIaFZxQXZ2Q2t0MmYvRnhtS1RMQkJ5dEYrRENPSG8yV0crNkRGUVdGcWg4K1pvNnRNSEI5OEFwOHVJdFJEWkJwQkk0VEU4Y0hRUWE3WDNNMnQ3dFpoTTR2ekJvVWYvRWk3YW1idkFYd0Z4SUNzS2p2YnN4YlRWbFNmV1AxMm9OS0FHRTgwckVHclBrSzJrcVgxMTdFcjZpQWcrQkIxSmlzam41dU1scTBMdlhPQU11R3RTbVV3R1JFRk5xWC9rY2NXK1Z5bS8rQXMzUmY4UEZyNTZLWGtKYW01RmFoaTVPYUw1RCt1R294WGY5NlVoZ3FIUTlUaTNlenVhalVkVXo5cWJXbGFGL25PWlJkck9jeWFDQkdFcml6ZFFLWjNxNHNDdUhORVNQZTV2aUJJdG1weVVEeUZJdWVXLzZpRVRmOUkyY2JnaG05SHNPUFYxR1VaOFB1ZUxvbjlJSUNGYUpmUHVLd0lBQVFUKyt3RTJ6cU0zWjJpeVc1L0dORENvV3crOWkzTEpVZU9vK0tRVCtYSE14Nm8vbGgwaS9VKzFadkEyMGVMS0ZQMjZrRnNLb2F5dDVzajlVeUI4K2Q5UzNCUkRnNTFsc0JkTlUwVjNaQXdYeHBZZWIwZHg4U2M3QlBxaWJJL1Q3dExhRGdzamdzSUhFa1dROVRhcjZpZk93emxrd3hUaTJnSlllSnc1bk84Ynh4YWIweTdmM2xhNFl2VkxoSFRMOVZJZmMybmJuUHMvQVlhVW1iYS9jODBORUY1VWY4M084dHRaYWN6OUhGNTdLZGFtK2xpUjRGem40cFYzb2M1aHdNSHYyUjlUK2E2aDR6ckJ0RDBoL0Naengzanpzdzd5aDZMeXV3Mis0UkdVSHFGcnhtd0Z6UEtCUHhYVSthazlvV2hGTHZxNW1tbHJGcU1iWEhtTHkvbGdldVVLUnh0TUU3cjE4YU1VSUJsNGpVMVI5QkxlOHBCQ2xDZ2szODhrbXpCbmNSNXFyNUNhQWtRR25mempiSWp2TEEyZHRzYWhIclFvUEYvTFhaNWdYY2J2NmloRkxHYmJ6NW5NbTJ4Ynhva3RuTmhtZnpmcG01eStGQTdwNm5MUXkxZFFyNXZmYi9YYkJvMll0UitIQzE0Z1V2ZVpIYnNKeXBzSkRoeVp0ZUZNSEdQdkVXY2gzdEU1NXN2aXlWdGZZRUNkcmJBRGVkcjY1SU11SUVWK3VTbHBzZHp0UVo1eGdqbUVQQzl2VjUwOFd1bk9Ib2tkSzl3WHZWbjduZnVzN21VNWZ0dGZDUEcwd3p5NG1VeTNkWlpGMDlhV2NMTUVKYkRxTFMwWndGdXN3UjNoODkxN1JKeE5SMjN5RXFIeW9BeFBHREFOV25EOTRmdFQ5bFFoMWZQYkxEK0NzYUxQbmUvWG1PaTZtY3lvcWthQlJQa2ZoUEJWc3d2SnRnWHJQMDJFdTUrOXBJdFBJNzZKaXJWSUF4cVF6c1hQZVpzM2MrNmJ0SnE2anphTWZyVXN6Q0NYZ1R0czZZNkZRZzl4OGVUZ0VlaGFoanVKdFdjSnpJRk10NmlwbFhrdTNMTTVQQTg4T0drOEl3RVV3Yk8xQVEzbGV2T3NMK3JEOEtCdEJ6VnFnYzlJWFFudDNqQzFkeldIYlVCN3FkVFhEUTdMYWlUVlVrTEpYc1hjN1JsMUY5dzdEOEZRQXVWcFRjK0FOYW15ZlM4Q0NoVVhkMitaNDhDMnB4ZXN1QXgyZG9GNkZJQ3NIaDhQallKQ3RZT2RoK1Q5TUZWcXdIQ2F3QmZkdExjbFBpOFczYmtzc1oweVI3YW0vRC9JZ0o0NW1QM3VMNFQ4ek1GdjRwUklEclhtRUVRWlV2aStPeGQxWHUwRjFNMHQ5N2JSTGxZN0ZBTU1vejhPOW1FZURNbDEwbE1hSGtVajVjMEN1dndYaytYTm5rSTdhSC8rcnc0cUFkUjFmcHlqT3VFZUp6Yjh3Qmt5UzVxa0JUOHNoRnJGV0plekI5UTdzdTJSR1o2cDJEL0Fva0FySDRiWXRIRGU0V2pXWVZ6T1VOZWg0Rm9lbWVLeThabDVCTzJFYnFuT0JKL0FPYnlWMFYxdlZLZTlETVA3SFVrVWFvMzJ1RzBXLzlzdXN3YzdTMGNzZTFsVGo4NHN0RHg0RVhxNlVSaERDSllVQlBrdlNkVWxoRWFhbmVjSUkxR3NySjZmTEkyUnpESEhWV3NQeDFscVJUdjR0RnlVVUQ1R0VjVVRzUC95QnM4cW02WlZyMXBndmsySzFlMW9PT0phZ3hlL1l2N2RiT2Q5R2E2S0FnQUJCUDc3Qk5OZUVrWHFBamF1R2orRTZjdzg3bGxCOTdCWG5XckhESFFJUU1UOGp1dUxYaXZJdktUZEJ0VWJmSTA0ZytOcVlyL2xMQ0wwUFFFb0oyMS9RV3lTVGNmc1lNUFA5M1RYRzdKZzhYT0dia1RnclQ0MXkzSkNoVkJNV05TOWcvaU01M09SQlNYY1lVWFdJcjhDQUJSdFZKR25CZ29tUnJvcVVwamVFU3p1MG5YS2xvYU5VYURBS2dYREtXZXJHQ3prVzZmckxlZVFGczRRVTAvRkVUYldUYzUwUGovSGZkdHVhUTFNeEFGM1VpdmlxbDJyWUZxMDlSM2RYVWJJWjFnMktFL1Y2UWo5VmIzYVhBVnd2Y25oQkl6RDNtU25OUHJZNk9CKzI2Z2Y5VWJQNkZEUmxpZFdyc0tyTXR6aGczZVY4U3dFRzkwMVZHVU5VMGxIQ1NzY3dPUVdmcnNheUZGbkFhSnRzMXdER1lmU3dtTmY1QmNKR0xRZ3hoSElMWm42YWN6MHYvTVlYN1lsZVZ3Rld6c2hzMnpNd0RwUmxud1RmWTNaOGdLSXBYZ2t0bnhoaDVSUlFZYTJOUVluVDM2V1JJeHFvbmdiYkpMOEdoSFNDWFNIcFAvY05PSXdFeStJZnRDcGxuUlVjVXFqMFY2TVVGbzFCZExRMkgwWHhocGpMWk4yQm9pcFd0VCtGZHZ2WmpZSWx2WVlHMENOMnk3eVBuNFUvVzNienA0V1hBZDVwbWJDcDA0NU1lQVVsWGJUQnlKaDJhMHczSVVYSGVnbTEzeW1xamlTUWYvU1RCajE2YVlIYitQcGZhWTVKeTdYSE14cVh4ZmtyeEIzNzRUNnYzZm16R2JST0ZiNEZkQVpNNG0vNE5uWFhpQ1V0eFpYY09vN0xDYmZKczdVNzA5UHRHb0UvMzc2RkY2bXlmMnFCZENjVEJacmNONUNLa2hQL1pNSW5KeHBFcWxzUDdGYk1hQU55Ync1YUdIVktUUjV2STlKdUN3ekZaa1RQZ1RQSGI5a2lBR3A3RWZVLzFsVmkvcFBnTkFxWWRJVGQvcGp5UkRQaytmdnZYL1dycUxIS0dwbFpZYTVqSnIyNXFqWlJseCtiL0JyTXYvQXRrZUFBajRhck5WaFJhS2ZJdnd3YXhuUGh4cUlYNjk1ZGV2TmpDdjVhd2lDWGVLWTM3Qi9rWWtCZkp1ME9VVWF3TmZrWldJWEU5NjNDaHNTQm9OcTZudzdzbGo4WW0wYjVQR25sQUtuemVyZlQ5UGVOQTFjQjVMUkpHWlBBMnpySWZpcVB1TVVaWDQrMDRZV21KU3hHbTJJdjFkcDdQZ3ZoOGJxVGlwTDBFL2JJQW9DOEx4MHNpNnNBa3d6amVkbGtta2VNUnNnWm4zUWhJK0Q1M2RjQjhoZ1hZZ1Mzek81Sy9NUFVZcXFvS0UzOGN3L3cxTGpWTE0xTXV6MUloZko3U2tFTjg1SE1ZRVNEMXcwMkVweWpRYk9QSlJzZDc2RXdRUkd2MUxKUzBYTExSRm5PZUl2ZzdhTElzTUZYcXl2ais3WDRiTmNlZ00vVWlsdlp0TTgzRnUyVjRjaHRMQWtlNmNpcVE2cGVSSVZoRFMydFdhVkFBZ1cydXVZRVJrQSs0YzdwbkVlNHBiZktFcTBwdnBzeVJwWU5USnhRbkxLK1p0NjY0dWpOSlc1ZEh2YlE2bVJUZjdFYk1VQ3B1L3QwS2lBS0xXTEw0bFVnMTgyVnVpcmxIMXFJbjJVVDc2anNadUhZeWgwRVVtMXpBU3NYckV6a1UvalFzZEZ3VVFacWpqbVdWM241WDBDQUFFRS92c0F3OFNTeXBWTzFXM25UK0xEVSs4bzhobDhSTHhsS2F3MUtyQUN6N2dVYTNCcW1nODE2NXlCclVCeWJIR3lEK0Y1WlBxQUFoQktWVEhOeDVlVHRJQVBNYmJkTnRxdnhpK1hPWHY3K2tabHpEL3YvYWg4S1BBZm9yVFViZytTNG1VdGlKWk9Dc1dhTCs1aWo4cEdVNDZmWFh1YnlsNHRZbi9jRGh5d1FZS0pkU3ZiUFlMYmI5ckU3Zmp6Z1daTit5eVJ4cEtjUmY0QU5uMG1ZMlU0eVZjMk9PTjlUdE9rMjZsWDZUemlMMlNlSk0wV0Vja1hLL0VYQitOUUdMRkszVDUzUTFURmJNR3ZKOFExMjZuWGIzNmNFL0dwQklkaXE1Z09reVh1MmI2U2Vkd2NhdWhZSHBBY2ZoZTB2eVFsQzhacmdiSGJCQWJOWTN4VG9WVFlUczcyQ09FL0dueTZ6YTBJV2tWUUIxSVMvRjM3c2NJY1A4cHdadTZSdHozdXJPVU1sb2NGbWMrT0ZjU3c2M1V2K0V2Y245RUdBa2x1RzlQZUsxc1FlZ2RKUEdBemh6OVJkYTdEMG1SU01BQzFtRDVVS2ZrVElRNHhteHc3a2MyRDJKZm5vWU5xRHBkbVEvbmNUbWZ5eG1EV3lQRHdkdzByUmY1dzFKdm1UN0FUWFB3Q3dwNmRTQnRaN2hnQVZLY0xmOUhyOVVoalhMNWMwbkZyclhCMG8zQWw2Mkl5aEFyK3RHS1JubTEwbkdLYUVWbVBaSEcvY2ZHbmptSVg5clIzQWZ4bFNMRXlPSWpzTm4yT21Cd1N0Nmd1c1Fjd1FlZVhzd3dBQVZ3VC9SRjVRV244L09wVnNQSWtweWdNNGU2UjF2OGNKdk9XMi9QMWtlaTFwZVB6bjJTTHdyRXBDWVo1SzJ3djJBUVVEcEdNWmxuYTN6Qzl0aFBkWjk1Qkd2djQycnJjZEVvZGxBQ3M2SlBrMFdlQVhzcUNGNXBaVkRVa2d2d2oxYWhlSHFTUmsyWUxTV0NuamRYMFVCbUtEUHhtRkNpUmMrZ1RTc2pLanROUDU5K3pHRGczTEp4QUtpNnRrWFZ5dTcyOFIwSFIvQ0gyN1labDJqaXlLRG9FNkVpMnVjMUo3NExKMmVSTDVTckl1UEp3dHRrVytNYTVvbzBQdFBvUXBOR0NNQzM2TTFYbnhKemY0WEFpMzdiY3h5UGpTZlM3enBQQXVPd2xGNjNjRy9Fdlk1S1pUZEkrWmNZeUhnYXFlLzM4K2lXRklxOCtsbFNxMStVWGJHYnZoTE5lYndzUHk0R3BBN1VxYmZaQVRNampQY3Q5TXlqbytVRC9iWDZyZXpDK1N1RzlmK1hQaXozcEZ3UU82SHVZbXR5d0lEVlNBcXhJOVM2L0h2Qmg0T0FYUnJnalBtZEdXNGVRQWY5ekhFYklwTlRRZHZ4TEl3THdWVnRFcHBqd0U3aWR6YnZzUUhLRXRMUzNJNWkrbzdLQlBPbS9tZGNFVGxKTU5nOTFCVVJsemlqbFpLQXh3YmJNQjNocVdVOXpEVThUNUdCWFZDRVZBRU5TcjdsWTVQUzFmTnRsblFoVU9CWE00WEhNMGJMN3BJTUxuTXlMVFRXL2xUQVo3R05tZ3BHOHRvWFFibk00NG92S0FmRlN6M2Vta3gva3gxc0JwZHlDbUQ2c2dLdjRVYWZmL2JlRlM0WUNxczNyVXFhZGNvWGh4anJKM1paNE96dThTY3F1dEttc1JYMTQ4VnRxY0FvbUZBOTFWSlpDK3NxRlREc2ZXTE5PcnppV1BJbU5NSmJmLzhUUTVRSUFBUVQrK3dCU2R0RmNINGVUT0RQY01zRThPWW9ISWxNc2lJYjdOR21zaURHRGRrMjZ1bkJWVmNUNXVUQmI3dFFNNzBIMGhtZHpDVE9qYk9qWFhRbEVqMElJd1ZqVndCZC9QbFl0UW5zNlpUZXZiR3pDc1hmeitrL3FWeWtocUlyZVJNN3VlQ2QreHc1ekhEUDdURGJjaDNhU3NoQmRJRDhrOVR6Z3FTL3JsRUNWTWs3UGkrWnlJdWs4QU9lT3o1UnkxSHhlVFBzT1VSa3YzWUpaUHc4SnpPWUhBOFlXY1ZaUEcrSWNrbWQ2L3l2b083alJvRGN0MytDRzVrUzdZb3RVQ1EybWlSTEdIOTZZaS9td2ZCdDlMWnlWTmRnMjBrWFprYmtDTVFIM0s0U3hhblVKNitMcmQ2TEJ0RFFpME1RNzhCcTRWYVhEdkFJSjlUTWtuT1Y2Z2puR3FocXZMbkg1dGhnQVhEWE9mMUlMSUFRZFh2QXIrdkRYZGJwSFRkQTQzZW9lNWgrNmlQci9JdFo1ektVRmZyUkwvYm9INkZFWDBTbnpKcXpGZElGeUVWd1dsYXl4aXFLbGNzZnIvVUozUllWMmRGbysyUFVHdEM0TEIwUklRQ0YzRHFIS0JLczdNVE9CU1dOV0xlQWZYTWZZeWtRWkh2NFhRMGQyN0V4Ym9tM1JYVmNObjZjdnNuUGpyZ0M4U1BsOVBURjZJS2xxbGlDa0VWMEh4YnYvREwweHJqSyt0YWdhTTUwZ21aWlJpM04zNHprUXNBaW1QSGRURGpxQlNGbEVsOUcxYTVrL1RaS0JJOU9RSGVlSVpLS2MxUGNBbGpQdmJ4K05oVkhVTFI4N3o5N1VESHdTdnZTQlpHeGtweC9BclcycEdTL1pCS3Z4RFJNWHhzRVgrWlE2OGl0dUhLc3QxZ2dHQ1Z0S0I5RkZ1QThjVHFxQjIrVW5KamFVUEFkdXdKbVNUTVZhMm5QVFkxaWJNOE01UWtjRlJVTWFMYXBVOEt2L3NIYlhEcmMxbHMzWHE4NUdERXNPOXFONW0wbVJPNVYvZFJMV2JQVUNzaFprcXZEN0xMZnV5a254bHBER3JjWHBvV2V5UFJtK0Zpc3NIdEZ3bU5XdzJKeE1yUy82ODhjWUgyMlZFUTMrZGZNM2E1dWFJdWRHK0NGbWxjcGpzTnB2Rncrb21Bb2hqR2lyYjlKck0vSnBaQzlrS3Rrd0Q3cHBGTmtpWGN3cVF4Um1odFl6YmoyNkZrTUFXQjBsa21Dbkk2WkcyZDBmbkc0TFBpdEVlOUh5YUZUM0ZZVm4ralV3dzNmUjV4K3RTTGtoWk1nMkZ6d1NERkdiZkIrejBQc2llcGVaRXJiYWlOR3pPT01OS1JnRWFuT25MZjV2c0NwWVBqR0RER0NaM2RBNVczamVWUkZ6YXpGVTd4VHh2WEcrblNMQUVob3YvRWlQdXo1MGRDT0hLN0xqd3cxdU84UitxNmcrZkM0QUNGZzE0bGJtYkdoNkpNdU9HN1RPckpaalhPTWVHY1I3ME0wbTdYSVAzZkpETGwreEJMZDlqWmtYTEtLVC9ja1VqaHk1ZU9CZ0VoS1laT1Y0V0xuMVhNa29mWUxTT2ZWUUhLbXlUM1F2VzdIY2dpYmdzb01yUndnZHFiamVidVByYWsraVpZMWhBcm9WK3dibWF0MHJMSGFaWW9LSkVJNGxnaGwrNS9tL2VhTERMUkRrUU40ZHZMS29KOUJ3R0d4a2JMNlZtQndUK0tZRmFidkU0MTFsTzBONkxxWlVDNGFPb2Y3eFNjeUlYa0FBSmJYNHBNaWZ4T1MwQWdBQkJQNzdBUkZhTG51SGlOOEhWVWhudU5qNXFFWnEvK3NOeWFTWUhsWWs3OU1sZ1luVDdvTndoWXo2OERNRzkrejV2THpJS2J4bVFOcVhDQjFjVjhzUWhqSXhmMkRFVEV4VEhFclJUYjNGU0l0ZjVzYk5sWTlVNFJCZ1JjKzZIOVRnYys5MXdlWkFZS0p3YlF2K1FJOUNKNTNmaDFORk03c3ArMGFMa1VQalNWbDB0emdSRWN1V2NKTUZ5UWpTTE9rKy9IK2l6R0ZKVGxkUXFIUkdpdUhHdmZENXQrNGFJM0o3Uzl6U0VEb2orK2FDdVNyNjNTUk56SzJHN2tFYVZGN0ZHNXJBdEJxNFNZaTNQV2ZyaWNaVzZ4bU1LMGZEcUtRLzJSZFBYVXVSYkFlc2JRUjRBY0svMElYbW1YdVFLbnRVN2NJL1RJOWpTdXRVNS84ejlvU1ltaGZPdktyYnZZZ1VKWHB3d21LdEZHM0J0MjcvZEkzZS9KZWxZaEQvdzl3Q0NRSzVkSlJvNTRraVJueGdJS25oU0hRWTFxQmxTRWpiYjg0a25MNWJXQWsyQS9QY1FrZ2NjWkhCWFpxS0VEYjZtcld0YWJiL3V1SldqUWFJR1Bvd1hPVWdPK04xRXRRRytvYldJanp6bk1GbTExRFBoQmRGZjJmTmJUMkx5dVNzK3ZzSURVZkZwNXQraFVkSVFoUEM4SkVJVnhnUEZDOW43RE11TFB5ZGtQeWhiT21sazFmTGtoK0VwMUpvV3ZXYmJCcGFEYldxdnlDQkZsL20zdHlaNTRsWENjanBNQ1BIWGl5cUdjVlc0aSt5cmFqeDlUSUtUN2I4NldveGg3TzlFUVNzdUw4RXUzbG1HNEhHdWVrSnBtcnMzaUtFUm1pMjhtem9ZNVJ2MjhteklEenpmZVA5N2tLUFNGZStHYkdWazFiMTFwRUNIWGpOdmlSbFo0RXdjNlJFR1BVaHQ0MDdTS1EwSUNMUHhhZGpGNVVnZ2UxWlU3MjZFY1REangzRWx5ZE1zSmNQTGl2MU91NkM1Q0YrNGJiUjNnUjI3MGhMNVF2NmgrbEdqWGkvTllaR0szZXhHL1NNd2V3Sy85blJaQ041ZUFjSUtJSXJMNzV3Y3poL0RRZ05KUFVUQWE3SWUxZGF1THBhcm05elBSWVg2dkJycUZ3WUZML1J3OTJ2Yk5VSVZESEovRjN1Qyt5VmRsSm94bnhONEZhVm43RjhXOS8rbDdtU1dybHQwUEx4VW5JUk8zbjlmWHA5Sm1vSERaVTFxc2djTHFmYytJbHYvYjFpQnNmS3M0QTE2UXNGZ2xqV3hFMFlTRGR5K242Wk4vM0RNTk9Ea2V3OEtiTkdDVGttWjAyTEp2YkI1UzVZdWhBZE9LSlBWZlNXcmJNWmtsemk1SWNtUnYrNDJkQm0yZ09zUzVXVWhLSmQ4QXFKUXJycU0zRFR4TzBqRktkUEZ1OWpaWWwvTHZyZ2NuUDlURFQwZkVrd1VrMEYxdFJLM2EvQzlCZVJoRE81OGp0V1NDZFJ5YU81QWJ3OHhuNEtobHdKY1JMcmcwbXVyM2tGcTVmVWROS29oT1I4Wm02TEhuRTl0ZkdpZUJjSXZlWG1jeW9DcXd3U3hHQmliSDhVZW9iUzdPcElsZ1d1OHdGSmxINFp4RlliajVIRkxZUE14L0o1djlLRS9BN1JVTi9FR1ZmZmlsWkJNSDZUVnZaaTBrOTIvUHVaM3FiM3ZuVDgzQStZVWM5S2lJY3IzemMwTW1KSjJPZ0VpeWV3R1BOY0hpYW1XTTdvL2JQRVFEdGViNXZzVmduNEFEY0NBQUVFL3ZzREtScEhEU3FaWWNvMzlHUVBIa0ZjRlk0cFN5ZEFyRElLWXNrUjZQTmliZTR4UFMzdHpkQjFGQTZPbmNQa0d6VWZvbHBNdDhNUWJnNFFRQXpxUUJ2bzdzZzNETDNNdDJ3dXhIZUMyc0VIV0tkdWNQZmJIUWJEc2VoeVBMMVZXQVdKQzZwUUNmSko0dUJwc1RjYkdNVFZwY2FyLzZ4SytFWVM5OHVuSTdVbkRHUWgzSmJOMWsvc1RiRkl3Z0lPbGVqZ1NWZjBTNWtIUnlCVGpGUzVpOFVuQzRpSHRKUTJabWx1SDJWaC80TDZSc2tHd2hwenpYdVozcXNFWEcwQTIzdTZNc1ByaTNPenJaUlNGYXFBc0oyQ3Y4Ykg0a2g0dWxKRklFNnI4SFN1ZThzUVpGb3BINHdSd1NHZ3dYMHM3R3VQMGpGelNEdm42VmV0VGRvWDdUS3o0N0dySFA2L0VNeWwzVWJIODBUU1cwbHJoSGVMUHJvUWhoYW9Xbk1UdjMwWG1SdUVNaFdKdjZxcDhneURlb3BONjlNWTc4RFNRMjFLc3NXeW92dHdtcFdoa1hWZWJCb0ltN3RlemFDWWJlRHhvdTFRNndnaHFqVllpcGFLdjdoR3J3cmNCSlNET3AzTEo4dGRrODlueG5ROWhlb1hqV0EzTWJ1Tkl5U0dBSjU4VFd1cW91OGdTWWkvQ0hpT25vNEVUL2dka0FBQjVvdU1taHRUQ0ppOUh6eDVzWFNxVjA2a2pJZ2pFU3lvS0hOTmlBa2NTM1FNWGNoaC9md0I5dVFiR3pob09Mam1Xc2lPdmE4V3NDc3dsZFlhUmViOEtxeE94LzBqK3hHbjd2NXdaKzlTMXNmcllRbi8wUFJqTFRXT3gxMVdIb2ZkU1RNZ1V4SG56c1VpVTQvRmMvMzhNWlZiMnpYdm9nbkhqUlZJdmFmL3QybXYwa0VlUzNEWmFQclJtWTZUN3BCQjd4VndBblNJTlFnbU5aRnQ0Rng4elZpNFVIVWxQWjBVWnl4a3R4a2VVbE1CaktEdWViMmozTEtWSE14QUY5RDA4L09BTVFoN3Y0UmJtYlNpOXlyQUFhWWg3UzRPSTNyMWFiV2ppOUxNLy9vTkZSaUpCQThlNUlkN3l1THU3c2lJT0pDZ01ubUx3MGtOWUFvUnlQWjBmdFpHYk1GTjJGdDRmWFR6WUYyR2YxOXdtZDlOU2pKek5TTjVPWmhFWElENjR0SnoyN3RTY2Ftam5aTXFlemQ5UTdMdmVYNUxRUTVIOTNxanY0dzMvSjFSbkYyZVZ3MndZbWZoQUJEQWowVE1tNWNrVHkwQkNoekUvU211U2RPWnh3OHkwYnl2R2NCcWZLLy9aTnBiMWxSQktYb0RnQ2ZWMXZWRVRrZWlpZURXejhvWE5nZ2dVS09MeG5zVGR2VzhOMVdkQi9UZW01WGJCcm9ZQ29GbW1mSEpYSmNRd0JNRGc0MnphMU9kclBKK0ltbW9sSEpiQ25XMGo4ekRPUVp3eE91TllpVmtHZ2VHMFNFVVJsUGt5ZFY2Vjd0SXVjSGt3YUhOdG9qTDRSM2w2eVFoZzJKeWowclZxTFVmMFF3Tms5dDFkVUd4Vmg1Y1dDTDhqaTNpMzRQWEtheVR1ck5OL0xCcWtzYUZkUFhYeWFZL2FZdmROSXhVd3RZeXc0eVZPRlVxd0lGSGJBR2gzUmtwc2FhNUFjMGZObkhrK0hra2hjNjJ6TVhZblFjWkJXbTZoOStiTjN3TzFEWjg2dmQrVitBaUd3WUtGTEFDMjU3OUUyQXRrOVVBVm5leEMveERmeEp2UXdJQUFRVCsrd1JoMDgweEpWcUFuWkZCYXBFVWJISDM3OEUvUFdENE5yM2c4KytjMC9GKzlNSXZreHZkYjJoY0FncDdxL2VQbmIvakVSbGg5RldwMjc2T1NTekhMRG1jVnJUUzhaMkYyelI5WjdLUGhlUnFVNG9ucjFtMFdlYW92WjlHMjRXT2I4b0E0Qy9vQmQzajU2QjhjcXN5TFc1TlhCTWsvSUFzNjR0YUczMUhRL0h0cy9yMDdWbmR4N3NnSHBCMmMzUVZBZXhZK05MQkE5dUxncy9mcStBbjlIeXRua281eXJIcUpiaFlWZHphZFpvZE1NTWxHZ2REam1vN2ZWZzc1cWZ0elRwTVMrV2pOSlc1VGR2MjJxaEU2ZFpVN04vRjQ0YUg5QWlnOTkwbVlwcVdSTEw1ZkJvTGJsWFhOYmFCMzBLRjJDSENaMHpOUEJaSUFSdVhYelkwNzliRzlCL1d6dis4NnJhTWpYZDVYWmhvODNYRWRQMTJrSW12Z3oraVpCM3BSakRNcTVFL0FQSWcwWXBFYWZQVjJpTWQ3dzBOUzR5UEtuWEo0S2M3Y1Y1aGJsWTl1by9Yb1hlZ2huczU5TUFPellqaC8xVXBqMG9KVFNYbmdRbzZRQkpodDBBTFVSUDcyVGRhVWdGdW5JUkltdkpZQ0l0OFIxSUx2Qk9WbU83a0g4aURzTEhiZVRwQlYzK1lFN01zZXoybUQ5WHVYVnBUT0FGZnA0QjNKdmVkZE1BUzcwZVZQdy80RzlrV09vRzF3d1luRGpraHIvaTR0S21ocWQ4MDJRcERFT1ZLajV2T0NDMm1yb1lHOEdMbHZUZmZNOWRxWFgzSTJCVTEyV3NvSXhOcWNpVWYvbXIwVVNIZThVc0hITkQ1NFl5SW1BMkpQYkpVVkxZRlVRYmRXQ0RKTHNxYUkxeWVNTDZTMlQybStpNmE1TjR2Vms0R2plMDdGNktwcTYwMGNCZmZ6dlBOWjVSYWEwMjBqV0RERlNNSDE2Ni9MaGdIZXNsWkVrQjBBRXJJREFickdac2ZVUHA1aVB6emE4a0lzZEM3RGR4R3I3bGJjV3o1WXI0dis2aVRZT1E0ck5rZVpBT0hEckowaUczZDJTWUVwcTJqMU13WnNnK0hydzJWU0dUZTBSL2RHWkNaSlNheldQWnlhYXBXa3hoRjhRbDJBNkcyd1dUTER6VCt0eklXZGVYQzl4QWd6ejh1WDkvd3FuYjVyZGFKTXVWYnNVcnloUW9vbjFVeHB2eTB1ZE94MkMza250djlzd3I3WE1RYTV5WksxZ3MrcElnWFN5VmMyNWtOaFpid003UU9pc05zOUk0eXNLRjZMdTM4MXlWKzNVbkd5MHpiamxad2FXcXpyZ2Z5Rmp1UVAybXBIdFVPMmNienFTb0oyS0o1YWZaSGdkYWhyM29DTW1jdzhXK3EwcGNkNVhIRm9EUWRPbjBpL2V6clVDSldWVUowWWMxR25IdkNuZmxza0h4TXZHaWw2OEx2dG9KZjdzNkZGS1E1SHgyZXp2T3EzZkc5ZDIzRWdDazg1dFlpSEhDT0N3ditVdkI2STBtMGpLL2NDVGZCZzNOVlNMUTdnbklrQjVJVlBMMlh3dHdwVjRBd2NPZHU5RlVCaXU0dWZhaEZ4ODRXYmxJVmtQN3phaGFDQTBzRnBiZHJjbDFNRFR4aUZBM3orZFFNRzdxNHlCNmFLaHZTZW4vSEVtTTQ3M1BCOWxTclNsSkN5TjRJeFlQaUgzUnhyakhITDFZdEQ5S0lMSU91L3krY0NKb0V4aEh2R3h1OEhKT3NzOTdxUmtqbERwV2dBZ0FCQlA3N0Fkc3lSUDRVZ1JLWFZNOUNmZTd5R3IrVkh3SmtMYVBCejJzUzBCUmhPQjFHUHZ1VW01NTdURnJxTXVDaWZTbW9JWktZdTMyWnNjRXBvVjlhbSt5QUh6aHdDUzZKa2EwdURMelRNZDhUMzAvMFk2amxXUEI5aWZ0TjI1RmZadUVwWm1ha215RDQxOW9mSGFqeHBRRTRFN2dsOE1UYUU0RWYveGVLZHpSQU5kcExHelpJZWQyR3VGU0lhVGE4RlAwZFFVZ3lmQ3JpVHB6YU55Sk90eXhuTVBMZXRVYjFEYkpYNWdsRGtXb1Erb0FmWFc4bmQ4aDFyOWIwb052SnpXMkpkckpsT28vamx5WVV2WGdyTUd6bjRXb1QrL3B0bHd2NWp3N3doNnh4Q01ZY2VDN3dyVzdNRnZXbVdHZ3VxT0NRNTBLUUx0a1NzaUR1V0o4NUpjVXA1bnY3TTE1NktzYmVvT2xoWFgvOW8vWDFmOTg2L3ArU0d4WGNveWlZY3lndk1OSU9kVjNrK05MYjZTVCtWNEFvdDRybWh6MFkzeExuRE92NmhyT2pkNTdXV2FZMzZkaTRwTmpFaTFTM2VEcUFsa2NsOWlRRzBLOVY5MnIxR3FVY3lxaGVSYWFZQm5vOUp3US9OWHdpbjZkZk1HQjBEWk5FM0svRlBZRXNlVFAvM2dPVTQ5NGRIQXBaaUwvUTc5aDJSZEZmcVR0UzJFR29QWGVKWHlQVUFkQXNZbmVRTldaWTRkRjVTMTVkRDdpMW1VeTErdTZqcXVMZEU3dTNZcExMbmo5bjEvVjBiRUVsbmw3ejQ4M1ZYK2hZK0N5ZzluVzNEZUVpR1dPUEgvWXZHMDhrSW9oS1duUndwNk10NU1pQTNaWHJDYlhJTHI0U2VyZ3JBVll3dlNBL2NoMUI2ejRxS0ZTLzJhYU5pWVNRQ2oyWitVUlVkV1dJZFVTa25KWnloRVNhMWhITGhsK2V0b3lDK0JKZVZKa3NSU1FwS1A3MXZmcUppWXBBR0FMb2RiUlJwMXdBQTJwZDhrem9HWkhVMUpVdXNBajc1RjBBekh5ZU1Oc3BVQmIrcXI3S3k5MU5qb254TFB5VEM2Q1dYT0M0TVZjQVFkaSs2cHRkdGtKUmlwUzBVVTVCbU9hZE03OVZCa2RNN3dWWi9wOU91QVE2Yi9BV1REV3BIa0IzTDJWNjF4Y29Td3QzVWw4ak43UWNjUnhNeVk2WisxQnpCVVN2amF5V2dqTkl6b1BrTGx5dUk0VE9ZYVVYTFpOVUVZN0x0UG5DMVpEMlRSL1hEcTdSVUhnZmhrLzlWWHh5SWI2ckU2Z2VpQ2JrZmo2WlY4UkJqaHZZc2xJd3U1ZUI2TElLNVZ4ajRNaHlMU1BCRk15RVhyVlRKNzA4VFFTVG9GNVhjOUpGZFVBaVFoRDBPQ0pwTHJNVUdiaDd3LzlvZmJSVE9Hbk5DRHRyU1VxR1JpZHljTGZUUTY3Rm00cGNwVDU5VEVVZVFFR3k1NG13dGRJeFhsQVJkRUl3d281THIwT1VBUUVRZThDMVJ3NFg2TmNsSkZzdlRPaFV4YVZCOUQ5OUJwRzJFYWFYNCtVZ3F2RW4zSzg5RjE4MlJVTlovQWRPbng4SmJmWlVsd1crc29QNU53OThUNE96Q2dnd1VTOFNjaGoyWFFmQXpyZE9EUVFwaTlnc2VlVU1RVjRrM1ltU3Y4cUprOXc4bWhUM25IdDloVk94NTlwRnZ3b3l1VytaQnFkT1h3NW1ISitBZG9wVVdaMmtNVWpJNndtSFdYRnVEUnNGMjhjUGtPZzE0d2c1MnFBQ0FBRUUvdnNDVTQ4VjZDaGtVSk1scWRSWTNVMVNJVUVtMnNXVnpFMlppc2lKQnBFblI1S2JNYWRkVVJVL0ZzRk1SN24yWFdUKzl2QVFYUHRMdjZ2YWZWYm00TU44dkI3ZGUrN3pzdTY3QjJzZnVSRXU0cmpOQVV0RGF5MEhKUDZ3enlBQmtFa2NEYmdaSXlrQ3pURytOVUZ3NWY0Ylg3Sk1DeFVJd0V0cUM2ZGVkeDNydjBEVHdWN0dlbkYzREdPN1IwMzlKL3ZCL1E2dmo2YTIyVEVrODQ3SVNydFBTY1FFMVZYQ1BxT2QzWUNrMUhIelNxR0pxMk9iOEU5MFdhWGwrNVEreFd1d2ZrK2xjd21uOGgwV0tBMEhYbm1rRGdDZlAwZzAxdXB6dGtURGNxQyswYW1NVWY4NExzNUh5YmpFREdSc0xEb2tTK1VDUTFaWUdFTXNOSlJEcUNEZnVqTmhxV1FkcjZ0UnNyUFgxeUM4ZlRKbkZHSVZBeGNlaklPVFpZbWx5d2ZvaE5SbElSb21iNnJma01NckhGeDBSM29DOHA4WEtFeXM5L3J5U0VuemswZnoxZUZaNUkxUTVQTEpIY0tlNDg2TE50RWxURWd2bUlLdWROZ1JGSFVFSzMxTFRqMjQ1VWdMYUJiVDk4V3VUQ1k2S0JieVUzK0dqdjNFYjB4bFI2TWJrTzl6YlNiZHJILzZ4bjdKU1VlTEVnMVgzaXVPM1l1VGZNbGhNOFpiSUZQK001cjZieFJXQXZPNllaYy9EWTZKSUxrTmk2K1FoVkcwNlYrRkhaUWFyNmpJU20zT0RZNFRYTzkvaGd2OGtnckNub0xDL1ZyWVNKa042Q0x6SUdtQ2h0bzUvSmt2QzBZUzg0NjdpVlhYNUw4dURYTE12N2xWaGdFR0NKa2tMeWd1TzkyajRKeklmdjVqemxMeHJ5N25zWEtBQ2NVanJrWnc5UXg4bER3VWt2ZC9nbkRLNlZKYk1XaFg1MkI1eXliRkVCT3VsUGhidUI3L0ZuejNFSFl2MHFJVzY1M3QxS1NvcXYyR0EyMHRPbmtESmZzaCtVV0dUbytIR3pYN3Q5c3QzTXFuaFdZRjhqem11WnYxa0tzM2JwVWM2c2M0bk5SZ2JsTXd0S0xkQnRLTWdmTGRhcGVMejZWeXpYenh5TGpOSmg5anhBZGtDV1VnbHB4STRMZWI2Q01oMGdwTFdTYm5LNWVlQUJYQ3BxR0tlYStuenQ1bVJNLzBPdnlmY1BMM0tJS0FRMVpyZURXd0ROTFFSZHlvanB4dlprTFFEVkl6VnhNZkVRcEpYRmExQW5jVStyVDFrQ1ZDTWN1Y3RGNkJreit0bklDODBScnRzcE9sM0xnYjdscnQ1Rm44K1Z3SXVwUDZEamEzV081cUMrekV6aUVLRFhTNFpUQUFvQ0tjTGZUVHBwd28xczRVV0VjOTJHOU80WmNONG4xcFRDY3UyZTM0ZXZPMG55WU1lSytuMFBLK3RLb0VGaFBCdElqbldVbFpCTzBSL2g1NXZzM1Q3eFJQSDdTZ2FpY1FxR3hsUFZiUUxwZlAyUng5UloraUhDS1YxVnBzQnBWb1lDNG5qN0Z6K3ppeXZ2RWpTMjkvR1hJcVpVTkw1U3dPQXFjVDdsbVR6SzVTU1ZFbnpiSm84S3RKa1RJQllxdU5VVGJFeEVXREJOVlBnTlZqdm11Qkk1eVR2bHYwUnZraUgxd2VCeVMrdzFkRDk1cEhRak9kdTFzU3BkOVorajhUb0xWYTBRaVdtMFlOa1AzSnFlakxzTDBLL1duSFpCNHJROEZReDBRa3NSRDA3Z0lBQVFUKyt3U0ZVRm9QUEhOMnd0VWFHc084NEJHVVNnUHBzS0NjYWlFVW81Mml2VFMyVUdveTlEc1pmVllkMGdCa1FDTXBsRHZsVlNLWVV0cnVtY3JXUzRpdjA5ZWZTY050Vnl6RFJEVlpkWUE1aFF1R3l0eEp0MjdKMFdoaTdJL3IvQzlYODRUZFJFaEZGZmhGSU9OVzl5MnRIZDZ5WTlQQ0JSL1dMUXFrdUhSMTkybWRzSUZmeE5HaXhSUjdkbXZqVUFCaTBUSWNjOVJpVGRZeTUvMWt3RDArQXpEREVldCthc0NKemlFRHZTT05kY2RIMnRIbWZEMGF3Sk56M2RBWkFlS1hSMVRCOXZSeHR1eHk2djA0dDVpKy9KdW8vZWtHWFFzOG9NaTRxNjJCWXAyRFljUGszeEloTlNGbERkcVlKbXpNem1naGo3ZGo2NkpRZ0t0TVRSTDU3NXpGc2srZEpPMzY5OUJwZFRhRmVZelFKb3dtVCs2NTQyQlVBK3FlWUR3VG94Nm5Pb1l6TVNvdTZNaFFuVW5JTkFCdjdaZzNBeTUvRnY2TVpGZThBUXNadm56aE85ZXJkdGdlSnYyajN0TVQ3cXZCTmJZYmFGM0lNM1pQUkRQNVdaZTUwUEV3alJvSXc1ZUJVQ3VtQ1pITmc4RzZzckRDTU5GTFJFTzBnL1QyMUxLeFdBT2lLS29hWEdvaWhPZ1ZtWDRDaVVQeFFuYmRYWHNiQ3E3YStNSGgwZkU4ZUNzRDRjaFpDS1dScEJpZHA1V0FMTDJkOFI2UU9ob2VTbnhsSFpnVzcvOVdoSW5XKzZid3hsUG5BcERGZWpJcEdvalhieFNOV3ZyRTVoaDVpZzRPWDErUzJCWERuN3g2YTVYZ3dRRCs3YnJseFBITlgvNHZselIzeUxZUVZiMU9vQ1hHb3AyU3VnbTRjNmRYYk95NEtCQ3YxQnRNbnlmbHJhLzNxR3JraEkrMVhiZWljZG9GZUQ1Q2t4UENIc1FuTXRsNk5xTDRjM2YvNm1mSDh3L0pxRFJWN2tqU2hEbWJHUXZQUEwyZHJDYjQ0bU8vVE0rT0wrZkFoOW05TTF2ZVpaMTduaFZMSkJmTDFjRUxIR2xKWFBPemFqd3d5emd5WTN4Rm5DMjhINFFZMDNvcVVxeXJDempOMnZzLzY3elcrbkVBdk94dm9jekNxR3dIM0NJS0F2Vkd0U0VUSk83NTdCUDI2UEFVTnZsMGRrVGp6U0h6NkIrWmpiaGtROXNuZGhOYW1tRWg2QUhtdHRPbWxEdlZFbDJnZm9ZcDBXUU9ySXlodU9BNkk5RmZRZ2NGWGJHaFFMTWx1VXliaDUzUjNrNllPZElsZlN5YzFRTW9TVk1JREM3MjBKcWw0d3VYZjlqd050WDJWcm5TWTN2Y0FvMVovR240QlUwWHFSeTlJNmhPTUVvWGRiTC83dXBOVjE5OVBrTVI2cTJpcTJDWFc5cUQydXMvTWZkRlBBTHdXeTcveEJTMjdTc0YvZ0tiODVuM0xNTHZJWXFPeUJQclhRN1Z1dVF1R2VlNmNSWXB5TUt4eDZlQWhtSGNmaXV4bDAydnFSZG9ySTJyRGtPWENZWGdUZDlhdVkxcS9tR0hVYnRoQkt1cGlxTW9hcUh1d2ZJaUg2VnJyYWsxRDBhVGgyakx2UXpEcFl6MVVnVC9PVUlQdzliYmdyVStSMGRHQUxlNzJMR0cvN1ViWStLNHlOem5vR2krOG1BSVJuL3FnLzdlSEUxV2JXeEN1OWhmMThldEg0ME8rTS9TVlR4SHlxYVdKUU16NW5PYVJEdWpVbkkyYkhTakFnQUJCUDc3QkZIWTNCc2VZby9GYmwzRGw3VkJiZS8rb3AzWG15dEo3NjJ4dVpYeW1IL20xSnhRZjE1Z0dsZU04cjZXbS8ydEtYakczdXMwZXE1VTdqQ0YzZzNwNU05cjV6WGFXOUpsQ0NUOGFHdWZMTlMwZDZTZXNVMjRHK0JjMzBsc0RGRjNxaVRBSDVmSmtLU3BBVWxjWGx3bGIrTmVSQlVUU1JlU1oydlhFRnlEVXFXZUFYU01BeVVKU0pVWktoUnVTdWZtTStVUHdRYkt0T1RaWWhBRjFwd1daYjVvK0NkR3BzYzNUdllZUXMvYVpxY2JKTk8zMERRQTFCYnR4SFdLTEJ2TXhQbHByMXVHTVVRc3dFWFIxa0xSYmhhYmF6UnFrTlVPMkVzZG5lcGlLZ2hEN2RWNjlOL3BpYlZWanhoMjBCL1V1dUdqQUNKMlJEOUZCQXhJKzRhSThMeG5mOVlDRXR1MTdVanorRFlEdCtsc2dsSGVxL3dhNnZsZ3lFSXRJMHNSTGtPNktTSzcwREJqZUsyaHRCMFJxVTU0b0wvUWJjaURjN0ZYQi96STVQU2lXZzNTWHJzWHZCVHRKbFBVT2pubHZmMW5PN2RFZTFTMDVNNzFsd1VKTVZxRkJVbzF3WmhIbUZCTmVpME0xNUt0a3VWbXR2TTdsMGd4dlVFT3VmL3MyQnM0dmNjZ015VDJWU2pQK0RYVXVLUGRXOWhnOHE2MVRidjlMd3JHb1ZEc1F2eWhXRHJXNnNxQXlEK3NQejNsNFJxdDc1cmp2VEhrWGl2ck10aktPTHd3bWx5Y2pjdG4zVnlPWWxITUNIS0xsclJOVHBjUU1MRGJUeHJBMSt6YTRsYThoeHcyNnBZNUVadHh4aUNhYmM0bjNhNVdrdmVLeVo2R09Bb2JSa2VRWEZ0U3NOSXFuTTZZNUdCaFZZZUFTL0JiWVFMb2haeFRadjlHZjZMM0V1U0k4bkpiOStHRHBjbm9PY3UwbGpIcUM5bmhTT214aTR1anlTOGtNYnE3M0NvYVUzZ3hPYjRndXNUd1ZNbk9XL0s4bldpKzN4S2V3N3JkckZCRHR4VUFkWk5ndElWRlJOREdFUk93T290YldNblQ0YzZ1TW1wSTZLbFI0TmV3emNpWTdBRkYvdThEbmtHRE5zNGd6ZmthdWV1WEdQWkVZZndqUEV0MC9rY0xheHlhRVh4UVhFMWpFNkxaRFEwZEF6dm5mdU1LUkdBZi9Dbi93RW1uTTk4NnMrai8xRExTWkRZS09pTDVVUE9NOWhpR1pYWXIvM05BYjdsb0ZpMldibVlBK1hTS0RrSzZTRWx3OVRhYUxxMG52UTR2UHpCR3FjQmkxaG5aSDBqamV5NVBqdU5yN1RwSUphRmZ6ZCtCcUluTjlKUnM2K1N4N3JYMnhlcHFJeGhRbmdzRi9RM1orZ3JjajJRM0VFN0ZpWmhpZ1A0OXNDb1ErVmpSM1RaNWY5UUtJakczckpUZW8rM1poVFBmckxIUGVwc1loY05jV1U5eEc4RDdkWnZyelJFdktySUhqKzV0QkxrUEMrdFJvZXRhSFRrT1hyakdiUVZjUE9SYlcybHEwVU5XK3FuaEJ3L0tERE1pYkVUNHhld24vWFhXOWpOSEVPTFZRTVdNdkhrdm9mbk4yWjY4MVBFbTVFZXFYRmlvV0JtYnowbjJrNThmemZpYk5KWGtDckY4S2RwYng4NjdZNnR0bFRGeVNieHNBb3ovc1Z6ZDg5VXNXbzVCUlZOc2VLN3VieDdMTDVPYVptUGVEYy82RUJsRmtRM3lZQ2ZUblNxYTFuSXdtRnNDQUFFRS92c0NNT21UOThaRnRmay9hcGUxWHprdXNGOXRuUXhCL1BGY2pZMDJHbGI1blJwU0xRVjUrU1JrVFB5L3pIOVdZOGx4eEN0alZ4UXpmVWU2RlV0QVE1c3dhbDNuVXhWV2krQjhxLzEzVTRXU2l4a1JmekJUR0NFQ3B2bDdVZS9tZnJHMUtWRTVCTlozS3JxY2pkU2hWdkVvdjdtMnkrVDN6bmZoS2kvWmxaNXQrS1FKZWJNYmpWMFVVR0ZWa25KRTYwV3Q3WjMwN2ZTTVJub1hQSTg1TmRlTlNkMlhnemdORGY1QzE1YXJ4bUszM3k2MkV4T2dZdktBakJMdnFPN29zRVhSNXJJN3M3UGZBaXRqYXhmYWtFQzczV1paRWxCUUNOUUVSeldZMVNmdmt4bGN6MHNyWE9XcTFYWUxSa09CWnE3M1VzenFKYTdacmt0U2x5dlJNMEFDMlBDanlmYVhUMVJhVlBtalc2K0k2cUVOTXpHam15QldGa1Jmd1U0SEFWcElwS0c5akdUVStEMFdTZzFDK25mdEJVSkZiWlFoQXRvVC8rM0NObUhUR3hiOEZzeE5taDMyUGFaUlVNMzhpTG5EOG0rR2NZRVdiVmgvWFJLTDNtdXFDOEp0QmVnVzhWUCswTjJRSHg2enFLdGp1d0pyOEdMTWNNdEhyZEtrbjlFRC9GUU15VFFRYk5ramdxU1V1VzJCOGdnR24xRUJYcmFpTEJMa2JDRnJqemJoeEZQSkl2OGZlTXZEWFZ6b3R1QmNNTUNEeU1WUEltbHRqOWc3eDRvQjlvK2tzblgyTWhneXdHa21lWWZzOUxuTDB2Ujk0c2lpWnBVVTNHdlVGbTVjYjhzTVFQRmoxVTMwWGVlNGJQOVdHMkpnWi9LM1l1WWIxU2g1SU12MDhhMkMyU2JiZ3BxUG1zOHF3Nk9XZnlueWFsbWRqOVdnd3FOSEowY0NTVjRjMSsvSUpoTzRlWEdDVnFORWJGY1R4dG9Iek9ZMVVHQ3hzSlJHTk5ZUXI0TDBkdVpINmVzSS9zMnRreWNGQ2lpMFh0a2NQeVdKNVFjODc1bGdqUUxUVUpITy80VmIvYVZSYUgzaFZyNk4rL2pHNER6NGhmTGRVK1ZNeWM0ZElwWDBJSE5mQWVzdFJXL0s1YWFVRDFjQndTaVFQQ293MUtyODRYN3RibGh2all2Qmo5ZjFJdit5K3k0ZE1lN3MwWE1LeUl4NHdhbzMwU3MvTzVtYUplZ1pkV0tNdUMzaW5vbEJtMkkxWDBqTElTZEwybTdmWTBHWGpmTWozMWRXVnBydExLVVNIdW1CSHA5RnhZb2ZiZFY2ZS9jdTNHTEpIRVZuOGJZMnYzSVFrQU5pV2lpTC9zdW1xWmFkNWV5V3NUV25lOFljN1gzYTlHd2lJWmdyUVU2OUI3SHJKZlNzZFhHTjVmN3VxLzhhOWs5OTE0alg3OHBCdXpYRFNDTHIwRjA5ZU1lY0JudjYwa1F2L3d6ZG9NWTlJdnB6bDhRcCtPZjlLWTB2NmRya012RVNqblpUL1J1QVFwakUreDBrTHVJeGpwb0RlUnFQMzd2SXowL1J1bklMSDl6TVJJMTUrMkxOU01YNFRrMTZjMmJ5NTdrc2hGZDJLYkFSZTJYMkJJVXkrYWxEUGpJZEJ1ZHN6c2RQMU1EeWwrRU5hTitmZFZOaUFvUDQ2NnEyZkh6enVPdy9LWlBiRHovekxQc3BuZ1k5YTRSS2tVcmlJSlNmbjA3QTJwMzRPOTFDWUhucUlRaDA5WW9seVM4MGJ1TlpwMW1rblYxYXlJdUtwYVJhN3RqYUlnSUFBUVQrK3dITDBKdWwvY2FuajRRSVRhZlhTdGl1dlhhd1VOMzZ3SnU1RnlNSEVFK1BWT1NvZG9ocERoZlJwSERFQmxYdklRU3NKVURtbWNOMW5pMVptK0NsanR4UDNmY05QS3ExVDRoSFNjV0NlbGt0RldrdElOendnSW5VTk14Y2tqS3F6Y0NnZzhMeGlZZ2x6cFhnanRjbDZGN3lmUHhGbk9JOGltbG11MVViL1RXclZuN09NUWh0M2xMeEthL0hLTFdMOGpIdlJpWWJQbmtQR3NMQjJHN29aU1RMNVdZOGJDOWRqRTVJb05pbFppanB6QXB6bFE3Q2FBWTI0Y25qK0paMVJBb0FGN2lNNDgzWTBtQmJ5MUwvYWlMbHBnVU5KNGFaNE5kWnhNb0lFakNvZTVkOFVHRHpKMVRTRVBOL2dxdUpGc2xSY2RWK0FDbFcrRXJtRnZmNHh4S1hXemtnbyt4T2VnVGhQdCtHTGhtdERpazJsbXo0OU9ISnFzc1oydllWWWUrTTRVUDNpU0ZCWW9UVlY2NkJScDRDU1dUQndYZmtiQ2IrMmZWUndJTlVFd1FiZXcxQkpua0JpYnlQQlhENGdIclRld05Cc0J6aWg5QnptcTdGY3hkbStXM1hRaVJ4aTJUL0F5alZvb3M5S2JTejBNUGVJM0tPVDM4dXBBbW9zL2tGL1JJc0l0eTVSOG9udzJESld2RGFIMEpUSDdiQ2RrYWlkY09reVpsZ2tHNTZUZXJXUzNEYUxsVllXVGRzbkhqcUdGaDltcmVhTDZLUzg3QlN0dUVQazljSjArdUU0emMvTDhvYnBQSFl1QmsrdlFyMHl1emlzYzFheGcwM1ZFQ3QzSU9zVzh0YkN2WHNXUi9Bc1VIaGFROWd5WURXN0tMQk00YTc1Vy9NNUVWRHp2Wi9XVjZTdUdjZFVXUGdaSERHR3dNSUVUWVFUYlpaR1IvcWFmRWpZUlY3bHFsQnlTb3UvcWxHSUovdGRhRW81dk1yVDc1UTMrM2VzWHFVSXE2REQwODdBaXRjSVp4eWFDUmg4YVNyK0ZXWmFhNHZEZGtESXB4c1FGZHlNbE5reExPUmpVTHE4cWpxSE14M1NqNG9SdkF2RFJ0Y05lNjd4Z3BONFVMdmd1RWRjWlFiVWNMOG8yTHBJK3I1bWxiYkc0ZklUSytWbEhlNG9FT0NFdWxZd09YaG1mSElFU3VqT2ZQZlhMWE1keHpsZDE1NzBmdVV5aFprRCtVSVFHa2N6UmZIUVFqOUpRUzUyWWpzUmhtVDNSWkNYUU5BUmhVRDUvOUppak43aUk2SFFJMHlJQUdhUTJOV00rUWZkMWRycExzUU85UlZrT2lwZWJ1dzBIS3lyVUUwbHlmQkt3S2tPc1FuelhnMHYxRVlVbTNYajhPaXBjcTdLc1BVNHZHTmovZ1FXdzk0ak5PSFAzd25uUkxpS2VHcDlOcEltSDRVRzJtRU85dFF1RmlrWDBKWUwwVFZxM3VwMStTT3hsYXVWaUl0bXFvc1JjYVovSHNmRjQyaTZpckdQTm5nM1FwVHAyVDRTVEk1S1FxYnNKTm1iNjltcGhkeHJ2Z25vTlVRK3VRdTUrTXBDQmJrVHg2MHZXa0hjRFA2c3BjaHFJRzRhd0Y2ejN5QW1SUldyUlNaUWZ2Q0poMGFvTGkxRXM1bUNjV2lxUHpWY0dNcVBqS0RERmpyR1FYWVVjRE95Z2ptRWt2aUJwOGJVYTFWUGxkalF4dTdUSVVPcUlZVllvN285NVNpZXNOS2JuaWJncVRuOHBWZTIxN1RXWmxaaWpFU0VFeVIxL0FLQWdBQkJQNzdBZzVBSysydWo5RHZvV2hra3FDSTh3ekRkNDFGSFBUT08ySFVaTWwzUjBuelUrMVRtSUtVNHBHY3Rvbk85VEFwUW4vOVcySGVybXBBUDBsb2lhMWlVSjJzTS9uWUk4am02WDRWNTV6ZzZOYncvWTh1TTFGK0tTT1BsN2dyMkc0WGx6UDlXbFVSTW1uR3VDenFpVUsySXZsZlNYYmNSYjhFYmIwRy9JRFplZDdaeHdoUnpqQS91dm5PdDJRVFhMZ3B5MFNnWjI1akJYQU02a0lMN1F1VTg4V1ppaGFQUytXVDRSWE9KWW9veWhRdzkrZTJmejFvaEU4QVoyZ1FqNTFqWHBCV0JicEZJVlR5RmNWUG14U21EcEx4bGF6eXpXL1FNaHNSYkZzVFBaVnBuYTFTbG9xK3c5RFNQRUpHVnJ5Y3lHVXdSOVFWZjRKRERhQmREWkd1R01JSDRTRGltSlNzSFRNdGs4V1E2dmhGN3dYVTZPSHYwQXUybndMamhZS3dFSmU5dS9pS1BCdzUvc1EvMjl6YXNWbGFTK1BoVXJrUnJpMCtYTjlRMGtwbDJDNkh0QUgrYndWWm9rWThXWC8rRnJnbEljWkNOODUwSjdUd0lCTXRGcnpISklEWWRtL0g2TkxvVzlhcnY4SCtjU3kya3FxdmZBLzQ2bnZ4WXFWOFlqSnplTzRsOHduZyt4eTJzWFpkc1dEZE5najdwR29mWjVMU2hoVGpKS1d5dm1nMWpGZGdsUUVZQXNaaWd5VHpKN3JoRXhhcGZNaE80Mk95WjJ0bWZBUXBKUys0c21VUGhNWUk1bDBmZlVOMUJIaXZHRDJyT0hyVzZlZHZwaHJqWUpLTUozdGNCSXdJMnZWMk0xakZsNVorWjFDRGJ2djF1aThuV0tKbmVJb2laTStNeS9yY0drTWd1Zkg4N0J3QkNZRTZVdHllNjlXQXEzNGNoc0laUEdRSDhHQnFHbW9wQzZzSXdlT3oxdXBxTUljS1BteDcrOVlNaGdzaHJNVUxSck9nQ3RMSUtVYTBiajJxSEFxSTJNSmRhSEQ3aFUxdXFXTUs1aXFnbHJIdW9sVmkwOWNOczRjOUFBUHZZVVFQbnZlWGhGZnJ1QjBXV3luTVJ6RTN6bS82cnRUN0hmdGczb0lrY1UwMytwdExuRnczdnBHb3NYQkwwY0VLWGpzS21ua1R0cWxZTGV5T2lxUHJtS29iWHZTUTR6WS9HK0MyRUhVTVRYd0lPbFMvcEUrbkJLS21VMisrSTdLNFBmMVo1L1RRVE0va29CUEY1eDgzYi9TNGd0V0IremxDYU5RSHJsckgwZFl2cXQrc29pd01jK1JoTWp5SEJGL3hOU1QzL1dJdTR6R0FTekJwcEFudExQNTQweFFhdENneHMxd1owbWlmT1kvU1dKdkhsNkgwSnAzRlRmQ3h2ZlIzeUNRK0piY3BkR1BsWGlUOU5QU2lIdlgyS25XaWJRdDFRenBiS3YyRFEyN0c2SUpRdWdpL1ZoNCtidndIQTQvNFFvcUVoVjhnSVFXWFdxbTFUQ0VHR1RNYkZ1dTNXc0JmRHBSUXJDYmxHUjRuZko0REdPRUltdEl1OTM1NXBQRHlUVVdReGx6UmE3c3pkSnpRK0pHMWx6SHNXaWpDbEVrUjIra28wK3hmRkJQY0hxa29nc2tGZ2plUjN0ZTdMS3ZSeXh2UFRBeEplSVc1UDQvUVU3U0VBZ00vWDZtN295ZSswdVFmM1lTbldudkp3Q2RNa2g2bG1OaEtlTlpBVEVGdmUwRFZHUEpTTDJvTnRwM0lnR2hJVkNGNTRUTUNBQUVFL3ZzRTRBUVIrbktpQ3ppMTY1VVhvcmx4ajNOUFo5QUJORE8vd2Y3RDR6czlSRktDRnB0cnRJRURJdFdFTXZJenVhVGg5VGFYbTFFNkFPTSs5ZG8renVWbW5kd0dabEl2K3J4UzdKcnZFQTBuelNCU2tadXFBN3FJNFJ2WU1Ra2kzdStFWUNhRmZkRTZHeitCbE5GL3FNSEM3M2FwbURkZGdyY1FvSHBlU3E4anFJeFE0VWVtQW5RWHBMRU14bkF6T1V2YmVxOHhRRnMrQW9pc3VsVDlBZm9Scm1ieVhvb280d0c2UWc5TlcrYzNUVTVQYVdqSUNFSjRaajUybGorTm5RRyt0K2xZeFZPWSt0MHFiRFBXR2dQU3BPc0JjbmFYMzlKZVRqQi9IUkpEaFZUclkrZ0treVB6NnpQM2FkcjhZOWh3K2VZcUwyeTNzNk1KYnpYNzNXMUhDVDR1NFd3S3I0Vytid3YwWVpEQ0Q4dkc4ZnpRTzhvMnFMQlBDWWpvelMwb20zYkFBUlA4OVJTSDJsYVRFVVNZV1ZiRmJheXNLL3RWVFFtZkdOL1NxcEdJdFRhK3hPRkpqd3ZhVjVyUGxvUitWZ1Q1ZGlMdEN0d29nS2swNUo5TUd3TllzNXJVbG1nbGhCUlU2UlQxdlVzU0lNS0llZ1kvTkVaaGtZaWhvRUc4bi9OT0cwaGFWRlZQZWFQNzM0dGhBaVY0U2NucCtSaFRzU051MlJDSnQ1N2hGZUlGTkxoUndpa1E1SWphMnhLQUN5VmtMdTlRekpwTW5kbTNDRUw0bmZSU2NNVG1qc3ZSa2FvbFdjNWxZZlFwWkREbmNKOUk0U2N5aGlKdG1VR3p4OUswUFVxZ29pSC8wU2d1UTFUd0lnempWenMrcnRtMjZRVEczTjh1Y09DaTF5T3hoU1ZiM3Z4YnM3MjJzWXVnUlNNSFAwMDVJMjNWMXl6SVlzakxudVRqL2lwZE5yZTJITDdSbUpoemlrSEhCeHg0VEkrMEUwSlBuTWNFcCtBTzJON0c1L2l1QzNjbHdDWEh5b3hGdi8zb3FmM3crNnJlbVAvejMyRFNLMmJUU2J0T3VFb3FLUHBicTZ3QkR6MWIxekVJSFlGR3NEdnlGU1RHZTRsQmNxL3lWbm41SjRZTm1uTlVVRDZ2OStZNmVNMzFML1Ewd1FlblRydmJNY29LaHhFUzFKNEkyanpwZkNGcjRwUjErR3gyNHpjdFdBQWorYVR4enZQclZrMW9JQnU0b3JDZ0RWNURmMnlPK3hxZXlRbUlPb1U5Vit3OCtLWW1JbnFFYkIybVZVdFc1Qkx5RE5YNklRTlFFZE9NK2c0RGVFQUlNM1lGUW8zc3dnWHBSVmJWZU5lTGJMRkRUU1Z0MlFYUFhHU0VyVit3R1dwTDNNTUZpRGN6NDRscVo1K1l4cmJMSnhvMGxNRy8xMGQ0QWV3TVNvNFpLdk1LUmdlcVUyNXBBMHNZd2ZReFpYaG9BLzdMT3JhZ0JRZk1ZbGRPdUFpRmtkMlk2WlZISE1zU1BiZDBvekZkdDRJRFZockVJdHB1Y2dlRWtFSVh6clQ5ZzIxRHdhSVU3TzhQc3NueW1TazJQZlpjaWdhS0xUelFLUXFLOGhYc2pWRkRRZGpaV3NiL3p0QmtQcS9HNi9YYUhGZEtHSjE1V0F5ZDNvclo3MGUrNFVpb1h4NStHYmNpcmpnenl2aG8vZVY4aXhKWG14OUdiM1dnTXQ5RlBmMnJibHo2SlVqOHA0cjc4Vmx6OU4xdGUyam1ROHVBQ2twS3E3K3E0VFNQSUJCS3RnZU1uLzlOTUFJQUFRVCsrd1BvNzdNV1JGVTN2ZVFJeFhJQUtETUxiYk45c2tBRnd5NHJaWUVSQlU5Uk9NNDlWcDZtRjd2TEJLZHltT25CR0l6eFE0aCtVdXJIeTBLelUwOTYwLytOWmYxWG90VThFR0gwLzlyV1Z3TE9PK204N0xLc0thRlRLM3dWOFZkSDFFSWRybWpkQm1BRWlneHJtcWRpR0p1Z0UyMUhqdE1teDBMdTRXb3BBMlVuYWVUUHBKOGE3N0cxSFJpU3ZGbU1IWkczKzhSbmcrTW50NFh6Z0FKMGp6V2gzMzJtbmxJKzRVSzZncEpyZEtTM09EL2UrQTVRWEJMZVAwcFJlSVFZeVRDdVFBdjZFZk1QTmdHdFE0RWtDR1VURGlEZ2ttN05OaHErb1UzRFZaa2xla1hGaUlycFQ5M05MaXg0VDZzWXAwU05CaVBsbzZGZVE1aHVWa2hwSlZSVndKallaazJveXFSNXpPOXpzdnNvT2pDZjF0ZFM5K1JIK1dSRHVpOURQaDd3VUxhckFvb1ZSTG41dkcrL1BRdENrU3E5VmZkQjU1d1FFcXk4N283N1BjU2tMQnhMMDhLazV2N0x5UmFhaEIvcVhKa0V0aFJHWFVsbTFsQ3NkZ1lndkJwMFNEbXBic1k2VnFGVVN2aXhqc2Z6R1B0QzdnUmhyM2N5V20vQ0FSZDhXb0FMZktiWjI0bWE0MmVyQSszbm1ZbmlYZlBGMTZxakV0VWJPR0tkblUxOHBQOWQwMXZKWGs5SDVMako5YklLdDBRQnVzWmVDT09RU3ZiblVCUWlLUFU0bW1rTWFhUUNPRStTdFVBcXNBUTlIQWNFdkVxQTZUcDMrRjlHdUtyRzc1VVlIdkN1UG5HS1hqWWp4eUkxU3hPSmNleUxEeGt6TnRVMGJZbHhsUDhPZ3cyK2Rsbno0cEtFcnVyRzZ2VldzYk9OUjlKbHpQc3lPSkNVUXRsK0lUamJqWlIyakVHenk5TE9CR2NVd2M1aGZmQjJQdXZoZ0Z4a2Z4NFJvUExWNm1LZnZha29WQnFuSGViTXNjajg3aE1reVpkMHFsTTBhMUJQNXZwb0djelhlWDYvRWVja0tYTmNYcEVxc1ZHTmRYZWs1VDVVMEg0VFpTdVhFRFdsUHY5dXJzU2doMHpzV2lQSEtjN2t3YkczMUNXeDN2TmFYc2pGRysrV3NkVm5SdXZSOUJRTE9qSTIyaDZxMG1DMHkyWHNvNzYwWVVURmUyQko3ZVlCalhZTUNFbEZ5WGI1eTdSaXhsemdXQTZnQ2IyK0dtYnpRSkZJWUJPVVRpblF2Y29Gc2FnTEl3VTlJejRVdlpIQjJLTnc1Ty93WElGWVFGN2tZZXJqa3pSRjRFZW9uVFVCM0t6a0l2enhiK3hDOXlaZ2RIYjJSMUdKK2wvejJBa2plR05QOG5YMnczWFY2eHRIVDJDNUdvVEpWeU1CQ3FaVitRS3VPNGNaamhBR25pK0FEbDJFaUJKcnNmZlFrbGVVWlpFeU13TEthTmNhNEtYaVozYVBJanhTSTNmM0RPK2pyQ0NOQ1lrMlRORlhvb3JSS0NraU55OGwwVVJISmZrcGRheEF1R2JMMWYwdDdiQ3NxN2VHNTBmUTJtQmxlWk85eXFKclVWY21kbkVHdWlSc2lxWFlSS1I2OFhWQXBUTXZtQVJ2TkFGaWkza1RsZVJoOWwvVHZ5ZkhVTlZXZWhIN2t0WlhaMlBFWlkveVdKUEdHWUl0eW40WnB5bWswZGFRbnB5aElIeDdnd0VhcU5iWmUxaGphcDhFU3NEaE95TEFST2c1K29vMmdNd1BBZ0FCQlA3N0JHYUtlK2RRNHd1cklPL0gzWWpZb0ZLZFRNcmNoaW13ZjlaeHNRZC8xSm84OUI0dS8xdlJHbnJZZVdMcUg5OExHQTQzaWZreWw0R3RnOTlIOExEbzVCWHRCUUI3VFZsWFhNTVArWmtFaXVlWXZrYzQycW45SllMTXN0enVxZk5QRjBFZjcrMU4wUWw0STI4UlQzTnZNWlJBSVN1NWNML3VmTmJid1Rad3M4bWJ3dXdhOVpjWlhYem93MGhSYlVqUlZ3c0o1Kzd5U1YrQ0hGd0gwdlBsUjlHUkVJejRNMEJTaG9TdlJwRWl6a1FmVitnQnlpdWorcWNsbWxWby9TdU5HREMrWlZYb2VVTE5qekc1SmVOeDRlRFVWeTlDL3JtdkxWVEZ6Zk1CTTloV3lNSC9UdkxSMGxIdTF0T0RLd1MzVlA4dGQ1eHNUYTg1TnNOT0xTSURKTHViRXpHSGFlMWJ1OFZicGZtQUNoZEVGb0dRNll5WlBXWUU5TXpsL3B0N1FjaXk3YXMySVlXUU5vVU9oaEtmbFVVc0UwRjNZcFVzdFRvQTdBRkIxOTRpN0YzTGdHbXFIQjhRV3M3WWRYMGtnMnBRb2F0OGhUMlpKdkwyOTdWejM4OE1RaUNBK2g4QUNQbWY1a0VFYnE1bFZCd08zY01xSkhCU0RZUHB1eFRUcnZhazhzVG1PUFhlbFB3RW9yVUZFTE81cWFkeEM1eFIvYU1DY2owQ0VKSGhrMlIybjc5MytyMkplTnE1ZlAzM3RSYThQNzF2OWN3RVp2bFBBcFQyWEY3YTZOcG9wNGg3TU8rWVE0Y2RVMU9LR1d6amJiUGZnZEJCMm0yREhBNmxvVkttbHM4UDU3UmEybTZwT2pZZ3hhcTNPcDVUdnlDcWNCWWdpQXVQc3phbjRTMW1jZDlPa3o2RHd5bVlaMGVvOWtuVFZhR3ZKenJMTWxnUmQ0S1kxSUhqMHo2ZGtmQ1hadzcrcHFib2VhbnoyUVpTMDNqZGxCK3luWmJVM1Z0OGxiUnBqQWppbnNmcUozZzY1K05uNjd4dm00ZGFIL0R1dURnN0lqMzg0eHBWaUxib0VxcG9jdjgrQytENXRQRmt3NnBLRk4rU2FjVXFFY0NrWmhqTDNGd20yS2kwTU1qT2FUd0hIYUg2bGhINmg0VnR6Z3BVT3ljR0Z2MjJ0eVd6VXpqRkpsOWsxN2Z5T2lBUmo3REN5TGYwbm82MlJRTFRRdVdYcVdmcjd5N1F0M3NRQjhVRnM4S25sMVRORmhIQW9GWUVXUWpxaWgvVFA4TSt4aldIeWNOcGV3WW1ZSmhud0h6V3V2WVlVd0xEYmg0QWN1Ni9NTDJZamxvMGhhQ2dTcUxibGg1K2xvcVU4dThNdEp5SFZHT1pWamFiNTF5UlVnMnpnRmVPamFRVVliT3RyU0d5emhPK0NSNDlsMHlJZHpVOTAyUUZNc1J3YjRpbjl6K1FVTDVnSVBiRmcwYWhRa3U5a2lHcm1JZENjc2tCVzEySkdxdkw1MVNXTkFMenZ2RTcyTzQva2lLYytVSyt0T1NuRkRHdURxcFVGVXQ0dWh4M1kza0QrK1VPMFVVRFJ1ZnlHZjlnK2czaDQyREN2T2d0Ti9hdnhnYVR4VGZ6Ni9PRFN1R3RjVXErbmpFdldMcVFKMmRWZ0xnSGd0OVJwMFdJRDROVVhMaElYekZrY0g4UUdINGZNNkI3S1pnLzRqckJVVWVORWtkNitMS3VYL2x4L2F2RmpnM3N1clFIbGNIM3RlMnNqOTRDMjgxWkVMUUxyWnA2eTlNa282UjhKdkZ3OGJBQ0FBRUUvdnNCd1RYSzdKdFFzcUdTV3JxWklMSW1tVkFFRm9SWXFWa0VLY0JpdkE3UlJXOVlwK2dNMFBzTlNmWnFqL2JUYlpQL015NGpCOGhMc0N6c1dTT1BjaXp2UEJrUlFMcEFHRWNJTUJUUythWkpDeVZrUm11ZFNnaGxVYk9zVHA5eWpkek10TWNaYTZESDJXckRPOVcwQnBRelByWVJaQk9hLzNzRzNTcmtwazZ2Tm1CVFRiVFZyV2hrNHR5REQ3L1cva3RzSW4wZnJ0ZnFwVG9ZWnkyeWg1L2hOSUdvOEE4dWl6WEpMZU5RK09FVFYzRWV4MHMvd2gxTy9UaTFmdkFJMGYvSy92MTdrQUFLTWF5eTVnSDlBaUJTK1E1U05SUlRnMUJsSHhjNVV6cDNmZ3lCeHBVZVZFY2w4VEE3Ty9yMWJLZlRSZEpnRHNValk4SzdFdTZRVHphUzZoUE96amxRdzJuaUZ3SzNlQzg1NXU4eng3aWJUUzQzM2h5NG1QWExoSS9MS1ZLcWMxRGJBL3VZQVNxVWNMWlhjMzhOcDE0d2Z6ck92OXRyYWZiOUNGN1lLZW1tSzFqMzRMYm5ZSlZpb1l0aDdNSGYyVEpUTWE2STQ1N0JWajBXL0taemYzanBzeUx5djZMTnUvMitnaEdsSGlOcksyeWN6S09CV0JWZytldzkyR2h1TGorNUMya01GbHNiSUhtMnkyWmdKK1c2UjJsTWpicHE4VHdVaGhrdmpjTlJYUkpOOGoxQ2tpak4zK1lrdlRBVGNUSnE3NUNhQW8wR052dzdiTS92QlEzVXRpaWgxTFNiUEhQTEVaN0dYWUx2ekNnZExDamJ2NWx3bTcxYlM0bVRuR3RtbWpjVm0rYStrZzYyNmp6UVIxZkVyKzdmMlBXbEJ2V1lReCtTQzVBZ0wvZnJIZWNKeDV2TERnMlpndUVnSE4zdlNHZHMzaUk1RThzeXlRZGZVa0FucmU0REg5cEU1RnN1aTBXZ3ViTnBNTng2UWVOeFB6a2ZQSXR2c1oweFdzYk9DNGx6S3lNWERsbE9uWEtzTW1Yc2ZzeGYxL0dhdzNDNENFdzZkYWRGQ2RaRWNEOEVjckNKTFE4WmFWdEZ3WVRoZDkzZFJHWk5YVzBqRWhIeXhReTVHRVFOS0hETDRlSlQzVlRyMWJqYjJUOGtzWXpQUys4Sm1EMjZXY3dJcWpXQnJQbEJoSkZWNUF0UnR1ZnJ4RTArdXpDOUk0dFNJNldKWGJXa0EzS1E2OFVwZVRJM0plN3N0Q1c2b1RheWZzb3MvQ0RFZ2Exc09JNU1RdlJ4MU9TZkVUNWFianVQdFNvSmY0SDV0N0twOTNuVjNORTU5UTlIT0FrOFN3RWV3UzYxdHcyWGVydXNsT3EzOE9odFhqV2NnZUJJS0FtQTNnSzFERFV3YmFwN290VGxEUzNMaUNTZFVxUEpMTVU4N1lCMUo5eUlEOUZRMitWalRjcUFrS2xTZmZzQ3JCV3FkMStabGNETHB6K3NrQXdqZGxaNmxvQkFIcnNQY29MbXRZeWQzT1RHTUgxcVVuRGF3RDNkbkxmMlBnc1dwN25rc2E0eTJyYVUvUGJJcHA0dG1QTHV0SVFPekZCdmZKU1BEb0htbkVTK1VuTyt3aGVCWHBZRnA4MXY5eUxSS2xiZkZFUU1Wei9FOWk0ZVRzbEYwcDRhS1VVODVTRUN2dnhGazVQTmpVSVhhSEgrVGc2cEFhWjFYNXlCT3NrZTl6YWZ3UEF5OXBxeEJTTXM4MW93V0pTemt0U2dzZ21Sbko3ejJLYkFSa0N0SDh2WWMzRC80UUlBQVFUKyt3TGpiRXNlYzF0RnByQm5vRHkzRUlSWFhpM25nN25TODZIOURpVmVwMUxoTkJkZ0Q3MmNiV0tScFp0VHROejdRUEFjY1l2TGdBV29IdVdtSVBzVGxNRTFoZlEvdUtENXV5cFFpeHBsU25BVnU0UkRMcEU0T2E2c1RRSXM3eURReFlCRXRiUXZCMVRqWHhkV1dGYjdmVGs2UEFBcjVUU3g0MmJjL2pqUlA3V1ZCQnNSOFRQVVR3dGc3MFdLaFlUeFZQOHNYZkxsRnRNTkV1bnFQVGFSR21XR0VNeW9aWU5CZ2VkSyszQzJkSFRnejZlcE8rdkM2bUMycXFTa0JtanUzSTFyZEFKbndDbG5MSVFPc2pCUUp3YTI5a0hOVGJyc2pjTlE0RUtFaUxKYWFSdHlpby9IMkx2VFFEZk5YbHhNRGw5Ly9YTGQ0WE9qQlNFOWMwVXZJamdDUWhRQ1ZNUDQ4SHhLUEk4dWpwc0FVRDNDVTlycWFPK05XMUFXd2k4L21sNUNHTC9QdE16UEFVSmJ1TTVublNyRkJNYmp0Rys3aFNYb1hSTnV5VzF3eExlN2QwbGJVa0FVLzhWTTlmL2RMMFlLWjZSZGptTW9PNXg5azcwMG5LY3gzTW5rdlZMWmdpK3hOTWJZMGlKbDI2Y2poYmIrNkJLNy9pYzRWQnJaTVBQVWc5S1ZNZmJSR3pFMWMyVzRVMEI4K2g0THdMd1d2YnZSeUF3eFIxWXJ5d1VEVERaRHd1V2pwcGQ0a3lIWVdJQisxYWo2aE16WXY2dmlmbStGWDdFRkphdHpzOHZCMGpyVWxsVVJSbzF3OGwySWJIalFGcE90dTdsTVFTblVRZ1lYVCt1V0dJd1lhMHdNYUQvY0dtOG5wcVNQcEU3Y2pxY28raEFwM05Dam9Nb1paY3JpODFadkhGSDcyYWdUWkgwNTVSYkUxb2tpbjNOVTVwc0pTbXJCdmpZMVZ1ZHI2WlBiMjBPaGFINm8vVWZiZ0o2UFc0TTRFRkR3cCtCTlR1REcrRHZUb1V3RzJaNVJjRzRZRlF1SmJId3l6cHlRUTZEUTZ6dlMxS1pCSXgwYTQ2WmpVWWNOcmhuaFgvVGtHVmFRNzNRNWczZmV6RlRSNmxiVWVYNWRLaEI1TVFuWHlrUlV0NFM2TUU2MjJBVUtLOHVaNzZ4UGxXb09YMFA2S2w0RXlUMWVkZEJsc2Z1MzZvbTMxdTRpdEg1Ym5Ia3M3WWdXUDhqQVMxWTN5VWFNeW1IYzhKQmhsWThQSy9KL3F0OGRoNWt3Tnhvam1NcXBGMGRKR3BCYWx2by85bmtUMTlJU2QrbGpLbjVwazZrNGRXbEJyckpVWGpFL3FqUzVnRjZxbms1MmxrVVMySjN4OS85UnRtQ0FQSWZKOTdGaG82SmxldTMwbEJtc2h6aUliNi9YZGRCdms5Vk90cjJDZnMvVzMvdGhIWWtSZklvdXYwVjIyNmJrRG1MRUUyS2NUaXkxamUxcSszeVpYQUhSUGNGK3FjbnkzQUp2elNiZjVOTzVORVY2M3ZXdnVpQlBxV3lRSWYycXZTY3RXTzBuS2NqeW1NcXhRbTFVdWp2YWJQZ0t3OHpxV2YvMzBPYmJxd29NOEwxME1DNGtNaTRQWkNuOGtwOGV0cWlPbVJlQkZsZHlFb3VmcmM3dUhqVHFVRFBHS3lwdzZKc015NjN0SjVXWnRGWGpwSnFXTWdZbjVVdjVCaWRPbDg2VzQrNm13ajRzU0xheVJCeWNWSUdERHI1eHdkNnMwMkR5STRONW1SR3ltN3N2cWJhV0loV2NMZFQ5ajh2S0FnQUJCUDc3QkIxRG8wMktQZDZwbERFMGhndERVbE9mOTRiWG1FUW5UNitOWjdlWDBVVFl6RFV5a2VaQ1R2TWk0emd0OERZdnBYN1BwMExWdmY5VTJGZWxENTMxQmJYODFFdWJ6cllsRmNPWG50QVFFN1g4QWpSUjc3cHNmODVkQlVOUURucWpFZzMzbGp6WVlRcXUrU1lOK0RKQ0dMamJ2S0ZGaHZrb1dCc3NUR3RLZ2lJZHVJNU5RVHpUakJPaklyN3UrczFYV2lkeWc0SmZHZ2JDdTlKRVNqR1JEbGNuYkZZcnJzWjZIS2RNTUoyZlVkRldYNDRWMHJNM3M2VGZTUlZ5TlZXK0h6RnlKQ29CWlRWWTZLeFoxUURLWU8rSDV6eThBUUtwSjRENUJlMUVTSFBNbncxSzBYdkw1ZHhXT1c3dU00d09hUkhRUWRSR0xRL3BwR29uNURpZE05aW9RZXNpUnNKQ0sydDBJTFdFNFNFeHpIUWhqZ2lDMkEwUmRwQWl4SXhPZU0xVkN6KzBvTkNDb1RoRW1nSW9rdXBNbzNZRWtvdU4zUVBCcW9aNFJVa0xGd3NLSXRDOUhoejI0M2YwcmJpelE0Wm5zeVlIblRlSEJINEhZbFRuWnFXK2dSSHpnb0pHYUxWeEtTd0xPWmRXaWl1L1QxRmV0KzBRQXQxejNBSnpvN0wrTFVGZkxxWVZUVjZ0aUNCTlBQRjM1RHRydXpqUEh6ZWxLSlB6b012dUJKdHVLMnFwUFpJSVJHeXUxNisxUnhmSWZpNkhxSFlndURCNkVEeVlJR0RvU0tDTDRObktKbkNkMU5HS3dkdzk2NTNqTEQ4c0dhTm0vU21FR3UrV1I4ZFIxQ21RMWs3VmxMdFY2SFl0VkVpTlRqMWkxcmlHSjdyalp6YnNBdnd2cHNCZTFpT1F0MnF0VmZOamkxYkpxTmk0Zy9MMDFPNmhESVJEVVdIbDhyazdKL1I3ZE1uZWNhclgxaFY1VWZ4Y3lib0xkKzBnMWcyTlBKU0hNcm1XVCtycE1iMXpTZjJXalkyVHVYSW12eWQ4Nm0wdUlyQVUwTXc3VzBXUXJNWVlzeEM5bjM1N3JFN0hnelVaNWFuMC9ZV05OYjYvcDZLV1d2YVlVbjRFVlQ4R1JZSnRKUjNydjRZQ21lS1FzUDhMRXlsZno0M0ZETVRqekxHcGc5azkzMWlJWjN3NjZ5U1VGYlJYcXZUaXpWWWZ2dTQzUm5EYUtCQ0pzLzhRRG9VUWhjNzlseW8wZk44VWg0YnVLU2FRbDAyMGVFaEp1R2RiTUl5OXFZcTFIRUJjR0hkVkpOUUx1YW5pTUdGd0VuZEszUElzUko0TEFRSytvTTFlWlN4bjFSczZ2a1FrK3BKRTBCK04zQkU4eExoWHRUSU5nc2tPblZISTExRitOWFJKL3lhYkxqa0dUY09jK3lvT0p4MHNUTkVwQ3lYZnl1K0syZDM2QUNHM2RrVGJiVkNZaTdEKy9SK1MxRnZFOXVOMkVuZEhIbC9SOUhtNCtrM2VqOSthTHJxSUhYSkRRckg3SUFland0WFB3MGU4Z0JRdm14SkY5QjJwdS9iU0l1THRKdkNBVUttR1RRMEtoUlB5aVB6RjZMWGdKZ3V6aXY0RVRubXlWOTdLQmZRVmlNb21Kb3c2T3FzZjg5bitRUDBuUU5oU05sYU9SRWx2ODF5OEJnRWdNWjNJREhuL1U0ejBNRGlLbWdHVktoSmkzYjAwOUpnbnlIUkZpYXJxN01sWFE3T08yV0FiZGt6NE1tNGpiRm4zL29HaFJ0cklGbVVHeUxjbzFzK0Y5L1lDQUFFRS92c0VpSmtkUWlRTGhUd1JkeFRWb05YTFVqNVptZU0yMDExRDFCRGIvZWJMTWk0QTZtQktmYjNyV0pDcHl4M1R3RzRoN01YVU9GVisxZFltR2JSNXlMOE5JMmZqN1c4V0JmZFZmNU5LRE1nM3RUaHI0em5MRnpQKzl3bXMvOG8ybHpoOWR3MjJMVjhLUFRWZlJaK2kxU21Kc0YxN2Zla0J3MTNlSS92OVlPZVk0MXAwV0JwbVU1bmhLd2x0YVRRd0tDUm85NkRmRkcyeklUKy96VTIrSUo2L24zNEpFMkxiQ1E2aWJ5R3RpRnhIUEM5U3ZnVlBxd1lONmdZT29hOVVyb3JjTEZOU0duMHlxN1AvWEZHa1FqeWh1TjcvZWtrVnVOSW4vS0NsdzRNQk5qd3dKblNMQm9qZVVzckM1b0cxdnVad2NEekFtaXl3MUtubFYxcnR6Qm9vaklGY0k0bWxqZ1FVOXh4RGhXTGRFNUM5UjJtUFIyVENVNDNOcDJWeTEwdXVRaTlUSUM1SWhuMlZ6NEZBTGVrY1orRStzZnB1YXZlSk5YSGE2Uk9SWmtrWTExU3R4Q0g3RHZ0UEd5MVBmd2dRaXNOME5STzV1eG5WeGF1SjVlWmZmUnNtdWF0MjRYTFZCVmZNV0tzK3R1ejJjNHFRSThhUS9yZmZNeGpHRDdoOHhFckNHc2hDeDYzbWRMd2lBZkRNWHJuaFhTUStUVS9mVGVwMFk5eTJ1QUlYVWt3aFZQVk0zYlNZWWZnS1gwVitPNTF0cnI0a0V2WDJVK0IvbllPOEJlNVQ5OTczblNnVm9MdDFVd3VjbG5HWFRHS1Z0WGtDZEZyNTdRVElXQTFITllqWS9kWVZtYmQ5aTd3V0s1Q0xOZnlmeTJHQmpYd3RZQytuVUo4ak1wY2MvRTRRYUZUS0VZN1QwdGY1cDVNVTA5S2hZWnBMejBwd3BjdjE1azdkb1MzK1A0cmcyRDg1cXdCY29FU3JzcXFuQmJ0R1hpYkpxN3BtMk9nd2Z3TzBzTmtsa3V1c2x5VlQyS3BMK1NOTXV2TXRIWW1LdW01dTMrRldwaDMrM05VenZITzF1Y2VmcjBQNGZCOUkwalBYTTVvblp2aGJ4NjNONm9qYW0yRERBUDdxbmxIMFE2bitvWkl1SmFweXU3Uno0clI1ZkRKTDRoQUNLK3ppQmJOQzBVVXpYLzA5c2Uzb3lMYkEwbHR6UWEyVTVGMFJBdDdHWU1kWkNZanYzMkNQcC8yRkZ3RTlGa0g3ODRnWUx1c3NxQ1pydjFSR3lTYytOUnErZ0pkRG44Tjl6d1Fjald5TTFvQVIzSDV2dlQ0TjlIakM2eEgycUNrMXNTOEoyMTFBbkZ4Y1pHZ1RJR3lPYk05TEYyU0gvZFJCNVJwT1poVzhiKzVkUzZuc2FpYko2OUZPNC85OFQ3dEM4OHFhdE5mT3B2TVk1TFNoSS9Oc3cwbVhxTCt1QnkwQjd2OVFnUjVxSHJoc0lZdWEwcWZSM0sza1BnWExrcXNIUUFpUkpyK2M2cnByVmo0dWU0OXI1YzNIaWRtekk2a1REeWJWUXFPY0s1NFpVbnZWSklBUVRFemZlenJtYWxsaTcxQjFEVER1emZtb283d29kRnNCSlI4aHo5dHVLY3BQL3YyTmtsYU9ReUxGV3FyWndHR1hITlA3bU92S2FNbndsNEtPckN3Y0drb25BQmgxU2s2UjVkcEpDTUxRSFRhOFE5aEpQZTJLM25mWHlsOEh2RTVSeVJiNWc4Znl5YWdEWWtRWWppVlFmZC9Vc245bHNLS1l0MlhxQzRLaHdRSUFBUVQrK3dERkJhSlkvYk5aMFN4ZWE2WG9NTDBwQ2F4dWw5WEszTlF5dTJCTWo4UHhNUkEyUERQRFFxWDNBcVR5ZHVNZVFralFDRGZldWJicTMxOUtpL2dzb0ZlSEltV05DcElzc29OQS9oQi9uTS9HWHZ6b3lUMllQakp0TTlGL1k5ZWo4dG1tbnRDM3BwVVJLMjF4MHNPa1FNQkxSMnRJZ2c2ZGFzdHBoWjFXUGpWVVNiZFRudStZSWVQc2x1WDNKNFpVUkJOMFhXQVRDaEZOTHVDWWx3MXo3VVIwZWNWZkhKQXZGZ2N2K0JPZlRrNGdqdHh6Y2hlcFliaUgrKzN1ZDBYemltTTZyeUlyWUd2dGE0QUMvNGduV2VpWXdZdnJGMzFQdzJQZWExazBWaWlCZkt1SFQwSk5ITnVXckN4TDIvRG1ONjk4V2Zza1B6OE5oRFN2WFkveTc5UFJHNHpKV0xUUml4TjR6TzZldUEvYTUwV0RGaCt2bEtXMXFTZXlma0w1cFdjVzlTUUpzRmIyVjNxbTlNc3VNQ1NSSlNDUFNMSTZNN29HaFl5TWxML05oNFZCQUxIQkh0citBc3NMN01mbFkwcGJBR1VLM1JyOFUyalI3TG91V3VvUStYT0hPeGMyU3QraER6OHVCMXFibXVFRzVaNXZCNUZkOTR5TTlyc2N6WEV1Q1Rpd1hKaGMrdS9zSWZrYzRoV1J5dmxEVFhyVWY5V0srWTlGeTFzeFdmQWM0c2Vla1BlbC9TY3JCL3NtdCtQSEwxMmM4OFBiZzhubEp2K0RCYlBnaG5sbHRxZmVrdjVPVGI4aU13dUVla1JCMTIxMWc2U0oyaFNKNWc2ZXF4ekxPTXpKdWU3RGd6cEVLb2xNWE42NUhFR3k5T2UyMU1ncnNNT2VTT3pCT3ExU0U0cnMxdFBQRVQzWVBQaklveUJud2o4b0N3bnp6NmVIQ1JZeXlkM1lWbHFGTCtkcGkxNG9WY2VNWlZHcEhNanlWUVd6aGViUTQ2U3ZkL1FNSEd4MGVLTEdPaTJtaFVxdVllVDVqT3g5UlJXbWhzUCsvS2s2WEo1VGppSHBOVFBUVnQzQ3lGZm50bjVNMExhdjM0TXB3RUV2VTM5SjZyN2xSV3ZLbnRsMEd3aEFVbHFNc2JyQ2ZpV2l0aEliZlhIRldybXFRa0sydW9USi90TkMzSy8zMVpXa2ptYXB3ZDh6OStVSW1rRVY0RDVUTFZkZjA3cTdwNHp1eU1rOXM0VXM0a2lJcmJDaC9XcExzZ1V0TU04YXhCMGIwbHVDU2FKUWNUZjlORTYxUE9xZ2s3UmdGTnRYUlIzVlppN2JZajN0ditqVkdCbVpLQXh0V2tvV0pUTi9lbEtzTllFNTFPT3NUcEs1SDdnUjBDZEpOU0k2dU9OdnRWdzlIVytxNjlQaTN3R2V6TU5zSFNqUGdQMzUxMTIxWmNObE9aWnlZZnFFZWswMSt1VzFuM2EzbFZVTGNrYmJaamxFQVIvZm5zU01BWkJSM3ZHaGwxZnBIbS9VdElqNDRhYTlTNm5LNi9xRlJuUkVnaExXSEVtbmlkeCt0SlF5QU1CcXUwMmpzcysveXpCMzlzN3pFc2x3aERZRmJqZk1Ec2xkYkZ1Rmcyd2NlN0ZNMW56T2duam9JK1FPdk5hWW9HdTRNQ2NDL3FYZmFjN0d1U0I2VTA0Ti9paXJZd2dJN1pMeTVsMm10bFdBc2wya2xtREEvaC8zN2xIL2pXRlJTeGxWUlpUY3A4eVpnSHZ3ZGh3OXhZMnJ3YlpHSC93bWpyVk5sekd4VGxWdENjeWU4d0RWQWdBQkJQNzdBeTh4bUIxSmlNUGh1ZVVuSlBLREVuSVpTckdvcFI5TERCK1RjSFc1UWZKV1lWelBJZytPRCtLZGc4d3BkSk5iczhEOHNXcU94bWgwYXRkZXBqQnBHZDBaakQzQytETDVqRHM0RmlyamdlVnNINkhTR2VXeEFMbC96YmcydmVSL2VXeUZRYll5eGNHZEdoblNhWmFIZXB1TGZMblVXM3dzOTZoWEl5TDFCamNVZ1FLT25sVVRtUzF0MVVsVzY3RzQvS1IvTjIrUXpzUHdaQ3BtWVE4M2xHVEdIb2RjSkk1Z1MveEExekp2WW13UkpmUFliWUF4WXkzY3pRQjExUTUvblNYa2ZUVkRvcWxNQk1OQ2J2QVFMUXd5UUVyb0hzamJERVRNTld6QXhFbUNITUdPV0hSdWEvZWdIYWZENHVoMFBEVlZqUVdvQzRkUWVmSXM0aXRwbkRmRUdNVFZpc2FiLzRwS0RFWlI5N21uV2JXdkRHOGhBWmJUMW83c2JMRnN3dDhPek9qeFNjdjB1NWtMUi9sVDZsU3lpOHNuWVlpdHRJbzI5MmxBSC9SaEpvSUVSaThHUkJxUnpTR1pHNnVmWEhZQU1udDNNc25ybUhQRXJaWlNtcXIvc0dPQ21NYmo0dUo0cEZKdUlPQ3JqblNsZTlBUXhsb0dIK2dSVmlHRXdZZ3NqMnRZMHJCektqc082YSt0VTlvWTdRU3plN0ZsSE8rLzlzeXEzY0xINEVRRlcyOXJUM2ViUHNJUUR4WVFXdUlUREgyU21haUV5Qlc2djJDcGJRenhlczVORWROcjd3UFNxMjFSc3R1eUdQdlFtajJodkhWc2JBQUlnYnQyeldXWUdPRHlvck5RelFpSnFqcFl3cFlKdi9wR3FBcGtCTmlERUowVEozbGR5czhEeG9NOTcrb1lqVFUzMkx0T0k2aUdOWjR6VFlDcWd1K1NTV3EvQ1hqd25wRUUzdmlTa0lRQnc0c21tcEpUTVpqQkgzQjVvblRaVjFDa0lvakZFZmFvbm5PcmlNRWM2WFJ6WGFwaGsveng5aFViTkRpd09PWG1jc2dGdlJNV1BDdTZsUlVhS2Vha0tsZE96LzByKzBDbmt2NHFaMU5TYnNjL1llUC9jdlJJTFJHT2dsMVNIcnpkaURNNFV6am54TVZjVXd6RkZ2MUJNVlZicXpWdW9zTEhKeFg0dlR6LzBtblYwdEVleW5Cc2FOTFJHWTZaN3Z0QjV4V2dBbkdJaHdnV05TcHRYRndZelhpNE9uV1FQVHNVeUN4eXQrWWUwMU1JakdidUM3MkszTXVWMmN5dUYzajA3ZlByTVJSN05JUUZtWkdpMENwNEFmTWhBQzVoSTkzMTg3VllpMXJNU1BvcUZSK0pTUTh2NU5GNzd1S3Q3dDZJdzVDT01rR0xwa2txWUpRUjYvWTVmdjVHcU1IRDJMNTRJSFRHWUNTRzJsOVhtUTVOK1RLY05hTjVVNWhGWEE3Njg5SnMyNFJTNjZsdW5XSXExVGQ3USs3dkUzN3RRUmxIaG5vS3Y4RTMvSjBQblAyZVNnM3dZclhoa1JBRmozZk04SmYvVC9rQnZ4eHQvY2F1RnRPM3gvRXlzcndtR1JacURLK3BaRmxiZ0ZTM0tjMEQ1Q2VyMWlkRStFZEVpZS9XQ2NvaE51QWd1NlBteHJFVEUvV3JOODJkY3ZTSm02bmJZYnJMQ2xGbTJQRUtYRk1RYWhQcGd4R3ptMU5HckxsK0NtbktsTGxiQ25Yamo2TERSUVlGeEIyTnhDV3NHczJHUGlGbVJpamtqTld6VnhoSStNRUNBQUVFL3ZzQ0hZNjdCR1ZTbG5xaEJRZkhyZHl0QjdLRHUxWEN2UGlTMGlSV1MyazhHdXY2QUw1WDFEQ2RPSHowbUMvRDdzNTlrend2enNhT0FCWDlvKzkzTElKa3lwcWxrV3NDeVRZTjFtSlpEY1hrMEF4enR2VElDS0VVRzlWZVpzZWY0Zy92MU1ITlI3RUpYVUpNM3JtZmVPS1JkSGV1eFpKV1ZwR0ZYWWlUQ1l4cEJwdzk2ZXVRemRNRk5EdjI3ZDVUM2pKR0V4MzZtaDloS2MyS0thVklKNUd6YXRXZmFPYUU3MWMvUW1DVVV0MGVxVmxMUElqREZ1K2xWRWJkbjJqOXlXSjdPL0FKUGNYajZERlA5SldYK0w1ZG1RU1dWUlBCVnZEU3I4cW0yMWFITkxJL2Y1NnZnTXVpWHN1cGRWWm5VOUZHQnFqUkJGRG40Qzg0N2VJaVFxQUljb1NKdzFPVThMVld5SUFTNi9GT3VIMlFoUWlKWENzN3NVdmRxMDlqQnZMc0RIVDJDUWV0MU5KTUF6bUwzOCtzcTAzV3orbnpuaVk1cU9LeUpXQllXTnlWZFdoZ2NTU0xNMnBEN1FTRXdVWTc2WVlyNnNLaW91VUZJalc1cHRzeVRuQkV1Tlk4N09oUEJtMnNCa1U5VTkwd2pYZVdkNW9CLzl1QlBsVzAydUtCWUN3MDJJamRVVXc5UEZSSXc2Zll2T2E0aWRaeTZRc3B1K1pRNmwyTXkzY1p1Y2xvVmZ6RmRQeDI1QURnTkRDaUhqblZSbG9LYTVHWUFPVGtQSW9iUlN2VjlpUHB4eDROV0ltVktpTEpVYWRoY2FaaGM3U1h1azBteGRDQ3dNNDVsOEJ6MUZEaDBsV2FpY0xPY1YvL2dVSVlQQktvdDkwYkxCT1kyZkphalFHNVZQcElBUElWTFVWODgyb3lJdm9XRGU0bkgxcURDamVBTVVacGtxbmI1UGtzQWg2RkVLN3U0MXJKT0JaZko0QTY1dms3NzhCK1JQdVZJdzhoTm1FV25ZRS93NmNuaWJlL3J4ZTQ5OFV0TFBVMG1Rb2xFTkpLUzV1UHhqbW1Qa2VXQ2k0UUtEZUdNeUNlajMwaGlTenRZVXQ5SStscXhTV0JtMTMwanNHSjhjdm9nZEMvNGRSSFVnMzBja3RVK1g1Qnp3aCtCaUN3MUtTYXRseTB0azhYN2c1aitvMmFadDdEaGZQdGtsVDZGd0xTYTYySWNOdG0xZk9RZWR4SnBVWmVGb1RTUFNNZjF6WGhNaGpRMGRKWkFoQ3ZrMzNJYkszSnY3SEVnL3BFaUhuemtMdXlzVmdGWkpUTHIvekJnbXlhV1dxT0xxajNmb2M0dTBpcGw4YlpSMDRHaUdiZGtKNHBwcDBSeHN3QnNqS0hmYVlFU0hxSFNucERHU3k1L1VZSDIxQnk0b2tHQzVWRkpnbXFFS20yeFdTdm1SWCttakozZFhUQ1doQ2lxM0l1M3Q5cXF2VDU0TUxKTWoxYkMwcUJEU1B1ZmxYSnBoYnE2OUFrMkpHSmhkdnBzMmo3SHVKUzV4aEtHUXRwcEswWGtlNnZJdllOQzVZR005TklsZ1lzQ0dveTBLSDRUeUszcjBTZVZ3anVlcTFYanFOdzFHNDV3R3cyalFCUVZBU3BsRkhBWmVPNURhbXptdUFMeGhzVGdUQ2hsYlF2NnFQU1QyK1NyMTRkWUI3WTB6STF3SDEyUlFyclgwZGVWYmgwSmxZSm5CNHBKQkxma0RGTWptaXk2Nm52U1lJWjdqYzBtNlRUTEFIREF2TW5zVlZTWW1Qbjludzh1OVpFb2dJQUFRVCsrd0FOdVNjOGV1aVVKSCt0aldYTjdPdHJocUliRWUyRjFURjBkcTROSTdOb2JPcjRtOFdSLzNSa0dRaGFXb09mMkJnVklzbFB2cDd6MGhPb0pBS00xK0owS3MwTWU0K2JoOGs1bjhaVTlzc1lPYmtNQ2wxU2xXWWNhQjdzK0JtNGJ1OWxNOHAwaGVTK1RyV2puWURMRWttRyttRGFsRmQ4MXhTVEJoVnRtcXJHdFVPVlJ6eTFCc0ZKaUF2VkVEU2Jma1hPbzNRZjRkdUxSSTN2b1ZiRVErdVl1REZJc3BuR2lMVGQ4MVYxU0Y3Q1JVdS8rMkxxL2MvMlc1dDlRbCtGdUNJVkFuREt6NVFvaGZvdEdVWVJ6aU9nOXJySXY3NHFOZTA1dTVFYmJuZXhUSzZLYlp0ajdUK0E3OTMrQ1dFcXM1cWNrRmpETmZZZFhpanVCVGlKQ3pjcCtReWhQRmN4OXdDU1JDVWZNbHZobG9tYldIQS90dEs0OVpNT2NBNGIwcVozTDZEREQzZnJQd3RaVnR2aWtGd3BsYnlTV1lhYUg1OElwK1gySXJDZmg2SEFjQWZCSGQ4dXdlWFozWkRaN2JqNHByNUJ6bGdVZTJzN3I2R0UrR3pNK0dRanJmTjNXNmVyRGxPZ2RoeExKL2VOeCsxaEJSL2RNM01FOCs4WjUxc1N3U1RyOVFOcUdXVVZtem4rYllOeXRqTDNXTEF0NDdaM1Y3V1VuMERxOFZVOVorYlZ2SjBnMVZzek84VTN5bU5acWhpU0FId1ZCNmxnUDlseVNlelhrc2tHamttdklNdGNqb0N5VUhrek9Pd2NpZFpKZFVvTlIwMkdzV01Sa3dYcmlSU0ZYTkNNZXlYVzV5b0R6VXNmSkhKWjZXL1FTNDk0MW9mTUZOcGpBZFg4MzZpRUxGY2NxcjlFK0M2RWJuay8vU0Y0Y1FCNFczRWQ2bVhZcGVJMVJIMzhldUhjUnJVWXRLdGQ2U3YvdkFqL1ZveE5ZY0FjY2NlaS9aTkFnMXYrVHpFUXBadGhDcVkrc093QVVVYWpyZU9oUWFKSzVUYWV0bVZiM3hSSVBvRHBvaVpUNFE3R1oxWTAwekI0UURiSWwyOWx5ZWFFaDlnd3NQc1oxMFlvN0ovK0JUR0tJYnIxdUx2TUZIRFB6ZFNnZGUzWEVzc3VzbERhVmhNUHV2d1JtQWVNeWRXK2hUY3A5T29BbnZHT0xEUjBFcFBPYUNPalZFSEJGT0FTdWNVK0psSmhnOVI3Z1lIQk9DWUtzY0pySWlTcVl0YStVZnpXa0x1OHlMT2pkMWxqZCtXSEVuOFZhM2QvNmVlbHIzVVFJTVhYdXBtUGxwY0ZIVG1JN2hsUWs2NnZSSE5VNE5aektyaVlYVEFWUjU5Y240SlQ2ZTBONnl1S2lhb0NrQW4yZTVVVDlEM2prL2o2VW9RTy9vZVVMTFQrL1pHNjFWZTVKdUErQzMwRG1MKzdkSVlMT0FKcUJxUjFZMHBaQXRYZ0JqVThyczRaV0FvTVBOSFl6ZUUzQlgwMXBKUEs2WWRWVzNua29rRlFnVkRZb0V4dkllK0Z4T0ZoSm9JUWRGR2dnWm9RSG5RemxPSlN3VjI2THhNMGRlbVU5eWNuZWV1S1QwR2Z0enNDNzRPRllORFcxUjFESXdxdzVvSFlJeGZHVW1ObkNDZFhneXFmaFNnK1FEM3RBZWVsTHJWVjNjK0M5QmcxeS9xZTl2SmxEa0RGaHJ5ZllBVVlCWjd2Wk1DOEhhWDBvOTVWWEhYTHN5dUcxZlhnU0k1QXZZdnhRU0NiN0FFajRqY1lBZ0FCQlA3N0FBWG5QZ3ZPQko1cFJFL1NoNWJCSU5ja045bHhQNnp3NHJGeGJiL0NwREszalhkTE40cGtqcTh2Tk1oY2xiTDBjWmZ1Q3FFQzcraWZ1QkRoclhWb2dYWDNlQnJNUTErSkRtT2oyYU5tb0tIM2FvMGMrUkZUZGhCbEYrTVg4Tll5RXhiMkdiZVlmcFdRQVVCYTJ5TzN0dC9lbjRvMExkYWZITjZoQm5vd3AwUmUwMkN1K1FZRFV4Q2NLVHBUbWV0VmllRlVoQk4rTGg1WkZCZHFwbkJvNzJ5TUR1RUVtQWRkamh1STM4TDQ2R3pPNTFBVHFlNllkNTNlN0krQmRFWThhYTM0Znk0eGlrQ1ZjU2d1QmJlbzFQYWxtazA3M2tqQ2FMZXVJd2tTZmlSclk1dk1mWks2cXNzQ1NFNFF6aWdDYVlHUmZnd0FBME4zQUJlZ0Jjcko2V3AvOFNwWEMrUDdDNU5NZG1vQlp0YjB0YmdSTDBpSkhCYVFEZFhuYW41cjdkZ3NocjRnZEFqdUQvODF0QkswQ0xkMEJnYW91RjQ3ZE41cGY1bFJqYWtyWFRHOVVVS20zNUZpMWFsUkRYNjVzN2prL3F4YjFuWWdja1Rza3dVT285bGp3dEZSSDNmLzVvdENMWXA3MGgzcTRpMHN2alNSYjl6M29lZzZtdEZYWnlZdFFpWDNUalFiTld2dFVRT1pZZ2FxMmhZM3lHQ3ZYeHgwelQrdDhnakk4VjNnWThRak5JSktYdnRab2JyQnlHaFBvWm1iQUxCc0JucjBTT0VvcUpxODVjVUNlU2t3dmN1bE1mN1RjRHNxYzJVSWFWMW9CKzVRTVcwQnZRTnFJdFFuODFQMUJqNmdkQjRld3RoN2F2ZXFodlh0RjAwQjNRbU92eFRIUXNuVTdjSDc5SmhtMnpJdUVxbCs1b0hkNkVoaU9Cc0RrQzdPYzBPYUVmaWZJYk9xeG13RjlPbXBreFZDVE9qRnA0QWRFOFZmckM5ZkU3WmZObk5UTmpNTnZHR082SjdXdTZzWHF1MUJjVmdGN3dJWUFOSmIvdkxXZ0ErRStlbmdjRks5bFBTWnVNV2owa2p0VTRTckN4SENIc2lLRTg0RGJCUEFDOG1nQm1qcDNiWXFLR3pjNTBuRng1aUVhSVZtOXFyVGNUbmZIRGxBQ0F1MU1Jb2VUZzM1eWttSm43cDVobWdGMGU2eW1Fb09McHBjeVA0bXFNVXZwYThlZ0JORkVab1FrcDVjSFY1STFZN0VGVE9USVNpaDJGOFp1Q0R4cUY5bjhuUGZqek53aDZBQ1hMYWtzUUJYcEM2TW5zU2xOZUEyeWtXR2ZMSG5xVm5hSE5naVc4VFAwcTJJVUZwazRTejhHVHIxVk9XOTJHZ3ZVek44Y2lWZWJsWEluaUgrZVhvQ05uSkZYWnZCR1FJQnZPaTJ4bk82SFRoMHdiWFdlY1QyUDhNc09SSHkwWnJEdnp3Mkc2eVNlNGF0ZUZPcGpsbjJhTnpLcFQ2bFFKdkVUWkduYlExdjdmM1YxeEdGSVZWWWJwZkFob3pWbFdPMVlTSHB2TVZsOGVQWUNSVjBFdGEyeUd2Y1R1MmZVSEk0ZmxoOXFOU054VzRhNDB6MEZSVm1SK1BKT20yL25aV25rVkFYOWNTNktEN25qOUdEamxmYisvYnRBMmVrVVVzSDBOQ3R1d3hBbFE0K1NoVDJsdExxdXYrNlpQNzVmWXNrYlBEQ3BldldOT29IZ1FxZVVsWm9HOCtuV1YrS001N3RlU2ZFaGFRWnN4Y2JqRlJOcWwzaHNzSVFxZUJIdlc0Q0FBRUUvdnNFeGJGcnAzcUdBdHc2S3l1WFVxK2xGMXlzbGF1ZFF3WUpNK0FBMzQyNTUycU9ZWVZSWjJGQXE0S0tHeWlWb1U3QkVDSU1wWEN0N0RXQ1JzaUhrc3ZwRER1bGFQVTBCSFU1TkE5ZDFwZUMzejQ5UjVBQVg3c3hzWkQvcGh0STRxbkk5T2QyYU56eTlnZ0pmeFNEMzk0YVRSOXRla0pyMkMvWElLMVdqYi80dDlLUlBJckthSlpJQTZMbWdKcEhPNjVTVnpaR2RJV0ZHeXlZUE50Mnk5VmhHaVc4MFJIRVN0RHBScUJMYWxZVXdaMzN2ZDYyTldyTDlMRVp6VmJDMGcxa1FDT1FsQUxsVGlLTFVwTHU2c3I5U3pldjVkYzJTVzV0MUN5M1JKWlpTb0FuaFdtR3R0eUh0MjdKNzJqdjdLanJKaTlZODByZDRVaGZGUnBGOHVOcjl5bXRZTjd0WTRMQ29COGZMWW1rckhSRzk0S2QvSUZOeERXaXR4U2tkcjNqUEFCUzBXc2MwdFI2VFhBeWJ2MHJ3UDQrcVRESUVlcCtuc0RtempjRCtpT0xkVlpISGRGcGZIWWEzNVBLM1pZWi9lS1FSNEhCRWZRTHRoNXl3LzFidDk2K241dFAvVGNHakF2bG9QVzRJNjNqWXFpRGVNTW0zNGNoa2lHRERTaVlMV3d2enFnaGdMZFM2eUpRS3FzM1RhYjVONXhzc2ppZEtlMXo5MUJwRmpaY2VaclFzNHdKVDNlNVFXQUZBNmFlblR6R284K25BSVpETWUwdTRNZ1FuVTdJUEFDRjdhNDN6UzVmRnMyTU1WY2tBZm9aZFh6Mk85T3I0dGlRSmk2akY5TUw3dkhCRmJidmFHeklJWFpUUkRYNUVKY0EwQzR3S0JwbHcvdUIzeXNxQ1FYTmk4R3lzakRDR3RIWVJHSzBWZlJLMUFteG9RTW5LS0FheUdxUmhGb1Y0WDVvaVNQeCtYYnRYYUViczY1MitIYmhOZkZXZU9vREljajdDTmVSWFJqYnAzdUFoTDA3OGRPUVFScEVTa2xsbjVpbjczNVdTSWx5KzRUdy9sT2JBczdGbVRKTEdublhxUlRnV25IRWRCZzlpbndPa1YrSjJGbkR4THhVYTNmZ1l3QVk3VkRsYmZHMVg0WXZyRFNCeU1JUU5yMmdvRi9HMEoyMnVnbTRZNmN4YkU2NGpoQUkxR05NbXlkRHJUajNBMnJGaEhhMVJMY1pjYk1GREQ3aWsvbkNQTVRXTXF4NjFxSlBjeUgvaTJlZjgwdkpJalNuN243U0F6bThHU25QMHIzcnJEbjRabU9rVFBHT3llY0xoNXE5ejFzS1pjNTc4eFVMSkJiTHhzSE5ITnBKWC9PU2FsVXdpRGpUWXdwRk95MGJIOEVZRG5yOVV1eXJ2emkrMm1NL2RMeG4rZ2dBUSt3S29kZkM3R3l2M0NzS0RmVUR0VmtUa080cDdBcjJHL0R5TnNKMElFVFV6U3p6NHgvampRRmtkOXNLZHNOYVVXRmk2TkRtMjlNM2xBTFY0MTIzZnNrcGhHUkxySE9oRitCOUl5bGY2QWNqWFpDaGlyTyt1WDJiZHAxVzNzcVlmdElVZlZtY1J3TW9TVnNJZnk2aTBNeWxXQXZIZnhyd2l0VnRWb0RTQ251YUFndFpwV243QlN3WFhCekhJNXBPMDByamRZZi9pT29pVjZsOTBFUEQ2aktpRUdEeVcxZUQ1dXZRTVp4RnNnSWFXOFQvblJRZDdYMEYzd0szODREMy9zSWhJVG1PL0JOcVhTSFZIT1RoR1pPNjNSYlJ5QUlBQVFUKyt3SDhnejlURlZvdE9WNWVVRitrQlNROFNmNTZYbWE1U1ZibnFib0hNK2xyTXlubzl2Z0Y3RnY5Z3pmMU0vcmJiZFZPS2tpOFd4ZVgrVmVxdDhlcnlvL2s0MTduV0RCWURoajJXc2lUTUIra3VIR1ZBK1M2RVhYWkFGdnR6cHJIeEZrV01ZNUpPV3dMak9DNDN0MmsxZEphNXdiMlV3WVBXOHN0RW1EN0Jwb2dCZzFORXZwa0dlRnVTZkpxY0l0bHFwcldjcUtZRzg5dlNVNGVLU25oYm0zRFNra2JOZEQrdjUxQ01zTW92a0RERGNlMlpseWwxRDFRVjVERGxUb0FtT0RKVTBxRERuaVZNZHBZL1E3ZTdxRmg1Ym9yNUE2bjl6WFBZS2RsdVBiVFVDa0EvUEl5ZDhDYXFyejJHeFA3czBtdTMvcnlXTXo4OERQSjRxUkpBWVZjVVN3dFBzVUNYajdWU1h5cXloYlU4dGVEanZPbVhEZU16NXBQU0FOcWtCU1FTdmptNk8xaXdTV2hyZVJ1WXF1bG1weEhrSWlZTkNmVmFmYzNiVTNWR1VvZVhhK3ZHMzJNUGxrYjFGcTVkYUw4UmVxZXlzM1dyeFhCTDBRM3dFTFJhVUpwaDNPTjBEUzdrTlBhOEV0dG5XUmlLd2p6N1lWNmtmcnlpYjJYNkRjYXRNZlU3dnpybVJsMmdvOVd1VDFJYW9aOXp6cEtEYWpobUo2MTZraVZtaU9BMDhFa0MzbEVHM29WYk1kanRCWjhJd0xQK1ZYQ1FaeXB1VEJEaFFKVFVSMlJjTEFLQUFoR3N2bmsyNkthQjJYSVVmUWFYc2xwQ3J2RnZQUHRaQmkzaHNUbFl2MkRPOGcydFZRZGJPTVVUd1hZMDZNQkZUM2F3Y3kzV25lMVhqZ01pT1ZBa25sbTdoWmpoZmlDdlVFVHVTSk9FaVZDdlpVMHA3ZElOUVBQUkRVSkhkYmRtOWc3Q0F1MXBjazNNbnJHalNGU1F1V2gxdzljSkFlQS8rWmUyNEdtNGRzV1Y4VGoxOUxIWHZqcnVGdFFxeUcxWEZ3MWlROW52YjhNWWxqTTAzTFdscjRlTmxZN01HemJhUnBDMXhyYVlTdUc3Nkkyd3BiTUVXb2N1ZlBoYlZZbkVLN0drbEtLd1o1dTliT2Qya2NpL2w1M0RkSklTbVl3T1p2T1ZRdU1kR2VFQ0hmU1Jnb2o4V2xHcmNhUEVscHFJeW9JQVVtRDN0TFVkajZESHZnRDltTGg4MWlKR2RzdHNTK205Y2F5amlxR1V5a3h4TDZidW9idzJZb0FFcEh6aFdqcnkvN2MyN284cExlL3BSWG1kZTFnYW9VVFJEbjhHQzZuT3NBaHExeFcvODJ1TWg2QVBHRlJJZnhCb3ZpWVZBSDIvdW9Ea2I5Tk5vZ2dsdm5sdWJxWDZ2YVFZVzJwK1V0Zi90VUxteHkrYXJkUW5jMXFlNFRab2cwa3Qyc3N5cW5ab1JJSkVDbEUra3FuTWQ5TWRPWTY3REtreHBVSzVTSlJKWEtNOGhnVUJUVXJRNDN6SFNIMXQ4WE5icXBWTkwvSUZVYTZuMk5oOVMxUjNORnNyRUl2ZnpBYWZjNWlieGt1NVVNZENDNG5xNlNBV2pxZ0pZY1c1Tjl6SGxURmxaVHA2M2V4czhyQU0yTnFEUmdtbmtoU0NvY2ZmcEF5eG1Ra0VDTEZXVDVoZ0dROXRtRm0rWmtDaUVRSGZ5Z0Y2VEdjaXl2ZXJlMHluY0Q1amJFWWEvc1lyTVBqV1d0eGJvb2RhU0xyWnhFMU1FUVc4V0pxbDNUcEFnQUJCUDc3QXlwdzVWdFRzQ3A5ZkhHQkxqR0txWklFaWdybUtmQUZxZVRxN1FveXZDZ0JhSXplTzN5Z2x2Z3FmMkV0eU5ORk82WVIrVjdCcy95aWlCNjdMTWlsYzA0M2lPQ2N3MWxzSUE4Y1VUeWdXQ3VXTXIrY2VRWG1ZRzVWWlU1WFdZMWdvQSs5RjJSZmE5VzUzL3h4dXBXWjJhT1BVY29GL2Z0MVFjWUpKRFhQUjZDU1h4YkcvSENhS09xUmd4U3VZNDRxalk3aS9OVFJJWS9MbWIwREFENFRFSjRDWkdCOVVhOWFWVlVyN0xlRWpScEU4V3Rkc0xpUm10L0hHT1NzTWdBN0NrZUNTcVZlMVVzWFF0N3RVd3ludnoyclEyZDlObzhVVnRCWVlPbEdlNmV2YkRBQ3lTY0tKRGljN3RUNEtlc2RkWDdaWG9JTkhNaFpyU1p3NERPeVErMUNubVZkQXcvNDFrMi9WR2VBT21FWGtNdWdCWGZvdlAyRDFpemZ4MUFHa25nNU11K0V3aTZ5YXM0blBvUk82YjkzK0NhTzF3OUtVTVhUa05nWjk5dTV4b2JDNGUyVGVtb2l0RnBoRFQ3Q3VlSUNya0FDMmZ4d3JLRzZCOUZxOXY4a2dDNXpIV1Vsei8xbGpiamdSYzc5R2pYMnkwMC93ei9hSzZYSlo1U3JEYktndS9XUEVDcmdHTUR3Z1NoWUdmZ2h6Um5VWi94R0hMOXJMa3BWTGFSR044VTErVFE3TmQ0dlVuWjA3Q2l4b2NCM0lHRzFTeHl4eUdkcU1pWW5VcnNJL2lFZmFFcjhlNERaRlJid1FBUFo5MGJDTkdmNzR2TjErbFB1VmRDSFliWHNKUVJmODZiSFdLTXJWR2gxMXVhaUlhYUxOdFNjenlnV0dDeVlnVUNXQTd4aDA2aWR5V0YrU2pLT2NwUmE2RHFiY0NMU3ZUQUNtRkFmUXBZa1JGWk53djQrbXhvUlMrZ0JHY0U4RUFBaVJ1NzJMbDN5RDF4U09kbUlFM3BJUWVEdzhRVXhLdEsvcHA4elNySTY1TDB3dmxickRvWjQ0QlR6ZFhNb3BaTkxJbzJvR2xyVE5nbFJxUHhBOFpLQ21CajExRzN0bTFOTitkV0ttZzRFK2d1bmJEb1ppa0I1azMvUFR2aFJ5VStCMWE5VTJGVWNaR25JcXYraEZhWWR5UjFaOHc2QjA0Mk56QW5mK1NWVmw0bDhDYnlDOXdDdnJTakI0S0NVWTdoSGErN0FJTzdYSVBUWmVabkxDSU5GODJKQk5NSHlneVV3U2trYk9yNlYrU0RtK1ZDcWY4NWpHYTZDOE5ZMENFcXZ3T3I5cXc4SUJvMnYyVlV4c1gxSlJTMXNJVjROU043OFd0bTNaaVJ4bmMwZGVybGVXeTdHQ0ZuekgzQnhyc3g0V25YU2RKRkJNeFhhQjJlWTBtbmpsc1N2dlZwcTVramx0T0J2NS9sYlhkMjB5Y252WTdyWkVlOUM5RThuTkI4QzJaNGttRzNTNkpDczhXV08xWmhLVUFHdFh6NStnU3ZPZCtycTVLSVJlNHVDSnhuNVpxV1NCMHk1dHUyVU5nMUt6SnVMVkt5YWpMeTFIWVYxcGRsTW1Jb28xekpZYVNSZmFWNzBnUUJLdXlPN1V2VEFxZEN2NUJidDRzNE5HWGNQY2ZQNi9pOFQ4aG9SUTNQU1RkMGpsMjhqT0Z5dDZZM3c3ZjJ6QUpmYmdFYkNrZFJzM1dLTUFCL2MyakJaK1hpS1BzUGNqUEpHSXIrM0lQWElPVW9TTUMvU2NmSW9wUWh6VkY4eVNrT0NHL0VDQUFFRS92c0FUT1JtSW9jTnRyMklvTG9zZ3dhNVF4NjBQbXJQaVRWa3liYzlSeU8vc1NzODNTSG9IK1NFRzhpV3pUeGlGN21uL0pIV0k2MHFoSGtEUGpLNkFBQ1Uxd3VncW94Q2JyMlZBaEF2a2RhQTBidFdzanJIWXAzMXpPcnVycHBxOW9hczZOaWVTOTRwUXFBWWdNbmp5VHVUYUpialhIM0tjUVowK0JNNE42NkJpOUs0SlRQRS9ZTnNJanZjNVh1SkRXS0xVcDZPZTNUTCtadmh5TTFDL2t6aWo2SWpwR2ZDNEJVWEliMUgxMFYyNnZyRGhwNkpZV3JELzI3VHdoWUxkK1BhSmN5bCs4MTRNanNURWFxd1B6NVhTenJqcVNkbXdFUTBVbXE4ZzVXeHpFaFFLODExa1pSaGxlaUV3QjdPdUpsNjcrcnRSd21LNFFteUV6RXV4NmpEdk9ITk1Sb09TY2hmNWl0UzZXcVJMRDVhanJ2cFd3eUpHc1I1WW16cW9tb3pjMWRuSlpaRzMwdm5oSlZhbEVZMU1zb3VJMWFYRS8rU1MwS2JIcUdLZ3ZhSDhBL2YwUHFGZENlOGpucituVFJkNURPYm9Wd3pPVm5ZRnZReHEzYXEvSjUxZng0Ykd3QXIvcUZxQytuNjBOV1BETGQ5UDZPWHpRR1dvaUYycGtxZzVWRTd0bWlpam90Nm9ydmhVK3cwOTgza1FBbGFQNTBwc1N2WG83NE15b0xyT2swdjNXUDl4Uk5id3FaYkJiYS9idnNTSU9lSDhXT3NFQTZrQ0pTdit3NFY3NW5xWHJCYTZkWDZ4bWJUODd0VGsvMFBJcGRKaWkzWUxBTmlZVXlTVjlFVEV0K2tBQldMVkVQM0NTVExrVlBwMEtoQTRwTi9DZ1lnQ2w0RjFUS0pweGR2MVZ1NVB6MDVtN0Z0aUxUZlU1RWlrdktXTktUcHVPcGRZb0lZSUk5TE1CQVdha2hqbUNCMDJTN0N2Wnh0aThIODRma2FTU0xQSUxteC9iOFJtVFNFclpzZXV3V1d1T3FmSGxvemtsQ3M3SE81UDI5OElpcjZYeTFwR3lrRkRUd0JMeWIydmdBYVNLb0Z5MmtFSHRod1dEQ0ZsZHY0NEgwMmVkVUFqMnFWbzlCWC9pc3dvMzRsSElZLzg2TDBKRkZ1L1duelBLcm9NWnJtb0FDM0p3UC9HemZKa2g0QTJrWXVPSkRTUjkxNjRqaC8yOGl6NjRRRWZOK3k5eVZzMGlJU3czUGUrQ3Vld3JZVGZTcVU5UGRkdHRONlR3VXZmQUpoM1Jpb3lleDVSMjJ2Y1o0RzVCK1JFNDhpM3E5R1lqUWhETFhvNVZCR01pY0hPQWdScHdScVcvZ3NqRXVFT1ZXbm55ZVBiVFIwRnE4ZTlqck1KSW8vSFZhR2FuOUtxZDU0ZFArR2s1M0hIVUtUVzFMNjNaN1RER24yUGZFWGoxVzV3cnFPOHQrWmJhZFlFTStNYkc2S1hRRUNNbk55RVVsN2kzcTVTTVJCemxCWlpuMEpsKzdJVDhXQmRHVUQzditsa3ZQQWpGbzhCYjh0eElSR1AxSDRaaGJyZHNrZUhrbm93WFhHakNTRkZXQVlGYWdKbU5ELzJheUNJUnIvR1U3YmJodGtGYmxDMzQxdkFheWxtMjVOTkNvUXUvNGtPbUhTbGlzNVlVRTdTSEFzeDFQM2VVTnpsS3NscW5WNUdUMjk3cGZaMkxFYkxyTUEwNkZYOUJYc2hqcnFNZ0VNd2RXUGNCZEs1VXBFVlk5WGlaMG9FZ1RqUDNxbUFXbHA0bnBKSyt3cjhBSUFBUVQrK3dSaU0wQVd2N2Z4d05mcWMxQWdKcGZnSGlkTm5rRHRIMlRhMGgvMy9LK3A4Tnp5WHBDTEZ2cHJKb25aVWxINDBZVFJNWmxhUk1LNVJWY3RyaUIwN0U4SllwRDJxY1dDOUdVUzJidmFTYnRtMVdyOUdqQ1NMSHF1NXJsODVUeWlIQWVya25WNmFMdGtIUmx1SEIrRGhGREFRY2szNGlLU1MzWDU2TCtXQWRiT1FVQWZxSWJYMVQ4dkNBMWluVjJBbDdzd0liaUo1QTRyUzBxZHNkQ0NvZm14TU5hN1owbkRPNDBLTmc3T3RXRmFoNFltNUhUM3dEZFRKSUw1NGcyKzRtdWRTcUxCclg4VmNuaDNDMnBSanZpWnFLMDd4QXZjdkxhSEl4Ym1tMzRXNTFmZ1JnTUgvVXRPeDFGcEtZNXl5TGdoZTFRc2t6T0tXaVFSM2pUc3VJYnFPbWRISWdLWmRuYm95Q2tFUHIzLy9OY1pBZDYxeHdkUnM5WWh1bzdIWFhIQ1hKdTNuOWNyWkZGZExCajFyRXB6OWd2ajg3S1pzUmI4NFhHVEVSSlBKVGtvd2RpbzJSKzI4ajFNMUxiaGxzYytqNUEvQ2dFdFdnU1lLRlF2RldCUEV2NDVEclh4Y2F0a3pTc0UyM1JBWmxVVDI5R3BuZUtpck9CdHhmUll6djVUVm5GdzRtQ0ZnTkN3cDRLdURVZnhFSW40R0x3SGNpQVZtT2FzQ1h6UHhsT0wzQkt1aUh6VWorcXozV3UyeGhzMWhaYXdLcDQ3VHIrSzVWMHgrSVEvamR3WEVMdkhLdlBGVWdjUlNObldVUm5qV2twNmpQYUhQRUlNYi9SWjQwYjZXYmgrd2pJWUpISkNnYzZyOXlEdytCT1VMZWV0N2xmSGRwbFNmRnZjdkRCN3NhTXhla1hGZFJmQk9BeWRFUzM4YS9PMGY5Vk9EcjBWNjBxNHhmbTJNWFlKNjJPR05xcllwQlVmQkpDeFNXY2FSZ1h5dmdJMWtXOHhsV1R2ZmNZN29wM0pOQ0VmRXdPSko4aHo0N3ZkQW10SnE2aFJSN3hLblRQeVFsT3Y1amdmQlVNRy91U3ZxajNpZGViVzN1Y1AzYWxRVVprWEp3YTN1OERYYzhSRFUxaUxZa04rNUZDY2NKcVJyUEQ3V09STUtsYlRRbWJRNGZyWTdDSWdaUEh6N0xnQkNGczNVcm91R1pQTnc2RTF5QUgwTFM1b1VtQnpHaUNTa3FzUndaMG95aFplTUU4R2pXZWhyelovTEFzOXJNSUxETE8vQ2xBWGcwWU5icktxTnYyVjJJRlZUM0NJTTFZTE5lSFY1dFY5MGJFOTlVQmlLOWZBczdoWWREbzJMWjhQbUw0RGRNdjRMdlhJWGxQTTRpUHBFTjM2QVBFcEhSaGdnR0ZsY2JYWXpDUGpuQiszVGIxcVlOQk9aY0hEVmtZS09uTVV0bHQ0V1A1alhlSHJUUDhRWGxpUUFyMG02ZHVINjNYdXJaZWljQSt5cEl0MDJNVTN0RzVCK1d2TlBTUHQyRW8rQ1dya3lBZEgvS1FlWmZRbGZuS0JRVDdrZFBmdVJWcE8wZHd2N2Y2WW9tZ01EVktzTWdHSEZ3aVdOVjMzdzkvUzR6b1hBQTdqSnNiMzVvR3oweUlhUDBDR3M1Z1oxMml5T1dlVXlqYUd0c0QwTmhheFhCYWdIUFJQeUI4K1V0SGpGL0VpQnZpMnpiU1pPZlZ2WThlaUF3dUdRMWhiNXYyK3ZtYkdrWUs3dWprVnM1SDViZ0VIOENnRlF2QU03Rjl3eHlCME1ZbG92MEVFQWdBQkJQNzdBeldUT29xVUdyV2xHQWt1a1ljM0lvckh1TXZhZ3YydURTS1lpeVhCNjJiT0NJSEhZdXBhUXFGcUZqcUkwdHZndEhPU0xqYWthRWRTN0YwTm1FVWpwdU82WXowL2ljTlJrWi9NQVptaFJuMmR0WC9Hc2tyWUJpQmc5NEhxS0ZGU0Z4Q21FbnJXUHVwSHgva0M3YjZDQmhrd0NUV2JTc0trTWFQK09JeEJVT2svK0VVUWJBU1JYcWtKSmRVTEFEeEpWU3lyYnc2Z0Vua2dLRkVDcVVtNDJnRHBrb2hhTkVTc2V6c1M1dm9Ld01MQWcwaTlLUlV0V0hQc2xSTUordERkNXRwQ1hhc1pnajNmaTkyUTk2b3JnaWVhMGE5YjZOaHJXREkxS1BhbHRtMzBWQVV5MUwrUGsrcHJDaHg5aHN5OWdOQlNOUExXZEVGa2JNRzBJeUhNQzk5ZWRTcVhvWDYxcll3OFBZeVVwTXBWdm9UL3dINWFhMFdndjNBV1FJekIwVHhGbWtUdE9nUSs0bzFjRDZHakdBQ1VVM3MxRTM5cllXSURucXpSU2lSRDk0ejhuYnRXaVYzcHM5NnVxQnMvYndPa2J2MkxmV3lGWkNrZEUvTkRuenU4TU1BWUVRY3FtVTJhdEltOFNXMXM3Uy80Y0g4QktUeDltSThPazJITFpGV3NOTS91OXlhSEhvNm5aMFFRK3hZRXVJUXlKVGk2OFZNcXNZaDRLQWhVQ1o1eFlMN0NrQnRUS1FvcnMrVEFFQ1RlWHpHQ2diMjAyaU9kK0Jla1B4YlFBUzI3YTB3S1l3TkRPaHhLdDV4QzdrRlEyWnRmdWc5YzA4cGZTUXNYWmpLQ2luV1dwZjBvZmtZREp0UHlWSUpYS1dGWjYramp6RlM4QWxrTXlIVWJ2QkRXbmdWRmg4WktmUUQ2eWpWSW1xZkpvTG1RaFJOZjZmTnRaNFZPcmFpQjVCMUNCUFJMRFFJVjR6bzhoWnRsTmR6YXlZRHBzYytiSU94SDMwei9Da0wwOUFWVkRqc1gxNzhEMTVCRHR0ZlhRUVpoNmdrNVVqVVNpYUlhU1BrWnp4Z2ppUmhiTEhSQW9OUXljUm9NYXhodEIwSEp4TUt3N1UvaHVlWVBuZUlZWXc4TlZPYmRVMk1tSFBMaXcrRVhtOXlnVkhXZ250Y1JLMlFyeGZYdHNMVFh0MnpPR0Nvalpsa1ZPM0xDTzBUR2EyN3gyZjZndzloSkR3SEpEc1BWT0xPMVI1ZlNmeHZBSzNmL3AxeEpmeUFZQklDT2h5cGRzQUdXSW9OV0FDT3MzclV3S3lxTnlqZmQ5YTk4a2ZXNXcxTyt6R3Zac0xkRHJIbzZBaW83cEYwMlEyaVR3MGdmeG8xclVDZ1FPZWUxZ0pkUm84Y0taU0hReUZLN2VDSi9ZVjNRMy92OE95M01MOVk1ZWhjK0xZVURtOFNxVTJzbzVxYVQramZCbWpCTjE3bjU3bGkvQjRFeHpiZmJKSTVJNVB1cFZsU09RNjlrcXhCbnppNENpazY2Y2U0QS9BbGxWbnFHZE85TUJXbG5Id3N0aENUY2VBWjdoK241OFJVRSt1cDJGTEtKWUFXeWxXc1N5b1IxU1UxL1pnZlFUS1RudmFiVkNjTHFFV0E4MGN6dENtT1czbi9lT2xTNEFwWkZZaE1GQ3cycUU4U3RjTEVMR3QwUW1OVjhVQWRwQ3M3a2xwOTVERkxyR04xTUVLU1hsVlIxc3lGbGUyYVBDT1NBSW9DS0JFRE1aNTlSc2ZlR2YvTGZ6MTFFd0ovdFBpQktiVFlsMis4RzlQUUNBQUVFL3ZzRGtvRFZJanVpWmRIREtYbzNoU1c1Uko0bCt5bnByRXU0VmN2ZS9YenRCYXpqdHhQbnk5Q0lZR0Y1YWIzeG90eFJEU1lXY1lLNjdtd0NwU2xFNzNyTGRadWxLUzh1QklnMFVtSkNlWEtWVTJIZ1gyKy9LY2ZTMVlKNnd2dVcxbnhubk1RY2p6UllnY2IzZ3IzS1R4bmxLVS9SK3BBRW5JNGc1bnM3QVNlb0RkbVNXSE5xR3dSL3dFWTc1TUNZNkJ2NkNEWUp6SkdIN29pZlJBWTN0dVJJeGIwQTFEUEJiZVI5TDBEZXc0VXJoSUdDQmI1UlljN0JWcDZtR3J0U0JDUnl3dW5xR0NieHRZaG9VcURIVkVMRVU3RjZLUDh1WlJ4WFo5VlZFSGYwaWRyQ1Y2ck9zdW11N0xlc0hLSDZLNzRWWEZjTTFFZ2RpR2drQm5JRW5RejltalJpeDVzaUUzbEgxZE1GeHgvdUJXcHRBOHdudGVRL3BBNGE3TEZXSFd1U2tsbUlIYmUzODhUMWcyMG5zSVZVZ1B4MFJqWGUzMlNtVEZJMTRkMjY4WklxZExDMy96OEYrQlJRSGhMdlAyQlJ5NFE5eVF5dW5BdVFFVndQWkFGSVE3MGs2MlhGRGl2Z1pXN3VOZ3krd0UyVlZYb2x0VVdYaU0vcHlkMmdMc2Q0ZTZ1eXA5Mk5TU01tb3c5ZU41ZytWa2hwd1ZUdXdOWFlnVTFaeXYxNTUrK3pzaUVvS2pEcjFtOVNHT1NNK1hkRFpDKzhQcC93TGJhdkFnTVY1TG5NdkhTL1V3dnJrZk85aGZkVjV5WVFocXpmN2cvN2VjVExMR3hMeThMdzV1bkxwUllIaE1ucWU1bjZ0cHhHNTBrLzF2aXM3Z1pSdk5WMFZEbWliaW82QnFIZFNsMnhlY2VPR0NKQ1ZBVFFyeTR5eW04OEFUWjh5NENyZk9YWlVZbGQ0M3lybSsyNG1UUGlPUE5BMXhPak90V0ZPTXVkT1UzeXBMaGRsbHUzWHNKSGM3Z3M5V0VLYkVUcXVwTmVCdU01U3NIbkhCUUJLQ0k0QzJtQmFmd0NJaytMdFFzcWdnUkFITFlFbmtwWTZmaDNtMSt4dUtER1g1WHFIZ0t1VlhHUlhySWphaUpKUy9DSlMreXZENTR6KzlXMGJVbHg1Zi81ZzJtK1FsbEQ0cW1Fc3VveDZobFdlN1BZUjZwbDFmdDFPSStVd05rNElmdmJNcFJOakhLemt0TEhCQUlVRDg0bWZmdDIvdXNtZ0F4ayt4NGVvRlRWY1dMc3ZRTW9jUnJOSGIvTWtjajY3cUVreEpkMHFpRTBVRkF3NWsxb0JNeGplUnkvUU9mR0tlUmNMWkVVc1dtTkxIZG81YkJVNTM3dFpmYVg5VFZnUGpOdUlzVDNod0RzTmlOWEtZcmtpYkZXMUxpeE0vTXJYb0hGMSsrM3NXMW4ydXZtOUlvTE56TFYydWVxY0dCOXl5SHNqYjRaWVU3Rk9HQWk3WmNCekhZVENOWkZhWGJ3eTZGaU5WeEtXS2VndjczbEdocnpaSkZQWUU2VUNpbHd2WVVGazZpV0k5TTlpVDdLdlJEQjVhUFM1Q0R3UklGR1FBUGtIdXBJay81RlAwZlZuZXNCWjZ5TUlxN3hpdXljOTk5Z05uWWJSemFKcEY4RzJPRWo2Mk9hOHZuMjMzV1k2N2xIaldBK0dsckpjeVBvQ3ZoVlVRTHBPM2NaakJBS252K0FHRjBhaUpsck92ZjVraFdVajVHMk0yUEtNZGVUNERiaXhuWlZJdnBTRW5kMkRMMmplaUJQQ1FJQUFRVCsrd0duZU41MWs2VTZXOFJuNEhpUUhCaGo5Z09JT25tSm5nTWZ4RzhaTFcwaVpVL2p3OEpPNkxJMzZhd1EyK0hPbnBtZDgyUE5PNWxaVllhZUJTK0R1c2FydEJwbXVPeUNVMUZTazZlQTNjMjBCc3pSS3lZd2Z3TVk3R0dZb0xjNGdaVVlFVVVTdk81alk5bktGcTRmRXVrVE5yRTR6OGk2Ky9wbXdRQlNnLzJ2M3VGNkExRmN0T2l0aFhxc01zdWpkYmhSK1pyeHhQZGl3UEdBN1F2N0lJZkh2SWplNTZFKyt5cGxKRUdocDlZTkFZTi9mSUl6NE0xZDJjVmc3Ti9ZQjRWS0h6UUxpUXkrdisrUW5IUmVsaEpLMlc0ZjVMN3RBRTQwS2lxZjg4TkpvcFVFRDMxeXZxanNOYW13N1VmTWJkeW9aSWp6MEU3U0huMXAzd20ySTNlZ1VHazFNZWRBRDFXc2NQMVlGN1l6WnJOd01ja3htYW9hU0plekJFa05DWm9aYlQzUkRiOHhtaFFDNzhKMXQ3RDhQSTNncUFDUjhKd2VNem90VUVtTWY5Y2l5MFJzbjMwQnhTdTdBakFsSFhLMyttazR4OVZhc2xTNDFrS1BrbWhBN2VOZ3FxdlVNQytEL3AvTUxMZy96ZVVPVy9ZZjNXK1N4UExiOGdqdWMyQzVyT3d1cGYvcGQ1eG9BNi91TnE5T3VpTDVKQjFUM1RGUUU1aGJINzlXcFhSOEtWU3pGbmQ1VnJNK1BmZ0VWQ1k0L3A5d3U4Z0M3Wk0yNk5WYUx2aS9MQkk3bFNBc2V4MFhZcmdzUmpxZHVMbHVDOTZYN0R6akZhaFdISGdRVEs3ZDBRWWt2R3FHb2ZZM2FtMzBKb3YyRDJyL0x1ZjEvd1VMS2Q1UDlpTXRlaTB6RWNnMEhWRU9KOFA2Sks3OEs0UHQ4dTdUQ1Z3NHM3ZWsvRVBGUGV3RVBMVTdTdHdGdTZjc0Mxd3pKUDliY2t3Q0xKSDdrejR5SXhzcURXQStNQ25OZklUM3ozUWFQNGdFWU13MFprdzJIcFNsWEpEb2U5clpUOTFzNGUvWFJOemc3MWw2R1kzamQ0dlUrdnhCMkZFNXJRMGwxRkxRZnFnOUJiU2xSbldwNnpaSXhiY2V0STMxdnlTcW9SWTNpR21QNDVLb3d6M1ppTkdsMmFtRDFPMVJaNWUzRHBSS1ZUWVd3YjZQTXMwUmVZS0wxRGpub1BXdWZDcVhxZzdJcHNQbzRhbE0yVXhTdkhoamxQNnlYSlpZM2Y5OFJDSkMwZy9wV1ZXL0o0bzZ3RzBONnpPTVM0Y015SkJrT0RnMURrdjhJUnBoaUJEb0M2b2pjcFhSRWtUV2R1Wkp1eUFxRklXU3k4WDdFWldrajd2U1JQNG1GNmdWZjR5eG9UemxUN1A2L2NteVBSSnRBeFpyTzZBR0diQ2IzZWF6KzhLT1c0VmtoTVIwZGdRUm1STHRDR2J5MDQ0UEtralRjZVh6OGdMclVDNXNoT0FRSVVqTXBscW5UYkNlRmpqMzNVNWhXY29valBSRXRCTDQ5VFdGeVRVMnh3SC9ka3R1SzN6YXVtbWpxdVN1VnJBQjJHQUQwbnphcDNFTWhmeWdQOUJuRENmL3hZcjg4dklNMDV3cEk0R1o1YVRlVmZEcmpvR1RvN2gxSGFUTVlVUS8wQjdJSVVPK0xCNHY1a21JbURXYzAyMEZoeS9oYnltbkpUK05OUG9Nd3ZaZzFuUTBnekdsa3RIZ1RiR2lFWWpSWktYaExNekw1bFExbVhielpWajZUcmsvRThnREtSdk9BZ0FCQlA3N0FQbzBucW5OY2RKRjZtZG5VTjBPdGpUdnZMQU95bERwQk4vMmNqRWk2Q3psT2ZhOE5mNXlFc1JIODd4ZzVMRlMwenh6NGxTS0NTTDdyWGcxSFJLaSsveTc1dEJURHFxR2dSejRqY2J3bHN6di85S21FQ3VRRjFVWEl6dmlOam9iVXdTSUlQeGRMdFpiUnE4QkpDR21uY1BXbG9HNWxVY2szTFk2TlF6c3p2K2V1VzdPcDg4S1FacFFzQlBnMFYxR3E5M1F5Nm9Id1FyS01GeGRmUHJ1Y0RicURucGNIbDZJY2hpMjhzdmUzNVV0QiswbGNxdEZZMXFJRlg5bjR3dUI5ai9lbW9sa0VaT3NLdGxvWEJQRmMzL1JOeVZ1a1ZCZXJocVFZdlY1d056SGhtWmEwanpLNXoyMUZIZWkvOGYzOEJnNXlNd003UURsRG8wT3ZsSlFNcE4vVnZER3RBenlLcXFtWjZXbGczNkplOUYrdjFna1FuTlUwVkhYaksyWTVsYURyakUvcFdCUXdYeWw5Uk9VUmlJY0c5b0RtWnd1OCt6S2N5akE5MzE0ZXRnZ3p3LzJGaG94dUNWb3dQRDc1djc0NHVVNjl2dGd5ZmJza1hTb1k1SVBxZ1BrcWJoVUdVSUx1MmtIS2pDaU8yUzNJRVBsWjdYa09WUGFkV25MRmZoZUhid1NvMUVjcm1pZmY5WWpWVzNnY25qLzg0Vzd6VkxWeURaSTdCbnRNQnNaMHlKT3FvdnRtN2ZDbExjaldtZUN0ZWtlcXgyVG1QdEVsa3FUSGNEWUE0RVhPSUlZdnNXeXN2aWxjYTFqMkdlaWF6Yy9GVlNPYXY1THRpQWZxeDJDSlRhUGJnTVZOcUIvUmlVb2F1UVdmdmY2aFNRZWVjVU5IcHREekJWb2ZzbU02dVp1Y0Exc21ZT3B2RHl2QVlXY0grMDJkTUJiZWJOZlp2aS9jTUZJM3dSM1NFVXhucGIvN3dlQ2pGNXhrc2laOTJ2M043cTVWS1VIV1pHRm1VZGUyWC9CR3dTU2RrMDZnVnJuMHc1b0hZcEpZdXdZVHVuQWVuYjZsQmNSR1FmSUl0ck5hYVJsbWZIQmJNR0JnUDR4MVQwd2ZMYlFWZWVOYW0zOHhsQ09qajhHbHNxSlRmQ08zRHRlWnFyZ0FGdHRJODN0eUxPdUhIdWVVQU1yWlFqTzBISjJVTTJTSWkxTDJwS1pQUHdIclBvdXlyUHlnSEhhZDI2RStYR3lzMVR5UFF2MG1mRERKSVZxS0FlSXFaOG1CRFNHMXcxbFBwM1ZjTmNRR3BPYUh2cmhWNUNpRXd4ODc5L09VOVY1VjhNY2dTVDliQ2dIQnFac1lrVlYzdHZPZnUzUE4vSXkzYnZLcVlLWWFRL3I5VnN5MGdiazkxTy9LVHR6NTZvR09zbDU0N1MweFp2N2pkaS9yeGtkQ3RRaTZrY2hleXhQSWJCSisvYng3NHlhMWVyZDZMeG9vYWI2YWRGK0hkWWo5TUk0Z0NWbXJQS1dVZmtiN0lNTVFIUnZjV1ZZRUR3WHF0bzVFd09leHNDUzF0QU10OHBnNEE1cHhCNWIxNjZ0QVFFYkxFcjZ6dDZROFU2enBzTGlxQ1lKSGJHMFZKelBKb0w4aGs0WmxFSDFyWFA0MEpWU1ZnQXh3emJsV2JHMmIxdXN3ckNMdm13VUxYVlI0bG9hMlEvM0czeDlJeHE0UEtPdzN5SXJVN0NrQm1JVGFOQnpvMmtpQVo0VXpscElBeTFpM1ZmNFFoeU5pSFkvZjk1OTFUc2UzSkNma09SMjZSd1FVckhpZ3M4Q0RBQjl4Q3FabEpnT2F3QUFBQUJKUlU1RXJrSmdnZz09JztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/common/gl/noise.base64.ts\n");

/***/ }),

/***/ "./src/common/image.ts":
/*!*****************************!*\
  !*** ./src/common/image.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.loadImage = void 0;\nfunction loadImage(src) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise((res, rej) => {\n      const img = new Image();\n      img.src = src;\n      img.onload = () => res(img);\n      img.onerror = rej;\n    });\n  });\n}\nexports.loadImage = loadImage;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tbW9uL2ltYWdlLnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhYi8uL3NyYy9jb21tb24vaW1hZ2UudHM/NzBlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sb2FkSW1hZ2UgPSB2b2lkIDA7XG5mdW5jdGlvbiBsb2FkSW1hZ2Uoc3JjKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWcuc3JjID0gc3JjO1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlcyhpbWcpO1xuICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSByZWo7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5sb2FkSW1hZ2UgPSBsb2FkSW1hZ2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/common/image.ts\n");

/***/ }),

/***/ "./src/firework/index.ts":
/*!*******************************!*\
  !*** ./src/firework/index.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst App_vue_1 = __importDefault(__webpack_require__(/*! ./App.vue */ \"./src/firework/App.vue\"));\nconst vue_1 = __webpack_require__(/*! vue */ \"./node_modules/vue/index.js\");\nfunction getWrapper() {\n  if (document.getElementById('app')) {\n    return document.getElementById('app');\n  }\n  const div = document.createElement('div');\n  div.id = 'app';\n  document.body.appendChild(div);\n  return div;\n}\n(0, vue_1.createApp)(App_vue_1.default).mount(getWrapper());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZmlyZXdvcmsvaW5kZXgudHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhYi8uL3NyYy9maXJld29yay9pbmRleC50cz83NjE4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQXBwX3Z1ZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0FwcC52dWVcIikpO1xuY29uc3QgdnVlXzEgPSByZXF1aXJlKFwidnVlXCIpO1xuZnVuY3Rpb24gZ2V0V3JhcHBlcigpIHtcbiAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcCcpKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBwJyk7XG4gICAgfVxuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5pZCA9ICdhcHAnO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICByZXR1cm4gZGl2O1xufVxuKDAsIHZ1ZV8xLmNyZWF0ZUFwcCkoQXBwX3Z1ZV8xLmRlZmF1bHQpLm1vdW50KGdldFdyYXBwZXIoKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/firework/index.ts\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=style&index=0&id=c032fbdc&lang=css":
/*!******************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=style&index=0&id=c032fbdc&lang=css ***!
  \******************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.id, \"body {\\n  background: linear-gradient(180deg, #060015, #180043);\\n}\\n\", \"\"]);\n// Exports\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxM10udXNlWzBdIS4vc3JjL2ZpcmV3b3JrL0FwcC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD1jMDMyZmJkYyZsYW5nPWNzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhYi8uL3NyYy9maXJld29yay9BcHAudnVlPzAzYzUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImJvZHkge1xcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDE4MGRlZywgIzA2MDAxNSwgIzE4MDA0Myk7XFxufVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=style&index=0&id=c032fbdc&lang=css\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=style&index=1&id=c032fbdc&scoped=true&lang=css":
/*!******************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=style&index=1&id=c032fbdc&scoped=true&lang=css ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.id, \".canvas[data-v-c032fbdc] {\\n  width: 100vw;\\n  height: 100vh;\\n}\\n\", \"\"]);\n// Exports\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxM10udXNlWzBdIS4vc3JjL2ZpcmV3b3JrL0FwcC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MSZpZD1jMDMyZmJkYyZzY29wZWQ9dHJ1ZSZsYW5nPWNzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhYi8uL3NyYy9maXJld29yay9BcHAudnVlPzZlNWIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5jYW52YXNbZGF0YS12LWMwMzJmYmRjXSB7XFxuICB3aWR0aDogMTAwdnc7XFxuICBoZWlnaHQ6IDEwMHZoO1xcbn1cXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=style&index=1&id=c032fbdc&scoped=true&lang=css\n");

/***/ }),

/***/ "./src/firework/frag.glsl":
/*!********************************!*\
  !*** ./src/firework/frag.glsl ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"\\n// https://www.shadertoy.com/view/4lfXRf\\n#ifdef GL_ES\\nprecision mediump float;\\n#endif\\nuniform vec2 u_resolution;\\nuniform float u_time;\\nuniform sampler2D iChannel0;\\n\\n#define NUM_PARTICLES 75\\n#define NUM_FIREWORKS 5\\n\\nvec3 pow3(vec3 v,float p)\\n{\\n    return pow(abs(v),vec3(p));\\n}\\n\\nvec2 noise(vec2 tc){\\n    return (2.*texture2D(iChannel0, tc).xy-1.).xy;\\n}\\n\\n\\nvec3 fireworks(vec2 p){\\n    vec3 color=vec3(0.,0.,0.);\\n    \\n    for(int fw=0;fw<NUM_FIREWORKS;fw++){\\n        vec2 pos=noise(vec2(.82,.11)*float(fw))*1.5;\\n        float time=mod(u_time*3.,6.*(1.+noise(vec2(.123,.987)*float(fw)).x));\\n        for(int i=0;i<NUM_PARTICLES;i++)\\n        {\\n            vec2 dir=noise(vec2(.512,.133)*float(i));\\n            dir.y-=time*.1;\\n            float term=1./length(p-pos-dir*time)/50.;\\n            color+=pow3(vec3(\\n                    term*noise(vec2(.123,.133)*float(i)).y,\\n                    .8*term*noise(vec2(.533,.133)*float(i)).x,\\n                    .5*term*noise(vec2(.512,.133)*float(i)).x),\\n                1.25);\\n            }\\n        }\\n        return color;\\n    }\\n    \\n    void main(){\\n        vec2 p=2.*gl_FragCoord.xy/u_resolution.xy-1.;\\n        p.x*=u_resolution.x/u_resolution.y;\\n        \\n        vec3 color=fireworks(p);\\n        gl_FragColor=vec4(color,1.);\\n    }\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZmlyZXdvcmsvZnJhZy5nbHNsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhYi8uL3NyYy9maXJld29yay9mcmFnLmdsc2w/OGJhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIlxcbi8vIGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy80bGZYUmZcXG4jaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZW5kaWZcXG51bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xcbnVuaWZvcm0gZmxvYXQgdV90aW1lO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGlDaGFubmVsMDtcXG5cXG4jZGVmaW5lIE5VTV9QQVJUSUNMRVMgNzVcXG4jZGVmaW5lIE5VTV9GSVJFV09SS1MgNVxcblxcbnZlYzMgcG93Myh2ZWMzIHYsZmxvYXQgcClcXG57XFxuICAgIHJldHVybiBwb3coYWJzKHYpLHZlYzMocCkpO1xcbn1cXG5cXG52ZWMyIG5vaXNlKHZlYzIgdGMpe1xcbiAgICByZXR1cm4gKDIuKnRleHR1cmUyRChpQ2hhbm5lbDAsIHRjKS54eS0xLikueHk7XFxufVxcblxcblxcbnZlYzMgZmlyZXdvcmtzKHZlYzIgcCl7XFxuICAgIHZlYzMgY29sb3I9dmVjMygwLiwwLiwwLik7XFxuICAgIFxcbiAgICBmb3IoaW50IGZ3PTA7Znc8TlVNX0ZJUkVXT1JLUztmdysrKXtcXG4gICAgICAgIHZlYzIgcG9zPW5vaXNlKHZlYzIoLjgyLC4xMSkqZmxvYXQoZncpKSoxLjU7XFxuICAgICAgICBmbG9hdCB0aW1lPW1vZCh1X3RpbWUqMy4sNi4qKDEuK25vaXNlKHZlYzIoLjEyMywuOTg3KSpmbG9hdChmdykpLngpKTtcXG4gICAgICAgIGZvcihpbnQgaT0wO2k8TlVNX1BBUlRJQ0xFUztpKyspXFxuICAgICAgICB7XFxuICAgICAgICAgICAgdmVjMiBkaXI9bm9pc2UodmVjMiguNTEyLC4xMzMpKmZsb2F0KGkpKTtcXG4gICAgICAgICAgICBkaXIueS09dGltZSouMTtcXG4gICAgICAgICAgICBmbG9hdCB0ZXJtPTEuL2xlbmd0aChwLXBvcy1kaXIqdGltZSkvNTAuO1xcbiAgICAgICAgICAgIGNvbG9yKz1wb3czKHZlYzMoXFxuICAgICAgICAgICAgICAgICAgICB0ZXJtKm5vaXNlKHZlYzIoLjEyMywuMTMzKSpmbG9hdChpKSkueSxcXG4gICAgICAgICAgICAgICAgICAgIC44KnRlcm0qbm9pc2UodmVjMiguNTMzLC4xMzMpKmZsb2F0KGkpKS54LFxcbiAgICAgICAgICAgICAgICAgICAgLjUqdGVybSpub2lzZSh2ZWMyKC41MTIsLjEzMykqZmxvYXQoaSkpLngpLFxcbiAgICAgICAgICAgICAgICAxLjI1KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gY29sb3I7XFxuICAgIH1cXG4gICAgXFxuICAgIHZvaWQgbWFpbigpe1xcbiAgICAgICAgdmVjMiBwPTIuKmdsX0ZyYWdDb29yZC54eS91X3Jlc29sdXRpb24ueHktMS47XFxuICAgICAgICBwLngqPXVfcmVzb2x1dGlvbi54L3VfcmVzb2x1dGlvbi55O1xcbiAgICAgICAgXFxuICAgICAgICB2ZWMzIGNvbG9yPWZpcmV3b3JrcyhwKTtcXG4gICAgICAgIGdsX0ZyYWdDb2xvcj12ZWM0KGNvbG9yLDEuKTtcXG4gICAgfVwiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/firework/frag.glsl\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=style&index=0&id=c032fbdc&lang=css":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=style&index=0&id=c032fbdc&lang=css ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var api = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/vue-loader/dist/stylePostLoader.js!../../node_modules/sass-loader/dist/cjs.js!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./App.vue?vue&type=style&index=0&id=c032fbdc&lang=css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=style&index=0&id=c032fbdc&lang=css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMTNdLnVzZVswXSEuL3NyYy9maXJld29yay9BcHAudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9YzAzMmZiZGMmbGFuZz1jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYWIvLi9zcmMvZmlyZXdvcmsvQXBwLnZ1ZT80NWZjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMTNdLnVzZVswXSEuL0FwcC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD1jMDMyZmJkYyZsYW5nPWNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=style&index=0&id=c032fbdc&lang=css\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=style&index=1&id=c032fbdc&scoped=true&lang=css":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=style&index=1&id=c032fbdc&scoped=true&lang=css ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var api = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/vue-loader/dist/stylePostLoader.js!../../node_modules/sass-loader/dist/cjs.js!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./App.vue?vue&type=style&index=1&id=c032fbdc&scoped=true&lang=css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=style&index=1&id=c032fbdc&scoped=true&lang=css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMTNdLnVzZVswXSEuL3NyYy9maXJld29yay9BcHAudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTEmaWQ9YzAzMmZiZGMmc2NvcGVkPXRydWUmbGFuZz1jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYWIvLi9zcmMvZmlyZXdvcmsvQXBwLnZ1ZT8yZWM4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMTNdLnVzZVswXSEuL0FwcC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MSZpZD1jMDMyZmJkYyZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=style&index=1&id=c032fbdc&scoped=true&lang=css\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : 0;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhYi8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcz8yZGJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gIHZhciBtZW1vO1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59KCk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gIHZhciBtZW1vID0ge307XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgfTtcbn0oKTtcblxudmFyIHN0eWxlc0luRG9tID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHZhciBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuXG4gIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG52YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpLmNvbmNhdChvYmouY3NzLCBcIn1cIikgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMDtcblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZTtcbiAgdmFyIHVwZGF0ZTtcbiAgdmFyIHJlbW92ZTtcblxuICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cbiAgICByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUob2JqKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXG4gIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgfVxuXG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5Eb21bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRG9tW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n");

/***/ }),

/***/ "./src/firework/App.vue":
/*!******************************!*\
  !*** ./src/firework/App.vue ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _App_vue_vue_type_template_id_c032fbdc_scoped_true_ts_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App.vue?vue&type=template&id=c032fbdc&scoped=true&ts=true */ \"./src/firework/App.vue?vue&type=template&id=c032fbdc&scoped=true&ts=true\");\n/* harmony import */ var _App_vue_vue_type_script_setup_true_lang_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./App.vue?vue&type=script&setup=true&lang=ts */ \"./src/firework/App.vue?vue&type=script&setup=true&lang=ts\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _App_vue_vue_type_script_setup_true_lang_ts__WEBPACK_IMPORTED_MODULE_1__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _App_vue_vue_type_script_setup_true_lang_ts__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _App_vue_vue_type_style_index_0_id_c032fbdc_lang_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./App.vue?vue&type=style&index=0&id=c032fbdc&lang=css */ \"./src/firework/App.vue?vue&type=style&index=0&id=c032fbdc&lang=css\");\n/* harmony import */ var _App_vue_vue_type_style_index_1_id_c032fbdc_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./App.vue?vue&type=style&index=1&id=c032fbdc&scoped=true&lang=css */ \"./src/firework/App.vue?vue&type=style&index=1&id=c032fbdc&scoped=true&lang=css\");\n/* harmony import */ var _Users_chante_workspace_self_lab_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ \"./node_modules/vue-loader/dist/exportHelper.js\");\n\n\n\n\n;\n\n\n\nconst __exports__ = /*#__PURE__*/(0,_Users_chante_workspace_self_lab_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(_App_vue_vue_type_script_setup_true_lang_ts__WEBPACK_IMPORTED_MODULE_1__[\"default\"], [['render',_App_vue_vue_type_template_id_c032fbdc_scoped_true_ts_true__WEBPACK_IMPORTED_MODULE_0__.render],['__scopeId',\"data-v-c032fbdc\"],['__file',\"src/firework/App.vue\"]])\n/* hot reload */\nif (false) {}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZmlyZXdvcmsvQXBwLnZ1ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFiLy4vc3JjL2ZpcmV3b3JrL0FwcC52dWU/NzQzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZW5kZXIgfSBmcm9tIFwiLi9BcHAudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWMwMzJmYmRjJnNjb3BlZD10cnVlJnRzPXRydWVcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9BcHAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZzZXR1cD10cnVlJmxhbmc9dHNcIlxuZXhwb3J0ICogZnJvbSBcIi4vQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmc2V0dXA9dHJ1ZSZsYW5nPXRzXCJcblxuaW1wb3J0IFwiLi9BcHAudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9YzAzMmZiZGMmbGFuZz1jc3NcIlxuaW1wb3J0IFwiLi9BcHAudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTEmaWQ9YzAzMmZiZGMmc2NvcGVkPXRydWUmbGFuZz1jc3NcIlxuXG5pbXBvcnQgZXhwb3J0Q29tcG9uZW50IGZyb20gXCIvVXNlcnMvY2hhbnRlL3dvcmtzcGFjZS9zZWxmL2xhYi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qc1wiXG5jb25zdCBfX2V4cG9ydHNfXyA9IC8qI19fUFVSRV9fKi9leHBvcnRDb21wb25lbnQoc2NyaXB0LCBbWydyZW5kZXInLHJlbmRlcl0sWydfX3Njb3BlSWQnLFwiZGF0YS12LWMwMzJmYmRjXCJdLFsnX19maWxlJyxcInNyYy9maXJld29yay9BcHAudnVlXCJdXSlcbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIF9fZXhwb3J0c19fLl9faG1ySWQgPSBcImMwMzJmYmRjXCJcbiAgY29uc3QgYXBpID0gX19WVUVfSE1SX1JVTlRJTUVfX1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghYXBpLmNyZWF0ZVJlY29yZCgnYzAzMmZiZGMnLCBfX2V4cG9ydHNfXykpIHtcbiAgICBhcGkucmVsb2FkKCdjMDMyZmJkYycsIF9fZXhwb3J0c19fKVxuICB9XG4gIFxuICBtb2R1bGUuaG90LmFjY2VwdChcIi4vQXBwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1jMDMyZmJkYyZzY29wZWQ9dHJ1ZSZ0cz10cnVlXCIsICgpID0+IHtcbiAgICBhcGkucmVyZW5kZXIoJ2MwMzJmYmRjJywgcmVuZGVyKVxuICB9KVxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgX19leHBvcnRzX18iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/firework/App.vue\n");

/***/ }),

/***/ "./src/firework/App.vue?vue&type=script&setup=true&lang=ts":
/*!*****************************************************************!*\
  !*** ./src/firework/App.vue?vue&type=script&setup=true&lang=ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* reexport default from dynamic */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_ts_loader_index_js_clonedRuleSet_1_use_1_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_script_setup_true_lang_ts__WEBPACK_IMPORTED_MODULE_0___default.a)\n/* harmony export */ });\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_ts_loader_index_js_clonedRuleSet_1_use_1_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_script_setup_true_lang_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!../../node_modules/ts-loader/index.js??clonedRuleSet-1.use[1]!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./App.vue?vue&type=script&setup=true&lang=ts */ \"./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[1]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=script&setup=true&lang=ts\");\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_ts_loader_index_js_clonedRuleSet_1_use_1_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_script_setup_true_lang_ts__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_ts_loader_index_js_clonedRuleSet_1_use_1_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_script_setup_true_lang_ts__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_ts_loader_index_js_clonedRuleSet_1_use_1_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_script_setup_true_lang_ts__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_ts_loader_index_js_clonedRuleSet_1_use_1_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_script_setup_true_lang_ts__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZmlyZXdvcmsvQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmc2V0dXA9dHJ1ZSZsYW5nPXRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFiLy4vc3JjL2ZpcmV3b3JrL0FwcC52dWU/NzAzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMS51c2VbMF0hLi4vLi4vbm9kZV9tb2R1bGVzL3RzLWxvYWRlci9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0xLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzEzXS51c2VbMF0hLi9BcHAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZzZXR1cD10cnVlJmxhbmc9dHNcIjsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMS51c2VbMF0hLi4vLi4vbm9kZV9tb2R1bGVzL3RzLWxvYWRlci9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0xLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzEzXS51c2VbMF0hLi9BcHAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZzZXR1cD10cnVlJmxhbmc9dHNcIiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/firework/App.vue?vue&type=script&setup=true&lang=ts\n");

/***/ }),

/***/ "./src/firework/App.vue?vue&type=template&id=c032fbdc&scoped=true&ts=true":
/*!********************************************************************************!*\
  !*** ./src/firework/App.vue?vue&type=template&id=c032fbdc&scoped=true&ts=true ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__esModule": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_ts_loader_index_js_clonedRuleSet_1_use_1_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_template_id_c032fbdc_scoped_true_ts_true__WEBPACK_IMPORTED_MODULE_0__.__esModule),
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_ts_loader_index_js_clonedRuleSet_1_use_1_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_template_id_c032fbdc_scoped_true_ts_true__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_1_use_0_node_modules_ts_loader_index_js_clonedRuleSet_1_use_1_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_template_id_c032fbdc_scoped_true_ts_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!../../node_modules/ts-loader/index.js??clonedRuleSet-1.use[1]!../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./App.vue?vue&type=template&id=c032fbdc&scoped=true&ts=true */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-1.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-1.use[1]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=template&id=c032fbdc&scoped=true&ts=true");


/***/ }),

/***/ "./src/firework/App.vue?vue&type=style&index=0&id=c032fbdc&lang=css":
/*!**************************************************************************!*\
  !*** ./src/firework/App.vue?vue&type=style&index=0&id=c032fbdc&lang=css ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_style_index_0_id_c032fbdc_lang_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/style-loader/dist/cjs.js!../../node_modules/css-loader/dist/cjs.js!../../node_modules/vue-loader/dist/stylePostLoader.js!../../node_modules/sass-loader/dist/cjs.js!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./App.vue?vue&type=style&index=0&id=c032fbdc&lang=css */ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=style&index=0&id=c032fbdc&lang=css");
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_style_index_0_id_c032fbdc_lang_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_style_index_0_id_c032fbdc_lang_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_style_index_0_id_c032fbdc_lang_css__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_style_index_0_id_c032fbdc_lang_css__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


/***/ }),

/***/ "./src/firework/App.vue?vue&type=style&index=1&id=c032fbdc&scoped=true&lang=css":
/*!**************************************************************************************!*\
  !*** ./src/firework/App.vue?vue&type=style&index=1&id=c032fbdc&scoped=true&lang=css ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_style_index_1_id_c032fbdc_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/style-loader/dist/cjs.js!../../node_modules/css-loader/dist/cjs.js!../../node_modules/vue-loader/dist/stylePostLoader.js!../../node_modules/sass-loader/dist/cjs.js!../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./App.vue?vue&type=style&index=1&id=c032fbdc&scoped=true&lang=css */ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[13].use[0]!./src/firework/App.vue?vue&type=style&index=1&id=c032fbdc&scoped=true&lang=css");
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_style_index_1_id_c032fbdc_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_style_index_1_id_c032fbdc_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_style_index_1_id_c032fbdc_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_13_use_0_App_vue_vue_type_style_index_1_id_c032fbdc_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./node_modules/regenerator-runtime/runtime.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/firework/index.ts");
/******/ 	
/******/ })()
;